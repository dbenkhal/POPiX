 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">
<table class="centered-small">
  <tr>
    <th><a href="index.html"><span>Home</span></a></th>
    <th> &bull; </th>
    <th><a href="documentation.html"><span>Docs</span></a></th>
    <th> &bull; </th>
    <th><a href="download.html"><span>Download</span></a></th>
    <th> &bull; </th>
    <th><a href="mail.html"><span>Mail</span></a></th>
    <th> &bull; </th>
    <th><a href="faq.html"><span>FAQ</span></a></th>
    <th> &bull; </th>
    <th><a href="awards.html"><span>Awards</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com"><span>MSR</span></a></th>
  </tr>
</table>
<p class="Z3Title"><img align="middle" src="z3.png" alt="Z3" /> An Efficient Theorem Prover</p>
<!-- Generated by Doxygen 1.6.3 -->
  <div class="navpath"><b>Microsoft</b>::<b>Z3</b>::<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html">RawContext</a>
  </div>
<div class="contents">
<h1>RawContext Class Reference<br/>
<small>
[<a class="el" href="group__mapi.html">Managed (.NET) API</a>]</small>
</h1><!-- doxytag: class="Microsoft::Z3::RawContext" --><!-- doxytag: inherits="MarshalByRefObject" -->
<p>Z3 API object.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab8387be0b117e56351f808dbb8b0e808">IncRef</a> (AstPtr ast)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment and decrement reference counters on terms, sorts and declarations.  <a href="#ab8387be0b117e56351f808dbb8b0e808"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#afb2f967c3369cea3be9967c33403e7c7">RawContext</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_config.html">Config</a>^config)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a logical context using the given configuration.  <a href="#afb2f967c3369cea3be9967c33403e7c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3383f0c4429ce6cb11772eaf5dbc9e5f">RawContext</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_config.html">Config</a>^config, ReferenceCounted^rc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a logical context using the given configuration.  <a href="#a3383f0c4429ce6cb11772eaf5dbc9e5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RawTheory&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa414182801e38192dfb8beed739bfe23">MkTheory</a> (String^name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create user theory.  <a href="#aa414182801e38192dfb8beed739bfe23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a606e29bd48b267e20d8d04388cec4e4a">Query</a> (TermPtr query)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">post a query. The return value is LBool.True if the query is satisfiabl,e it is LBool.False if it is not satisfiabled, and Undef on timeouts or approximation.  <a href="#a606e29bd48b267e20d8d04388cec4e4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e">SearchFailureExplanation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0c54f0a096c506bf93bce1532ddf977a">GetQueryStatus</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">retrieve details on the search satus.  <a href="#a0c54f0a096c506bf93bce1532ddf977a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab2ed8df926ca0b94a1f186a7b7e529de">GetQueryAnswer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">retrieve formula that satisfies the previous query, assuming the return value was LBool.True  <a href="#ab2ed8df926ca0b94a1f186a7b7e529de"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Tracing and logging</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6381f3cb9e62a869a505bd9ffe6d3f5c"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae767eef7c521b644401e58a4adfb11a6">EnableDebugTrace</a> (String^tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable low-level debug tracing.  <a href="#ae767eef7c521b644401e58a4adfb11a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a74d274e8e6fc3ccc4ac39a375c0cc536">ToggleWarningMessages</a> (bool enabled)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable warning messages sent to the console out/error.  <a href="#a74d274e8e6fc3ccc4ac39a375c0cc536"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9e7467b18eba9cc3dc04495a7c51d1fa">UpdateParamValue</a> (String^param_id, String^value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update a mutable configuration parameter.  <a href="#a9e7467b18eba9cc3dc04495a7c51d1fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a23eedc7261b7af0d10d69bbb392d203d">GetParamValue</a> (String^param_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a configuration parameter.  <a href="#a23eedc7261b7af0d10d69bbb392d203d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a925fd320cf1476d3b08d70f169c6790d">SetLogic</a> (String^logic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configure the SMTLIB logic to be used in the given logical context.  <a href="#a925fd320cf1476d3b08d70f169c6790d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Symbols</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5214a8a633c296d1d9d504fc54556692"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4e1f9e0325bac5897d7d4099eca72ed0">MkSymbol</a> (int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a Z3 symbol using an intege or a string.  <a href="#a4e1f9e0325bac5897d7d4099eca72ed0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09d8a08a1734819f7a353936f46e56a1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSymbol" ref="a09d8a08a1734819f7a353936f46e56a1" args="(String^s)" -->
<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSymbol</b> (String^s)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpf2d346b1bb7c1c85ab6f7f21e3666b9f"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5111a4b70cadfbdb76491c889b57a312">MkSort</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a free (uninterpreted) type using the given name (symbol).  <a href="#a5111a4b70cadfbdb76491c889b57a312"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49a159fb80840f71583471f066a1fe23"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSort" ref="a49a159fb80840f71583471f066a1fe23" args="(String^s)" -->
SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSort</b> (String^s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a646a11b4d9e0f97d2adb789f5ab6daa0"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSort" ref="a646a11b4d9e0f97d2adb789f5ab6daa0" args="(int i)" -->
SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSort</b> (int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5a24352b12189b45134064790859850a">MkBoolSort</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the boolean type.  <a href="#a5a24352b12189b45134064790859850a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b">MkIntSort</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an integer type.  <a href="#a04bf543bb7b59788f7b7d40d4738648b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81">MkRealSort</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a real type.  <a href="#a9fc32a94ce1e1064c04f7fe4e1678e81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#adf17186c4a5ece22ff7d95d1b6722e7d">MkBvSort</a> (unsigned sz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a bit-vector type of the given size.  <a href="#adf17186c4a5ece22ff7d95d1b6722e7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a011fb26d01e3b5e696f5148da6d53d91">MkArraySort</a> (SortPtr domain, SortPtr range)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an array type.  <a href="#a011fb26d01e3b5e696f5148da6d53d91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a73705995afcb9e00c07338fbfc9b4b49">MkFiniteDomainSort</a> (String^name, unsigned __int64 domain_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a named finite domain sort.  <a href="#a73705995afcb9e00c07338fbfc9b4b49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af75bb103fc493958385de9c849482df9">MkTupleSort</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^mk_tuple_name, array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^field_names, array&lt; SortPtr &gt;^field_types,[Out] FuncDeclPtr%mk_tuple_decl,[In][Out] array&lt; FuncDeclPtr &gt;^proj_decl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a tuple type.  <a href="#af75bb103fc493958385de9c849482df9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e8b9d4b16d79ff2e248f1c70d300ed7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkTupleSort" ref="a1e8b9d4b16d79ff2e248f1c70d300ed7" args="(String^mk_tuple_name, array&lt; String^&gt;^field_names, array&lt; SortPtr &gt;^field_types,[Out] FuncDeclPtr%mk_tuple_decl,[In, Out] array&lt; FuncDeclPtr &gt;^proj_decl)" -->
SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkTupleSort</b> (String^mk_tuple_name, array&lt; String^&gt;^field_names, array&lt; SortPtr &gt;^field_types,[Out] FuncDeclPtr%mk_tuple_decl,[In, Out] array&lt; FuncDeclPtr &gt;^proj_decl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a72b2b9b3967c4638276bdccbdb0c9471">MkEnumerationSort</a> (String^name, array&lt; String^&gt;^enum_names, array&lt; FuncDeclPtr &gt;^enum_consts, array&lt; FuncDeclPtr &gt;^enum_testers)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create an enumeration type.  <a href="#a72b2b9b3967c4638276bdccbdb0c9471"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4d98cdbaeab75d52989ffbd655312dc6">MkListSort</a> (String^name, SortPtr elem_sort,[Out] FuncDeclPtr%nil_decl,[Out] FuncDeclPtr%is_nil_decl,[Out] FuncDeclPtr%cons_decl,[Out] FuncDeclPtr%is_cons_decl,[Out] FuncDeclPtr%head_decl,[Out] FuncDeclPtr%tail_decl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create list sort.  <a href="#a4d98cdbaeab75d52989ffbd655312dc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a30d1032d60ebd18e9d99d5c4191ab7b8">MkConstructor</a> (String^name, String^tester, array&lt; String^&gt;^field_names, array&lt; SortPtr &gt;^field_sorts, array&lt; unsigned &gt;^field_refs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create constructor object for datatype declarations. The object must be disposed with manually.  <a href="#a30d1032d60ebd18e9d99d5c4191ab7b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad778d157f274c72a2e88b806b41df89c">GetConstructor</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">retrieve constructor function declaration.  <a href="#ad778d157f274c72a2e88b806b41df89c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a97a7320cd3d9a7d77f52bf789f5c8839">GetTester</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">retrieve test function for constructor.  <a href="#a97a7320cd3d9a7d77f52bf789f5c8839"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">array&lt; FuncDeclPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab3ed56054afb442b0c26b073104c330e">GetAccessors</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">retrieve accessors for datatype.  <a href="#ab3ed56054afb442b0c26b073104c330e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#adb386d1976b2c6587844fe995444c46f">MkDataType</a> (String^name, array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&gt;^constructors)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create datatype sort.  <a href="#adb386d1976b2c6587844fe995444c46f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">array&lt; SortPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa44dbeb0d3495a206820ffa9ce249a0a">MkDataTypes</a> (array&lt; String^&gt;^names, array&lt; array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&gt;^&gt;^constructors)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create datatype sorts.  <a href="#aa44dbeb0d3495a206820ffa9ce249a0a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constants and Applications</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp7d7b29cd89445ba7223cbe1fd53c6244"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749">MkFuncDecl</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s, array&lt; SortPtr &gt;^domain, SortPtr range)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare a constant or function.  <a href="#a2bb4cecfa5619dbf2ed8f53d3b2f5749"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8cba05a2404c3c1e665ac951566eca4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="af8cba05a2404c3c1e665ac951566eca4" args="(String^s, array&lt; SortPtr &gt;^domain, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkFuncDecl</b> (String^s, array&lt; SortPtr &gt;^domain, SortPtr range)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea3b49f96cf036380d14a048ff676475"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConstDecl" ref="aea3b49f96cf036380d14a048ff676475" args="(Symbol^s, SortPtr ty)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkConstDecl</b> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s, SortPtr ty)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6088cc8ce911201229b364f1341b5aaf"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="a6088cc8ce911201229b364f1341b5aaf" args="(Symbol^s, SortPtr domain, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkFuncDecl</b> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s, SortPtr domain, SortPtr range)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c579ac1d186ef01534d6a396740a527"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="a6c579ac1d186ef01534d6a396740a527" args="(Symbol^s, SortPtr d1, SortPtr d2, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkFuncDecl</b> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s, SortPtr d1, SortPtr d2, SortPtr range)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93fedafeae678cac892223d88d29f7ff"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConstDecl" ref="a93fedafeae678cac892223d88d29f7ff" args="(String^s, SortPtr ty)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkConstDecl</b> (String^s, SortPtr ty)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f7d1875b95ff5851f5d5efd593a99cc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="a6f7d1875b95ff5851f5d5efd593a99cc" args="(String^s, SortPtr domain, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkFuncDecl</b> (String^s, SortPtr domain, SortPtr range)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb5e3934f525cf1f6bf1e10887bdbd95"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="abb5e3934f525cf1f6bf1e10887bdbd95" args="(String^s, SortPtr d1, SortPtr d2, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkFuncDecl</b> (String^s, SortPtr d1, SortPtr d2, SortPtr range)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50">MkApp</a> (FuncDeclPtr d, array&lt; TermPtr &gt;^args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a constant or function application.  <a href="#aa8a8ba273adfaadc01562b901524fd50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a7ce2ea730c4e1e5819919524b10782"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkApp" ref="a1a7ce2ea730c4e1e5819919524b10782" args="(FuncDeclPtr d, TermPtr arg)" -->
AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkApp</b> (FuncDeclPtr d, TermPtr arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a015b7c8c3603e50e4d16c1c40c09ecbf"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkApp" ref="a015b7c8c3603e50e4d16c1c40c09ecbf" args="(FuncDeclPtr d, TermPtr arg1, TermPtr arg2)" -->
AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkApp</b> (FuncDeclPtr d, TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5325f64b80a469970b7687ceab1e5cc2"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkApp" ref="a5325f64b80a469970b7687ceab1e5cc2" args="(FuncDeclPtr d, TermPtr arg1, TermPtr arg2, TermPtr arg3)" -->
AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkApp</b> (FuncDeclPtr d, TermPtr arg1, TermPtr arg2, TermPtr arg3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4119e0d04b9b4b8e95969e261b06aab7">MkConst</a> (FuncDeclPtr d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare and create a constant.  <a href="#a4119e0d04b9b4b8e95969e261b06aab7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b0770d3a236d24800348b296eed2e8a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConst" ref="a1b0770d3a236d24800348b296eed2e8a" args="(String^s, SortPtr ty)" -->
AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkConst</b> (String^s, SortPtr ty)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e7cd6efbeb680da34246288ddb7dcfc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConst" ref="a9e7cd6efbeb680da34246288ddb7dcfc" args="(Symbol^s, SortPtr ty)" -->
AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkConst</b> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s, SortPtr ty)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5251d6fc152aea96eac0e9e702dad707">MkFreshFuncDecl</a> (String^prefix, array&lt; SortPtr &gt;^domain, SortPtr range)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare a fresh constant or function.  <a href="#a5251d6fc152aea96eac0e9e702dad707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aabc8469e3803c5413a1a69c7cd001672">MkFreshConst</a> (String^prefix, SortPtr ty)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare and create a fresh constant.  <a href="#aabc8469e3803c5413a1a69c7cd001672"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aebcce24f39e8ce68930346c48ac5a57f">MkLabel</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^name, bool pos, TermPtr fml)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create labeled formula.  <a href="#aebcce24f39e8ce68930346c48ac5a57f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab462a1d684499a2265ee02801dfcb4f4">MkTrue</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>true</code>.  <a href="#ab462a1d684499a2265ee02801dfcb4f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4c138a08931900ebb7396484a6294cff">MkFalse</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>false</code>.  <a href="#a4c138a08931900ebb7396484a6294cff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab5b455baaffd7f2bf2a9508f801819de">MkEq</a> (TermPtr l, TermPtr r)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>l = r</code>.  <a href="#ab5b455baaffd7f2bf2a9508f801819de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a89bdd6aba66dab2a90592cea3263eb74">MkDistinct</a> (array&lt; TermPtr &gt;^args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>distinct(args[0], ..., args[args.Length-1])</code>.  <a href="#a89bdd6aba66dab2a90592cea3263eb74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#afc672bf3d4167000f8511454ef05a83d">MkNot</a> (TermPtr arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>not(a)</code>.  <a href="#afc672bf3d4167000f8511454ef05a83d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4c1882945cd1a8462070e5d92e7a6b93">MkIte</a> (TermPtr t1, TermPtr t2, TermPtr t3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing an if-then-else: <code>ite(t1, t2, t3)</code>.  <a href="#a4c1882945cd1a8462070e5d92e7a6b93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af0019c9b938cbfc228d538500e25ab1f">MkIff</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>t1 iff t2</code>.  <a href="#af0019c9b938cbfc228d538500e25ab1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#afcbf82213943aa0a30efb51dbf81b7dd">MkImplies</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>t1 implies t2</code>.  <a href="#afcbf82213943aa0a30efb51dbf81b7dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a80631b59bd60e34b88cdc676274334b0">MkXor</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>t1 xor t2</code>.  <a href="#a80631b59bd60e34b88cdc676274334b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8793a422c6c2d7b34000cc0032a4cdc4">MkAnd</a> (array&lt; TermPtr &gt;^args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>args[0] and ... and args[args.Length-1]</code>.  <a href="#a8793a422c6c2d7b34000cc0032a4cdc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9f066dd8874ff5cf46e98000e7a8b70"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkAnd" ref="ae9f066dd8874ff5cf46e98000e7a8b70" args="(TermPtr arg1, TermPtr arg2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkAnd</b> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a72a8f73bed309b8924dd49eba903bb24">MkOr</a> (array&lt; TermPtr &gt;^args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>args[0] or ... or args[args.Length-1]</code>.  <a href="#a72a8f73bed309b8924dd49eba903bb24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8c4978b2f3002563c99febd28722fda"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkOr" ref="ad8c4978b2f3002563c99febd28722fda" args="(TermPtr arg1, TermPtr arg2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkOr</b> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5668c488c12e405f662807b4f47860da">MkAdd</a> (array&lt; TermPtr &gt;^args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>args[0] + ... + args[args.Length-1]</code>.  <a href="#a5668c488c12e405f662807b4f47860da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05f1e9e13ed994d2d6b3da91f3ae53d6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkAdd" ref="a05f1e9e13ed994d2d6b3da91f3ae53d6" args="(TermPtr arg1, TermPtr arg2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkAdd</b> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa20eacf8d7fa0e446c1081e5ff01de77">MkMul</a> (array&lt; TermPtr &gt;^args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>args[0] * ... * args[args.Length-1]</code>.  <a href="#aa20eacf8d7fa0e446c1081e5ff01de77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af98a6c9470b5f2f39f418ce49f29e619"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkMul" ref="af98a6c9470b5f2f39f418ce49f29e619" args="(TermPtr arg1, TermPtr arg2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkMul</b> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a01178a7c619ac2bd6c2e4d4f3da743d2">MkSub</a> (array&lt; TermPtr &gt;^args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>args[0] - ... - args[args.Length - 1]</code>.  <a href="#a01178a7c619ac2bd6c2e4d4f3da743d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f7f345609875c3279b167a92e9e4df3"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSub" ref="a0f7f345609875c3279b167a92e9e4df3" args="(TermPtr arg1, TermPtr arg2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSub</b> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4314bcfc4435b1f79028bc11b8774c28">MkUnaryMinus</a> (TermPtr arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>- arg</code>.  <a href="#a4314bcfc4435b1f79028bc11b8774c28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae7f8e2e8eb754c5a87fa3faa51ff8baf">MkDiv</a> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create integer or real division.  <a href="#ae7f8e2e8eb754c5a87fa3faa51ff8baf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5a9f33467a473c739edac3721e0d56ea">MkMod</a> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create integer modulus.  <a href="#a5a9f33467a473c739edac3721e0d56ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5e8abfb87c0e9eb2be93a85af185038e">MkRem</a> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create integer remainder.  <a href="#a5e8abfb87c0e9eb2be93a85af185038e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aecac3390e05c8743587c5bed03338b84">MkToReal</a> (TermPtr arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create coercion from integer to real.  <a href="#aecac3390e05c8743587c5bed03338b84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a89955af727ba82dbb38b734befd37cdc">MkToInt</a> (TermPtr arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create coercion from real to integer (floor).  <a href="#a89955af727ba82dbb38b734befd37cdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a71f742709784da4b25d39a72d4cd3b69">MkIsInt</a> (TermPtr arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if real is an integer value.  <a href="#a71f742709784da4b25d39a72d4cd3b69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa817a455803ab79b220b0182b48e2ae5">MkLt</a> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create less than.  <a href="#aa817a455803ab79b220b0182b48e2ae5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa4993b3a46531ed7c4924d64185344d2">MkLe</a> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create less than or equal to.  <a href="#aa4993b3a46531ed7c4924d64185344d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5935871bfbeda8fcd6bc467d8d49afc2">MkGt</a> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create greater than.  <a href="#a5935871bfbeda8fcd6bc467d8d49afc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a7a08b71116843992a1078d9df3889f09">MkGe</a> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create greater than or equal to.  <a href="#a7a08b71116843992a1078d9df3889f09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a45b8b6397e45ac3fc6b38e873eed9d33">MkBvNot</a> (TermPtr t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise negation.  <a href="#a45b8b6397e45ac3fc6b38e873eed9d33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4487dd1d501cb49fa5f4d046e28ae650">MkBvReduceAnd</a> (TermPtr t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take conjunction of bits in vector.  <a href="#a4487dd1d501cb49fa5f4d046e28ae650"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab00941985b6e6675b2304831aa4845c0">MkBvReduceOr</a> (TermPtr t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take disjunction of bits in vector.  <a href="#ab00941985b6e6675b2304831aa4845c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aadd6a00031fb92a88ca6c177d4d75509">MkBvAnd</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise and.  <a href="#aadd6a00031fb92a88ca6c177d4d75509"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a472170308fc0ce228ad1ee1b683811cd">MkBvOr</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise or.  <a href="#a472170308fc0ce228ad1ee1b683811cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a684ce5c64067b6d5d4cddfbfe32789b4">MkBvXor</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise exclusive-or.  <a href="#a684ce5c64067b6d5d4cddfbfe32789b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5d58dfc570dde7e49faab8ed4dcfbfc7">MkBvNand</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise nand.  <a href="#a5d58dfc570dde7e49faab8ed4dcfbfc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa486a9f49b3fc395f37b56f0975a243b">MkBvNor</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise nor.  <a href="#aa486a9f49b3fc395f37b56f0975a243b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0112b7f61d18dcd15369566cdcf4b05f">MkBvXnor</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise xnor.  <a href="#a0112b7f61d18dcd15369566cdcf4b05f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae21724e2d70e5aec94cfa59726565063">MkBvNeg</a> (TermPtr t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard two's complement unary minus.  <a href="#ae21724e2d70e5aec94cfa59726565063"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a30237a1d6603428640b6db89d5d157fa">MkBvAdd</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard two's complement addition.  <a href="#a30237a1d6603428640b6db89d5d157fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea836bb8f5dcec3f401d77538e31e248">MkBvSub</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard two's complement subtraction.  <a href="#aea836bb8f5dcec3f401d77538e31e248"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae5585802bf0ff4f5188bfbe1fd361470">MkBvMul</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard two's complement multiplication.  <a href="#ae5585802bf0ff4f5188bfbe1fd361470"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a98ee5b832fa8f1a44998a2541bf4114c">MkBvUdiv</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned division.  <a href="#a98ee5b832fa8f1a44998a2541bf4114c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae96a3f936b75c53d7ab8eed094eb7b94">MkBvSdiv</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed division.  <a href="#ae96a3f936b75c53d7ab8eed094eb7b94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a30f13a71debd51968bc2129eaa26121d">MkBvUrem</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned remainder.  <a href="#a30f13a71debd51968bc2129eaa26121d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a1db91c0489ac65927dc14613e0b2225b">MkBvSrem</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed remainder (sign follows dividend).  <a href="#a1db91c0489ac65927dc14613e0b2225b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a094b16beaa982ef3500633b3482d2603">MkBvSmod</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed remainder (sign follows divisor).  <a href="#a094b16beaa982ef3500633b3482d2603"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a71e25df68e31503191875d9348c9f823">MkBvUlt</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned less than.  <a href="#a71e25df68e31503191875d9348c9f823"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8352294e2808ce534fc83ec39bca8fbd">MkBvSlt</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed less than.  <a href="#a8352294e2808ce534fc83ec39bca8fbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa434742064f523ecf5a7e13a113df86b">MkBvUle</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned less than or equal to.  <a href="#aa434742064f523ecf5a7e13a113df86b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac37363c17a7308be4ca999068da16fbb">MkBvSle</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed less than or equal to.  <a href="#ac37363c17a7308be4ca999068da16fbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#acb5149b9f7b1d823cd93ed6f43db5a17">MkBvUge</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned greater than or equal to.  <a href="#acb5149b9f7b1d823cd93ed6f43db5a17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a27a2d12f9e8d5639fa86b4d0997e2b17">MkBvSge</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed greater than or equal to.  <a href="#a27a2d12f9e8d5639fa86b4d0997e2b17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#afcb8b1208ec0cc2c1579c29158b3815e">MkBvUgt</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned greater than.  <a href="#afcb8b1208ec0cc2c1579c29158b3815e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a013910a4fa70b37878520b4400b1c107">MkBvSgt</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed greater than.  <a href="#a013910a4fa70b37878520b4400b1c107"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#afaba9154d1be03ec6d738951e94d37cb">MkBvConcat</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate the given bit-vectors.  <a href="#afaba9154d1be03ec6d738951e94d37cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac2c8940627f740c9ec3b637ef2031887">MkBvExtract</a> (unsigned high, unsigned low, TermPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract the bits <code>high</code> down to <code>low</code> from a bitvector of size <code>m</code> to yield a new bitvector of size <code>n</code>, where <code>n = high - low + 1</code>.  <a href="#ac2c8940627f740c9ec3b637ef2031887"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af94e12dbe34a66f358baebe8ef6848fc">MkBvSignExt</a> (unsigned i, TermPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sign-extend of the given bit-vector to the (signed) equivalent bitvector of size <code>m+i</code>, where <code>m</code> is the size of the given bit-vector.  <a href="#af94e12dbe34a66f358baebe8ef6848fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#add245de4256b820ef7d66ce58fd43385">MkBvZeroExt</a> (unsigned i, TermPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extend the given bit-vector with zeros to the (unsigned) equivalent bitvector of size <code>m+i</code>, where <code>m</code> is the size of the given bit-vector.  <a href="#add245de4256b820ef7d66ce58fd43385"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#afa18939e43ef603b1bdfac2cdbefd4f0">MkBvRepeat</a> (unsigned i, TermPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Repeat the bit-vector <code>i</code> times.  <a href="#afa18939e43ef603b1bdfac2cdbefd4f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a484c128e627a79c8af7fcbb531b0ba39">MkBvShl</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift left.  <a href="#a484c128e627a79c8af7fcbb531b0ba39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2de5b050301845c2fa902a8a910db8ed">MkBvLshr</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logical shift right.  <a href="#a2de5b050301845c2fa902a8a910db8ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4e8836887c24503234e99a94dd31a660">MkBvAshr</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arithmetic shift right.  <a href="#a4e8836887c24503234e99a94dd31a660"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#adecfc831ae6c9135828e3095b27a4956">MkBvRotateLeft</a> (unsigned i, TermPtr t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate bits of <code>t1</code> to the left <code>i</code> times.  <a href="#adecfc831ae6c9135828e3095b27a4956"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3df09da772a462d74c9f08546a44562b">MkBvRotateRight</a> (unsigned i, TermPtr t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate bits of <code>t1</code> to the right <code>i</code> times.  <a href="#a3df09da772a462d74c9f08546a44562b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac3ad21f1134a4ff73727b4bb4b364c2d">MkBvRotateLeft</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate bits of <code>t1</code> to the left <code>t2</code> times.  <a href="#ac3ad21f1134a4ff73727b4bb4b364c2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a78ad6677f780f863dad1e7e79997274e">MkBvRotateRight</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate bits of <code>t1</code> to the right <code>t2</code> times.  <a href="#a78ad6677f780f863dad1e7e79997274e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a711b2b4ca79395d1d56820b7b3f9b3cc">MkBv2Int</a> (TermPtr t1, bool is_signed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert bit vector to integer.  <a href="#a711b2b4ca79395d1d56820b7b3f9b3cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a43be2bceee8a6d4a870733196a149612">MkInt2Bv</a> (unsigned size, TermPtr t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert integer to bit vector.  <a href="#a43be2bceee8a6d4a870733196a149612"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a202fffba746c16499d216354e97ac74b">MkBvAddNoOverflow</a> (TermPtr t1, TermPtr t2, bool is_signed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that addition does not overflow.  <a href="#a202fffba746c16499d216354e97ac74b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a421fc4943889a1c10d2dddbdaac5d09d">MkBvAddNoUnderflow</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that addition does not underflow.  <a href="#a421fc4943889a1c10d2dddbdaac5d09d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a44065d4fa565d6efa0f351f266c61c58">MkBvSubNoOverflow</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that subtraction does not overflow.  <a href="#a44065d4fa565d6efa0f351f266c61c58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3386aa55309ead169a54aeeed1cef0d6">MkBvSubNoUnderflow</a> (TermPtr t1, TermPtr t2, bool is_signed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that subtraction does not underflow.  <a href="#a3386aa55309ead169a54aeeed1cef0d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac537f6c8529718162b4a16a926f145f8">MkBvSDivNoOverflow</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that division does not overflow.  <a href="#ac537f6c8529718162b4a16a926f145f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a7dcdbe9ddac5ccf9744174f4a20aac19">MkBvNegNoOverflow</a> (TermPtr t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that negation does not overflow.  <a href="#a7dcdbe9ddac5ccf9744174f4a20aac19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a688f2a2cb04cb30f68dca62c6477f14b">MkBvMulNoOverflow</a> (TermPtr t1, TermPtr t2, bool is_signed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that multiplication does not overflow.  <a href="#a688f2a2cb04cb30f68dca62c6477f14b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a036fccd286efdc90134941defd6a1df8">MkBvMulNoUnderflow</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that multiplication does not underflow.  <a href="#a036fccd286efdc90134941defd6a1df8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af0606dc016c08c4086d43d43ed45794c">MkArraySelect</a> (TermPtr a, TermPtr i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array read.  <a href="#af0606dc016c08c4086d43d43ed45794c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aaed9edcce01c069fcb982262ae01e14d">MkArrayStore</a> (TermPtr a, TermPtr i, TermPtr v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array update.  <a href="#aaed9edcce01c069fcb982262ae01e14d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3fcbf7757a9ffdb56c4bdd145c145246">MkArrayMap</a> (FuncDeclPtr d, array&lt; TermPtr &gt;^args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array map.  <a href="#a3fcbf7757a9ffdb56c4bdd145c145246"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab5341894979c077ef1ad93ef67691c2a">MkArrayConst</a> (SortPtr domain, TermPtr v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant array.  <a href="#ab5341894979c077ef1ad93ef67691c2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac645da9e615bc4e20515ef3cd8f74893">MkArrayDefault</a> (TermPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the array default.  <a href="#ac645da9e615bc4e20515ef3cd8f74893"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Sets</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp86f5baf708c6c250204451eb89736947"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4fd038edb773b86952a3f4890d6bb0f5">MkSetSort</a> (SortPtr ty)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create Set type.  <a href="#a4fd038edb773b86952a3f4890d6bb0f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae3a1a555a0fce2e8c1dfdfb863b56216">MkEmptySet</a> (SortPtr ty)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the empty set.  <a href="#ae3a1a555a0fce2e8c1dfdfb863b56216"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a71d300776d9303680e79f784a2644e4c">MkFullSet</a> (SortPtr ty)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the full set.  <a href="#a71d300776d9303680e79f784a2644e4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a443543c80f0ace5c902df3589d3154c4">MkSetAdd</a> (TermPtr set, TermPtr elem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an element to a set.  <a href="#a443543c80f0ace5c902df3589d3154c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a99a686c0e68a6862f47f066eac39f84e">MkSetDel</a> (TermPtr set, TermPtr elem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an element to a set.  <a href="#a99a686c0e68a6862f47f066eac39f84e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a72da2154689afc36a91ba955e9ccf081">MkSetUnion</a> (array&lt; TermPtr &gt;^sets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take the union of a arrays of sets.  <a href="#a72da2154689afc36a91ba955e9ccf081"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a621809e5409417fe6c15543391378c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetUnion" ref="a3a621809e5409417fe6c15543391378c" args="(TermPtr set1, TermPtr set2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSetUnion</b> (TermPtr set1, TermPtr set2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a1bb3e567ae8090d8a659ad556c083e32">MkSetIntersect</a> (array&lt; TermPtr &gt;^sets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take the intersection of a arrays of sets.  <a href="#a1bb3e567ae8090d8a659ad556c083e32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea3abcabd7822795387885d0f8dff43c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetIntersect" ref="aea3abcabd7822795387885d0f8dff43c" args="(TermPtr set1, TermPtr set2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSetIntersect</b> (TermPtr set1, TermPtr set2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad51d6429450362ce9dc9f476b86d22e1">MkSetDifference</a> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take the set difference between two sets.  <a href="#ad51d6429450362ce9dc9f476b86d22e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae33216f5018efff4077640204c219dc2">MkSetComplement</a> (TermPtr arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take the complement of a set.  <a href="#ae33216f5018efff4077640204c219dc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8449281ead0996eccbe5867d3b6ca96c">MkSetMember</a> (TermPtr elem, TermPtr set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for set membership.  <a href="#a8449281ead0996eccbe5867d3b6ca96c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac05b3fbb60eecb46617782cd53e2b293">MkSetSubset</a> (TermPtr arg1, TermPtr arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for subsetness of sets.  <a href="#ac05b3fbb60eecb46617782cd53e2b293"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Injective functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp416b3f905361ddea45e5b6a444ec6031"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a1c4f013234b21f0c4599f3c44fb778fb">MkInjectiveFunction</a> (String^name, array&lt; SortPtr &gt;^domain, SortPtr range)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create injective function.  <a href="#a1c4f013234b21f0c4599f3c44fb778fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47bac504c0044a005351db1ff40ddf28"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkInjectiveFunction" ref="a47bac504c0044a005351db1ff40ddf28" args="(Symbol^name, array&lt; SortPtr &gt;^domain, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkInjectiveFunction</b> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^name, array&lt; SortPtr &gt;^domain, SortPtr range)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Numerals</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd07ae7077a8b8edd229ba6a965699bfd"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196">MkNumeral</a> (String^numeral, SortPtr ty)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a numeral of a given type.  <a href="#ad04ee26dbb08422102bdc1189e293196"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad87299eff0469717b9d4e4605ced2644"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNumeral" ref="ad87299eff0469717b9d4e4605ced2644" args="(int n, SortPtr ty)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkNumeral</b> (int n, SortPtr ty)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68c052546b106dd7ce0958b7fc8f8ae1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNumeral" ref="a68c052546b106dd7ce0958b7fc8f8ae1" args="(unsigned n, SortPtr ty)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkNumeral</b> (unsigned n, SortPtr ty)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6740ac1dd6beaa381b5aa8c0e3e9e7f8"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNumeral" ref="a6740ac1dd6beaa381b5aa8c0e3e9e7f8" args="(__int64 n, SortPtr ty)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkNumeral</b> (__int64 n, SortPtr ty)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a051610b11665f400cf4aa443b4b8c6fc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNumeral" ref="a051610b11665f400cf4aa443b4b8c6fc" args="(unsigned __int64 n, SortPtr ty)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkNumeral</b> (unsigned __int64 n, SortPtr ty)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3">MkIntNumeral</a> (String^n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a numeral of type Int.  <a href="#a48ef6618f933a3cf309e8462e48cf4e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44c551f535a6a7e14dc9b1bfce4d0bbd"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIntNumeral" ref="a44c551f535a6a7e14dc9b1bfce4d0bbd" args="(int n)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkIntNumeral</b> (int n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77e5e490494056fe8208670bfa8e3b08"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIntNumeral" ref="a77e5e490494056fe8208670bfa8e3b08" args="(unsigned n)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkIntNumeral</b> (unsigned n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c5550feb945bf1a0131017d40f45782"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIntNumeral" ref="a8c5550feb945bf1a0131017d40f45782" args="(__int64 n)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkIntNumeral</b> (__int64 n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac68dc0a00b2ae526f0f12f2acd027463"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIntNumeral" ref="ac68dc0a00b2ae526f0f12f2acd027463" args="(unsigned __int64 n)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkIntNumeral</b> (unsigned __int64 n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40">MkRealNumeral</a> (String^n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a numeral of type Real.  <a href="#ac6bbb2be135e462bf68e86d53e07eb40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2531aa006d0fe42cec320e61123baf19"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkRealNumeral" ref="a2531aa006d0fe42cec320e61123baf19" args="(int n)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkRealNumeral</b> (int n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0325a91b173a42859f4187b0eb48082c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkRealNumeral" ref="a0325a91b173a42859f4187b0eb48082c" args="(unsigned n)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkRealNumeral</b> (unsigned n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e6a61de7c9fc6198e0d1eb6c0b47ded"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkRealNumeral" ref="a5e6a61de7c9fc6198e0d1eb6c0b47ded" args="(__int64 n)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkRealNumeral</b> (__int64 n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac55efb1e6f79074149118058e6ff20bf"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkRealNumeral" ref="ac55efb1e6f79074149118058e6ff20bf" args="(unsigned __int64 n)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkRealNumeral</b> (unsigned __int64 n)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Quantifiers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpe2ab8ac3d2e085e624d15e1383e79ab5"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PatternPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a">MkPattern</a> (array&lt; TermPtr &gt;^terms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a pattern for quantifier instantiation.  <a href="#a8a941e796cdc983459602aeb22178d8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2e1ef04d234928c64248ce7eaf73502a">MkBound</a> (unsigned index, SortPtr ty)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a bound variable.  <a href="#a2e1ef04d234928c64248ce7eaf73502a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe">MkForall</a> (unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^names, TermPtr body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a forall formula.  <a href="#ad7d64f035d843f300b7fffcfb148e1fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a810d22421101b29aef8864c6e2aa3a3f">MkForall</a> (unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; String^&gt;^names, TermPtr body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a forall formula.  <a href="#a810d22421101b29aef8864c6e2aa3a3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8c6471e0eb3e8a5a5a6c7c7e9e5bd8d7">MkForall</a> (unsigned weight, array&lt; AppPtr &gt;^bound, array&lt; PatternPtr &gt;^patterns, TermPtr body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a forall formula.  <a href="#a8c6471e0eb3e8a5a5a6c7c7e9e5bd8d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9">MkExists</a> (unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^names, TermPtr body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an exists formula. Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a>.  <a href="#a60c9cdf799990ce4ed2dd7f8caa914e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29b180bdd8f7dab8a79fef081d6c6e83"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkExists" ref="a29b180bdd8f7dab8a79fef081d6c6e83" args="(unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; String^&gt;^names, TermPtr body)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkExists</b> (unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; String^&gt;^names, TermPtr body)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbd2d3966ec0fa20840339907a090a85"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkExists" ref="abbd2d3966ec0fa20840339907a090a85" args="(unsigned weight, array&lt; AppPtr &gt;^bound, array&lt; PatternPtr &gt;^patterns, TermPtr body)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkExists</b> (unsigned weight, array&lt; AppPtr &gt;^bound, array&lt; PatternPtr &gt;^patterns, TermPtr body)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c">MkQuantifier</a> (bool is_forall, unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; TermPtr &gt;^no_patterns, array&lt; SortPtr &gt;^types, array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^names, TermPtr body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a quantifier with no-pattern directives and symbols.  <a href="#a3f6fe0d5e63e2aec779538fef2669a3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bd2ab283b4595e3c18fd81884692fec"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkQuantifier" ref="a1bd2ab283b4595e3c18fd81884692fec" args="(bool is_forall, unsigned weight, Symbol^quantifier_id, Symbol^skolem_id, array&lt; PatternPtr &gt;^patterns, array&lt; TermPtr &gt;^no_patterns, array&lt; SortPtr &gt;^types, array&lt; Symbol^&gt;^names, TermPtr body)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkQuantifier</b> (bool is_forall, unsigned weight, <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^quantifier_id, <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^skolem_id, array&lt; PatternPtr &gt;^patterns, array&lt; TermPtr &gt;^no_patterns, array&lt; SortPtr &gt;^types, array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^names, TermPtr body)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4727759e5f6b9a0a8629e3ac29ce47b8">MkQuantifier</a> (bool is_forall, unsigned weight, <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^quantifier_id, <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^skolem_id, array&lt; PatternPtr &gt;^patterns, array&lt; TermPtr &gt;^no_patterns, array&lt; TermPtr &gt;^bound, TermPtr body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a quantifier with no-pattern directives and symbols.  <a href="#a4727759e5f6b9a0a8629e3ac29ce47b8"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp04cb611d2bf0c8edd5b113799b30e174"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae810fc8c305ae442e0a516c1cb9f78a8">GetTermId</a> (TermPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a unique identifier for <code>t</code>.  <a href="#ae810fc8c305ae442e0a516c1cb9f78a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a30fc9cb5ea8660841b6912251b5c7574">GetFuncDeclId</a> (FuncDeclPtr f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a unique identifier for <code>f</code>.  <a href="#a30fc9cb5ea8660841b6912251b5c7574"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#acb7747c8b17c86b75c4102f6a5adfafd">GetSortId</a> (SortPtr s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a unique identifier for <code>s</code>.  <a href="#acb7747c8b17c86b75c4102f6a5adfafd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#ga05812818de02fb4b202d7513ce50745d">SymbolKind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0e5e137439c1194fe6ceadd130c32844">GetSymbolKind</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>SymbolKind.Int</code> if the symbol was constructed using MkIntSymbol, and <code>SymbolKind.String</code> if the symbol was constructed using MkStringSymbol.  <a href="#a0e5e137439c1194fe6ceadd130c32844"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#afabdd4c7aa7001151713568aaf4e27b9">GetSymbolInt</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the symbol int value.  <a href="#afabdd4c7aa7001151713568aaf4e27b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a63af55d0bc85edc1a08938fe94d059c3">GetSymbolString</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the symbol name.  <a href="#a63af55d0bc85edc1a08938fe94d059c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a95167a48c7a40a4acf32631a527758da">IsEq</a> (TermPtr t1, TermPtr t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if the two given AST nodes are equal.  <a href="#a95167a48c7a40a4acf32631a527758da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6e20e01d6d3f85406b9ba5091f2e60f7">IsWellSorted</a> (TermPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if <code>t</code> is well sorted.  <a href="#a6e20e01d6d3f85406b9ba5091f2e60f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc">TermKind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa92cc97ea26a5d7ca06f7337a750c964">GetTermKind</a> (TermPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the kind of the given AST.  <a href="#aa92cc97ea26a5d7ca06f7337a750c964"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425">DeclKind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab5bd163cb2dff9a325fd961d413a8c22">GetDeclKind</a> (FuncDeclPtr d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the kind of the built-in operator.  <a href="#ab5bd163cb2dff9a325fd961d413a8c22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">array&lt; <a class="el" href="interface_microsoft_1_1_z3_1_1_i_raw_parameter.html">IRawParameter</a>^&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#accdc25299d9fe8c5a7fa0889c46cbdf5">GetDeclParameters</a> (FuncDeclPtr d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return auxiliary parameters associated with the built-in operator. For example, the operator for bit-vector extraction uses two parameters, the upper and lower bit-index for extraction.  <a href="#accdc25299d9fe8c5a7fa0889c46cbdf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6aebc549137b2458e195ebe6d9d4c4ba">GetAppDecl</a> (AppPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the declaration of a constant or function application.  <a href="#a6aebc549137b2458e195ebe6d9d4c4ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">array&lt; TermPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab021d6b4e58c052472ec3cd6d2dd0fac">GetAppArgs</a> (AppPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the arguments of an application. If <code>t</code> is an constant, then array is empty.  <a href="#ab021d6b4e58c052472ec3cd6d2dd0fac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512">GetNumeralString</a> (TermPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of a numeric ast.  <a href="#aea8f522b8fd2fd2d7e48296b5c7a9512"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa00bb4f5b7abc37cf6c24e1c8ce08f4a">GetNumeralInt</a> (TermPtr v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine int. Throw InvalidArgument if the call fails.  <a href="#aa00bb4f5b7abc37cf6c24e1c8ce08f4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88b55d61e4809bb10bc62806385f5a3f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TryGetNumeralInt" ref="a88b55d61e4809bb10bc62806385f5a3f" args="(TermPtr v,[Out] int%i)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>TryGetNumeralInt</b> (TermPtr v,[Out] int%i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae40d08d8f9fc05ea8bb0b035f0da9f09">GetNumeralUInt</a> (TermPtr v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine unsigned int. Throw InvalidArgument if the call fails.  <a href="#ae40d08d8f9fc05ea8bb0b035f0da9f09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45c57058d28144a320c9befb686d41a0"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TryGetNumeralUInt" ref="a45c57058d28144a320c9befb686d41a0" args="(TermPtr v,[Out] unsigned int%u)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>TryGetNumeralUInt</b> (TermPtr v,[Out] unsigned int%u)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa78f20144c40600d63c87ebc8bd5d85e">GetNumeralUInt64</a> (TermPtr v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine unsigned long long int. Throw InvalidArgument if the call fails.  <a href="#aa78f20144c40600d63c87ebc8bd5d85e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa08f1290c8aabf083f251db7dc515f78"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TryGetNumeralUInt64" ref="aa08f1290c8aabf083f251db7dc515f78" args="(TermPtr v,[Out] unsigned __int64%u)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>TryGetNumeralUInt64</b> (TermPtr v,[Out] unsigned __int64%u)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a016d026fcaf6c2299687ae4407533390">GetNumeralInt64</a> (TermPtr v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine long long int. Throw InvalidArgument if the call fails.  <a href="#a016d026fcaf6c2299687ae4407533390"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f52fc54245c49e7df976cc272c49296"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TryGetNumeralInt64" ref="a3f52fc54245c49e7df976cc272c49296" args="(TermPtr v,[Out] __int64%i)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>TryGetNumeralInt64</b> (TermPtr v,[Out] __int64%i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af74f7a7602abaa3b7d6451f33439af63">TryGetNumeral</a> (TermPtr v,[Out] __int64%num,[Out] __int64%den)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine long long int. Throw InvalidArgument if the call fails.  <a href="#af74f7a7602abaa3b7d6451f33439af63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16fa8ae368ba270f7f3048d2d3da60fc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumeral" ref="a16fa8ae368ba270f7f3048d2d3da60fc" args="(TermPtr v,[Out] System::Numerics::BigInteger%num,[Out] System::Numerics::BigInteger%den)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNumeral</b> (TermPtr v,[Out] System::Numerics::BigInteger%num,[Out] System::Numerics::BigInteger%den)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a74ec06b79df90539553d1c53c2a02bdd">GetBoolValue</a> (TermPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Boolean value of a truth constant. Return LBool::Undef if a is not a boolean constant (true or false).  <a href="#a74ec06b79df90539553d1c53c2a02bdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a17499379d443ca6ee0bf3770d18135af">GetVarIndex</a> (TermPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the index of a de-Brujin bound variable.  <a href="#a17499379d443ca6ee0bf3770d18135af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RawQuantifier&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4dc623c04dfdeaef8d17f88034aab270">GetQuantifier</a> (TermPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return components of a quantifier.  <a href="#a4dc623c04dfdeaef8d17f88034aab270"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">array&lt; TermPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a029d7befda8b1da2f597b3c9d3b5b998">GetPatternTerms</a> (PatternPtr p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return array of terms in the pattern.  <a href="#a029d7befda8b1da2f597b3c9d3b5b998"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a7c62d9f2161dec8b726996082f05875c">GetDeclName</a> (FuncDeclPtr d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the constant declaration name as a symbol.  <a href="#a7c62d9f2161dec8b726996082f05875c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a16e84dca2b1d23ce89a98276e943eb59">GetSortName</a> (SortPtr ty)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the type name as a symbol.  <a href="#a16e84dca2b1d23ce89a98276e943eb59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad563e3268d5034c9147c98190c4327d6">GetSort</a> (TermPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the type of an AST node.  <a href="#ad563e3268d5034c9147c98190c4327d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">array&lt; SortPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a612c60dae8dbc7cc04ebf8a299d7f78d">GetDomain</a> (FuncDeclPtr d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the domain of a function declaration.  <a href="#a612c60dae8dbc7cc04ebf8a299d7f78d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a84d2dfcc3f579dcce0820cad12686f42">GetRange</a> (FuncDeclPtr d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the range of the given declaration.  <a href="#a84d2dfcc3f579dcce0820cad12686f42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#ga7664c6569cf130a5d166ec8c8dc27101">SortKind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac105e2a1c10a81fcbbda92338319b821">GetSortKind</a> (SortPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the type kind (e.g., array, tuple, int, bool, etc).  <a href="#ac105e2a1c10a81fcbbda92338319b821"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a423fc3c6dda476f6799a85a2168c78b1">GetBvSortSize</a> (SortPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the size of the given bit-vector type.  <a href="#a423fc3c6dda476f6799a85a2168c78b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad230ba9177f3ca00d509b1ee4f1ab8a5">GetArraySortDomain</a> (SortPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the domain of the given array type.  <a href="#ad230ba9177f3ca00d509b1ee4f1ab8a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3de655e8182580662528e278b9bef566">GetArraySortRange</a> (SortPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the range of the given array type.  <a href="#a3de655e8182580662528e278b9bef566"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8faadbc0b5b7aa7e1f5fb988eddb0467">GetTupleConstructor</a> (SortPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the constructor declaration of the given tuple type.  <a href="#a8faadbc0b5b7aa7e1f5fb988eddb0467"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">array&lt; FuncDeclPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a91e7e6ddb2615bb55ee58ea57c34f308">GetTupleFields</a> (SortPtr t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the field declarations of a given tuple type.  <a href="#a91e7e6ddb2615bb55ee58ea57c34f308"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifiers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpab38583cb2c8b20fce79578435547208"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a12f2bc414c2c1520880db1444edd72d1">UpdateTerm</a> (TermPtr t, array&lt; TermPtr &gt;^new_args)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the arguments of a term or quantifier.  <a href="#a12f2bc414c2c1520880db1444edd72d1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constraints</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa5d083fbfc0611e061663c6b1a8ba698"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c">Push</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a backtracking point.  <a href="#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aac40326c3b51f26bf05a823061429cc1">Pop</a> (unsigned num_scopes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Backtrack.  <a href="#aac40326c3b51f26bf05a823061429cc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a701a584ce72cccbcce9cb0656b6c898b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Pop" ref="a701a584ce72cccbcce9cb0656b6c898b" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Pop</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2782df00daf528e1c6d19097b19475f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumScopes" ref="ad2782df00daf528e1c6d19097b19475f" args="()" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNumScopes</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a268029705dabf988d7655c85df1b548e">PersistTerm</a> (TermPtr t, unsigned num_scopes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Persist a term during num_scopes of pops.  <a href="#a268029705dabf988d7655c85df1b548e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a48d8c58bf4484b54bf612a3b81526648">AssertCnstr</a> (TermPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assert a constraing into the logical context.  <a href="#a48d8c58bf4484b54bf612a3b81526648"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed51407e62b77b7bcc14d25ca8e320af">CheckAndGetModel</a> ([Out] <a class="el" href="class_microsoft_1_1_z3_1_1_raw_model.html">RawModel</a>^%m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the given logical context is consistent or not.  <a href="#aed51407e62b77b7bcc14d25ca8e320af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a">Check</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the given logical context is consistent or not.  <a href="#a338b5a83abb0751e1485885f7f6f513a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6623753616cdabbfeb889ed4a31dfbc7">CheckAssumptions</a> ([Out] <a class="el" href="class_microsoft_1_1_z3_1_1_raw_model.html">RawModel</a>^%m,[In] array&lt; TermPtr &gt;^assumptions,[Out] TermPtr%proof,[Out] array&lt; TermPtr &gt;^%core)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the given logical context is consistent or not with respect to auxiliary assumptions.  <a href="#a6623753616cdabbfeb889ed4a31dfbc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4717aab1cfc427ec9c049c9ba743a006">SoftCheckCancel</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel the current search initiated using <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a>, <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed51407e62b77b7bcc14d25ca8e320af" title="Check whether the given logical context is consistent or not.">CheckAndGetModel</a>, or <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6623753616cdabbfeb889ed4a31dfbc7" title="Check whether the given logical context is consistent or not with respect to auxiliary...">CheckAssumptions</a>.  <a href="#a4717aab1cfc427ec9c049c9ba743a006"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a680762fecac781975b588f102dd8ae3e">GetImpliedEqualities</a> ([In] array&lt; TermPtr &gt;^terms,[Out] array&lt; unsigned &gt;^%class_ids)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve congruence class representatives for terms.  <a href="#a680762fecac781975b588f102dd8ae3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e">SearchFailureExplanation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3c2e03935c06e79eb6c4b249b910307d">GetSearchFailureExplanation</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain explanation for search failure.  <a href="#a3c2e03935c06e79eb6c4b249b910307d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4db4d536f2203faa741073c01f61fb0e">GetAssignments</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return conjunction of literals and formulas assigned to true in the current state.  <a href="#a4db4d536f2203faa741073c01f61fb0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac91878a6a5fd8cb8173aed946528f42f">GetRelevantLabels</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve set of labels set in current satisfying assignment.  <a href="#ac91878a6a5fd8cb8173aed946528f42f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed54018936a4d19c92a05d8c770d3c33">GetRelevantLiterals</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve set of literals satisfying the current assignment.  <a href="#aed54018936a4d19c92a05d8c770d3c33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9522ebeb37a88abbb1a4a1c4cf75ac9f">GetGuessedLiterals</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve set of guessed literals satisfying the current assignment.  <a href="#a9522ebeb37a88abbb1a4a1c4cf75ac9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a712b529cbbcd86eb099bcb97289f9a77">BlockLiterals</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>^labels)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block the combination of remaining non-disabled labels.  <a href="#a712b529cbbcd86eb099bcb97289f9a77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a21c01788a1c75b8e9ee86634aec4ca8c">GetLiteral</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>^labels, unsigned idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain literal corresponding to index in list of literals.  <a href="#a21c01788a1c75b8e9ee86634aec4ca8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea36484f844217cc37a206be0fe565f6">Simplify</a> (TermPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface to simplifier.  <a href="#aea36484f844217cc37a206be0fe565f6"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">String conversion</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb80287159f835fe49edeac7e7e9b17d1"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a17471e6be035651820a92e6c4e31d673">SetPrintMode</a> (<a class="el" href="group__mapi.html#ga8fcc700aeeee633213b4e5f433e5e12e">PrintMode</a> mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select mode for the format used for pretty-printing AST nodes.  <a href="#a17471e6be035651820a92e6c4e31d673"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aeacea454f727994d3088b0a329ce0994">ToString</a> (AstPtr a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the given AST node into a string.  <a href="#aeacea454f727994d3088b0a329ce0994"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaf92bee9704e9bafb7cd576d4d0b4ef"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Display" ref="aaaf92bee9704e9bafb7cd576d4d0b4ef" args="(System::IO::TextWriter^w, AstPtr a)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Display</b> (System::IO::TextWriter^w, AstPtr a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a08d99b52685eab1e9d5ac4d9223cb2be">ToString</a> () override</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the given logical context into a string.  <a href="#a08d99b52685eab1e9d5ac4d9223cb2be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf8bef9b1d9ed1692886459d39821267"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Display" ref="aaf8bef9b1d9ed1692886459d39821267" args="(System::IO::TextWriter^w)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Display</b> (System::IO::TextWriter^w)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0c7570d3474aec2457249e00de34c51a">StatisticsToString</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the given logical context into a string.  <a href="#a0c7570d3474aec2457249e00de34c51a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac57794a2c82648589e3ff80d27701c85"></a><!-- doxytag: member="Microsoft::Z3::RawContext::DisplayStatistics" ref="ac57794a2c82648589e3ff80d27701c85" args="(System::IO::TextWriter^w)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>DisplayStatistics</b> (System::IO::TextWriter^w)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0805c579c20f25fec2c0f293259d9473">BenchmarkToSmtlib</a> (String^name, String^logic, String^status, String^attributes, array&lt; TermPtr &gt;^assumptions, TermPtr formula)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the given benchmark into SMT-LIB formatted string.  <a href="#a0805c579c20f25fec2c0f293259d9473"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Parser interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp08942d40136243c542bf881d555127d1"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3d9995b5f0cd4395f93c9ad17a63d7cc">ParseSmtlibString</a> (String^string,[In] array&lt; SortPtr &gt;^sorts,[In] array&lt; FuncDeclPtr &gt;^decls,[Out] array&lt; TermPtr &gt;^%assumptions,[Out] array&lt; TermPtr &gt;^%formulas,[Out] array&lt; FuncDeclPtr &gt;^%new_decls,[Out] array&lt; SortPtr &gt;^%new_sorts,[Out] String^%parser_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse the given string using the SMT-LIB parser.  <a href="#a3d9995b5f0cd4395f93c9ad17a63d7cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a189844e560a2e30995b6d68823304932">ParseSmtlibFile</a> (String^file,[In] array&lt; SortPtr &gt;^sorts,[In] array&lt; FuncDeclPtr &gt;^decls,[Out] array&lt; TermPtr &gt;^%assumptions,[Out] array&lt; TermPtr &gt;^%formulas,[Out] array&lt; FuncDeclPtr &gt;^%new_decls,[Out] array&lt; SortPtr &gt;^%new_sorts,[Out] String^%parser_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3d9995b5f0cd4395f93c9ad17a63d7cc" title="Parse the given string using the SMT-LIB parser.">ParseSmtlibString</a>, but reads the benchmark from a file.  <a href="#a189844e560a2e30995b6d68823304932"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ade46bed01c907e799528075996072637">ParseZ3String</a> (String^s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a string in the native Z3 format.  <a href="#ade46bed01c907e799528075996072637"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#abb1e2e3a1d96aa625758845ed3b8d534">ParseZ3File</a> (String^filename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a file containing formulas in Z3's native format.  <a href="#abb1e2e3a1d96aa625758845ed3b8d534"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#afd791c9297c9a547017ba2cf0b94ee81">ParseSmtlib2String</a> (String^s, array&lt; SortPtr &gt;^sorts, array&lt; FuncDeclPtr &gt;^decls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a string in the SMT-LIB2 format.  <a href="#afd791c9297c9a547017ba2cf0b94ee81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aedcfe737b097182e955e06099747630f">ParseSmtlib2File</a> (String^filename, array&lt; SortPtr &gt;^sorts, array&lt; FuncDeclPtr &gt;^decls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a file containing formulas in SMT-LIB2 format.  <a href="#aedcfe737b097182e955e06099747630f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9d6d0233ca62b250f4ab0d7ffd34a021">ExecSmtlib2String</a> (String^s, array&lt; SortPtr &gt;^sorts, array&lt; FuncDeclPtr &gt;^decls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute commands from a string in the SMT-LIB2 format.  <a href="#a9d6d0233ca62b250f4ab0d7ffd34a021"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a41d7b23fa1f48ebaab07718ca78d7d1e">ExecSmtlib2File</a> (String^filename, array&lt; SortPtr &gt;^sorts, array&lt; FuncDeclPtr &gt;^decls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute commands from a file containing formulas in SMT-LIB2 format.  <a href="#a41d7b23fa1f48ebaab07718ca78d7d1e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp387baf0199e7c9cc944fae94e96448fa"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a7068a418e65d2a184e2275e72300afc1">GetVersion</a> ([Out] unsigned%major,[Out] unsigned%minor,[Out] unsigned%build_number,[Out] unsigned%revision_number)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return Z3 version number information.  <a href="#a7068a418e65d2a184e2275e72300afc1"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Errors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5ef0c737746fae2ca90e66c39333f8f6"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a22af33e79aad8e443bfe2c249c6255ef">SetErrorHandler</a> (<a class="el" href="interface_microsoft_1_1_z3_1_1_i_error_handler.html">IErrorHandler</a>^h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a Z3 error handler.  <a href="#a22af33e79aad8e443bfe2c249c6255ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8478b135914c2e8c78127a50361331c4">GetErrorMessage</a> (<a class="el" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f">ErrorCode</a> err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing the given error code.  <a href="#a8478b135914c2e8c78127a50361331c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6bcc908b9ba41cd95dae64006321b34b">ResetMemory</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all resources allocated for Z3.  <a href="#a6bcc908b9ba41cd95dae64006321b34b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">internal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad9010a8c0b8110f5e670fa5fc280f064">__pad1__</a>: IntPtr m_simplifier_gch</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register user rewrite function.  <a href="#ad9010a8c0b8110f5e670fa5fc280f064"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Z3 API object. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l00868">868</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afb2f967c3369cea3be9967c33403e7c7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::RawContext" ref="afb2f967c3369cea3be9967c33403e7c7" args="(Config^config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html">RawContext</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_config.html">Config</a>^&nbsp;</td>
          <td class="paramname"> <em>config</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a logical context using the given configuration. </p>
<p>After a context is created, the configuration cannot be changed. All main interaction with Z3 happens in the context of a <code><a class="el" href="class_microsoft_1_1_z3_1_1_context.html" title="Type safe contexts.">Context</a></code>.</p>
<p>All contexts that are created must be disposed (call Dispose). Failure to dispose contexts cause memory leaks. Garbage collection will not free resources allocated in contexts. </p>

</div>
</div>
<a class="anchor" id="a3383f0c4429ce6cb11772eaf5dbc9e5f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::RawContext" ref="a3383f0c4429ce6cb11772eaf5dbc9e5f" args="(Config^config, ReferenceCounted^rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html">RawContext</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_config.html">Config</a>^&nbsp;</td>
          <td class="paramname"> <em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReferenceCounted^&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a logical context using the given configuration. </p>
<p>This constructor is similar to the default <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a> constructor. Reference counts to terms, functions, and sorts that are created over the API have to be handled explicitly by the caller, however.</p>
<p>Terms (sorts, declarations) created by the context have initially reference count 0, and the caller has to explicitly manage the reference counts. This mode is more flexible, but also very error prone.</p>
<p>Use the metheods AddRef and DecRef on terms, sorts, declarations to control the reference counts.</p>
<p>All contexts that are created must be disposed (call Dispose). Failure to dispose contexts cause memory leaks. Garbage collection will not free resources allocated in contexts. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a48d8c58bf4484b54bf612a3b81526648"></a><!-- doxytag: member="Microsoft::Z3::RawContext::AssertCnstr" ref="a48d8c58bf4484b54bf612a3b81526648" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AssertCnstr </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assert a constraing into the logical context. </p>
<p>After one assertion, the logical context may become inconsistent.</p>
<p>The functions <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a> or <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed51407e62b77b7bcc14d25ca8e320af" title="Check whether the given logical context is consistent or not.">CheckAndGetModel</a> should be used to check whether the logical context is consistent or not.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed51407e62b77b7bcc14d25ca8e320af" title="Check whether the given logical context is consistent or not.">CheckAndGetModel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0805c579c20f25fec2c0f293259d9473"></a><!-- doxytag: member="Microsoft::Z3::RawContext::BenchmarkToSmtlib" ref="a0805c579c20f25fec2c0f293259d9473" args="(String^name, String^logic, String^status, String^attributes, array&lt; TermPtr &gt;^assumptions, TermPtr formula)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String BenchmarkToSmtlib </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>logic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>formula</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert the given benchmark into SMT-LIB formatted string. </p>

</div>
</div>
<a class="anchor" id="a712b529cbbcd86eb099bcb97289f9a77"></a><!-- doxytag: member="Microsoft::Z3::RawContext::BlockLiterals" ref="a712b529cbbcd86eb099bcb97289f9a77" args="(LabeledLiterals^labels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BlockLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>^&nbsp;</td>
          <td class="paramname"> <em>labels</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block the combination of remaining non-disabled labels. </p>
<p>Subsequent calls to Check will not contain satisfying assignments with the same combination of labels. </p>

</div>
</div>
<a class="anchor" id="a338b5a83abb0751e1485885f7f6f513a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Check" ref="a338b5a83abb0751e1485885f7f6f513a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a> Check </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the given logical context is consistent or not. </p>
<p>The function <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed51407e62b77b7bcc14d25ca8e320af" title="Check whether the given logical context is consistent or not.">CheckAndGetModel</a> should be used when models are needed. </p>

</div>
</div>
<a class="anchor" id="aed51407e62b77b7bcc14d25ca8e320af"></a><!-- doxytag: member="Microsoft::Z3::RawContext::CheckAndGetModel" ref="aed51407e62b77b7bcc14d25ca8e320af" args="([Out] RawModel^%m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a> CheckAndGetModel </td>
          <td>(</td>
          <td class="paramtype">[Out] <a class="el" href="class_microsoft_1_1_z3_1_1_raw_model.html">RawModel</a>^%&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the given logical context is consistent or not. </p>
<p>If the logical context is not unsatisfiable (i.e., the return value is different from <code>false</code>) and model construction is enabled (see Config), then a model is stored in <code>m</code>. Otherwise, the value <code>null</code> is stored in <code>m</code>. The caller is responsible for deleting the model using its Dispose method.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Model construction must be enabled using configuration parameters (See, Config).</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6623753616cdabbfeb889ed4a31dfbc7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::CheckAssumptions" ref="a6623753616cdabbfeb889ed4a31dfbc7" args="([Out] RawModel^%m,[In] array&lt; TermPtr &gt;^assumptions,[Out] TermPtr%proof,[Out] array&lt; TermPtr &gt;^%core)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a> CheckAssumptions </td>
          <td>(</td>
          <td class="paramtype">[Out] <a class="el" href="class_microsoft_1_1_z3_1_1_raw_model.html">RawModel</a>^%&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] TermPtr%&nbsp;</td>
          <td class="paramname"> <em>proof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] array&lt; TermPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>core</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the given logical context is consistent or not with respect to auxiliary assumptions. </p>
<p>If the logical context is not unsatisfiable (i.e., the return value is different from <code>false</code>) and model construction is enabled (see Config), then a model is stored in <code>m</code>. Otherwise, the value <code>null</code> is stored in <code>m</code>. The caller is responsible for deleting the model using its Dispose method. If the logical context is unsatisfiable, then a proof object is return and stored in <code>proof</code>. An unsatisfiable core (subset) for the set of supplied assumptions is returned.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Model construction must be enabled using configuration parameters (See, Config).</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>returned model. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assumptions</em>&nbsp;</td><td>array of auxiliary assumptions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proof</em>&nbsp;</td><td>proof object. Proofs must be enabled for this value to be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>core</em>&nbsp;</td><td>subset of assumptions that is an unsatisfiable core.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae767eef7c521b644401e58a4adfb11a6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::EnableDebugTrace" ref="ae767eef7c521b644401e58a4adfb11a6" args="(String^tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnableDebugTrace </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>tag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable low-level debug tracing. </p>
<p>This method only works with debug builds. </p>

</div>
</div>
<a class="anchor" id="a41d7b23fa1f48ebaab07718ca78d7d1e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ExecSmtlib2File" ref="a41d7b23fa1f48ebaab07718ca78d7d1e" args="(String^filename, array&lt; SortPtr &gt;^sorts, array&lt; FuncDeclPtr &gt;^decls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr ExecSmtlib2File </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>sorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>decls</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute commands from a file containing formulas in SMT-LIB2 format. </p>
<p>Return conjunction of Asserts modulo push/pop. </p>

</div>
</div>
<a class="anchor" id="a9d6d0233ca62b250f4ab0d7ffd34a021"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ExecSmtlib2String" ref="a9d6d0233ca62b250f4ab0d7ffd34a021" args="(String^s, array&lt; SortPtr &gt;^sorts, array&lt; FuncDeclPtr &gt;^decls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr ExecSmtlib2String </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>sorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>decls</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute commands from a string in the SMT-LIB2 format. </p>
<p>Return conjunction of Asserts modulo push/pop. </p>

</div>
</div>
<a class="anchor" id="ab3ed56054afb442b0c26b073104c330e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetAccessors" ref="ab3ed56054afb442b0c26b073104c330e" args="(Constructor^c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;FuncDeclPtr&gt; GetAccessors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>retrieve accessors for datatype. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01191">1191</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01191"></a>01191 { <span class="keywordflow">return</span> c-&gt;GetAccessors(); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab021d6b4e58c052472ec3cd6d2dd0fac"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetAppArgs" ref="ab021d6b4e58c052472ec3cd6d2dd0fac" args="(AppPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;TermPtr&gt; GetAppArgs </td>
          <td>(</td>
          <td class="paramtype">AppPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the arguments of an application. If <code>t</code> is an constant, then array is empty. </p>

</div>
</div>
<a class="anchor" id="a6aebc549137b2458e195ebe6d9d4c4ba"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetAppDecl" ref="a6aebc549137b2458e195ebe6d9d4c4ba" args="(AppPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr GetAppDecl </td>
          <td>(</td>
          <td class="paramtype">AppPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the declaration of a constant or function application. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(a) == TermKind.App </dd></dl>

</div>
</div>
<a class="anchor" id="ad230ba9177f3ca00d509b1ee4f1ab8a5"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetArraySortDomain" ref="ad230ba9177f3ca00d509b1ee4f1ab8a5" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr GetArraySortDomain </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the domain of the given array type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetSortKind(t) == SortKind.Array</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3de655e8182580662528e278b9bef566"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetArraySortRange" ref="a3de655e8182580662528e278b9bef566" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr GetArraySortRange </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the range of the given array type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetSortKind(t) == SortKind.Array</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4db4d536f2203faa741073c01f61fb0e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetAssignments" ref="a4db4d536f2203faa741073c01f61fb0e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr GetAssignments </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return conjunction of literals and formulas assigned to true in the current state. </p>

</div>
</div>
<a class="anchor" id="a74ec06b79df90539553d1c53c2a02bdd"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetBoolValue" ref="a74ec06b79df90539553d1c53c2a02bdd" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a> GetBoolValue </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the Boolean value of a truth constant. Return LBool::Undef if a is not a boolean constant (true or false). </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(a) == TermKind.App </dd></dl>

</div>
</div>
<a class="anchor" id="a423fc3c6dda476f6799a85a2168c78b1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetBvSortSize" ref="a423fc3c6dda476f6799a85a2168c78b1" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned GetBvSortSize </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the size of the given bit-vector type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetSortKind(t) = SortKind.Bv</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#adf17186c4a5ece22ff7d95d1b6722e7d" title="Create a bit-vector type of the given size.">MkBvSort</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad778d157f274c72a2e88b806b41df89c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetConstructor" ref="ad778d157f274c72a2e88b806b41df89c" args="(Constructor^c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr GetConstructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>retrieve constructor function declaration. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01181">1181</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01181"></a>01181 { <span class="keywordflow">return</span> c-&gt;GetConstructor(); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab5bd163cb2dff9a325fd961d413a8c22"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetDeclKind" ref="ab5bd163cb2dff9a325fd961d413a8c22" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425">DeclKind</a> GetDeclKind </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the kind of the built-in operator. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(a) == TermKind.App </dd></dl>

</div>
</div>
<a class="anchor" id="a7c62d9f2161dec8b726996082f05875c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetDeclName" ref="a7c62d9f2161dec8b726996082f05875c" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a> GetDeclName </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the constant declaration name as a symbol. </p>

</div>
</div>
<a class="anchor" id="accdc25299d9fe8c5a7fa0889c46cbdf5"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetDeclParameters" ref="accdc25299d9fe8c5a7fa0889c46cbdf5" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;<a class="el" href="interface_microsoft_1_1_z3_1_1_i_raw_parameter.html">IRawParameter</a>^&gt; GetDeclParameters </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return auxiliary parameters associated with the built-in operator. For example, the operator for bit-vector extraction uses two parameters, the upper and lower bit-index for extraction. </p>

</div>
</div>
<a class="anchor" id="a612c60dae8dbc7cc04ebf8a299d7f78d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetDomain" ref="a612c60dae8dbc7cc04ebf8a299d7f78d" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;SortPtr&gt; GetDomain </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the domain of a function declaration. </p>

</div>
</div>
<a class="anchor" id="a8478b135914c2e8c78127a50361331c4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetErrorMessage" ref="a8478b135914c2e8c78127a50361331c4" args="(ErrorCode err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static String GetErrorMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f">ErrorCode</a>&nbsp;</td>
          <td class="paramname"> <em>err</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a string describing the given error code. </p>

</div>
</div>
<a class="anchor" id="a30fc9cb5ea8660841b6912251b5c7574"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetFuncDeclId" ref="a30fc9cb5ea8660841b6912251b5c7574" args="(FuncDeclPtr f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned GetFuncDeclId </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a unique identifier for <code>f</code>. </p>

</div>
</div>
<a class="anchor" id="a9522ebeb37a88abbb1a4a1c4cf75ac9f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetGuessedLiterals" ref="a9522ebeb37a88abbb1a4a1c4cf75ac9f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a> GetGuessedLiterals </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve set of guessed literals satisfying the current assignment. </p>

</div>
</div>
<a class="anchor" id="a680762fecac781975b588f102dd8ae3e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetImpliedEqualities" ref="a680762fecac781975b588f102dd8ae3e" args="([In] array&lt; TermPtr &gt;^terms,[Out] array&lt; unsigned &gt;^%class_ids)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a> GetImpliedEqualities </td>
          <td>(</td>
          <td class="paramtype">[In] array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>terms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] array&lt; unsigned &gt;^%&nbsp;</td>
          <td class="paramname"> <em>class_ids</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve congruence class representatives for terms. </p>
<p>The function can be used for relying on Z3 to identify equal terms under the current set of assumptions. The array of terms and array of class identifiers should have the same length. The class identifiers are numerals that are assigned to the same value for their corresponding terms if the current context forces the terms to be equal. You cannot deduce that terms corresponding to different numerals must be different, (especially when using non-convex theories). Also note that not necessarily all implied equalities are returned by this call. Only the set of implied equalities that follow from simple constraint and equality propagation is discovered.</p>
<p>A side-effect of the function is a satisfiability check. The function return LBool.False if the current assertions are not satisfiable.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a21c01788a1c75b8e9ee86634aec4ca8c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetLiteral" ref="a21c01788a1c75b8e9ee86634aec4ca8c" args="(LabeledLiterals^labels, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr GetLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>^&nbsp;</td>
          <td class="paramname"> <em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain literal corresponding to index in list of literals. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02855">2855</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02855"></a>02855                                                                   {
<a name="l02856"></a>02856             <span class="keywordflow">return</span> labels-&gt;GetLiteral(idx);
<a name="l02857"></a>02857         }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa00bb4f5b7abc37cf6c24e1c8ce08f4a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumeralInt" ref="aa00bb4f5b7abc37cf6c24e1c8ce08f4a" args="(TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetNumeralInt </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine int. Throw InvalidArgument if the call fails. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(v) == TermKind.Numeral &amp;&amp; IsInt32(v)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a016d026fcaf6c2299687ae4407533390"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumeralInt64" ref="a016d026fcaf6c2299687ae4407533390" args="(TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__int64 GetNumeralInt64 </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine long long int. Throw InvalidArgument if the call fails. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(v) == TermKind.Numeral </dd></dl>

</div>
</div>
<a class="anchor" id="aea8f522b8fd2fd2d7e48296b5c7a9512"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumeralString" ref="aea8f522b8fd2fd2d7e48296b5c7a9512" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String GetNumeralString </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of a numeric ast. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(a) == TermKind.Numeral </dd></dl>

</div>
</div>
<a class="anchor" id="ae40d08d8f9fc05ea8bb0b035f0da9f09"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumeralUInt" ref="ae40d08d8f9fc05ea8bb0b035f0da9f09" args="(TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GetNumeralUInt </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine unsigned int. Throw InvalidArgument if the call fails. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(v) == TermKind.Numeral</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa78f20144c40600d63c87ebc8bd5d85e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumeralUInt64" ref="aa78f20144c40600d63c87ebc8bd5d85e" args="(TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned __int64 GetNumeralUInt64 </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine unsigned long long int. Throw InvalidArgument if the call fails. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(v) == TermKind.Numeral</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a23eedc7261b7af0d10d69bbb392d203d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetParamValue" ref="a23eedc7261b7af0d10d69bbb392d203d" args="(String^param_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String GetParamValue </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>param_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a configuration parameter. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__capi.html#ga7d6c40d9b79fe8a8851cc8540970787f" title="Create a configuration.">Z3_mk_config</a> </dd>
<dd>
<a class="el" href="group__capi.html#ga001ade87a1671fe77d7e53ed0f4f1ec3" title="Set a configuration parameter.">Z3_set_param_value</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a029d7befda8b1da2f597b3c9d3b5b998"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetPatternTerms" ref="a029d7befda8b1da2f597b3c9d3b5b998" args="(PatternPtr p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;TermPtr&gt; GetPatternTerms </td>
          <td>(</td>
          <td class="paramtype">PatternPtr&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return array of terms in the pattern. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(a) = TermKind.Pattern </dd></dl>

</div>
</div>
<a class="anchor" id="a4dc623c04dfdeaef8d17f88034aab270"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetQuantifier" ref="a4dc623c04dfdeaef8d17f88034aab270" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RawQuantifier GetQuantifier </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return components of a quantifier. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(a) = TermKind.Quantifier </dd></dl>

</div>
</div>
<a class="anchor" id="ab2ed8df926ca0b94a1f186a7b7e529de"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetQueryAnswer" ref="ab2ed8df926ca0b94a1f186a7b7e529de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr GetQueryAnswer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>retrieve formula that satisfies the previous query, assuming the return value was LBool.True </p>

</div>
</div>
<a class="anchor" id="a0c54f0a096c506bf93bce1532ddf977a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetQueryStatus" ref="a0c54f0a096c506bf93bce1532ddf977a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e">SearchFailureExplanation</a> GetQueryStatus </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>retrieve details on the search satus. </p>

</div>
</div>
<a class="anchor" id="a84d2dfcc3f579dcce0820cad12686f42"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetRange" ref="a84d2dfcc3f579dcce0820cad12686f42" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr GetRange </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the range of the given declaration. </p>
<p>If <code>d</code> is a constant (i.e., has zero arguments), then this function returns the type of the constant. </p>

</div>
</div>
<a class="anchor" id="ac91878a6a5fd8cb8173aed946528f42f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetRelevantLabels" ref="ac91878a6a5fd8cb8173aed946528f42f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a> GetRelevantLabels </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve set of labels set in current satisfying assignment. </p>

</div>
</div>
<a class="anchor" id="aed54018936a4d19c92a05d8c770d3c33"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetRelevantLiterals" ref="aed54018936a4d19c92a05d8c770d3c33" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a> GetRelevantLiterals </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve set of literals satisfying the current assignment. </p>

</div>
</div>
<a class="anchor" id="a3c2e03935c06e79eb6c4b249b910307d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSearchFailureExplanation" ref="a3c2e03935c06e79eb6c4b249b910307d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e">SearchFailureExplanation</a> GetSearchFailureExplanation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain explanation for search failure. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad563e3268d5034c9147c98190c4327d6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSort" ref="ad563e3268d5034c9147c98190c4327d6" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr GetSort </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the type of an AST node. </p>
<p>The AST node must be a constant, application, numeral, bound variable, or quantifier. </p>

</div>
</div>
<a class="anchor" id="acb7747c8b17c86b75c4102f6a5adfafd"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSortId" ref="acb7747c8b17c86b75c4102f6a5adfafd" args="(SortPtr s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned GetSortId </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a unique identifier for <code>s</code>. </p>

</div>
</div>
<a class="anchor" id="ac105e2a1c10a81fcbbda92338319b821"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSortKind" ref="ac105e2a1c10a81fcbbda92338319b821" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#ga7664c6569cf130a5d166ec8c8dc27101">SortKind</a> GetSortKind </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the type kind (e.g., array, tuple, int, bool, etc). </p>
<dl class="see"><dt><b>See also:</b></dt><dd>SortKind </dd></dl>

</div>
</div>
<a class="anchor" id="a16e84dca2b1d23ce89a98276e943eb59"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSortName" ref="a16e84dca2b1d23ce89a98276e943eb59" args="(SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a> GetSortName </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the type name as a symbol. </p>

</div>
</div>
<a class="anchor" id="afabdd4c7aa7001151713568aaf4e27b9"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSymbolInt" ref="afabdd4c7aa7001151713568aaf4e27b9" args="(Symbol^s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetSymbolInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the symbol int value. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetSymbolKind(s) == SymbolKind.Int</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MkIntSymbol </dd></dl>

</div>
</div>
<a class="anchor" id="a0e5e137439c1194fe6ceadd130c32844"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSymbolKind" ref="a0e5e137439c1194fe6ceadd130c32844" args="(Symbol^s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#ga05812818de02fb4b202d7513ce50745d">SymbolKind</a> GetSymbolKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return <code>SymbolKind.Int</code> if the symbol was constructed using MkIntSymbol, and <code>SymbolKind.String</code> if the symbol was constructed using MkStringSymbol. </p>

</div>
</div>
<a class="anchor" id="a63af55d0bc85edc1a08938fe94d059c3"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSymbolString" ref="a63af55d0bc85edc1a08938fe94d059c3" args="(Symbol^s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String GetSymbolString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the symbol name. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetSymbolKind(s) = SymbolKind.String</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MkStringSymbol </dd></dl>

</div>
</div>
<a class="anchor" id="ae810fc8c305ae442e0a516c1cb9f78a8"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetTermId" ref="ae810fc8c305ae442e0a516c1cb9f78a8" args="(TermPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned GetTermId </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a unique identifier for <code>t</code>. </p>

</div>
</div>
<a class="anchor" id="aa92cc97ea26a5d7ca06f7337a750c964"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetTermKind" ref="aa92cc97ea26a5d7ca06f7337a750c964" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc">TermKind</a> GetTermKind </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the kind of the given AST. </p>

</div>
</div>
<a class="anchor" id="a97a7320cd3d9a7d77f52bf789f5c8839"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetTester" ref="a97a7320cd3d9a7d77f52bf789f5c8839" args="(Constructor^c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr GetTester </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>retrieve test function for constructor. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01186">1186</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01186"></a>01186 { <span class="keywordflow">return</span> c-&gt;GetTester(); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8faadbc0b5b7aa7e1f5fb988eddb0467"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetTupleConstructor" ref="a8faadbc0b5b7aa7e1f5fb988eddb0467" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr GetTupleConstructor </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the constructor declaration of the given tuple type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetSortKind(t) == SortKind.Tuple</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af75bb103fc493958385de9c849482df9" title="Create a tuple type.">MkTupleSort</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a91e7e6ddb2615bb55ee58ea57c34f308"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetTupleFields" ref="a91e7e6ddb2615bb55ee58ea57c34f308" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;FuncDeclPtr&gt; GetTupleFields </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the field declarations of a given tuple type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetSortKind(t) == SortKind.Tuple</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af75bb103fc493958385de9c849482df9" title="Create a tuple type.">MkTupleSort</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a17499379d443ca6ee0bf3770d18135af"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetVarIndex" ref="a17499379d443ca6ee0bf3770d18135af" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned GetVarIndex </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the index of a de-Brujin bound variable. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(a) == TermKind.Var </dd></dl>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02522">2522</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02522"></a>02522                                         {
<a name="l02523"></a>02523             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gaba865ef17f1692ab14dbd304987db411" title="Return index of de-Brujin bound variable.">Z3_get_index_value</a>(ctx(), get_ast(a));
<a name="l02524"></a>02524         }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7068a418e65d2a184e2275e72300afc1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetVersion" ref="a7068a418e65d2a184e2275e72300afc1" args="([Out] unsigned%major,[Out] unsigned%minor,[Out] unsigned%build_number,[Out] unsigned%revision_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GetVersion </td>
          <td>(</td>
          <td class="paramtype">[Out] unsigned%&nbsp;</td>
          <td class="paramname"> <em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] unsigned%&nbsp;</td>
          <td class="paramname"> <em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] unsigned%&nbsp;</td>
          <td class="paramname"> <em>build_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] unsigned%&nbsp;</td>
          <td class="paramname"> <em>revision_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return Z3 version number information. </p>

</div>
</div>
<a class="anchor" id="ab8387be0b117e56351f808dbb8b0e808"></a><!-- doxytag: member="Microsoft::Z3::RawContext::IncRef" ref="ab8387be0b117e56351f808dbb8b0e808" args="(AstPtr ast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IncRef </td>
          <td>(</td>
          <td class="paramtype">AstPtr&nbsp;</td>
          <td class="paramname"> <em>ast</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment and decrement reference counters on terms, sorts and declarations. </p>
<p>These methods are required when the context is created using the ReferenceCounted argument. </p>

</div>
</div>
<a class="anchor" id="a95167a48c7a40a4acf32631a527758da"></a><!-- doxytag: member="Microsoft::Z3::RawContext::IsEq" ref="a95167a48c7a40a4acf32631a527758da" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsEq </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return <code>true</code> if the two given AST nodes are equal. </p>

</div>
</div>
<a class="anchor" id="a6e20e01d6d3f85406b9ba5091f2e60f7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::IsWellSorted" ref="a6e20e01d6d3f85406b9ba5091f2e60f7" args="(TermPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsWellSorted </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return <code>true</code> if <code>t</code> is well sorted. </p>

</div>
</div>
<a class="anchor" id="a5668c488c12e405f662807b4f47860da"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkAdd" ref="a5668c488c12e405f662807b4f47860da" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkAdd </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>args[0] + ... + args[args.Length-1]</code>. </p>
<p>All arguments must have int or real type.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The number of arguments must be greater than zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a8793a422c6c2d7b34000cc0032a4cdc4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkAnd" ref="a8793a422c6c2d7b34000cc0032a4cdc4" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkAnd </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>args[0] and ... and args[args.Length-1]</code>. </p>
<p>All arguments must have Boolean type.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The number of arguments must be greater than zero. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8a8ba273adfaadc01562b901524fd50"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkApp" ref="aa8a8ba273adfaadc01562b901524fd50" args="(FuncDeclPtr d, array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AppPtr MkApp </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a constant or function application. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab5341894979c077ef1ad93ef67691c2a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArrayConst" ref="ab5341894979c077ef1ad93ef67691c2a" args="(SortPtr domain, TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkArrayConst </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constant array. </p>
<p>The node <code>a</code> must have an array type <code>[range]</code>, <code>domain</code> indicates the domain of the array. The type of the result is <code>[domain -&gt; range]</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aaed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac645da9e615bc4e20515ef3cd8f74893"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArrayDefault" ref="ac645da9e615bc4e20515ef3cd8f74893" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkArrayDefault </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the array default. </p>
<p>The node <code>a</code> must have an array type <code>[domain -&gt; range]</code>. The type of the result is <code>[range]</code>. The result is a term whose value holds the default array value. That is, models should ensure that the default for <code>a</code> (ElseCase) evaluates to the same value as <code>MkArrayDefault(a)</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aaed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a> </dd>
<dd>
MkArrayconst </dd></dl>

</div>
</div>
<a class="anchor" id="a3fcbf7757a9ffdb56c4bdd145c145246"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArrayMap" ref="a3fcbf7757a9ffdb56c4bdd145c145246" args="(FuncDeclPtr d, array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkArrayMap </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array map. </p>
<p>The <code>n</code> nodes <code>args</code> must be of array sorts <code>[domain_i -&gt; range_i]</code>. The function declaration <code>f</code> must have type <code> range_1 .. range_n -&gt; range</code>. <code>v</code> must have sort range. The sort of the result is <code>[domain_i -&gt; range]</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aaed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af0606dc016c08c4086d43d43ed45794c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArraySelect" ref="af0606dc016c08c4086d43d43ed45794c" args="(TermPtr a, TermPtr i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkArraySelect </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array read. </p>
<p>The node <code>a</code> must have an array type <code>[domain -&gt; range]</code>, and <code>i</code> must have the type <code>domain</code>. The type of the result is <code>range</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aaed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a011fb26d01e3b5e696f5148da6d53d91"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArraySort" ref="a011fb26d01e3b5e696f5148da6d53d91" args="(SortPtr domain, SortPtr range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkArraySort </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an array type. </p>
<p>We usually represent the array type as: <code>[domain -&gt; range]</code>. Arrays are usually used to model the heap/memory in software verification.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aaed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3fcbf7757a9ffdb56c4bdd145c145246" title="Array map.">MkArrayMap</a> </dd>
<dd>
MkConstArray </dd></dl>

</div>
</div>
<a class="anchor" id="aaed9edcce01c069fcb982262ae01e14d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArrayStore" ref="aaed9edcce01c069fcb982262ae01e14d" args="(TermPtr a, TermPtr i, TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkArrayStore </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array update. </p>
<p>The node <code>a</code> must have an array type <code>[domain -&gt; range]</code>, <code>i</code> must have type <code>domain</code>, <code>v</code> must have type range. The type of the result is <code>[domain -&gt; range]</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#af0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a24352b12189b45134064790859850a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBoolSort" ref="a5a24352b12189b45134064790859850a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkBoolSort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create the boolean type. </p>
<p>This type is used to create propositional variables and predicates. </p>

</div>
</div>
<a class="anchor" id="a2e1ef04d234928c64248ce7eaf73502a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBound" ref="a2e1ef04d234928c64248ce7eaf73502a" args="(unsigned index, SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a bound variable. </p>
<p>Bound variables are indexed by de-Bruijn indices. It is perhaps easiest to explain the meaning of de-Bruijn indices by indicating the compilation process from non-de-Bruijn formulas to de-Bruijn format.</p>
<div class="fragment"><pre class="fragment">
           abs(forall (x1) phi) = forall (x1) abs1(phi, x1, 0)
           abs(forall (x1, x2) phi) = abs(forall (x1) abs(forall (x2) phi))
           abs1(x, x, n) = b_n
           abs1(y, x, n) = y
           abs1(f(t1,...,tn), x, n) = f(abs1(t1,x,n), ..., abs1(tn,x,n))
           abs1(forall (x1) phi, x, n) = forall (x1) (abs1(phi, x, n+1))
           </pre></div><p>The last line is significant: the index of a bound variable is different depending on the scope in which it appears. The deeper x appears, the higher is its index.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>de-Bruijn index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ty</em>&nbsp;</td><td>type of the bound variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a711b2b4ca79395d1d56820b7b3f9b3cc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBv2Int" ref="a711b2b4ca79395d1d56820b7b3f9b3cc" args="(TermPtr t1, bool is_signed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBv2Int </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_signed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert bit vector to integer. </p>
<p>The node <code>t1</code> must have a bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a30237a1d6603428640b6db89d5d157fa"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvAdd" ref="a30237a1d6603428640b6db89d5d157fa" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvAdd </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standard two's complement addition. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a202fffba746c16499d216354e97ac74b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvAddNoOverflow" ref="a202fffba746c16499d216354e97ac74b" args="(TermPtr t1, TermPtr t2, bool is_signed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvAddNoOverflow </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_signed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check that addition does not overflow. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a421fc4943889a1c10d2dddbdaac5d09d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvAddNoUnderflow" ref="a421fc4943889a1c10d2dddbdaac5d09d" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvAddNoUnderflow </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check that addition does not underflow. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="aadd6a00031fb92a88ca6c177d4d75509"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvAnd" ref="aadd6a00031fb92a88ca6c177d4d75509" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvAnd </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bitwise and. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a4e8836887c24503234e99a94dd31a660"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvAshr" ref="a4e8836887c24503234e99a94dd31a660" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvAshr </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Arithmetic shift right. </p>
<p>It is like logical shift right except that the most significant bits of the result always copy the most significant bit of the second argument.</p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="afaba9154d1be03ec6d738951e94d37cb"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvConcat" ref="afaba9154d1be03ec6d738951e94d37cb" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvConcat </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Concatenate the given bit-vectors. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have (possibly different) bit-vector types</p>
<p>The result is a bit-vector of size <code>n1+n2</code>, where <code>n1</code> (<code>n2</code>) is the size of <code>t1</code> (<code>t2</code>). </p>

</div>
</div>
<a class="anchor" id="ac2c8940627f740c9ec3b637ef2031887"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvExtract" ref="ac2c8940627f740c9ec3b637ef2031887" args="(unsigned high, unsigned low, TermPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvExtract </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract the bits <code>high</code> down to <code>low</code> from a bitvector of size <code>m</code> to yield a new bitvector of size <code>n</code>, where <code>n = high - low + 1</code>. </p>
<p>The node <code>t</code> must have a bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a2de5b050301845c2fa902a8a910db8ed"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvLshr" ref="a2de5b050301845c2fa902a8a910db8ed" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvLshr </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Logical shift right. </p>
<p>It is equivalent to unsigned division by <code>2^x</code> where <code>x</code> is the value of the third argument.</p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="ae5585802bf0ff4f5188bfbe1fd361470"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvMul" ref="ae5585802bf0ff4f5188bfbe1fd361470" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvMul </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standard two's complement multiplication. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a688f2a2cb04cb30f68dca62c6477f14b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvMulNoOverflow" ref="a688f2a2cb04cb30f68dca62c6477f14b" args="(TermPtr t1, TermPtr t2, bool is_signed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvMulNoOverflow </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_signed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check that multiplication does not overflow. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a036fccd286efdc90134941defd6a1df8"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvMulNoUnderflow" ref="a036fccd286efdc90134941defd6a1df8" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvMulNoUnderflow </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check that multiplication does not underflow. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a5d58dfc570dde7e49faab8ed4dcfbfc7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvNand" ref="a5d58dfc570dde7e49faab8ed4dcfbfc7" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvNand </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bitwise nand. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="ae21724e2d70e5aec94cfa59726565063"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvNeg" ref="ae21724e2d70e5aec94cfa59726565063" args="(TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvNeg </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standard two's complement unary minus. </p>
<p>The node <code>t1</code> must have bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a7dcdbe9ddac5ccf9744174f4a20aac19"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvNegNoOverflow" ref="a7dcdbe9ddac5ccf9744174f4a20aac19" args="(TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvNegNoOverflow </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check that negation does not overflow. </p>

</div>
</div>
<a class="anchor" id="aa486a9f49b3fc395f37b56f0975a243b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvNor" ref="aa486a9f49b3fc395f37b56f0975a243b" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvNor </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bitwise nor. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a45b8b6397e45ac3fc6b38e873eed9d33"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvNot" ref="a45b8b6397e45ac3fc6b38e873eed9d33" args="(TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvNot </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bitwise negation. </p>
<p>The node <code>arg1</code> must have a bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a472170308fc0ce228ad1ee1b683811cd"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvOr" ref="a472170308fc0ce228ad1ee1b683811cd" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvOr </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bitwise or. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a4487dd1d501cb49fa5f4d046e28ae650"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvReduceAnd" ref="a4487dd1d501cb49fa5f4d046e28ae650" args="(TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvReduceAnd </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take conjunction of bits in vector. </p>
<p>The node <code>arg1</code> must have a bit-vector type. </p>

</div>
</div>
<a class="anchor" id="ab00941985b6e6675b2304831aa4845c0"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvReduceOr" ref="ab00941985b6e6675b2304831aa4845c0" args="(TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvReduceOr </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take disjunction of bits in vector. </p>
<p>The node <code>arg1</code> must have a bit-vector type. </p>

</div>
</div>
<a class="anchor" id="afa18939e43ef603b1bdfac2cdbefd4f0"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvRepeat" ref="afa18939e43ef603b1bdfac2cdbefd4f0" args="(unsigned i, TermPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvRepeat </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Repeat the bit-vector <code>i</code> times. </p>
<p>The node <code>t1</code> must have a bit-vector type. </p>

</div>
</div>
<a class="anchor" id="ac3ad21f1134a4ff73727b4bb4b364c2d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvRotateLeft" ref="ac3ad21f1134a4ff73727b4bb4b364c2d" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvRotateLeft </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate bits of <code>t1</code> to the left <code>t2</code> times. </p>
<p>The node <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="adecfc831ae6c9135828e3095b27a4956"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvRotateLeft" ref="adecfc831ae6c9135828e3095b27a4956" args="(unsigned i, TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvRotateLeft </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate bits of <code>t1</code> to the left <code>i</code> times. </p>
<p>The node <code>t1</code> must have a bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a78ad6677f780f863dad1e7e79997274e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvRotateRight" ref="a78ad6677f780f863dad1e7e79997274e" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvRotateRight </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate bits of <code>t1</code> to the right <code>t2</code> times. </p>
<p>The node <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a3df09da772a462d74c9f08546a44562b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvRotateRight" ref="a3df09da772a462d74c9f08546a44562b" args="(unsigned i, TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvRotateRight </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate bits of <code>t1</code> to the right <code>i</code> times. </p>
<p>The node <code>t1</code> must have a bit-vector type. </p>

</div>
</div>
<a class="anchor" id="ae96a3f936b75c53d7ab8eed094eb7b94"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSdiv" ref="ae96a3f936b75c53d7ab8eed094eb7b94" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSdiv </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Two's complement signed division. </p>
<p>It is defined in the following way:</p>
<ul>
<li>The <code>floor</code> of <code>t1/t2</code> if <code>t2</code> is different from zero, and <code>t1*t2 &gt;= 0</code>.</li>
</ul>
<ul>
<li>The <code>ceiling</code> of <code>t1/t2</code> if <code>t2</code> is different from zero, and <code>t1*t2 &lt; 0</code>.</li>
</ul>
<p>If <code>t2</code> is zero, then the result is undefined.</p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="ac537f6c8529718162b4a16a926f145f8"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSDivNoOverflow" ref="ac537f6c8529718162b4a16a926f145f8" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSDivNoOverflow </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check that division does not overflow. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a27a2d12f9e8d5639fa86b4d0997e2b17"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSge" ref="a27a2d12f9e8d5639fa86b4d0997e2b17" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSge </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Two's complement signed greater than or equal to. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a013910a4fa70b37878520b4400b1c107"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSgt" ref="a013910a4fa70b37878520b4400b1c107" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSgt </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Two's complement signed greater than. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a484c128e627a79c8af7fcbb531b0ba39"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvShl" ref="a484c128e627a79c8af7fcbb531b0ba39" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvShl </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shift left. </p>
<p>It is equivalent to multiplication by <code>2^x</code> where <code>x</code> is the value of the third argument.</p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="af94e12dbe34a66f358baebe8ef6848fc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSignExt" ref="af94e12dbe34a66f358baebe8ef6848fc" args="(unsigned i, TermPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSignExt </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sign-extend of the given bit-vector to the (signed) equivalent bitvector of size <code>m+i</code>, where <code>m</code> is the size of the given bit-vector. </p>
<p>The node <code>t</code> must have a bit-vector type. </p>

</div>
</div>
<a class="anchor" id="ac37363c17a7308be4ca999068da16fbb"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSle" ref="ac37363c17a7308be4ca999068da16fbb" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSle </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Two's complement signed less than or equal to. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a8352294e2808ce534fc83ec39bca8fbd"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSlt" ref="a8352294e2808ce534fc83ec39bca8fbd" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSlt </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Two's complement signed less than. </p>
<p>It abbreviates: </p>
<div class="fragment"><pre class="fragment">           (or (and (= (extract[|m-1|:|m-1|] s) bit1)
                    (= (extract[|m-1|:|m-1|] t) bit0))
               (and (= (extract[|m-1|:|m-1|] s) (extract[|m-1|:|m-1|] t))
                    (bvult s t)))
</pre></div><p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a094b16beaa982ef3500633b3482d2603"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSmod" ref="a094b16beaa982ef3500633b3482d2603" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSmod </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Two's complement signed remainder (sign follows divisor). </p>
<p>If <code>t2</code> is zero, then the result is undefined.</p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a1db91c0489ac65927dc14613e0b2225b" title="Two&#39;s complement signed remainder (sign follows dividend).">MkBvSrem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adf17186c4a5ece22ff7d95d1b6722e7d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSort" ref="adf17186c4a5ece22ff7d95d1b6722e7d" args="(unsigned sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkBvSort </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a bit-vector type of the given size. </p>
<p>This type can also be seen as a machine integer.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The size of the bitvector type must be greater than zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a1db91c0489ac65927dc14613e0b2225b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSrem" ref="a1db91c0489ac65927dc14613e0b2225b" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSrem </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Two's complement signed remainder (sign follows dividend). </p>
<p>It is defined as <code>t1 - (t1 /s t2) * t2</code>, where <code>/s</code> represents signed division. The most significant bit (sign) of the result is equal to the most significant bit of <code>t1</code>.</p>
<p>If <code>t2</code> is zero, then the result is undefined.</p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a094b16beaa982ef3500633b3482d2603" title="Two&#39;s complement signed remainder (sign follows divisor).">MkBvSmod</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aea836bb8f5dcec3f401d77538e31e248"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSub" ref="aea836bb8f5dcec3f401d77538e31e248" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSub </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standard two's complement subtraction. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a44065d4fa565d6efa0f351f266c61c58"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSubNoOverflow" ref="a44065d4fa565d6efa0f351f266c61c58" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSubNoOverflow </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check that subtraction does not overflow. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a3386aa55309ead169a54aeeed1cef0d6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSubNoUnderflow" ref="a3386aa55309ead169a54aeeed1cef0d6" args="(TermPtr t1, TermPtr t2, bool is_signed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSubNoUnderflow </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_signed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check that subtraction does not underflow. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a98ee5b832fa8f1a44998a2541bf4114c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUdiv" ref="a98ee5b832fa8f1a44998a2541bf4114c" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUdiv </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unsigned division. </p>
<p>It is defined as the <code>floor</code> of <code>t1/t2</code> if <code>t2</code> is different from zero. If <code>t2</code> is zero, then the result is undefined.</p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="acb5149b9f7b1d823cd93ed6f43db5a17"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUge" ref="acb5149b9f7b1d823cd93ed6f43db5a17" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUge </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unsigned greater than or equal to. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="afcb8b1208ec0cc2c1579c29158b3815e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUgt" ref="afcb8b1208ec0cc2c1579c29158b3815e" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUgt </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unsigned greater than. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="aa434742064f523ecf5a7e13a113df86b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUle" ref="aa434742064f523ecf5a7e13a113df86b" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUle </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unsigned less than or equal to. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a71e25df68e31503191875d9348c9f823"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUlt" ref="a71e25df68e31503191875d9348c9f823" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUlt </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unsigned less than. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a30f13a71debd51968bc2129eaa26121d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUrem" ref="a30f13a71debd51968bc2129eaa26121d" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUrem </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unsigned remainder. </p>
<p>It is defined as <code>t1 - (t1 /u t2) * t2</code>, where <code>/u</code> represents unsigned division.</p>
<p>If <code>t2</code> is zero, then the result is undefined.</p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a0112b7f61d18dcd15369566cdcf4b05f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvXnor" ref="a0112b7f61d18dcd15369566cdcf4b05f" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvXnor </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bitwise xnor. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a684ce5c64067b6d5d4cddfbfe32789b4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvXor" ref="a684ce5c64067b6d5d4cddfbfe32789b4" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvXor </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bitwise exclusive-or. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. </p>

</div>
</div>
<a class="anchor" id="add245de4256b820ef7d66ce58fd43385"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvZeroExt" ref="add245de4256b820ef7d66ce58fd43385" args="(unsigned i, TermPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvZeroExt </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extend the given bit-vector with zeros to the (unsigned) equivalent bitvector of size <code>m+i</code>, where <code>m</code> is the size of the given bit-vector. </p>
<p>The node <code>t1</code> must have a bit-vector type. </p>

</div>
</div>
<a class="anchor" id="a4119e0d04b9b4b8e95969e261b06aab7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConst" ref="a4119e0d04b9b4b8e95969e261b06aab7" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AppPtr MkConst </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare and create a constant. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a30d1032d60ebd18e9d99d5c4191ab7b8"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConstructor" ref="a30d1032d60ebd18e9d99d5c4191ab7b8" args="(String^name, String^tester, array&lt; String^&gt;^field_names, array&lt; SortPtr &gt;^field_sorts, array&lt; unsigned &gt;^field_refs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a> MkConstructor </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>tester</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; String^&gt;^&nbsp;</td>
          <td class="paramname"> <em>field_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>field_sorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; unsigned &gt;^&nbsp;</td>
          <td class="paramname"> <em>field_refs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create constructor object for datatype declarations. The object must be disposed with manually. </p>
<p>Use the methods <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad778d157f274c72a2e88b806b41df89c" title="retrieve constructor function declaration.">GetConstructor</a>, <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a97a7320cd3d9a7d77f52bf789f5c8839" title="retrieve test function for constructor.">GetTester</a>, and <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab3ed56054afb442b0c26b073104c330e" title="retrieve accessors for datatype.">GetAccessors</a> to retrieve the function declarations for constructors, tester and accessors after the datatype has been declared.</p>
<p>A field_ref is the index of the (mutually) recursive datatype. For example, if you declare a single recursive datatype, then a reference to the recursive datatype that is being declared is the number 0. If you declare two mutually recursive datatypes, then the reference to the second recursive datatype is 1. </p>

</div>
</div>
<a class="anchor" id="adb386d1976b2c6587844fe995444c46f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkDataType" ref="adb386d1976b2c6587844fe995444c46f" args="(String^name, array&lt; Constructor^&gt;^constructors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkDataType </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&gt;^&nbsp;</td>
          <td class="paramname"> <em>constructors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create datatype sort. </p>

</div>
</div>
<a class="anchor" id="aa44dbeb0d3495a206820ffa9ce249a0a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkDataTypes" ref="aa44dbeb0d3495a206820ffa9ce249a0a" args="(array&lt; String^&gt;^names, array&lt; array&lt; Constructor^&gt;^&gt;^constructors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;SortPtr&gt; MkDataTypes </td>
          <td>(</td>
          <td class="paramtype">array&lt; String^&gt;^&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&gt;^&gt;^&nbsp;</td>
          <td class="paramname"> <em>constructors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create datatype sorts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>array of names for the recursive datatypes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>constructors</em>&nbsp;</td><td>array of arrays of constructors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89bdd6aba66dab2a90592cea3263eb74"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkDistinct" ref="a89bdd6aba66dab2a90592cea3263eb74" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkDistinct </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>distinct(args[0], ..., args[args.Length-1])</code>. </p>
<p>The <code>distinct</code> construct is used for declaring the arguments pairwise distinct. That is, <code>Forall 0 &lt;= i &lt; j &lt; args.Length. not args[i] = args[j]</code>.</p>
<p>All arguments must have the same type.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The number of arguments of a distinct construct must be greater than one. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7f8e2e8eb754c5a87fa3faa51ff8baf"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkDiv" ref="ae7f8e2e8eb754c5a87fa3faa51ff8baf" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkDiv </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create integer or real division. </p>
<p>The nodes <code>arg1</code> and <code>arg2</code> must have the same type, and must be int or real. </p>

</div>
</div>
<a class="anchor" id="ae3a1a555a0fce2e8c1dfdfb863b56216"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkEmptySet" ref="ae3a1a555a0fce2e8c1dfdfb863b56216" args="(SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkEmptySet </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create the empty set. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01966">1966</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01966"></a>01966 { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga358b6b80509a567148f1c0ca9252118c" title="Create the empty set.">Z3_mk_empty_set</a>(ctx(), get_sort(ty))); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a72b2b9b3967c4638276bdccbdb0c9471"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkEnumerationSort" ref="a72b2b9b3967c4638276bdccbdb0c9471" args="(String^name, array&lt; String^&gt;^enum_names, array&lt; FuncDeclPtr &gt;^enum_consts, array&lt; FuncDeclPtr &gt;^enum_testers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkEnumerationSort </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; String^&gt;^&nbsp;</td>
          <td class="paramname"> <em>enum_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>enum_consts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>enum_testers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create an enumeration type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>- name of enumeration sort. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enum_names</em>&nbsp;</td><td>- names of enumerated elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enum_consts</em>&nbsp;</td><td>- output function declarations for enumerated elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enum_testers</em>&nbsp;</td><td>- output function declarations for enumeration testers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5b455baaffd7f2bf2a9508f801819de"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkEq" ref="ab5b455baaffd7f2bf2a9508f801819de" args="(TermPtr l, TermPtr r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkEq </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>l = r</code>. </p>
<p>The nodes <code>l</code> and <code>r</code> must have the same type. </p>

</div>
</div>
<a class="anchor" id="a60c9cdf799990ce4ed2dd7f8caa914e9"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkExists" ref="a60c9cdf799990ce4ed2dd7f8caa914e9" args="(unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; Symbol^&gt;^names, TermPtr body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkExists </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; PatternPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an exists formula. Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2e1ef04d234928c64248ce7eaf73502a" title="Create a bound variable.">MkBound</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4c138a08931900ebb7396484a6294cff"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFalse" ref="a4c138a08931900ebb7396484a6294cff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkFalse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>false</code>. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01307">1307</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01307"></a>01307 { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(ctx())); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a73705995afcb9e00c07338fbfc9b4b49"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFiniteDomainSort" ref="a73705995afcb9e00c07338fbfc9b4b49" args="(String^name, unsigned __int64 domain_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkFiniteDomainSort </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned __int64&nbsp;</td>
          <td class="paramname"> <em>domain_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a named finite domain sort. </p>
<p>To create constants that belong to the finite domain, use MkNumeral for creating numerals and pass a numeric constant together with the sort returned by this call. </p>

</div>
</div>
<a class="anchor" id="a8c6471e0eb3e8a5a5a6c7c7e9e5bd8d7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkForall" ref="a8c6471e0eb3e8a5a5a6c7c7e9e5bd8d7" args="(unsigned weight, array&lt; AppPtr &gt;^bound, array&lt; PatternPtr &gt;^patterns, TermPtr body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkForall </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; AppPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; PatternPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a forall formula. </p>
<p>This function allows creating a forall without using de-Bruijn indices in the body or patterns. It is sometimes convenient to create the body of a quantifier without de-Bruijn indices, but instead use constants. These constants have to be replaced by de-Bruijn indices for the internal representation. This function allows the caller to hand over the task to Z3 of abstracting the constants into bound variables, so that each occurrence of the variables in the array <code>bound</code> gets replaced by a de-Bruijn index.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bound</em>&nbsp;</td><td>array containing the constants to be abstracted as bound variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patterns</em>&nbsp;</td><td>array containing the patterns created using <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>body</em>&nbsp;</td><td>the body of the quantifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a810d22421101b29aef8864c6e2aa3a3f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkForall" ref="a810d22421101b29aef8864c6e2aa3a3f" args="(unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; String^&gt;^names, TermPtr body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkForall </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; PatternPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; String^&gt;^&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a forall formula. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patterns</em>&nbsp;</td><td>array containing the patterns created using <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>types</em>&nbsp;</td><td>array containing the types of the bound variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>array containing the names as strings of the bound variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>body</em>&nbsp;</td><td>the body of the quantifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2e1ef04d234928c64248ce7eaf73502a" title="Create a bound variable.">MkBound</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad7d64f035d843f300b7fffcfb148e1fe"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkForall" ref="ad7d64f035d843f300b7fffcfb148e1fe" args="(unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; Symbol^&gt;^names, TermPtr body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkForall </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; PatternPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a forall formula. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patterns</em>&nbsp;</td><td>array containing the patterns created using <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>types</em>&nbsp;</td><td>array containing the types of the bound variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>array containing the names as symbols of the bound variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>body</em>&nbsp;</td><td>the body of the quantifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2e1ef04d234928c64248ce7eaf73502a" title="Create a bound variable.">MkBound</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aabc8469e3803c5413a1a69c7cd001672"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFreshConst" ref="aabc8469e3803c5413a1a69c7cd001672" args="(String^prefix, SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkFreshConst </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare and create a fresh constant. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5251d6fc152aea96eac0e9e702dad707"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFreshFuncDecl" ref="a5251d6fc152aea96eac0e9e702dad707" args="(String^prefix, array&lt; SortPtr &gt;^domain, SortPtr range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr MkFreshFuncDecl </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare a fresh constant or function. </p>
<p>Z3 will generate an unique name for this function declaration.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a71d300776d9303680e79f784a2644e4c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFullSet" ref="a71d300776d9303680e79f784a2644e4c" args="(SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkFullSet </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create the full set. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01971">1971</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01971"></a>01971 { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga5e92662c657374f7332aa32ce4503dd2" title="Create the full set.">Z3_mk_full_set</a>(ctx(), get_sort(ty))); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2bb4cecfa5619dbf2ed8f53d3b2f5749"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="a2bb4cecfa5619dbf2ed8f53d3b2f5749" args="(Symbol^s, array&lt; SortPtr &gt;^domain, SortPtr range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr MkFuncDecl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare a constant or function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>name of the constant or function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>domain</em>&nbsp;</td><td>array containing the type of each argument. The array must contain domain_size elements. It is 0 whe declaring a constant. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>range</em>&nbsp;</td><td>type of the constant or the return type of the function.</td></tr>
  </table>
  </dd>
</dl>
<p>After declaring a constant or function, the function <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a> can be used to create a constant or function application.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a08b71116843992a1078d9df3889f09"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkGe" ref="a7a08b71116843992a1078d9df3889f09" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkGe </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create greater than or equal to. </p>
<p>The nodes <code>arg1</code> and <code>arg2</code> must have the same type, and must be int or real. </p>

</div>
</div>
<a class="anchor" id="a5935871bfbeda8fcd6bc467d8d49afc2"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkGt" ref="a5935871bfbeda8fcd6bc467d8d49afc2" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkGt </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create greater than. </p>
<p>The nodes <code>arg1</code> and <code>arg2</code> must have the same type, and must be int or real. </p>

</div>
</div>
<a class="anchor" id="af0019c9b938cbfc228d538500e25ab1f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIff" ref="af0019c9b938cbfc228d538500e25ab1f" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkIff </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>t1 iff t2</code>. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have Boolean type. </p>

</div>
</div>
<a class="anchor" id="afcbf82213943aa0a30efb51dbf81b7dd"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkImplies" ref="afcbf82213943aa0a30efb51dbf81b7dd" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkImplies </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>t1 implies t2</code>. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have Boolean type. </p>

</div>
</div>
<a class="anchor" id="a1c4f013234b21f0c4599f3c44fb778fb"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkInjectiveFunction" ref="a1c4f013234b21f0c4599f3c44fb778fb" args="(String^name, array&lt; SortPtr &gt;^domain, SortPtr range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr MkInjectiveFunction </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create injective function. </p>

</div>
</div>
<a class="anchor" id="a43be2bceee8a6d4a870733196a149612"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkInt2Bv" ref="a43be2bceee8a6d4a870733196a149612" args="(unsigned size, TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkInt2Bv </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert integer to bit vector. </p>
<p>The node <code>t1</code> must have a integer type. </p>

</div>
</div>
<a class="anchor" id="a48ef6618f933a3cf309e8462e48cf4e3"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIntNumeral" ref="a48ef6618f933a3cf309e8462e48cf4e3" args="(String^n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkIntNumeral </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a numeral of type Int. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02075">2075</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02075"></a>02075 { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>()); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a04bf543bb7b59788f7b7d40d4738648b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIntSort" ref="a04bf543bb7b59788f7b7d40d4738648b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkIntSort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an integer type. </p>
<p>This type is not the int type found in programming languages. A machine integer can be represented using bit-vectors. The function MkBvType creates a bit-vector type.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>MkBvType </dd></dl>

<p>Referenced by <a class="el" href="_microsoft_8_z3_8h_source.html#l02075">RawContext::MkIntNumeral()</a>.</p>

</div>
</div>
<a class="anchor" id="a71f742709784da4b25d39a72d4cd3b69"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIsInt" ref="a71f742709784da4b25d39a72d4cd3b69" args="(TermPtr arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkIsInt </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if real is an integer value. </p>
<p>The node <code>arg</code> must have real type. </p>

</div>
</div>
<a class="anchor" id="a4c1882945cd1a8462070e5d92e7a6b93"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIte" ref="a4c1882945cd1a8462070e5d92e7a6b93" args="(TermPtr t1, TermPtr t2, TermPtr t3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkIte </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing an if-then-else: <code>ite(t1, t2, t3)</code>. </p>
<p>The node <code>t1</code> must have Boolean type, <code>t2</code> and <code>t3</code> must have the same type. The type of the new node is equal to the type of <code>t2</code> and <code>t3</code>. </p>

</div>
</div>
<a class="anchor" id="aebcce24f39e8ce68930346c48ac5a57f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkLabel" ref="aebcce24f39e8ce68930346c48ac5a57f" args="(Symbol^name, bool pos, TermPtr fml)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>fml</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create labeled formula. </p>

</div>
</div>
<a class="anchor" id="aa4993b3a46531ed7c4924d64185344d2"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkLe" ref="aa4993b3a46531ed7c4924d64185344d2" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkLe </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create less than or equal to. </p>
<p>The nodes <code>arg1</code> and <code>arg2</code> must have the same type, and must be int or real. </p>

</div>
</div>
<a class="anchor" id="a4d98cdbaeab75d52989ffbd655312dc6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkListSort" ref="a4d98cdbaeab75d52989ffbd655312dc6" args="(String^name, SortPtr elem_sort,[Out] FuncDeclPtr%nil_decl,[Out] FuncDeclPtr%is_nil_decl,[Out] FuncDeclPtr%cons_decl,[Out] FuncDeclPtr%is_cons_decl,[Out] FuncDeclPtr%head_decl,[Out] FuncDeclPtr%tail_decl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkListSort </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>elem_sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>nil_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>is_nil_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>cons_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>is_cons_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>head_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>tail_decl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create list sort. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>of resulting list type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>elem_sort</em>&nbsp;</td><td>sort of elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nil_decl</em>&nbsp;</td><td>function declaration for nil. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_nil_decl</em>&nbsp;</td><td>function declaration for nil tester. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cons_decl</em>&nbsp;</td><td>function declaration for cons constructor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_cons_decl</em>&nbsp;</td><td>function declaration for cons tester. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head_decl</em>&nbsp;</td><td>function declaration for head accessor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tail_decl</em>&nbsp;</td><td>function declaration for tail accessor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa817a455803ab79b220b0182b48e2ae5"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkLt" ref="aa817a455803ab79b220b0182b48e2ae5" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkLt </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create less than. </p>
<p>The nodes <code>arg1</code> and <code>arg2</code> must have the same type, and must be int or real. </p>

</div>
</div>
<a class="anchor" id="a5a9f33467a473c739edac3721e0d56ea"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkMod" ref="a5a9f33467a473c739edac3721e0d56ea" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkMod </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create integer modulus. </p>
<p>The nodes <code>arg1</code> and <code>arg2</code> must have integer type. </p>

</div>
</div>
<a class="anchor" id="aa20eacf8d7fa0e446c1081e5ff01de77"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkMul" ref="aa20eacf8d7fa0e446c1081e5ff01de77" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkMul </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>args[0] * ... * args[args.Length-1]</code>. </p>
<p>All arguments must have int or real type.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Z3 has limited support for non-linear arithmetic. </dd>
<dd>
The number of arguments must be greater than zero. </dd></dl>

</div>
</div>
<a class="anchor" id="afc672bf3d4167000f8511454ef05a83d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNot" ref="afc672bf3d4167000f8511454ef05a83d" args="(TermPtr arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual TermPtr MkNot </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>not(a)</code>. </p>
<p>The node <code>a</code> must have Boolean type. </p>

</div>
</div>
<a class="anchor" id="ad04ee26dbb08422102bdc1189e293196"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNumeral" ref="ad04ee26dbb08422102bdc1189e293196" args="(String^numeral, SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkNumeral </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>numeral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a numeral of a given type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numeral</em>&nbsp;</td><td>An integer, or a string representing the numeral value in decimal notation. If the given type is a real, then the numeral can be a rational, that is, a string of the form <code>[num]* / [num]*</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ty</em>&nbsp;</td><td>The type of the numeral. In the current implementation, the given type can be an int, real, or bit-vectors of arbitrary size. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="_microsoft_8_z3_8h_source.html#l02075">RawContext::MkIntNumeral()</a>, and <a class="el" href="_microsoft_8_z3_8h_source.html#l02085">RawContext::MkRealNumeral()</a>.</p>

</div>
</div>
<a class="anchor" id="a72a8f73bed309b8924dd49eba903bb24"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkOr" ref="a72a8f73bed309b8924dd49eba903bb24" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkOr </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>args[0] or ... or args[args.Length-1]</code>. </p>
<p>All arguments must have Boolean type.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The number of arguments must be greater than zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a941e796cdc983459602aeb22178d8a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkPattern" ref="a8a941e796cdc983459602aeb22178d8a" args="(array&lt; TermPtr &gt;^terms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PatternPtr MkPattern </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>terms</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a pattern for quantifier instantiation. </p>
<p>Z3 uses pattern matching to instantiate quantifiers. If a pattern is not provided for a quantifier, then Z3 will automatically compute a set of patterns for it. However, for optimal performance, the user should provide the patterns.</p>
<p>Patterns comprise an array of terms. The array of terms passed to MkPattern should be non-empty. If the array comprises of more than one term, it is a called a multi-pattern.</p>
<p>In general, one can pass in an array of (multi-)patterns in the quantifier constructor.</p>
<p>To summarize, each quantifier takes an array of alternative multi-patterns. The quantifier is instantiated for every multi-pattern that is matched. Each multi-pattern is an array of terms. All terms must match for the multi-pattern to trigger instantiation. Create a multi-pattern using <code>MkPattern</code>. Create an array of multi-patterns and pass it to the quantifier constructor. If you just want a multi-pattern with a single term, then pass in the singleton array</p>
<p>For example, if you want to create the multi-pattern consisting of the two terms: <code>(store A I V)</code> and <code>(select A J)</code> where A, I, J, V are bound variables, create the pattern</p>
<pre>
           pattern1 = context.MkPattern(new TermPtr[]{ 
                             context.MkArrayStore(A,I,V),
                             context.MkArraySelect(A,J)
                                      })
           </pre><p> Then form the array </p>
<pre> 
                 new PatternPtr[]{ pattern1 }</pre><pre>           </pre><p> and pass it to the function <code>MkForall</code> or <code>MkExists</code>. Suppose you also want to have the quantifier be instantiated if the pattern <code>(select (store A I V) J)</code> is matched, then create the pattern: </p>
<pre>
           pattern2 = context.MkPattern(new TermPtr[] {
                                         context.MkArraySelect(context.MkArrayStore(A,I,V),J) })
           </pre><p> Then form the array: </p>
<pre>
                 new PatternPtr[] { pattern1, pattern2 }
           </pre><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4727759e5f6b9a0a8629e3ac29ce47b8"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkQuantifier" ref="a4727759e5f6b9a0a8629e3ac29ce47b8" args="(bool is_forall, unsigned weight, Symbol^quantifier_id, Symbol^skolem_id, array&lt; PatternPtr &gt;^patterns, array&lt; TermPtr &gt;^no_patterns, array&lt; TermPtr &gt;^bound, TermPtr body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkQuantifier </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_forall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>quantifier_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>skolem_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; PatternPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>no_patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a quantifier with no-pattern directives and symbols. </p>
<p>Abstract terms as the bound variables.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2e1ef04d234928c64248ce7eaf73502a" title="Create a bound variable.">MkBound</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3f6fe0d5e63e2aec779538fef2669a3c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkQuantifier" ref="a3f6fe0d5e63e2aec779538fef2669a3c" args="(bool is_forall, unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; TermPtr &gt;^no_patterns, array&lt; SortPtr &gt;^types, array&lt; Symbol^&gt;^names, TermPtr body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkQuantifier </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_forall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; PatternPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>no_patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a quantifier with no-pattern directives and symbols. </p>
<p>Use de-Bruijn indexing.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2e1ef04d234928c64248ce7eaf73502a" title="Create a bound variable.">MkBound</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02297">2297</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02306"></a>02306         {
<a name="l02307"></a>02307             <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c" title="Create a quantifier with no-pattern directives and symbols.">MkQuantifier</a>(is_forall, weight, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, patterns, no_patterns, types, names, body);
<a name="l02308"></a>02308         }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac6bbb2be135e462bf68e86d53e07eb40"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkRealNumeral" ref="ac6bbb2be135e462bf68e86d53e07eb40" args="(String^n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkRealNumeral </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a numeral of type Real. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02085">2085</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02085"></a>02085 { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>()); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9fc32a94ce1e1064c04f7fe4e1678e81"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkRealSort" ref="a9fc32a94ce1e1064c04f7fe4e1678e81" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkRealSort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a real type. </p>
<p>This type is not a floating point number. Z3 does not have support for floating point numbers yet. </p>

<p>Referenced by <a class="el" href="_microsoft_8_z3_8h_source.html#l02085">RawContext::MkRealNumeral()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e8abfb87c0e9eb2be93a85af185038e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkRem" ref="a5e8abfb87c0e9eb2be93a85af185038e" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkRem </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create integer remainder. </p>
<p>The nodes <code>arg1</code> and <code>arg2</code> must have integer type. </p>

</div>
</div>
<a class="anchor" id="a443543c80f0ace5c902df3589d3154c4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetAdd" ref="a443543c80f0ace5c902df3589d3154c4" args="(TermPtr set, TermPtr elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetAdd </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>elem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an element to a set. </p>
<p>The first argument must be a set, the second an element. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01978">1978</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01978"></a>01978                                                     {
<a name="l01979"></a>01979             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga856c3d0e28ce720f53912c2bbdd76175" title="Add an element to a set.">Z3_mk_set_add</a>(ctx(), get_ast(<span class="keyword">set</span>), get_ast(elem)));
<a name="l01980"></a>01980         }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae33216f5018efff4077640204c219dc2"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetComplement" ref="ae33216f5018efff4077640204c219dc2" args="(TermPtr arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetComplement </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take the complement of a set. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02014">2014</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02014"></a>02014                                              {
<a name="l02015"></a>02015             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga5c57143c9229cdf730c5103ff696590f" title="Take the complement of a set.">Z3_mk_set_complement</a>(ctx(), get_ast(arg)));
<a name="l02016"></a>02016         }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a99a686c0e68a6862f47f066eac39f84e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetDel" ref="a99a686c0e68a6862f47f066eac39f84e" args="(TermPtr set, TermPtr elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetDel </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>elem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an element to a set. </p>
<p>The first argument must be a set, the second an element. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01987">1987</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01987"></a>01987                                                     {
<a name="l01988"></a>01988             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga80e883f39dd3b88f9d0745c8a5b91d1d" title="Remove an element to a set.">Z3_mk_set_del</a>(ctx(), get_ast(<span class="keyword">set</span>), get_ast(elem)));
<a name="l01989"></a>01989         }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad51d6429450362ce9dc9f476b86d22e1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetDifference" ref="ad51d6429450362ce9dc9f476b86d22e1" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetDifference </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take the set difference between two sets. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02008">2008</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02008"></a>02008                                                             {
<a name="l02009"></a>02009             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gabb49c62f70b8198362e1a29ba6d8bde1" title="Take the set difference between two sets.">Z3_mk_set_difference</a>(ctx(), get_ast(arg1), get_ast(arg2)));
<a name="l02010"></a>02010         }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1bb3e567ae8090d8a659ad556c083e32"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetIntersect" ref="a1bb3e567ae8090d8a659ad556c083e32" args="(array&lt; TermPtr &gt;^sets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetIntersect </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>sets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take the intersection of a arrays of sets. </p>

</div>
</div>
<a class="anchor" id="a8449281ead0996eccbe5867d3b6ca96c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetMember" ref="a8449281ead0996eccbe5867d3b6ca96c" args="(TermPtr elem, TermPtr set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetMember </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for set membership. </p>
<p>The first argument should be an element type of the set. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02023">2023</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02023"></a>02023                                                        {
<a name="l02024"></a>02024             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gac6e516f3dce0bdd41095c6d6daf56063" title="Check for set membership.">Z3_mk_set_member</a>(ctx(), get_ast(elem), get_ast(<span class="keyword">set</span>)));
<a name="l02025"></a>02025         }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4fd038edb773b86952a3f4890d6bb0f5"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetSort" ref="a4fd038edb773b86952a3f4890d6bb0f5" args="(SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkSetSort </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create Set type. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01961">1961</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01961"></a>01961 { <span class="keywordflow">return</span> SortPtr(<a class="code" href="group__capi.html#ga6865879523e7e882d7e50a2d8445ac8b" title="Create Set type.">Z3_mk_set_sort</a>(ctx(), get_sort(ty))); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac05b3fbb60eecb46617782cd53e2b293"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetSubset" ref="ac05b3fbb60eecb46617782cd53e2b293" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetSubset </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for subsetness of sets. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02030">2030</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02030"></a>02030                                                         {
<a name="l02031"></a>02031             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga139c5803af0e86464adc7cedc53e7f3a" title="Check for subsetness of sets.">Z3_mk_set_subset</a>(ctx(), get_ast(arg1), get_ast(arg2)));
<a name="l02032"></a>02032         }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a72da2154689afc36a91ba955e9ccf081"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetUnion" ref="a72da2154689afc36a91ba955e9ccf081" args="(array&lt; TermPtr &gt;^sets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetUnion </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>sets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take the union of a arrays of sets. </p>
<p>The arguments must all be of the same type and all be of set types. </p>

</div>
</div>
<a class="anchor" id="a5111a4b70cadfbdb76491c889b57a312"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSort" ref="a5111a4b70cadfbdb76491c889b57a312" args="(Symbol^s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkSort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a free (uninterpreted) type using the given name (symbol). </p>
<p>Two free types are considered the same iff the have the same name. </p>

</div>
</div>
<a class="anchor" id="a01178a7c619ac2bd6c2e4d4f3da743d2"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSub" ref="a01178a7c619ac2bd6c2e4d4f3da743d2" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSub </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>args[0] - ... - args[args.Length - 1]</code>. </p>
<p>All arguments must have int or real type.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The number of arguments must be greater than zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e1f9e0325bac5897d7d4099eca72ed0"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSymbol" ref="a4e1f9e0325bac5897d7d4099eca72ed0" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a> MkSymbol </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a Z3 symbol using an intege or a string. </p>
<p>Symbols are used to name several term and type constructors. </p>

</div>
</div>
<a class="anchor" id="aa414182801e38192dfb8beed739bfe23"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkTheory" ref="aa414182801e38192dfb8beed739bfe23" args="(String^name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RawTheory MkTheory </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create user theory. </p>

</div>
</div>
<a class="anchor" id="a89955af727ba82dbb38b734befd37cdc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkToInt" ref="a89955af727ba82dbb38b734befd37cdc" args="(TermPtr arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkToInt </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create coercion from real to integer (floor). </p>
<p>The node <code>arg</code> must have real type. </p>

</div>
</div>
<a class="anchor" id="aecac3390e05c8743587c5bed03338b84"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkToReal" ref="aecac3390e05c8743587c5bed03338b84" args="(TermPtr arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkToReal </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create coercion from integer to real. </p>
<p>The node <code>arg</code> must have integer type. </p>

</div>
</div>
<a class="anchor" id="ab462a1d684499a2265ee02801dfcb4f4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkTrue" ref="ab462a1d684499a2265ee02801dfcb4f4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkTrue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>true</code>. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01301">1301</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01301"></a>01301 { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gae898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(ctx())); }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af75bb103fc493958385de9c849482df9"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkTupleSort" ref="af75bb103fc493958385de9c849482df9" args="(Symbol^mk_tuple_name, array&lt; Symbol^&gt;^field_names, array&lt; SortPtr &gt;^field_types,[Out] FuncDeclPtr%mk_tuple_decl,[In][Out] array&lt; FuncDeclPtr &gt;^proj_decl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkTupleSort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>mk_tuple_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^&nbsp;</td>
          <td class="paramname"> <em>field_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>field_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>mk_tuple_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>proj_decl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a tuple type. </p>
<p>A tuple with <code>n</code> fields has a constructor and <code>n</code> projections. This function will also declare the constructor and projection functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mk_tuple_name</em>&nbsp;</td><td>name of the constructor function associated with the tuple type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>field_names</em>&nbsp;</td><td>name of the projection functions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>field_types</em>&nbsp;</td><td>type of the tuple fields. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mk_tuple_decl</em>&nbsp;</td><td>output parameter that will contain the constructor declaration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proj_decl</em>&nbsp;</td><td>output parameter that will contain the projection function declarations. This field must be a buffer of size <code>num_fields</code> allocated by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4314bcfc4435b1f79028bc11b8774c28"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkUnaryMinus" ref="a4314bcfc4435b1f79028bc11b8774c28" args="(TermPtr arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkUnaryMinus </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>- arg</code>. </p>
<p>The argument must have int or real type. </p>

</div>
</div>
<a class="anchor" id="a80631b59bd60e34b88cdc676274334b0"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkXor" ref="a80631b59bd60e34b88cdc676274334b0" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkXor </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an AST node representing <code>t1 xor t2</code>. </p>
<p>The nodes <code>t1</code> and <code>t2</code> must have Boolean type. </p>

</div>
</div>
<a class="anchor" id="aedcfe737b097182e955e06099747630f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseSmtlib2File" ref="aedcfe737b097182e955e06099747630f" args="(String^filename, array&lt; SortPtr &gt;^sorts, array&lt; FuncDeclPtr &gt;^decls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr ParseSmtlib2File </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>sorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>decls</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse a file containing formulas in SMT-LIB2 format. </p>
<p>Return conjunction of Asserts occurring in the file. </p>

</div>
</div>
<a class="anchor" id="afd791c9297c9a547017ba2cf0b94ee81"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseSmtlib2String" ref="afd791c9297c9a547017ba2cf0b94ee81" args="(String^s, array&lt; SortPtr &gt;^sorts, array&lt; FuncDeclPtr &gt;^decls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr ParseSmtlib2String </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>sorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>decls</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse a string in the SMT-LIB2 format. </p>
<p>Return conjunction of Asserts occurring in the string. </p>

</div>
</div>
<a class="anchor" id="a189844e560a2e30995b6d68823304932"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseSmtlibFile" ref="a189844e560a2e30995b6d68823304932" args="(String^file,[In] array&lt; SortPtr &gt;^sorts,[In] array&lt; FuncDeclPtr &gt;^decls,[Out] array&lt; TermPtr &gt;^%assumptions,[Out] array&lt; TermPtr &gt;^%formulas,[Out] array&lt; FuncDeclPtr &gt;^%new_decls,[Out] array&lt; SortPtr &gt;^%new_sorts,[Out] String^%parser_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParseSmtlibFile </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>sorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>decls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] array&lt; TermPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] array&lt; TermPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>formulas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] array&lt; FuncDeclPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>new_decls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] array&lt; SortPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>new_sorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] String^%&nbsp;</td>
          <td class="paramname"> <em>parser_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3d9995b5f0cd4395f93c9ad17a63d7cc" title="Parse the given string using the SMT-LIB parser.">ParseSmtlibString</a>, but reads the benchmark from a file. </p>

</div>
</div>
<a class="anchor" id="a3d9995b5f0cd4395f93c9ad17a63d7cc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseSmtlibString" ref="a3d9995b5f0cd4395f93c9ad17a63d7cc" args="(String^string,[In] array&lt; SortPtr &gt;^sorts,[In] array&lt; FuncDeclPtr &gt;^decls,[Out] array&lt; TermPtr &gt;^%assumptions,[Out] array&lt; TermPtr &gt;^%formulas,[Out] array&lt; FuncDeclPtr &gt;^%new_decls,[Out] array&lt; SortPtr &gt;^%new_sorts,[Out] String^%parser_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParseSmtlibString </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>sorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In] array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>decls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] array&lt; TermPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] array&lt; TermPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>formulas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] array&lt; FuncDeclPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>new_decls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] array&lt; SortPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>new_sorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] String^%&nbsp;</td>
          <td class="paramname"> <em>parser_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse the given string using the SMT-LIB parser. </p>
<p>The symbol table of the parser can be initialized using the given types and declarations. The symbols in the arrays <code>type_names</code> and <code>decl_names</code> don't need to match the names of the types and declarations in the arrays <code>types</code> and <code>decls</code>. This is an useful feature since we can use arbitrary names to reference types and declarations defined using the C API.</p>
<p>The formulas, assumptions and declarations defined in <code>str</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The string contianing the SMT-LIB benchmark </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sorts</em>&nbsp;</td><td>List of auxiliary sorts used in SMT-LIB benchmark. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>decls</em>&nbsp;</td><td>List of declarations to be used for parsing the SMT-LIB string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assumptions</em>&nbsp;</td><td>Returned set of assumptions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>formulas</em>&nbsp;</td><td>Returned set of formulas. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_decls</em>&nbsp;</td><td>Additional declarations from the SMT-LIB benchmark. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_sorts</em>&nbsp;</td><td>Additional sorts fromt he SMT-LIB benchmark. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parser_out</em>&nbsp;</td><td>String containing error messages from parsing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb1e2e3a1d96aa625758845ed3b8d534"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseZ3File" ref="abb1e2e3a1d96aa625758845ed3b8d534" args="(String^filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr ParseZ3File </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>filename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse a file containing formulas in Z3's native format. </p>
<p>Return conjunction of Asserts occurring in the file. </p>

</div>
</div>
<a class="anchor" id="ade46bed01c907e799528075996072637"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseZ3String" ref="ade46bed01c907e799528075996072637" args="(String^s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr ParseZ3String </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse a string in the native Z3 format. </p>
<p>Return conjunction of Asserts occurring in the string. </p>

</div>
</div>
<a class="anchor" id="a268029705dabf988d7655c85df1b548e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::PersistTerm" ref="a268029705dabf988d7655c85df1b548e" args="(TermPtr t, unsigned num_scopes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PersistTerm </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_scopes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Persist a term during num_scopes of pops. </p>
<p>Normally, references to terms are no longer valid when popping scopes beyond the level where the terms are created. If you want to reference a term below the scope where it was created, use this method to specify how many pops the term should survive. The current scope level is given as the current total number of calls to push subtracted by the total number of calls to pop. If num_scopes is larger or equal to the current scope level, then the term pointer persists throughout the life-time of the context.</p>
<p>Example usage:</p>
<p>context.Push(); context.Push(); Term t = context.MkNumeral(1, context.MkIntSort()); context.PersistTerm(t, 1); context.Pop(); reference to t is valid. context.Pop(); reference to t is not valid. </p>

</div>
</div>
<a class="anchor" id="aac40326c3b51f26bf05a823061429cc1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Pop" ref="aac40326c3b51f26bf05a823061429cc1" args="(unsigned num_scopes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Pop </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_scopes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Backtrack. </p>
<p>Restores the context from the top of the stack, and pops it off the stack. Any changes to the logical context (by <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a48d8c58bf4484b54bf612a3b81526648" title="Assert a constraing into the logical context.">AssertCnstr</a> or other functions) between the matching <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Create a backtracking point.">Push</a> and <code>Pop</code> operators are flushed, and the context is completely restored to what it was right before the <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Create a backtracking point.">Push</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_scopes</em>&nbsp;</td><td>number of scopes to pop. Default value is 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Create a backtracking point.">Push</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a268029705dabf988d7655c85df1b548e" title="Persist a term during num_scopes of pops.">PersistTerm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a447d9c1a5a8c1d7ea7ff8d1b8c9a834c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Push" ref="a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Push </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a backtracking point. </p>
<p>The logical context can be viewed as a stack of contexts. The scope level is the number of elements on this stack. The stack of contexts is simulated using trail (undo) stacks.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aac40326c3b51f26bf05a823061429cc1" title="Backtrack.">Pop</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a268029705dabf988d7655c85df1b548e" title="Persist a term during num_scopes of pops.">PersistTerm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a606e29bd48b267e20d8d04388cec4e4a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Query" ref="a606e29bd48b267e20d8d04388cec4e4a" args="(TermPtr query)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">LBool</a> Query </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>query</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>post a query. The return value is LBool.True if the query is satisfiabl,e it is LBool.False if it is not satisfiabled, and Undef on timeouts or approximation. </p>

</div>
</div>
<a class="anchor" id="a6bcc908b9ba41cd95dae64006321b34b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ResetMemory" ref="a6bcc908b9ba41cd95dae64006321b34b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ResetMemory </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free all resources allocated for Z3. </p>

</div>
</div>
<a class="anchor" id="a22af33e79aad8e443bfe2c249c6255ef"></a><!-- doxytag: member="Microsoft::Z3::RawContext::SetErrorHandler" ref="a22af33e79aad8e443bfe2c249c6255ef" args="(IErrorHandler^h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SetErrorHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_microsoft_1_1_z3_1_1_i_error_handler.html">IErrorHandler</a>^&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a Z3 error handler. </p>
<p>A call to a Z3 function throw <a class="el" href="class_microsoft_1_1_z3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a> when it is not used correctly. An error handler can be registered and will be called in this case prior to throwing <a class="el" href="class_microsoft_1_1_z3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a>. </p>

</div>
</div>
<a class="anchor" id="a925fd320cf1476d3b08d70f169c6790d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::SetLogic" ref="a925fd320cf1476d3b08d70f169c6790d" args="(String^logic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SetLogic </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>logic</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure the SMTLIB logic to be used in the given logical context. </p>

</div>
</div>
<a class="anchor" id="a17471e6be035651820a92e6c4e31d673"></a><!-- doxytag: member="Microsoft::Z3::RawContext::SetPrintMode" ref="a17471e6be035651820a92e6c4e31d673" args="(PrintMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPrintMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mapi.html#ga8fcc700aeeee633213b4e5f433e5e12e">PrintMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select mode for the format used for pretty-printing AST nodes. </p>
<p>The default mode for pretty printing AST nodes is to produce SMT-LIB style output where common subexpressions are printed at each occurrence. The mode is called PrintMode.SmtlibFull. To print shared common subexpressions only once, use the PrintMode.LowLevel mode. </p>

</div>
</div>
<a class="anchor" id="aea36484f844217cc37a206be0fe565f6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Simplify" ref="aea36484f844217cc37a206be0fe565f6" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr Simplify </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interface to simplifier. </p>
<p>Provides an interface to the AST simplifier used by Z3. It allows clients to piggyback on top of the AST simplifier for their own term manipulation. </p>

</div>
</div>
<a class="anchor" id="a4717aab1cfc427ec9c049c9ba743a006"></a><!-- doxytag: member="Microsoft::Z3::RawContext::SoftCheckCancel" ref="a4717aab1cfc427ec9c049c9ba743a006" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoftCheckCancel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel the current search initiated using <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a>, <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed51407e62b77b7bcc14d25ca8e320af" title="Check whether the given logical context is consistent or not.">CheckAndGetModel</a>, or <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6623753616cdabbfeb889ed4a31dfbc7" title="Check whether the given logical context is consistent or not with respect to auxiliary...">CheckAssumptions</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed51407e62b77b7bcc14d25ca8e320af" title="Check whether the given logical context is consistent or not.">CheckAndGetModel</a> </dd>
<dd>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6623753616cdabbfeb889ed4a31dfbc7" title="Check whether the given logical context is consistent or not with respect to auxiliary...">CheckAssumptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0c7570d3474aec2457249e00de34c51a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::StatisticsToString" ref="a0c7570d3474aec2457249e00de34c51a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String StatisticsToString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert the given logical context into a string. </p>
<p>This function is mainly used for debugging purposes. It displays the internal structure of a logical context. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02912">2912</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02912"></a>02912                                      {
<a name="l02913"></a>02913             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> String(<a class="code" href="group__capi.html#ga660933fbbc1cd0dce85680d532fb56e0" title="Return runtime statistics as a string.">Z3_statistics_to_string</a>(ctx()));
<a name="l02914"></a>02914         }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a74d274e8e6fc3ccc4ac39a375c0cc536"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ToggleWarningMessages" ref="a74d274e8e6fc3ccc4ac39a375c0cc536" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ToggleWarningMessages </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable warning messages sent to the console out/error. </p>
<p>Warnings are printed after passing <code>true</code>, warning messages are suppressed after calling this method with <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="a08d99b52685eab1e9d5ac4d9223cb2be"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ToString" ref="a08d99b52685eab1e9d5ac4d9223cb2be" args="() override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual String ToString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert the given logical context into a string. </p>
<p>This function is mainly used for debugging purposes. It displays the internal structure of a logical context. </p>

</div>
</div>
<a class="anchor" id="aeacea454f727994d3088b0a329ce0994"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ToString" ref="aeacea454f727994d3088b0a329ce0994" args="(AstPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String ToString </td>
          <td>(</td>
          <td class="paramtype">AstPtr&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert the given AST node into a string. </p>

</div>
</div>
<a class="anchor" id="af74f7a7602abaa3b7d6451f33439af63"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TryGetNumeral" ref="af74f7a7602abaa3b7d6451f33439af63" args="(TermPtr v,[Out] __int64%num,[Out] __int64%den)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TryGetNumeral </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] __int64%&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Out] __int64%&nbsp;</td>
          <td class="paramname"> <em>den</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine long long int. Throw InvalidArgument if the call fails. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>GetTermKind(v) == TermKind.Numeral</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9e7467b18eba9cc3dc04495a7c51d1fa"></a><!-- doxytag: member="Microsoft::Z3::RawContext::UpdateParamValue" ref="a9e7467b18eba9cc3dc04495a7c51d1fa" args="(String^param_id, String^value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UpdateParamValue </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>param_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update a mutable configuration parameter. </p>
<p>The list of all configuration parameters can be obtained using the Z3 executable:</p>
<div class="fragment"><pre class="fragment">
           z3.exe -ini?
           </pre></div><p>Only a few configuration parameters are mutable once the context is created. The error handler is invoked when trying to modify an immutable parameter.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>SetParamValue </dd></dl>

</div>
</div>
<a class="anchor" id="a12f2bc414c2c1520880db1444edd72d1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::UpdateTerm" ref="a12f2bc414c2c1520880db1444edd72d1" args="(TermPtr t, array&lt; TermPtr &gt;^new_args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr UpdateTerm </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>new_args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the arguments of a term or quantifier. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The number of arguments passed in new_args should be the same as number of arguments to the term t. </dd></dl>

</div>
</div>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="ad9010a8c0b8110f5e670fa5fc280f064"></a><!-- doxytag: member="Microsoft::Z3::RawContext::__pad1__" ref="ad9010a8c0b8110f5e670fa5fc280f064" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad9010a8c0b8110f5e670fa5fc280f064">__pad1__</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register user rewrite function. </p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l03080">3080</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>

</div>
</div>
</div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Mon Mar 19 16:36:34 2012
</BODY>
</HTML>
