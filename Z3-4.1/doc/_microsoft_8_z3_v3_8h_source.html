 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">

<table>
<tr>
<th style="width:120px"><a style="border=0px" class="el" href="index.html"><img border="0" src="z3.png" alt="Z3" /></a></th>
<th style="width:100%">
<div id="nav">
<ul>
<li><a href="download.html">Download</a></li>
<li>/</li>
<li><a href="documentation.html#tutorial">Tutorials</a></li>
<li>/</li>
<li><a href="documentation.html">Documentation</a></li>
<li>/</li>
<li><a href="mail.html">Contact</a></li>
<li>/</li>
<li><a href="faq.html">FAQ</a></li>
<li>/</li>
<li><a href="awards.html">Awards</a></li>
<li>/</li>
<li><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx">RiSE</a></li>
</ul>
</div>
</th>
<th style="width:120px">
<a style="border=0px" class="el" href="http://research.microsoft.com"><img border="0" src="logo_msr.gif" alt="Microsoft Research" />
</th>
</tr>
</table>

<!-- <p> -->
<!-- <img align="middle" src="z3.png" alt="Z3" /> -->
<!-- <table class="centered-small"> -->
<!--   <tr> -->
<!--     <th><a href="index.html"><span>Home</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="documentation.html"><span>Docs</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="download.html"><span>Download</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="mail.html"><span>Mail</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="faq.html"><span>FAQ</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="awards.html"><span>Awards</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com"><span>MSR</span></a></th> -->
<!--   </tr> -->
<!-- </table> -->
<!-- </p> -->

<!-- Generated by Doxygen 1.6.3 -->
<h1>Microsoft.Z3V3/Microsoft.Z3V3.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*++</span>
<a name="l00002"></a>00002 <span class="comment">Copyright (c) 2007 Microsoft Corporation</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">Module Name:</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">    Microsoft.Z3V3.h</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">Abstract:</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">    Z3 Managed API.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">Author:</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    Nikolaj Bjorner (nbjorner)</span>
<a name="l00015"></a>00015 <span class="comment">    Leonardo de Moura (leonardo) 2007-06-8</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">Notes:</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">    This API is deprecated and support for this is discontinued.</span>
<a name="l00020"></a>00020 <span class="comment">    It is superseeded by the new Microsoft.Z3 API.</span>
<a name="l00021"></a>00021 <span class="comment">    </span>
<a name="l00022"></a>00022 <span class="comment">--*/</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#ifndef _MICROSOFT_Z3V3_H__</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#define _MICROSOFT_Z3V3_H__</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>
<a name="l00027"></a>00027 <span class="keyword">struct </span>_Z3_model {};
<a name="l00028"></a>00028 <span class="keyword">struct </span>_Z3_config {};
<a name="l00029"></a>00029 <span class="keyword">struct </span>_Z3_context {};
<a name="l00030"></a>00030 <span class="keyword">struct </span>_Z3_func_decl {};
<a name="l00031"></a>00031 <span class="keyword">struct </span>_Z3_app {};
<a name="l00032"></a>00032 <span class="keyword">struct </span>_Z3_sort {};
<a name="l00033"></a>00033 <span class="keyword">struct </span>_Z3_symbol {};
<a name="l00034"></a>00034 <span class="keyword">struct </span>_Z3_ast {};
<a name="l00035"></a>00035 <span class="keyword">struct </span>_Z3_literals {};
<a name="l00036"></a>00036 <span class="keyword">struct </span>_Z3_pattern {};
<a name="l00037"></a>00037 <span class="keyword">struct </span>_Z3_constructor {};
<a name="l00038"></a>00038 <span class="keyword">struct </span>_Z3_constructor_list {};
<a name="l00039"></a>00039 <span class="keyword">typedef</span> _Z3_literals *Z3_literals;
<a name="l00040"></a>00040 <span class="keyword">struct </span>_Z3_theory {};
<a name="l00041"></a>00041 <span class="keyword">struct </span>_Z3_ast_vector {};
<a name="l00042"></a>00042 <span class="keyword">struct </span>_Z3_fixedpoint {};
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">using namespace </span>System;
<a name="l00045"></a>00045 <span class="keyword">using namespace </span>System::Collections::Generic;
<a name="l00046"></a>00046 <span class="keyword">using namespace </span>System::Runtime::InteropServices;
<a name="l00047"></a>00047 <span class="keyword">using namespace </span>System::Numerics;
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;..\lib\z3.h&quot;</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="keyword">namespace </span>Microsoft {
<a name="l00053"></a>00053 <span class="keyword">namespace </span>Z3V3 {
<a name="l00054"></a>00054 
<a name="l00055"></a>00055     <span class="keyword">class </span>ref_context {
<a name="l00056"></a>00056         <span class="keywordtype">unsigned</span>   m_count;
<a name="l00057"></a>00057         <span class="keywordtype">bool</span>       m_owned;
<a name="l00058"></a>00058         <span class="keywordtype">bool</span>       m_scoped;
<a name="l00059"></a>00059         Z3_context m_ctx;
<a name="l00060"></a>00060         Z3_fixedpoint m_dl;
<a name="l00061"></a>00061     ref_context(Z3_context ctx, <span class="keywordtype">bool</span> owned, <span class="keywordtype">bool</span> scoped): m_count(1), m_owned(owned), m_scoped(scoped), m_ctx(ctx), m_dl(0) {}
<a name="l00062"></a>00062     <span class="keyword">public</span>:
<a name="l00063"></a>00063         <span class="keyword">static</span> ref_context* mk(Z3_context ctx, <span class="keywordtype">bool</span> owned, <span class="keywordtype">bool</span> scoped);
<a name="l00064"></a>00064         <span class="keywordtype">void</span> dec_ref();
<a name="l00065"></a>00065         <span class="keywordtype">void</span> inc_ref();
<a name="l00066"></a>00066         Z3_context operator()() { <span class="keywordflow">return</span> m_ctx; }
<a name="l00067"></a>00067         ~ref_context() {}
<a name="l00068"></a>00068         <span class="keywordtype">bool</span> is_ref_counted()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !is_scoped(); }
<a name="l00069"></a>00069         <span class="keywordtype">bool</span> is_scoped()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_scoped; }
<a name="l00070"></a>00070         Z3_fixedpoint dl();
<a name="l00071"></a>00071     };
<a name="l00072"></a>00072 
<a name="l00077"></a>00077 
<a name="l00078"></a>00078     <span class="keyword">public ref class</span> Z3Log {
<a name="l00079"></a>00079         <span class="keyword">static</span> <span class="keywordtype">bool</span> m_open = <span class="keyword">false</span>;
<a name="l00080"></a>00080     <span class="keyword">public</span>:
<a name="l00088"></a>00088         <span class="keyword">static</span> <span class="keywordtype">bool</span> Open(String^ filename);
<a name="l00089"></a>00089 
<a name="l00093"></a>00093         <span class="keyword">static</span> <span class="keywordtype">bool</span> IsOpen() { <span class="keywordflow">return</span> m_open; }
<a name="l00094"></a>00094         
<a name="l00100"></a>00100         <span class="keyword">static</span> <span class="keywordtype">void</span> Append(String^ <span class="keywordtype">string</span>);
<a name="l00101"></a>00101         
<a name="l00107"></a>00107         <span class="keyword">static</span> <span class="keywordtype">void</span> Close();
<a name="l00108"></a>00108     };
<a name="l00109"></a>00109     
<a name="l00119"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html">00119</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a> {
<a name="l00120"></a>00120         Z3_context   m_ctx;
<a name="l00121"></a>00121         Z3_symbol    m_symbol;
<a name="l00122"></a>00122     <span class="keyword">internal</span>:
<a name="l00123"></a>00123         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>(Z3_context c, Z3_symbol s) : m_ctx(c), m_symbol(s) { }
<a name="l00124"></a>00124         Z3_symbol <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_symbol; }      
<a name="l00125"></a>00125     <span class="keyword">public</span>:
<a name="l00126"></a>00126         <span class="keyword">virtual</span> String^ ToString() <span class="keyword">override</span>;
<a name="l00127"></a>00127     };
<a name="l00128"></a>00128 
<a name="l00137"></a><a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">00137</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a>
<a name="l00138"></a>00138     {
<a name="l00139"></a>00139         True,
<a name="l00140"></a>00140         False,
<a name="l00141"></a>00141         Undef
<a name="l00142"></a>00142     };
<a name="l00143"></a>00143 
<a name="l00169"></a><a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f">00169</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> 
<a name="l00170"></a>00170     {
<a name="l00171"></a>00171         Ok,
<a name="l00172"></a>00172         TypeError,
<a name="l00173"></a>00173         IndexOutOfBounds,
<a name="l00174"></a>00174         InvalidArgument,
<a name="l00175"></a>00175         ParserError,
<a name="l00176"></a>00176         NoParser,
<a name="l00177"></a>00177         InvalidPattern,
<a name="l00178"></a>00178         InternalFatal,
<a name="l00179"></a>00179         InvalidUsage,
<a name="l00180"></a>00180         FileAccessError,
<a name="l00181"></a>00181         NonDisposedConfig,
<a name="l00182"></a>00182         NonDisposedContext,
<a name="l00183"></a>00183         NonDisposedLiterals,
<a name="l00184"></a>00184         NonDisposedModel
<a name="l00185"></a>00185     };
<a name="l00186"></a>00186 
<a name="l00195"></a><a class="code" href="group__mapi.html#ga8fcc700aeeee633213b4e5f433e5e12e">00195</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga8fcc700aeeee633213b4e5f433e5e12e" title="Z3 pretty printing modes used when pretty printing terms.">PrintMode</a> 
<a name="l00196"></a>00196     {
<a name="l00197"></a>00197         SmtlibFull,
<a name="l00198"></a>00198         LowLevel,
<a name="l00199"></a>00199         SmtlibCompliant,
<a name="l00200"></a>00200         Smtlib2Compliant
<a name="l00201"></a>00201     };
<a name="l00202"></a>00202 
<a name="l00209"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_z3_error.html">00209</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a> : Exception {
<a name="l00210"></a>00210     <span class="keyword">public</span>:
<a name="l00211"></a>00211         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a>(<a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> c) { Code = c; InternalCode = 0; }
<a name="l00212"></a>00212         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a>(<span class="keywordtype">int</span> i) { Code = ErrorCode::Ok; InternalCode = i; }
<a name="l00213"></a>00213         <a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> Code;
<a name="l00214"></a>00214         <span class="keywordtype">int</span>       InternalCode;
<a name="l00215"></a>00215     };
<a name="l00216"></a>00216 
<a name="l00217"></a>00217     
<a name="l00219"></a>00219     <span class="keyword">typedef</span> IntPtr AstPtr;
<a name="l00220"></a>00220     <span class="keyword">typedef</span> IntPtr SortPtr;
<a name="l00221"></a>00221     <span class="keyword">typedef</span> IntPtr FuncDeclPtr;
<a name="l00222"></a>00222     <span class="keyword">typedef</span> IntPtr TermPtr;
<a name="l00223"></a>00223     <span class="keyword">typedef</span> IntPtr PatternPtr;
<a name="l00224"></a>00224     <span class="keyword">typedef</span> IntPtr AppPtr;
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     Z3_func_decl get_func_decl(FuncDeclPtr t) { 
<a name="l00228"></a>00228         <span class="keywordflow">if</span> (t == IntPtr::Zero) {
<a name="l00229"></a>00229             <span class="keywordflow">throw</span> <span class="keyword">gcnew</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a>(ErrorCode::InvalidArgument);
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Z3_func_decl<span class="keyword">&gt;</span>(t.ToPointer()); 
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233     Z3_ast get_ast(TermPtr t) { 
<a name="l00234"></a>00234         <span class="keywordflow">if</span> (t == IntPtr::Zero) {
<a name="l00235"></a>00235             <span class="keywordflow">throw</span> <span class="keyword">gcnew</span> Z3Error(ErrorCode::InvalidArgument);
<a name="l00236"></a>00236         }
<a name="l00237"></a>00237         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Z3_ast<span class="keyword">&gt;</span>(t.ToPointer()); 
<a name="l00238"></a>00238     }
<a name="l00239"></a>00239     Z3_sort get_sort(SortPtr t) { 
<a name="l00240"></a>00240         <span class="keywordflow">if</span> (t == IntPtr::Zero) {
<a name="l00241"></a>00241             <span class="keywordflow">throw</span> <span class="keyword">gcnew</span> Z3Error(ErrorCode::InvalidArgument);
<a name="l00242"></a>00242         }
<a name="l00243"></a>00243         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Z3_sort<span class="keyword">&gt;</span>(t.ToPointer()); 
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245     Z3_app get_const_ast(AppPtr c) { 
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (c == IntPtr::Zero) {
<a name="l00247"></a>00247             <span class="keywordflow">throw</span> <span class="keyword">gcnew</span> Z3Error(ErrorCode::InvalidArgument);
<a name="l00248"></a>00248         }
<a name="l00249"></a>00249         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Z3_app<span class="keyword">&gt;</span>(c.ToPointer()); 
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251     Z3_pattern get_pattern(PatternPtr p) { 
<a name="l00252"></a>00252         <span class="keywordflow">if</span> (p == IntPtr::Zero) {
<a name="l00253"></a>00253             <span class="keywordflow">throw</span> <span class="keyword">gcnew</span> Z3Error(ErrorCode::InvalidArgument);
<a name="l00254"></a>00254         }
<a name="l00255"></a>00255         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Z3_pattern<span class="keyword">&gt;</span>(p.ToPointer()); 
<a name="l00256"></a>00256     }
<a name="l00257"></a>00257 
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     
<a name="l00268"></a><a class="code" href="group__mapi.html#ga05812818de02fb4b202d7513ce50745d">00268</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga05812818de02fb4b202d7513ce50745d" title="In Z3, a symbol can be represented using integers and strings (See GetSymbolKind)...">SymbolKind</a> 
<a name="l00269"></a>00269     {
<a name="l00270"></a>00270         Int, 
<a name="l00271"></a>00271         String
<a name="l00272"></a>00272     };
<a name="l00273"></a>00273 
<a name="l00277"></a><a class="code" href="group__mapi.html#ga7664c6569cf130a5d166ec8c8dc27101">00277</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga7664c6569cf130a5d166ec8c8dc27101" title="The different kinds of Z3 sorts (See GetSortKind).">SortKind</a> 
<a name="l00278"></a>00278     {
<a name="l00279"></a>00279         Uninterpreted,
<a name="l00280"></a>00280         Bool,
<a name="l00281"></a>00281         Int,
<a name="l00282"></a>00282         Real,
<a name="l00283"></a>00283         BitVector,
<a name="l00284"></a>00284         Array,
<a name="l00285"></a>00285         Datatype,
<a name="l00286"></a>00286         Unknown
<a name="l00287"></a>00287     };
<a name="l00288"></a>00288 
<a name="l00302"></a><a class="code" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e">00302</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e" title="Different failure kinds.">SearchFailureExplanation</a>
<a name="l00303"></a>00303     {
<a name="l00304"></a>00304         NoFailure,
<a name="l00305"></a>00305         Unknown,
<a name="l00306"></a>00306         TimeOut,
<a name="l00307"></a>00307         MemOut,
<a name="l00308"></a>00308         UserCanceled,
<a name="l00309"></a>00309         MaxConflicts,
<a name="l00310"></a>00310         Theory,
<a name="l00311"></a>00311         Quantifiers
<a name="l00312"></a>00312     };
<a name="l00313"></a>00313 
<a name="l00323"></a><a class="code" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc">00323</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc" title="The different kinds of Z3 Terms.">TermKind</a> 
<a name="l00324"></a>00324     {
<a name="l00325"></a>00325         Numeral,
<a name="l00326"></a>00326         App,
<a name="l00327"></a>00327         Var,
<a name="l00328"></a>00328         Quantifier,
<a name="l00329"></a>00329         Unknown
<a name="l00330"></a>00330     };
<a name="l00331"></a>00331     
<a name="l00332"></a>00332 
<a name="l00336"></a><a class="code" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425">00336</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425" title="Different kinds of Z3 built-in declarations (See GetDeclKind).">DeclKind</a> 
<a name="l00337"></a>00337     {
<a name="l00338"></a>00338         <span class="comment">// Basic operators</span>
<a name="l00339"></a>00339         True,
<a name="l00340"></a>00340         False,
<a name="l00341"></a>00341         Eq,
<a name="l00342"></a>00342         Distinct,
<a name="l00343"></a>00343         Ite,
<a name="l00344"></a>00344         And,
<a name="l00345"></a>00345         Or,
<a name="l00346"></a>00346         Iff,
<a name="l00347"></a>00347         Xor,
<a name="l00348"></a>00348         Not,
<a name="l00349"></a>00349         Implies,
<a name="l00350"></a>00350         <span class="comment">// Arithmetic</span>
<a name="l00351"></a>00351         ArithNum,
<a name="l00352"></a>00352         Le,
<a name="l00353"></a>00353         Ge,
<a name="l00354"></a>00354         Lt,
<a name="l00355"></a>00355         Gt,
<a name="l00356"></a>00356         Add,
<a name="l00357"></a>00357         Sub,
<a name="l00358"></a>00358         Uminus,
<a name="l00359"></a>00359         Mul,
<a name="l00360"></a>00360         Div,
<a name="l00361"></a>00361         IDiv,
<a name="l00362"></a>00362         Rem,
<a name="l00363"></a>00363         Mod,
<a name="l00364"></a>00364         ToReal,
<a name="l00365"></a>00365         ToInt,
<a name="l00366"></a>00366         IsInt,
<a name="l00367"></a>00367         <span class="comment">// Arrays</span>
<a name="l00368"></a>00368         Store,
<a name="l00369"></a>00369         Select,
<a name="l00370"></a>00370         ConstArray,
<a name="l00371"></a>00371         DefaultArray,
<a name="l00372"></a>00372         MapArray,
<a name="l00373"></a>00373         Union,
<a name="l00374"></a>00374         Intersect,
<a name="l00375"></a>00375         Difference,
<a name="l00376"></a>00376         Complement,
<a name="l00377"></a>00377         Subset,
<a name="l00378"></a>00378         AsArray,
<a name="l00379"></a>00379         <span class="comment">// Bit-vectors.            </span>
<a name="l00380"></a>00380 
<a name="l00381"></a>00381         BitNum,
<a name="l00382"></a>00382         Bit1,
<a name="l00383"></a>00383         Bit0,
<a name="l00384"></a>00384         BNeg,
<a name="l00385"></a>00385         BAdd,
<a name="l00386"></a>00386         BSub,
<a name="l00387"></a>00387         BMul,
<a name="l00388"></a>00388         BSDiv,
<a name="l00389"></a>00389         BUDiv,
<a name="l00390"></a>00390         BSRem,
<a name="l00391"></a>00391         BURem,
<a name="l00392"></a>00392         BSMod,
<a name="l00393"></a>00393 
<a name="l00394"></a>00394         BSDiv0,
<a name="l00395"></a>00395         BUDiv0,
<a name="l00396"></a>00396         BSRem0,
<a name="l00397"></a>00397         BURem0,
<a name="l00398"></a>00398         BSMod0,
<a name="l00399"></a>00399         BULeq,
<a name="l00400"></a>00400         BSLeq,
<a name="l00401"></a>00401         BUGeq,
<a name="l00402"></a>00402         BSGeq,
<a name="l00403"></a>00403         BULt,
<a name="l00404"></a>00404         BSLt,
<a name="l00405"></a>00405         BUGt,
<a name="l00406"></a>00406         BSGt,
<a name="l00407"></a>00407         BAnd,
<a name="l00408"></a>00408         BOr,
<a name="l00409"></a>00409         BNot,
<a name="l00410"></a>00410         BXor,
<a name="l00411"></a>00411         BNand,
<a name="l00412"></a>00412         BNor,
<a name="l00413"></a>00413         BXnor,
<a name="l00414"></a>00414         BConcat,
<a name="l00415"></a>00415         BSignExt,
<a name="l00416"></a>00416         BZeroExt,
<a name="l00417"></a>00417         BExtract,
<a name="l00418"></a>00418         BRepeat,
<a name="l00419"></a>00419         BRedOr,
<a name="l00420"></a>00420         BRedAnd,
<a name="l00421"></a>00421         BComp,
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         BShl,
<a name="l00424"></a>00424         BLShr,
<a name="l00425"></a>00425         BAShr,
<a name="l00426"></a>00426         BRotateLeft,
<a name="l00427"></a>00427         BRotateRight,
<a name="l00428"></a>00428         BExtRotateLeft,
<a name="l00429"></a>00429         BExtRotateRight,
<a name="l00430"></a>00430         BInt2Bv,
<a name="l00431"></a>00431         BBv2Int,
<a name="l00432"></a>00432         BCarry,
<a name="l00433"></a>00433         BXor3,
<a name="l00434"></a>00434 
<a name="l00435"></a>00435         PrAsserted,
<a name="l00436"></a>00436         PrGoal,
<a name="l00437"></a>00437         PrModusPonens,
<a name="l00438"></a>00438         PrReflexivity,
<a name="l00439"></a>00439         PrTransitivity,
<a name="l00440"></a>00440         PrTransitivityStar,
<a name="l00441"></a>00441         PrSymmetry,
<a name="l00442"></a>00442         PrMonotonicity,
<a name="l00443"></a>00443         PrQuantIntro,
<a name="l00444"></a>00444         PrDistributivity,
<a name="l00445"></a>00445         PrAndElim,
<a name="l00446"></a>00446         PrNotOrElim,
<a name="l00447"></a>00447         PrRewrite,
<a name="l00448"></a>00448         PrRewriteStar,
<a name="l00449"></a>00449         PrPullQuant,
<a name="l00450"></a>00450         PrPullQuantStar,
<a name="l00451"></a>00451         PrPushQuant,
<a name="l00452"></a>00452         PrElimUnusedVars,
<a name="l00453"></a>00453         PrDer,
<a name="l00454"></a>00454         PrQuantInst,
<a name="l00455"></a>00455         PrHypothesis,
<a name="l00456"></a>00456         PrLemma,
<a name="l00457"></a>00457         PrUnitResolution,
<a name="l00458"></a>00458         PrIffTrue,
<a name="l00459"></a>00459         PrIffFalse,
<a name="l00460"></a>00460         PrCommutativity,
<a name="l00461"></a>00461         PrDefAxiom,
<a name="l00462"></a>00462         PrDefIntro,
<a name="l00463"></a>00463         PrApplyDef,
<a name="l00464"></a>00464         PrIffOeq,            
<a name="l00465"></a>00465         PrNnfPos,
<a name="l00466"></a>00466         PrNnfNeg,
<a name="l00467"></a>00467         PrNnfStar,
<a name="l00468"></a>00468         PrSkolemize,
<a name="l00469"></a>00469         PrCnfStar,
<a name="l00470"></a>00470         PrModusPonensOeq,
<a name="l00471"></a>00471         PrThLemma,
<a name="l00472"></a>00472 
<a name="l00473"></a>00473         RaStore,
<a name="l00474"></a>00474         RaEmpty,
<a name="l00475"></a>00475         RaIsEmpty,
<a name="l00476"></a>00476         RaJoin,
<a name="l00477"></a>00477         RaUnion,
<a name="l00478"></a>00478         RaWiden,
<a name="l00479"></a>00479         RaProject,
<a name="l00480"></a>00480         RaFilter,
<a name="l00481"></a>00481         RaNegationFilter,
<a name="l00482"></a>00482         RaRename,
<a name="l00483"></a>00483         RaComplement,
<a name="l00484"></a>00484         RaSelect,
<a name="l00485"></a>00485         RaClone,
<a name="l00486"></a>00486 
<a name="l00487"></a>00487         Label,
<a name="l00488"></a>00488         LabelLit,
<a name="l00489"></a>00489         Uninterpreted            
<a name="l00490"></a>00490     };
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 
<a name="l00500"></a><a class="code" href="interface_microsoft_1_1_z3_v3_1_1_i_error_handler.html">00500</a>     <span class="keyword">public interface class</span> <a class="code" href="interface_microsoft_1_1_z3_v3_1_1_i_error_handler.html" title="IErrorHandler is an abstract (interface) class for passing an error handler.">IErrorHandler</a> 
<a name="l00501"></a>00501     {
<a name="l00502"></a>00502     <span class="keyword">public</span>:
<a name="l00503"></a>00503         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Handler(<a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> code) = 0;
<a name="l00504"></a>00504     };
<a name="l00505"></a>00505 
<a name="l00507"></a>00507     <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> ToLBool(<a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> b) {
<a name="l00508"></a>00508         <span class="keywordflow">switch</span>(b) {
<a name="l00509"></a>00509         <span class="keywordflow">case</span> Z3_L_FALSE: <span class="keywordflow">return</span> LBool::False; 
<a name="l00510"></a>00510         <span class="keywordflow">case</span> Z3_L_TRUE:  <span class="keywordflow">return</span> LBool::True; 
<a name="l00511"></a>00511         <span class="keywordflow">default</span>:         <span class="keywordflow">return</span> LBool::Undef; 
<a name="l00512"></a>00512         }
<a name="l00513"></a>00513     }
<a name="l00515"></a>00515 
<a name="l00523"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_labeled_literals.html">00523</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_labeled_literals.html" title="Container for labeled literals.">LabeledLiterals</a> {
<a name="l00524"></a>00524         ref_context&amp; m_context;
<a name="l00525"></a>00525         Z3_literals  m_labels;
<a name="l00526"></a>00526     <span class="keyword">internal</span>:
<a name="l00527"></a>00527         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_labeled_literals.html" title="Container for labeled literals.">LabeledLiterals</a>(ref_context&amp; ctx, Z3_literals lbls): m_context(ctx), m_labels(lbls) { ctx.inc_ref(); }
<a name="l00528"></a>00528         Z3_literals Get() { <span class="keywordflow">return</span> m_labels; }
<a name="l00529"></a>00529         TermPtr GetLiteral(<span class="keywordtype">unsigned</span> idx) { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga515a79517c3c80da345027846eea2a81" title="Retrieve literal expression at idx.">Z3_get_literal</a>(m_context(), m_labels, idx)); }
<a name="l00530"></a>00530     <span class="keyword">protected</span>:
<a name="l00531"></a>00531         !<a class="code" href="class_microsoft_1_1_z3_v3_1_1_labeled_literals.html" title="Container for labeled literals.">LabeledLiterals</a>(); 
<a name="l00532"></a>00532     <span class="keyword">public</span>:
<a name="l00533"></a>00533         ~<a class="code" href="class_microsoft_1_1_z3_v3_1_1_labeled_literals.html" title="Container for labeled literals.">LabeledLiterals</a>() { <span class="keywordflow">if</span> (m_labels) { <a class="code" href="group__capi.html#ga3224882c7224ee76787c8e48ecc0a7ae" title="Delete a labels context.">Z3_del_literals</a>(m_context(), m_labels); } m_labels = 0; m_context.dec_ref(); }
<a name="l00534"></a>00534         <span class="keywordtype">unsigned</span> GetNumLabels() { <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gaae868f4ef6939b95d9c0ba2eb3d1e913" title="Retrieve the number of label symbols that were returned.">Z3_get_num_literals</a>(m_context(), m_labels); }
<a name="l00535"></a>00535         <span class="keywordtype">void</span> Disable(<span class="keywordtype">unsigned</span> idx) { <a class="code" href="group__capi.html#ga9e7d5cb3fe2b88c5938668c93fa6a4ff" title="Disable label.">Z3_disable_literal</a>(m_context(), m_labels, idx); }
<a name="l00536"></a>00536         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ GetLabel(<span class="keywordtype">unsigned</span> idx) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>(m_context(), <a class="code" href="group__capi.html#gaf0ecf0a7282aba9556e7c34bbe332568" title="Retrieve label symbol at idx.">Z3_get_label_symbol</a>(m_context(), m_labels, idx)); }
<a name="l00537"></a>00537     };
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 
<a name="l00545"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_constructor.html">00545</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a> {
<a name="l00546"></a>00546         ref_context&amp;          m_context;
<a name="l00547"></a>00547         Z3_constructor      m_constructor;
<a name="l00548"></a>00548         FuncDeclPtr         m_constructor_decl;
<a name="l00549"></a>00549         FuncDeclPtr         m_tester;
<a name="l00550"></a>00550         array&lt;FuncDeclPtr&gt;^ m_accessors;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552         !<a class="code" href="class_microsoft_1_1_z3_v3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>();
<a name="l00553"></a>00553 
<a name="l00554"></a>00554     <span class="keyword">internal</span>:
<a name="l00555"></a>00555         String^          m_name;
<a name="l00556"></a>00556         String^          m_tester_name;
<a name="l00557"></a>00557         array&lt;String^&gt;^  m_field_names;
<a name="l00558"></a>00558         array&lt;SortPtr&gt;^  m_field_sorts;
<a name="l00559"></a>00559         array&lt;unsigned&gt;^ m_field_refs;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>(
<a name="l00562"></a>00562             ref_context&amp;     context,
<a name="l00563"></a>00563             String^          name,
<a name="l00564"></a>00564             String^          tester,
<a name="l00565"></a>00565             array&lt;String^&gt;^  field_names,
<a name="l00566"></a>00566             array&lt;SortPtr&gt;^  field_sorts,
<a name="l00567"></a>00567             array&lt;unsigned&gt;^ field_refs
<a name="l00568"></a>00568             );
<a name="l00569"></a>00569 
<a name="l00570"></a>00570         Z3_constructor Query();
<a name="l00571"></a>00571         Z3_constructor Get();
<a name="l00572"></a>00572         FuncDeclPtr GetConstructor();
<a name="l00573"></a>00573         FuncDeclPtr GetTester();
<a name="l00574"></a>00574         array&lt;FuncDeclPtr&gt;^ GetAccessors();
<a name="l00575"></a>00575     <span class="keyword">public</span>:    
<a name="l00576"></a>00576         ~<a class="code" href="class_microsoft_1_1_z3_v3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>();   
<a name="l00577"></a>00577     };
<a name="l00578"></a>00578 
<a name="l00579"></a>00579     
<a name="l00580"></a>00580 
<a name="l00592"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_config.html">00592</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_config.html" title="Configuration.">Config</a>
<a name="l00593"></a>00593     {
<a name="l00595"></a>00595         Z3_config m_config;
<a name="l00597"></a>00597     <span class="keyword">internal</span>:
<a name="l00599"></a>00599         Z3_config <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_config; }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602     <span class="keyword">protected</span>:
<a name="l00603"></a>00603         !<a class="code" href="class_microsoft_1_1_z3_v3_1_1_config.html#a539a941e29cde8d13e413c515d9801cd" title="Create configuration context.">Config</a>();
<a name="l00604"></a>00604 
<a name="l00605"></a>00605     <span class="keyword">public</span>:
<a name="l00613"></a>00613         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_config.html#a539a941e29cde8d13e413c515d9801cd" title="Create configuration context.">Config</a>();
<a name="l00614"></a>00614 
<a name="l00616"></a>00616         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_config.html#a54dfba499c9d9e1003d4c9bcbe6ad1c5" title="Configuration destructor.">~Config</a>();
<a name="l00617"></a>00617         
<a name="l00627"></a>00627         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_config.html#a58c38c04f7b5d1553ff23d28b29dbcd9" title="Set parameter to specified value.">SetParamValue</a>(String^ name, String^ value);
<a name="l00628"></a>00628     };
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 
<a name="l00634"></a><a class="code" href="interface_microsoft_1_1_z3_v3_1_1_i_raw_parameter.html">00634</a>     <span class="keyword">public interface class</span> <a class="code" href="interface_microsoft_1_1_z3_v3_1_1_i_raw_parameter.html" title="Z3 Parameter values.">IRawParameter</a> {  };
<a name="l00635"></a>00635     <span class="keyword">public interface class</span> IParameter {  };
<a name="l00636"></a>00636 
<a name="l00637"></a>00637     <span class="keyword">public ref class</span> IntParameter : <span class="keyword">public</span> IRawParameter, <span class="keyword">public</span> IParameter { 
<a name="l00638"></a>00638         <span class="keywordtype">int</span> m_value;
<a name="l00639"></a>00639     <span class="keyword">internal</span>:
<a name="l00640"></a>00640         IntParameter(<span class="keywordtype">int</span> i) : m_value(i) {}
<a name="l00641"></a>00641     <span class="keyword">public</span>:
<a name="l00642"></a>00642         <span class="keyword">property</span> <span class="keywordtype">int</span> Int { <span class="keywordtype">int</span> <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00643"></a>00643         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value.ToString(); }
<a name="l00644"></a>00644     };
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     <span class="keyword">public ref class</span> DoubleParameter : <span class="keyword">public</span> IRawParameter, <span class="keyword">public</span> IParameter  { 
<a name="l00647"></a>00647         <span class="keywordtype">double</span> m_value;
<a name="l00648"></a>00648     <span class="keyword">internal</span>:
<a name="l00649"></a>00649         DoubleParameter(<span class="keywordtype">double</span> i) : m_value(i) {}
<a name="l00650"></a>00650     <span class="keyword">public</span>:
<a name="l00651"></a>00651         <span class="keyword">property</span> <span class="keywordtype">double</span> Double { <span class="keywordtype">double</span> <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00652"></a>00652         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value.ToString(); }
<a name="l00653"></a>00653     };
<a name="l00654"></a>00654 
<a name="l00655"></a>00655     <span class="keyword">public ref class</span> RationalParameter : <span class="keyword">public</span> IRawParameter, <span class="keyword">public</span> IParameter  { 
<a name="l00656"></a>00656         String^ m_value;
<a name="l00657"></a>00657     <span class="keyword">internal</span>:
<a name="l00658"></a>00658         RationalParameter(String^ s): m_value(s) {}
<a name="l00659"></a>00659     <span class="keyword">public</span>:
<a name="l00660"></a>00660         <span class="keyword">property</span>  String^ GetRational {  String^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00661"></a>00661         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value; }
<a name="l00662"></a>00662     };
<a name="l00663"></a>00663 
<a name="l00664"></a>00664     <span class="keyword">public ref class</span> SymbolParameter : <span class="keyword">public</span> IRawParameter, <span class="keyword">public</span> IParameter  { 
<a name="l00665"></a>00665         Symbol^ m_value;
<a name="l00666"></a>00666     <span class="keyword">internal</span>:
<a name="l00667"></a>00667         SymbolParameter(Symbol^ s): m_value(s) {}
<a name="l00668"></a>00668     <span class="keyword">public</span>:
<a name="l00669"></a>00669         <span class="keyword">property</span>  Symbol^ GetSymbol {  Symbol^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00670"></a>00670     };
<a name="l00671"></a>00671 
<a name="l00672"></a>00672     <span class="keyword">public ref class</span> TermPtrParameter : <span class="keyword">public</span> IRawParameter  { 
<a name="l00673"></a>00673         TermPtr m_value;
<a name="l00674"></a>00674     <span class="keyword">internal</span>:
<a name="l00675"></a>00675         TermPtrParameter(TermPtr t) : m_value(t) {}
<a name="l00676"></a>00676     <span class="keyword">public</span>:
<a name="l00677"></a>00677         <span class="keyword">property</span> TermPtr GetTerm {  TermPtr <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00678"></a>00678     };
<a name="l00679"></a>00679 
<a name="l00680"></a>00680     <span class="keyword">public ref class</span> SortPtrParameter : <span class="keyword">public</span> IRawParameter  { 
<a name="l00681"></a>00681         SortPtr m_value;
<a name="l00682"></a>00682     <span class="keyword">internal</span>:
<a name="l00683"></a>00683         SortPtrParameter(SortPtr t) : m_value(t) {}
<a name="l00684"></a>00684     <span class="keyword">public</span>:
<a name="l00685"></a>00685         <span class="keyword">property</span>  SortPtr GetSort {  SortPtr <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00686"></a>00686     };
<a name="l00687"></a>00687 
<a name="l00688"></a>00688     <span class="keyword">public ref class</span> FuncDeclPtrParameter : <span class="keyword">public</span> IRawParameter  { 
<a name="l00689"></a>00689         FuncDeclPtr m_value;
<a name="l00690"></a>00690     <span class="keyword">internal</span>:
<a name="l00691"></a>00691         FuncDeclPtrParameter(FuncDeclPtr t) : m_value(t) {}
<a name="l00692"></a>00692     <span class="keyword">public</span>:
<a name="l00693"></a>00693         <span class="keyword">property</span>  FuncDeclPtr GetFuncDecl {  FuncDeclPtr <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00694"></a>00694     };
<a name="l00695"></a>00695 
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 
<a name="l00698"></a>00698 
<a name="l00702"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_array_value.html">00702</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_array_value.html" title="Z3 Array Value object.">RawArrayValue</a> {
<a name="l00703"></a>00703     <span class="keyword">public</span>:
<a name="l00704"></a>00704         array&lt;TermPtr&gt;^   Domain; 
<a name="l00705"></a>00705         array&lt;TermPtr&gt;^   Range;
<a name="l00706"></a>00706         TermPtr           ElseCase;
<a name="l00707"></a>00707     };
<a name="l00708"></a>00708 
<a name="l00715"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_function_entry.html">00715</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_function_entry.html" title="Z3 Function entry object.">RawFunctionEntry</a> {
<a name="l00716"></a>00716     <span class="keyword">public</span>:
<a name="l00717"></a>00717         array&lt;TermPtr&gt;^ Arguments;
<a name="l00718"></a>00718         TermPtr         Result;
<a name="l00719"></a>00719     };
<a name="l00720"></a>00720 
<a name="l00735"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_function_graph.html">00735</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_function_graph.html" title="Z3 Function graph object.">RawFunctionGraph</a> {
<a name="l00736"></a>00736     <span class="keyword">public</span>:
<a name="l00737"></a>00737         FuncDeclPtr               Declaration;
<a name="l00738"></a>00738         array&lt;RawFunctionEntry^&gt;^ Entries;
<a name="l00739"></a>00739         TermPtr                   Else;
<a name="l00740"></a>00740     };
<a name="l00741"></a>00741 
<a name="l00742"></a>00742     <span class="keyword">public ref class</span> RawQuantifier {
<a name="l00743"></a>00743     <span class="keyword">public</span>:
<a name="l00744"></a>00744         <span class="keywordtype">bool</span>               IsForall;
<a name="l00745"></a>00745         <span class="keywordtype">unsigned</span>           Weight;
<a name="l00746"></a>00746         array&lt;PatternPtr&gt;^ Patterns;
<a name="l00747"></a>00747         array&lt;TermPtr&gt;^    NoPatterns;
<a name="l00748"></a>00748         array&lt;SortPtr&gt;^    Sorts;
<a name="l00749"></a>00749         array&lt;Symbol^&gt;^    Names;
<a name="l00750"></a>00750         TermPtr            Body;
<a name="l00751"></a>00751     };
<a name="l00752"></a>00752 
<a name="l00753"></a>00753     <span class="keyword">ref class</span> RawModel;
<a name="l00754"></a>00754 
<a name="l00755"></a>00755     <span class="keyword">public</span> delegate <span class="keywordtype">void</span> Action0();
<a name="l00756"></a>00756 
<a name="l00757"></a>00757     <span class="keyword">generic</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S&gt;
<a name="l00758"></a>00758         <span class="keyword">public</span> delegate <span class="keywordtype">void</span> Action2(
<a name="l00759"></a>00759             T obj1, 
<a name="l00760"></a>00760             S obj2
<a name="l00761"></a>00761             );
<a name="l00762"></a>00762     <span class="keyword">generic</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S, <span class="keyword">typename</span> U&gt;
<a name="l00763"></a>00763         <span class="keyword">public</span> delegate <span class="keywordtype">void</span> Action3(
<a name="l00764"></a>00764             T obj1, 
<a name="l00765"></a>00765             S obj2,
<a name="l00766"></a>00766             U obj3
<a name="l00767"></a>00767             );
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 
<a name="l00770"></a>00770     <span class="keyword">generic</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00771"></a>00771         <span class="keyword">public</span> delegate T Func0();
<a name="l00772"></a>00772     
<a name="l00773"></a>00773     <span class="keyword">generic</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S&gt;
<a name="l00774"></a>00774         <span class="keyword">public</span> delegate S Func1(
<a name="l00775"></a>00775             T obj
<a name="l00776"></a>00776             );
<a name="l00777"></a>00777     
<a name="l00778"></a>00778     <span class="keyword">generic</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S, <span class="keyword">typename</span> U&gt;
<a name="l00779"></a>00779         <span class="keyword">public</span> delegate U Func2(
<a name="l00780"></a>00780             T obj1,
<a name="l00781"></a>00781             S obj2
<a name="l00782"></a>00782             );
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 
<a name="l00788"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html">00788</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html" title="Z3 RawModel object.">RawModel</a> {
<a name="l00789"></a>00789         ref_context&amp; m_context;
<a name="l00790"></a>00790         Z3_model     m_model;
<a name="l00791"></a>00791         Dictionary&lt;FuncDeclPtr, RawFunctionGraph^&gt;^ m_graphs;
<a name="l00792"></a>00792     <span class="keyword">internal</span>:           
<a name="l00793"></a>00793         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html" title="Z3 RawModel object.">RawModel</a>(ref_context&amp; c, Z3_model m) : m_context(c), m_model(m), m_graphs(<span class="keyword">nullptr</span>) { c.inc_ref(); }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795         <span class="keywordtype">void</span> Reset();
<a name="l00796"></a>00796     <span class="keyword">protected</span>:
<a name="l00797"></a>00797         !<a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html" title="Z3 RawModel object.">RawModel</a>();
<a name="l00798"></a>00798     <span class="keyword">public</span>:
<a name="l00799"></a>00799         ~<a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html" title="Z3 RawModel object.">RawModel</a>();
<a name="l00800"></a>00800 
<a name="l00801"></a>00801 
<a name="l00805"></a>00805         array&lt;FuncDeclPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html#af0fb784251b4fffac765eae0407d357e" title="Return the constants assigned by the given model.">GetModelConstants</a>();
<a name="l00806"></a>00806            
<a name="l00813"></a>00813         Dictionary&lt;FuncDeclPtr, RawFunctionGraph^&gt;^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html#a396820d1169832b11b9fa7a7b33fea0c" title="Return the function interpretations in the given model.">GetFunctionGraphs</a>();
<a name="l00814"></a>00814 
<a name="l00837"></a>00837         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html#ab660c31d8c3b6fc624f86dbd6d171d10" title="Evaluate the AST node t in the given model.">Eval</a>(TermPtr);
<a name="l00838"></a>00838 
<a name="l00839"></a>00839         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html#ab660c31d8c3b6fc624f86dbd6d171d10" title="Evaluate the AST node t in the given model.">Eval</a>(FuncDeclPtr, array&lt;TermPtr&gt;^ args);
<a name="l00840"></a>00840 
<a name="l00841"></a>00841         
<a name="l00845"></a>00845         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html#a82cd22745e05b27b028a26c21423664e" title="Return decomposed sequence of stores as an array value.">TryGetArrayValue</a>(TermPtr a,[Out] <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_array_value.html" title="Z3 Array Value object.">RawArrayValue</a>^% av);
<a name="l00846"></a>00846 
<a name="l00850"></a>00850         <span class="keyword">virtual</span> String^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html#a08d99b52685eab1e9d5ac4d9223cb2be" title="Convert the given model into a string.">ToString</a>() <span class="keyword">override</span>;
<a name="l00851"></a>00851 
<a name="l00855"></a>00855         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_model.html#aaf8bef9b1d9ed1692886459d39821267" title="Display model to TextWriter.">Display</a>(System::IO::TextWriter^ w);
<a name="l00856"></a>00856     };
<a name="l00857"></a>00857 
<a name="l00858"></a>00858     <span class="keyword">public ref class</span> ReferenceCounted {};
<a name="l00859"></a>00859 
<a name="l00860"></a>00860     <span class="keyword">public ref class</span> TermProofPtr {
<a name="l00861"></a>00861         TermPtr m_term;
<a name="l00862"></a>00862         TermPtr m_proof; <span class="comment">// proof is optional, use IntPtr::Zero for absence of proofs.</span>
<a name="l00863"></a>00863     <span class="keyword">public</span>:
<a name="l00864"></a>00864         TermProofPtr(TermPtr term, TermPtr proof): m_term(term), m_proof(proof) {}
<a name="l00865"></a>00865         <span class="keyword">property</span> TermPtr GetTerm { TermPtr <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_term; } }
<a name="l00866"></a>00866         <span class="keyword">property</span> TermPtr Proof { TermPtr <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_proof; } }
<a name="l00867"></a>00867     };
<a name="l00868"></a>00868 
<a name="l00869"></a>00869     <span class="keyword">ref class</span> RawTheory;
<a name="l00873"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html">00873</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a> : <span class="keyword">public</span> MarshalByRefObject
<a name="l00874"></a>00874     {        
<a name="l00875"></a>00875         ref_context* m_context;        
<a name="l00876"></a>00876         <span class="keywordtype">bool</span>         m_disposed;
<a name="l00877"></a>00877         <span class="keyword">static</span> List&lt;KeyValuePair&lt;AstPtr,RawContext^&gt; &gt;^  s_todec;
<a name="l00878"></a>00878         <span class="keyword">static</span> IntPtr^ s_monitor;
<a name="l00879"></a>00879         <span class="keyword">static</span> <span class="keywordtype">bool</span>    s_nonempty;
<a name="l00880"></a>00880 
<a name="l00881"></a>00881         <span class="keywordtype">void</span> Init();
<a name="l00882"></a>00882     <span class="keyword">internal</span>:
<a name="l00883"></a>00883         <span class="keyword">static</span> <a class="code" href="interface_microsoft_1_1_z3_v3_1_1_i_error_handler.html" title="IErrorHandler is an abstract (interface) class for passing an error handler.">IErrorHandler</a>^ m_error_handler = <span class="keyword">nullptr</span>;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885         Z3_context ctx() { <span class="keywordflow">return</span> (*m_context)(); }
<a name="l00886"></a>00886         Z3_fixedpoint dl() { <span class="keywordflow">return</span> m_context-&gt;dl(); }
<a name="l00887"></a>00887         ref_context&amp; ref_context() { <span class="keywordflow">return</span> *m_context; }
<a name="l00888"></a>00888 
<a name="l00896"></a>00896         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ab8387be0b117e56351f808dbb8b0e808" title="Increment and decrement reference counters on terms, sorts and declarations.">IncRef</a>(AstPtr ast);
<a name="l00897"></a>00897 
<a name="l00898"></a>00898         <span class="keywordtype">void</span> EnqueueDecRef(AstPtr ast);
<a name="l00899"></a>00899 
<a name="l00900"></a>00900     <span class="keyword">protected</span>:
<a name="l00901"></a>00901 
<a name="l00902"></a>00902         !<a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>();
<a name="l00903"></a>00903     <span class="keyword">public</span>: 
<a name="l00915"></a>00915         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_config.html" title="Configuration.">Config</a>^ config); 
<a name="l00916"></a>00916 
<a name="l00935"></a>00935         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_config.html" title="Configuration.">Config</a>^ config, ReferenceCounted^ rc);
<a name="l00936"></a>00936 
<a name="l00937"></a>00937         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>();
<a name="l00938"></a>00938 
<a name="l00939"></a>00939         <span class="keywordtype">void</span> SetContext(Z3_context ctx);
<a name="l00940"></a>00940 
<a name="l00941"></a>00941         <span class="keywordtype">void</span> Reset();
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         ~<a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>();
<a name="l00944"></a>00944 
<a name="l00949"></a>00949         
<a name="l00955"></a>00955         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ae767eef7c521b644401e58a4adfb11a6" title="Enable low-level debug tracing.">EnableDebugTrace</a>(String^ tag);
<a name="l00956"></a>00956 
<a name="l00963"></a>00963         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a74d274e8e6fc3ccc4ac39a375c0cc536" title="Enable or disable warning messages sent to the console out/error.">ToggleWarningMessages</a>(<span class="keywordtype">bool</span> enabled);
<a name="l00964"></a>00964 
<a name="l00979"></a>00979         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a9e7467b18eba9cc3dc04495a7c51d1fa" title="Update a mutable configuration parameter.">UpdateParamValue</a>(String^ param_id, String^ value);
<a name="l00980"></a>00980 
<a name="l00987"></a>00987         String^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a23eedc7261b7af0d10d69bbb392d203d" title="Get a configuration parameter.">GetParamValue</a>(String^ param_id);
<a name="l00988"></a>00988 
<a name="l00993"></a>00993         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a925fd320cf1476d3b08d70f169c6790d" title="Configure the SMTLIB logic to be used in the given logical context.">SetLogic</a>(String^ logic);
<a name="l00994"></a>00994 
<a name="l01008"></a>01008         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4e1f9e0325bac5897d7d4099eca72ed0" title="Create a Z3 symbol using an intege or a string.">MkSymbol</a>(<span class="keywordtype">int</span> i);
<a name="l01009"></a>01009 
<a name="l01010"></a>01010         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4e1f9e0325bac5897d7d4099eca72ed0" title="Create a Z3 symbol using an intege or a string.">MkSymbol</a>(String^ s);
<a name="l01017"></a>01017         
<a name="l01023"></a>01023         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a5111a4b70cadfbdb76491c889b57a312" title="Create a free (uninterpreted) type using the given name (symbol).">MkSort</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s);
<a name="l01024"></a>01024 
<a name="l01025"></a>01025         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a5111a4b70cadfbdb76491c889b57a312" title="Create a free (uninterpreted) type using the given name (symbol).">MkSort</a>(String^ s); 
<a name="l01026"></a>01026 
<a name="l01027"></a>01027         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a5111a4b70cadfbdb76491c889b57a312" title="Create a free (uninterpreted) type using the given name (symbol).">MkSort</a>(<span class="keywordtype">int</span> i);
<a name="l01028"></a>01028 
<a name="l01029"></a>01029 
<a name="l01035"></a>01035         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a5a24352b12189b45134064790859850a" title="Create the boolean type.">MkBoolSort</a>();
<a name="l01036"></a>01036 
<a name="l01046"></a>01046         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>();
<a name="l01047"></a>01047 
<a name="l01054"></a>01054         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>();
<a name="l01055"></a>01055 
<a name="l01056"></a>01056 
<a name="l01064"></a>01064         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#adf17186c4a5ece22ff7d95d1b6722e7d" title="Create a bit-vector type of the given size.">MkBvSort</a>(<span class="keywordtype">unsigned</span> sz);
<a name="l01065"></a>01065 
<a name="l01078"></a>01078         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a>(SortPtr domain, SortPtr range);
<a name="l01079"></a>01079 
<a name="l01087"></a>01087         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a73705995afcb9e00c07338fbfc9b4b49" title="Create a named finite domain sort.">MkFiniteDomainSort</a>(String^ name, <span class="keywordtype">unsigned</span> __int64 domain_size);
<a name="l01088"></a>01088 
<a name="l01089"></a>01089 
<a name="l01104"></a>01104         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#af75bb103fc493958385de9c849482df9" title="Create a tuple type.">MkTupleSort</a>(
<a name="l01105"></a>01105             <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^               mk_tuple_name, 
<a name="l01106"></a>01106             array&lt;Symbol^&gt;^       field_names,
<a name="l01107"></a>01107             array&lt;SortPtr&gt;^       field_types,
<a name="l01108"></a>01108             [Out] FuncDeclPtr%         mk_tuple_decl,
<a name="l01109"></a>01109             [In] [Out] array&lt;FuncDeclPtr&gt;^  proj_decl
<a name="l01110"></a>01110             );
<a name="l01111"></a>01111 
<a name="l01112"></a>01112         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#af75bb103fc493958385de9c849482df9" title="Create a tuple type.">MkTupleSort</a>(
<a name="l01113"></a>01113             String^               mk_tuple_name, 
<a name="l01114"></a>01114             array&lt;String^&gt;^       field_names,
<a name="l01115"></a>01115             array&lt;SortPtr&gt;^       field_types,
<a name="l01116"></a>01116             [Out] FuncDeclPtr%         mk_tuple_decl,
<a name="l01117"></a>01117             [In, Out] array&lt;FuncDeclPtr&gt;^  proj_decl
<a name="l01118"></a>01118             );
<a name="l01119"></a>01119 
<a name="l01129"></a>01129         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a72b2b9b3967c4638276bdccbdb0c9471" title="create an enumeration type.">MkEnumerationSort</a>(
<a name="l01130"></a>01130             String^             name,
<a name="l01131"></a>01131             array&lt;String^&gt;^     enum_names,
<a name="l01132"></a>01132             array&lt;FuncDeclPtr&gt;^ enum_consts,
<a name="l01133"></a>01133             array&lt;FuncDeclPtr&gt;^ enum_testers);
<a name="l01134"></a>01134 
<a name="l01148"></a>01148         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4d98cdbaeab75d52989ffbd655312dc6" title="create list sort.">MkListSort</a>(
<a name="l01149"></a>01149             String^ name,
<a name="l01150"></a>01150             SortPtr elem_sort,
<a name="l01151"></a>01151             [Out] FuncDeclPtr% nil_decl,
<a name="l01152"></a>01152             [Out] FuncDeclPtr% is_nil_decl,
<a name="l01153"></a>01153             [Out] FuncDeclPtr% cons_decl,
<a name="l01154"></a>01154             [Out] FuncDeclPtr% is_cons_decl,
<a name="l01155"></a>01155             [Out] FuncDeclPtr% head_decl,
<a name="l01156"></a>01156             [Out] FuncDeclPtr% tail_decl
<a name="l01157"></a>01157             );
<a name="l01158"></a>01158         
<a name="l01159"></a>01159 
<a name="l01176"></a>01176         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a30d1032d60ebd18e9d99d5c4191ab7b8" title="create constructor object for datatype declarations. The object must be disposed...">MkConstructor</a>(
<a name="l01177"></a>01177             String^ name,
<a name="l01178"></a>01178             String^ tester,
<a name="l01179"></a>01179             array&lt;String^&gt;^ field_names,
<a name="l01180"></a>01180             array&lt;SortPtr&gt;^ field_sorts,
<a name="l01181"></a>01181             array&lt;unsigned&gt;^ field_refs
<a name="l01182"></a>01182             );
<a name="l01183"></a>01183 
<a name="l01187"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad778d157f274c72a2e88b806b41df89c">01187</a>         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad778d157f274c72a2e88b806b41df89c" title="retrieve constructor function declaration.">GetConstructor</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>^ c) { <span class="keywordflow">return</span> c-&gt;GetConstructor(); }
<a name="l01188"></a>01188 
<a name="l01192"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a97a7320cd3d9a7d77f52bf789f5c8839">01192</a>         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a97a7320cd3d9a7d77f52bf789f5c8839" title="retrieve test function for constructor.">GetTester</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>^ c) { <span class="keywordflow">return</span> c-&gt;GetTester(); }
<a name="l01193"></a>01193 
<a name="l01197"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ab3ed56054afb442b0c26b073104c330e">01197</a>         array&lt;FuncDeclPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ab3ed56054afb442b0c26b073104c330e" title="retrieve accessors for datatype.">GetAccessors</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>^ c) { <span class="keywordflow">return</span> c-&gt;GetAccessors(); }
<a name="l01198"></a>01198 
<a name="l01202"></a>01202         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#adb386d1976b2c6587844fe995444c46f" title="create datatype sort.">MkDataType</a>(
<a name="l01203"></a>01203             String^ name,
<a name="l01204"></a>01204             array&lt;Constructor^&gt;^ constructors
<a name="l01205"></a>01205             );
<a name="l01206"></a>01206 
<a name="l01207"></a>01207         
<a name="l01214"></a>01214         array&lt;SortPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa44dbeb0d3495a206820ffa9ce249a0a" title="create datatype sorts.">MkDataTypes</a>(
<a name="l01215"></a>01215             array&lt;String^&gt;^ names,
<a name="l01216"></a>01216             array&lt;array&lt;Constructor^&gt;^&gt;^ constructors
<a name="l01217"></a>01217             );
<a name="l01218"></a>01218 
<a name="l01226"></a>01226 
<a name="l01241"></a>01241         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l01242"></a>01242 
<a name="l01243"></a>01243         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(String^ s, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l01244"></a>01244 
<a name="l01245"></a>01245         FuncDeclPtr MkConstDecl(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s, SortPtr ty) {
<a name="l01246"></a>01246             <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(s, <span class="keyword">gcnew</span> array&lt;SortPtr&gt;(0), ty);
<a name="l01247"></a>01247         }
<a name="l01248"></a>01248         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(Symbol^ s, SortPtr domain, SortPtr range);
<a name="l01249"></a>01249 
<a name="l01250"></a>01250         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(Symbol^ s, SortPtr d1, SortPtr d2, SortPtr range);
<a name="l01251"></a>01251 
<a name="l01252"></a>01252         FuncDeclPtr MkConstDecl(String^ s, SortPtr ty) {
<a name="l01253"></a>01253             <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(s, <span class="keyword">gcnew</span> array&lt;SortPtr&gt;(0), ty);
<a name="l01254"></a>01254         }
<a name="l01255"></a>01255         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(String^ s, SortPtr domain, SortPtr range);
<a name="l01256"></a>01256 
<a name="l01257"></a>01257         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(String^ s, SortPtr d1, SortPtr d2, SortPtr range);
<a name="l01258"></a>01258 
<a name="l01259"></a>01259     
<a name="l01265"></a>01265         AppPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a>(FuncDeclPtr d, array&lt;TermPtr&gt;^ args);
<a name="l01266"></a>01266         AppPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a>(FuncDeclPtr d, TermPtr arg);
<a name="l01267"></a>01267         AppPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a>(FuncDeclPtr d, TermPtr arg1, TermPtr arg2);
<a name="l01268"></a>01268         AppPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a>(FuncDeclPtr d, TermPtr arg1, TermPtr arg2, TermPtr arg3);
<a name="l01269"></a>01269 
<a name="l01276"></a>01276         AppPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4119e0d04b9b4b8e95969e261b06aab7" title="Declare and create a constant.">MkConst</a>(FuncDeclPtr d);
<a name="l01277"></a>01277         AppPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4119e0d04b9b4b8e95969e261b06aab7" title="Declare and create a constant.">MkConst</a>(String^ s, SortPtr ty);
<a name="l01278"></a>01278         AppPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4119e0d04b9b4b8e95969e261b06aab7" title="Declare and create a constant.">MkConst</a>(Symbol^ s, SortPtr ty);
<a name="l01279"></a>01279 
<a name="l01280"></a>01280 
<a name="l01288"></a>01288         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a5251d6fc152aea96eac0e9e702dad707" title="Declare a fresh constant or function.">MkFreshFuncDecl</a>(String^ prefix, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l01289"></a>01289     
<a name="l01296"></a>01296         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aabc8469e3803c5413a1a69c7cd001672" title="Declare and create a fresh constant.">MkFreshConst</a>(String^ prefix, SortPtr ty);
<a name="l01297"></a>01297 
<a name="l01302"></a>01302         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aebcce24f39e8ce68930346c48ac5a57f" title="Create labeled formula.">MkLabel</a>(Symbol^ name, <span class="keywordtype">bool</span> pos, TermPtr fml);
<a name="l01303"></a>01303     
<a name="l01307"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ab462a1d684499a2265ee02801dfcb4f4">01307</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ab462a1d684499a2265ee02801dfcb4f4" title="Create an AST node representing true.">MkTrue</a>() { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gae898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(ctx())); }
<a name="l01308"></a>01308 
<a name="l01309"></a>01309 
<a name="l01313"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4c138a08931900ebb7396484a6294cff">01313</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4c138a08931900ebb7396484a6294cff" title="Create an AST node representing false.">MkFalse</a>() { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(ctx())); }
<a name="l01314"></a>01314 
<a name="l01315"></a>01315     
<a name="l01321"></a>01321         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ab5b455baaffd7f2bf2a9508f801819de" title="Create an AST node representing l = r.">MkEq</a>(TermPtr l, TermPtr r);
<a name="l01322"></a>01322 
<a name="l01323"></a>01323 
<a name="l01334"></a>01334         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a89bdd6aba66dab2a90592cea3263eb74" title="Create an AST node representing distinct(args[0], ..., args[args.Length-1]).">MkDistinct</a>(array&lt;TermPtr&gt;^ args);
<a name="l01335"></a>01335 
<a name="l01336"></a>01336 
<a name="l01342"></a>01342         <span class="keyword">virtual</span> TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#afc672bf3d4167000f8511454ef05a83d" title="Create an AST node representing not(a).">MkNot</a>(TermPtr arg);
<a name="l01343"></a>01343     
<a name="l01351"></a>01351         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4c1882945cd1a8462070e5d92e7a6b93" title="Create an AST node representing an if-then-else: ite(t1, t2, t3).">MkIte</a>(TermPtr t1, TermPtr t2, TermPtr t3);
<a name="l01352"></a>01352 
<a name="l01358"></a>01358         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#af0019c9b938cbfc228d538500e25ab1f" title="Create an AST node representing t1 iff t2.">MkIff</a>(TermPtr t1, TermPtr t2);
<a name="l01359"></a>01359 
<a name="l01365"></a>01365         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#afcbf82213943aa0a30efb51dbf81b7dd" title="Create an AST node representing t1 implies t2.">MkImplies</a>(TermPtr t1, TermPtr t2);
<a name="l01366"></a>01366     
<a name="l01372"></a>01372         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a80631b59bd60e34b88cdc676274334b0" title="Create an AST node representing t1 xor t2.">MkXor</a>(TermPtr t1, TermPtr t2);
<a name="l01373"></a>01373     
<a name="l01381"></a>01381         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a8793a422c6c2d7b34000cc0032a4cdc4" title="Create an AST node representing args[0] and ... and args[args.Length-1].">MkAnd</a>(array&lt;TermPtr&gt;^ args);
<a name="l01382"></a>01382         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a8793a422c6c2d7b34000cc0032a4cdc4" title="Create an AST node representing args[0] and ... and args[args.Length-1].">MkAnd</a>(TermPtr arg1, TermPtr arg2);
<a name="l01383"></a>01383     
<a name="l01391"></a>01391         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a72a8f73bed309b8924dd49eba903bb24" title="Create an AST node representing args[0] or ... or args[args.Length-1].">MkOr</a>(array&lt;TermPtr&gt;^ args);
<a name="l01392"></a>01392         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a72a8f73bed309b8924dd49eba903bb24" title="Create an AST node representing args[0] or ... or args[args.Length-1].">MkOr</a>(TermPtr arg1, TermPtr arg2);
<a name="l01393"></a>01393 
<a name="l01401"></a>01401         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a5668c488c12e405f662807b4f47860da" title="Create an AST node representing args[0] + ... + args[args.Length-1].">MkAdd</a>(array&lt;TermPtr&gt;^ args);
<a name="l01402"></a>01402         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a5668c488c12e405f662807b4f47860da" title="Create an AST node representing args[0] + ... + args[args.Length-1].">MkAdd</a>(TermPtr arg1, TermPtr arg2);
<a name="l01403"></a>01403 
<a name="l01412"></a>01412         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa20eacf8d7fa0e446c1081e5ff01de77" title="Create an AST node representing args[0] * ... * args[args.Length-1].">MkMul</a>(array&lt;TermPtr&gt;^ args);
<a name="l01413"></a>01413         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa20eacf8d7fa0e446c1081e5ff01de77" title="Create an AST node representing args[0] * ... * args[args.Length-1].">MkMul</a>(TermPtr arg1, TermPtr arg2);
<a name="l01414"></a>01414     
<a name="l01422"></a>01422         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a01178a7c619ac2bd6c2e4d4f3da743d2" title="Create an AST node representing args[0] - ... - args[args.Length - 1].">MkSub</a>(array&lt;TermPtr&gt;^ args);
<a name="l01423"></a>01423         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a01178a7c619ac2bd6c2e4d4f3da743d2" title="Create an AST node representing args[0] - ... - args[args.Length - 1].">MkSub</a>(TermPtr arg1, TermPtr arg2);
<a name="l01424"></a>01424 
<a name="l01430"></a>01430         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4314bcfc4435b1f79028bc11b8774c28" title="Create an AST node representing - arg.">MkUnaryMinus</a>(TermPtr arg);
<a name="l01431"></a>01431 
<a name="l01437"></a>01437         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ae7f8e2e8eb754c5a87fa3faa51ff8baf" title="Create integer or real division.">MkDiv</a>(TermPtr arg1, TermPtr arg2);
<a name="l01438"></a>01438 
<a name="l01444"></a>01444         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a5a9f33467a473c739edac3721e0d56ea" title="Create integer modulus.">MkMod</a>(TermPtr arg1, TermPtr arg2);
<a name="l01445"></a>01445 
<a name="l01451"></a>01451         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a5e8abfb87c0e9eb2be93a85af185038e" title="Create integer remainder.">MkRem</a>(TermPtr arg1, TermPtr arg2);
<a name="l01452"></a>01452 
<a name="l01458"></a>01458         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aecac3390e05c8743587c5bed03338b84" title="Create coercion from integer to real.">MkToReal</a>(TermPtr arg);
<a name="l01459"></a>01459 
<a name="l01465"></a>01465         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a89955af727ba82dbb38b734befd37cdc" title="Create coercion from real to integer (floor).">MkToInt</a>(TermPtr arg);
<a name="l01466"></a>01466 
<a name="l01472"></a>01472         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a71f742709784da4b25d39a72d4cd3b69" title="Check if real is an integer value.">MkIsInt</a>(TermPtr arg);
<a name="l01473"></a>01473 
<a name="l01474"></a>01474 
<a name="l01475"></a>01475 
<a name="l01481"></a>01481         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa817a455803ab79b220b0182b48e2ae5" title="Create less than.">MkLt</a>(TermPtr arg1, TermPtr arg2);
<a name="l01482"></a>01482 
<a name="l01488"></a>01488         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa4993b3a46531ed7c4924d64185344d2" title="Create less than or equal to.">MkLe</a>(TermPtr arg1, TermPtr arg2);
<a name="l01489"></a>01489 
<a name="l01495"></a>01495         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a5935871bfbeda8fcd6bc467d8d49afc2" title="Create greater than.">MkGt</a>(TermPtr arg1, TermPtr arg2);
<a name="l01496"></a>01496 
<a name="l01502"></a>01502         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a7a08b71116843992a1078d9df3889f09" title="Create greater than or equal to.">MkGe</a>(TermPtr arg1, TermPtr arg2);
<a name="l01503"></a>01503 
<a name="l01509"></a>01509         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a45b8b6397e45ac3fc6b38e873eed9d33" title="Bitwise negation.">MkBvNot</a>(TermPtr t1);
<a name="l01510"></a>01510 
<a name="l01516"></a>01516         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4487dd1d501cb49fa5f4d046e28ae650" title="Take conjunction of bits in vector.">MkBvReduceAnd</a>(TermPtr t1);
<a name="l01517"></a>01517 
<a name="l01523"></a>01523         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ab00941985b6e6675b2304831aa4845c0" title="Take disjunction of bits in vector.">MkBvReduceOr</a>(TermPtr t1);
<a name="l01524"></a>01524 
<a name="l01530"></a>01530         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aadd6a00031fb92a88ca6c177d4d75509" title="Bitwise and.">MkBvAnd</a>(TermPtr t1, TermPtr t2);
<a name="l01531"></a>01531 
<a name="l01537"></a>01537         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a472170308fc0ce228ad1ee1b683811cd" title="Bitwise or.">MkBvOr</a>(TermPtr t1, TermPtr t2);
<a name="l01538"></a>01538 
<a name="l01544"></a>01544         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a684ce5c64067b6d5d4cddfbfe32789b4" title="Bitwise exclusive-or.">MkBvXor</a>(TermPtr t1, TermPtr t2);
<a name="l01545"></a>01545 
<a name="l01551"></a>01551         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a5d58dfc570dde7e49faab8ed4dcfbfc7" title="Bitwise nand.">MkBvNand</a>(TermPtr t1, TermPtr t2);
<a name="l01552"></a>01552 
<a name="l01558"></a>01558         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa486a9f49b3fc395f37b56f0975a243b" title="Bitwise nor.">MkBvNor</a>(TermPtr t1, TermPtr t2);
<a name="l01559"></a>01559 
<a name="l01565"></a>01565         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a0112b7f61d18dcd15369566cdcf4b05f" title="Bitwise xnor.">MkBvXnor</a>(TermPtr t1, TermPtr t2);
<a name="l01566"></a>01566 
<a name="l01572"></a>01572         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ae21724e2d70e5aec94cfa59726565063" title="Standard two&amp;#39;s complement unary minus.">MkBvNeg</a>(TermPtr t1);
<a name="l01573"></a>01573     
<a name="l01579"></a>01579         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a30237a1d6603428640b6db89d5d157fa" title="Standard two&amp;#39;s complement addition.">MkBvAdd</a>(TermPtr t1, TermPtr t2);
<a name="l01580"></a>01580 
<a name="l01586"></a>01586         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aea836bb8f5dcec3f401d77538e31e248" title="Standard two&amp;#39;s complement subtraction.">MkBvSub</a>(TermPtr t1, TermPtr t2);
<a name="l01587"></a>01587     
<a name="l01593"></a>01593         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ae5585802bf0ff4f5188bfbe1fd361470" title="Standard two&amp;#39;s complement multiplication.">MkBvMul</a>(TermPtr t1, TermPtr t2);
<a name="l01594"></a>01594 
<a name="l01604"></a>01604         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a98ee5b832fa8f1a44998a2541bf4114c" title="Unsigned division.">MkBvUdiv</a>(TermPtr t1, TermPtr t2);
<a name="l01605"></a>01605 
<a name="l01619"></a>01619         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ae96a3f936b75c53d7ab8eed094eb7b94" title="Two&amp;#39;s complement signed division.">MkBvSdiv</a>(TermPtr t1, TermPtr t2);
<a name="l01620"></a>01620 
<a name="l01630"></a>01630         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a30f13a71debd51968bc2129eaa26121d" title="Unsigned remainder.">MkBvUrem</a>(TermPtr t1, TermPtr t2);
<a name="l01631"></a>01631 
<a name="l01644"></a>01644         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a1db91c0489ac65927dc14613e0b2225b" title="Two&amp;#39;s complement signed remainder (sign follows dividend).">MkBvSrem</a>(TermPtr t1, TermPtr t2);
<a name="l01645"></a>01645 
<a name="l01655"></a>01655         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a094b16beaa982ef3500633b3482d2603" title="Two&amp;#39;s complement signed remainder (sign follows divisor).">MkBvSmod</a>(TermPtr t1, TermPtr t2);
<a name="l01656"></a>01656 
<a name="l01662"></a>01662         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a71e25df68e31503191875d9348c9f823" title="Unsigned less than.">MkBvUlt</a>(TermPtr t1, TermPtr t2);
<a name="l01663"></a>01663     
<a name="l01677"></a>01677         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a8352294e2808ce534fc83ec39bca8fbd" title="Two&amp;#39;s complement signed less than.">MkBvSlt</a>(TermPtr t1, TermPtr t2);
<a name="l01678"></a>01678 
<a name="l01684"></a>01684         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa434742064f523ecf5a7e13a113df86b" title="Unsigned less than or equal to.">MkBvUle</a>(TermPtr t1, TermPtr t2);
<a name="l01685"></a>01685 
<a name="l01691"></a>01691         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac37363c17a7308be4ca999068da16fbb" title="Two&amp;#39;s complement signed less than or equal to.">MkBvSle</a>(TermPtr t1, TermPtr t2);
<a name="l01692"></a>01692 
<a name="l01698"></a>01698         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#acb5149b9f7b1d823cd93ed6f43db5a17" title="Unsigned greater than or equal to.">MkBvUge</a>(TermPtr t1, TermPtr t2);
<a name="l01699"></a>01699 
<a name="l01705"></a>01705         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a27a2d12f9e8d5639fa86b4d0997e2b17" title="Two&amp;#39;s complement signed greater than or equal to.">MkBvSge</a>(TermPtr t1, TermPtr t2);
<a name="l01706"></a>01706 
<a name="l01712"></a>01712         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#afcb8b1208ec0cc2c1579c29158b3815e" title="Unsigned greater than.">MkBvUgt</a>(TermPtr t1, TermPtr t2);
<a name="l01713"></a>01713 
<a name="l01719"></a>01719         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a013910a4fa70b37878520b4400b1c107" title="Two&amp;#39;s complement signed greater than.">MkBvSgt</a>(TermPtr t1, TermPtr t2);
<a name="l01720"></a>01720 
<a name="l01729"></a>01729         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#afaba9154d1be03ec6d738951e94d37cb" title="Concatenate the given bit-vectors.">MkBvConcat</a>(TermPtr t1, TermPtr t2);
<a name="l01730"></a>01730     
<a name="l01738"></a>01738         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac2c8940627f740c9ec3b637ef2031887" title="Extract the bits high down to low from a bitvector of size m to yield a new bitvector...">MkBvExtract</a>(<span class="keywordtype">unsigned</span> high, <span class="keywordtype">unsigned</span> low, TermPtr t);
<a name="l01739"></a>01739 
<a name="l01747"></a>01747         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#af94e12dbe34a66f358baebe8ef6848fc" title="Sign-extend of the given bit-vector to the (signed) equivalent bitvector of size...">MkBvSignExt</a>(<span class="keywordtype">unsigned</span> i, TermPtr t);
<a name="l01748"></a>01748 
<a name="l01756"></a>01756         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#add245de4256b820ef7d66ce58fd43385" title="Extend the given bit-vector with zeros to the (unsigned) equivalent bitvector of...">MkBvZeroExt</a>(<span class="keywordtype">unsigned</span> i, TermPtr t);
<a name="l01757"></a>01757 
<a name="l01763"></a>01763         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#afa18939e43ef603b1bdfac2cdbefd4f0" title="Repeat the bit-vector i times.">MkBvRepeat</a>(<span class="keywordtype">unsigned</span> i, TermPtr t);
<a name="l01764"></a>01764 
<a name="l01773"></a>01773         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a484c128e627a79c8af7fcbb531b0ba39" title="Shift left.">MkBvShl</a>(TermPtr t1, TermPtr t2);
<a name="l01774"></a>01774 
<a name="l01783"></a>01783         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a2de5b050301845c2fa902a8a910db8ed" title="Logical shift right.">MkBvLshr</a>(TermPtr t1, TermPtr t2);
<a name="l01784"></a>01784 
<a name="l01794"></a>01794         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4e8836887c24503234e99a94dd31a660" title="Arithmetic shift right.">MkBvAshr</a>(TermPtr t1, TermPtr t2);
<a name="l01795"></a>01795     
<a name="l01801"></a>01801         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#adecfc831ae6c9135828e3095b27a4956" title="Rotate bits of t1 to the left i times.">MkBvRotateLeft</a>(<span class="keywordtype">unsigned</span> i, TermPtr t1);
<a name="l01802"></a>01802     
<a name="l01808"></a>01808         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3df09da772a462d74c9f08546a44562b" title="Rotate bits of t1 to the right i times.">MkBvRotateRight</a>(<span class="keywordtype">unsigned</span> i, TermPtr t1);
<a name="l01809"></a>01809 
<a name="l01815"></a>01815         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#adecfc831ae6c9135828e3095b27a4956" title="Rotate bits of t1 to the left i times.">MkBvRotateLeft</a>(TermPtr t1, TermPtr t2);
<a name="l01816"></a>01816     
<a name="l01822"></a>01822         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3df09da772a462d74c9f08546a44562b" title="Rotate bits of t1 to the right i times.">MkBvRotateRight</a>(TermPtr t1, TermPtr t2);
<a name="l01823"></a>01823 
<a name="l01829"></a>01829         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a711b2b4ca79395d1d56820b7b3f9b3cc" title="Convert bit vector to integer.">MkBv2Int</a>(TermPtr t1, <span class="keywordtype">bool</span> is_signed);
<a name="l01830"></a>01830 
<a name="l01836"></a>01836         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a43be2bceee8a6d4a870733196a149612" title="Convert integer to bit vector.">MkInt2Bv</a>(<span class="keywordtype">unsigned</span> size, TermPtr t1);
<a name="l01837"></a>01837 
<a name="l01843"></a>01843         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a202fffba746c16499d216354e97ac74b" title="Check that addition does not overflow.">MkBvAddNoOverflow</a>(TermPtr t1, TermPtr t2, <span class="keywordtype">bool</span> is_signed);
<a name="l01844"></a>01844 
<a name="l01850"></a>01850         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a421fc4943889a1c10d2dddbdaac5d09d" title="Check that addition does not underflow.">MkBvAddNoUnderflow</a>(TermPtr t1, TermPtr t2);
<a name="l01851"></a>01851 
<a name="l01857"></a>01857         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a44065d4fa565d6efa0f351f266c61c58" title="Check that subtraction does not overflow.">MkBvSubNoOverflow</a>(TermPtr t1, TermPtr t2);
<a name="l01858"></a>01858 
<a name="l01864"></a>01864         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3386aa55309ead169a54aeeed1cef0d6" title="Check that subtraction does not underflow.">MkBvSubNoUnderflow</a>(TermPtr t1, TermPtr t2, <span class="keywordtype">bool</span> is_signed);
<a name="l01865"></a>01865 
<a name="l01871"></a>01871         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac537f6c8529718162b4a16a926f145f8" title="Check that division does not overflow.">MkBvSDivNoOverflow</a>(TermPtr t1, TermPtr t2);
<a name="l01872"></a>01872 
<a name="l01876"></a>01876         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a7dcdbe9ddac5ccf9744174f4a20aac19" title="Check that negation does not overflow.">MkBvNegNoOverflow</a>(TermPtr t1);
<a name="l01877"></a>01877 
<a name="l01883"></a>01883         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a688f2a2cb04cb30f68dca62c6477f14b" title="Check that multiplication does not overflow.">MkBvMulNoOverflow</a>(TermPtr t1, TermPtr t2, <span class="keywordtype">bool</span> is_signed);
<a name="l01884"></a>01884 
<a name="l01890"></a>01890         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a036fccd286efdc90134941defd6a1df8" title="Check that multiplication does not underflow.">MkBvMulNoUnderflow</a>(TermPtr t1, TermPtr t2);
<a name="l01891"></a>01891 
<a name="l01901"></a>01901         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#af0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a>(TermPtr a, TermPtr i);
<a name="l01902"></a>01902     
<a name="l01912"></a>01912         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aaed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a>(TermPtr a, TermPtr i, TermPtr v);
<a name="l01913"></a>01913 
<a name="l01925"></a>01925         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3fcbf7757a9ffdb56c4bdd145c145246" title="Array map.">MkArrayMap</a>(FuncDeclPtr d, array&lt;TermPtr&gt;^ args);
<a name="l01926"></a>01926 
<a name="l01938"></a>01938         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ab5341894979c077ef1ad93ef67691c2a" title="Constant array.">MkArrayConst</a>(SortPtr domain, TermPtr v);
<a name="l01939"></a>01939 
<a name="l01954"></a>01954         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac645da9e615bc4e20515ef3cd8f74893" title="Access the array default.">MkArrayDefault</a>(TermPtr a);
<a name="l01955"></a>01955 
<a name="l01963"></a>01963 
<a name="l01967"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4fd038edb773b86952a3f4890d6bb0f5">01967</a>         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4fd038edb773b86952a3f4890d6bb0f5" title="Create Set type.">MkSetSort</a>(SortPtr ty) { <span class="keywordflow">return</span> SortPtr(<a class="code" href="group__capi.html#ga6865879523e7e882d7e50a2d8445ac8b" title="Create Set type.">Z3_mk_set_sort</a>(ctx(), get_sort(ty))); }
<a name="l01968"></a>01968 
<a name="l01972"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ae3a1a555a0fce2e8c1dfdfb863b56216">01972</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ae3a1a555a0fce2e8c1dfdfb863b56216" title="Create the empty set.">MkEmptySet</a>(SortPtr ty) { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga358b6b80509a567148f1c0ca9252118c" title="Create the empty set.">Z3_mk_empty_set</a>(ctx(), get_sort(ty))); }
<a name="l01973"></a>01973 
<a name="l01977"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a71d300776d9303680e79f784a2644e4c">01977</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a71d300776d9303680e79f784a2644e4c" title="Create the full set.">MkFullSet</a>(SortPtr ty) { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga5e92662c657374f7332aa32ce4503dd2" title="Create the full set.">Z3_mk_full_set</a>(ctx(), get_sort(ty))); }
<a name="l01978"></a>01978 
<a name="l01984"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a443543c80f0ace5c902df3589d3154c4">01984</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a443543c80f0ace5c902df3589d3154c4" title="Add an element to a set.">MkSetAdd</a>(TermPtr <span class="keyword">set</span>, TermPtr elem) {
<a name="l01985"></a>01985             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga856c3d0e28ce720f53912c2bbdd76175" title="Add an element to a set.">Z3_mk_set_add</a>(ctx(), get_ast(<span class="keyword">set</span>), get_ast(elem)));
<a name="l01986"></a>01986         }
<a name="l01987"></a>01987 
<a name="l01993"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a99a686c0e68a6862f47f066eac39f84e">01993</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a99a686c0e68a6862f47f066eac39f84e" title="Remove an element to a set.">MkSetDel</a>(TermPtr <span class="keyword">set</span>, TermPtr elem) {
<a name="l01994"></a>01994             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga80e883f39dd3b88f9d0745c8a5b91d1d" title="Remove an element to a set.">Z3_mk_set_del</a>(ctx(), get_ast(<span class="keyword">set</span>), get_ast(elem)));
<a name="l01995"></a>01995         }
<a name="l01996"></a>01996 
<a name="l02002"></a>02002         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a72da2154689afc36a91ba955e9ccf081" title="Take the union of a arrays of sets.">MkSetUnion</a>(array&lt;TermPtr&gt;^ sets);
<a name="l02003"></a>02003         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a72da2154689afc36a91ba955e9ccf081" title="Take the union of a arrays of sets.">MkSetUnion</a>(TermPtr set1, TermPtr set2);
<a name="l02004"></a>02004 
<a name="l02008"></a>02008         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a1bb3e567ae8090d8a659ad556c083e32" title="Take the intersection of a arrays of sets.">MkSetIntersect</a>(array&lt;TermPtr&gt;^ sets);
<a name="l02009"></a>02009         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a1bb3e567ae8090d8a659ad556c083e32" title="Take the intersection of a arrays of sets.">MkSetIntersect</a>(TermPtr set1, TermPtr set2);
<a name="l02010"></a>02010 
<a name="l02014"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad51d6429450362ce9dc9f476b86d22e1">02014</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad51d6429450362ce9dc9f476b86d22e1" title="Take the set difference between two sets.">MkSetDifference</a>(TermPtr arg1, TermPtr arg2) {
<a name="l02015"></a>02015             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gabb49c62f70b8198362e1a29ba6d8bde1" title="Take the set difference between two sets.">Z3_mk_set_difference</a>(ctx(), get_ast(arg1), get_ast(arg2)));
<a name="l02016"></a>02016         }
<a name="l02020"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ae33216f5018efff4077640204c219dc2">02020</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ae33216f5018efff4077640204c219dc2" title="Take the complement of a set.">MkSetComplement</a>(TermPtr arg) {
<a name="l02021"></a>02021             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga5c57143c9229cdf730c5103ff696590f" title="Take the complement of a set.">Z3_mk_set_complement</a>(ctx(), get_ast(arg)));
<a name="l02022"></a>02022         }
<a name="l02023"></a>02023 
<a name="l02029"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a8449281ead0996eccbe5867d3b6ca96c">02029</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a8449281ead0996eccbe5867d3b6ca96c" title="Check for set membership.">MkSetMember</a>(TermPtr elem, TermPtr <span class="keyword">set</span>) {
<a name="l02030"></a>02030             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gac6e516f3dce0bdd41095c6d6daf56063" title="Check for set membership.">Z3_mk_set_member</a>(ctx(), get_ast(elem), get_ast(<span class="keyword">set</span>)));
<a name="l02031"></a>02031         }
<a name="l02032"></a>02032 
<a name="l02036"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac05b3fbb60eecb46617782cd53e2b293">02036</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac05b3fbb60eecb46617782cd53e2b293" title="Check for subsetness of sets.">MkSetSubset</a>(TermPtr arg1, TermPtr arg2) {
<a name="l02037"></a>02037             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga139c5803af0e86464adc7cedc53e7f3a" title="Check for subsetness of sets.">Z3_mk_set_subset</a>(ctx(), get_ast(arg1), get_ast(arg2)));
<a name="l02038"></a>02038         }
<a name="l02046"></a>02046 
<a name="l02051"></a>02051         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a1c4f013234b21f0c4599f3c44fb778fb" title="Create injective function.">MkInjectiveFunction</a>(String^ name, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l02052"></a>02052 
<a name="l02053"></a>02053         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a1c4f013234b21f0c4599f3c44fb778fb" title="Create injective function.">MkInjectiveFunction</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ name, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l02054"></a>02054 
<a name="l02063"></a>02063         
<a name="l02072"></a>02072         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(String^ numeral, SortPtr ty);
<a name="l02073"></a>02073         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(<span class="keywordtype">int</span> n, SortPtr ty);
<a name="l02074"></a>02074         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(<span class="keywordtype">unsigned</span> n, SortPtr ty);
<a name="l02075"></a>02075         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(__int64 n, SortPtr ty);
<a name="l02076"></a>02076         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(<span class="keywordtype">unsigned</span> __int64 n, SortPtr ty);
<a name="l02077"></a>02077 
<a name="l02081"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3">02081</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3" title="Create a numeral of type Int.">MkIntNumeral</a>(String^ n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>()); }
<a name="l02082"></a>02082         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3" title="Create a numeral of type Int.">MkIntNumeral</a>(<span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>()); }
<a name="l02083"></a>02083         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3" title="Create a numeral of type Int.">MkIntNumeral</a>(<span class="keywordtype">unsigned</span> n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>()); }
<a name="l02084"></a>02084         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3" title="Create a numeral of type Int.">MkIntNumeral</a>(__int64 n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>()); }
<a name="l02085"></a>02085         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3" title="Create a numeral of type Int.">MkIntNumeral</a>(<span class="keywordtype">unsigned</span> __int64 n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>()); }
<a name="l02086"></a>02086 
<a name="l02087"></a>02087 
<a name="l02091"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40">02091</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40" title="Create a numeral of type Real.">MkRealNumeral</a>(String^ n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>()); }
<a name="l02092"></a>02092         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40" title="Create a numeral of type Real.">MkRealNumeral</a>(<span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>()); }
<a name="l02093"></a>02093         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40" title="Create a numeral of type Real.">MkRealNumeral</a>(<span class="keywordtype">unsigned</span> n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>()); }
<a name="l02094"></a>02094         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40" title="Create a numeral of type Real.">MkRealNumeral</a>(__int64 n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>()); }
<a name="l02095"></a>02095         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40" title="Create a numeral of type Real.">MkRealNumeral</a>(<span class="keywordtype">unsigned</span> __int64 n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>()); }
<a name="l02096"></a>02096 
<a name="l02103"></a>02103         
<a name="l02162"></a>02162         PatternPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a>(array&lt;TermPtr&gt;^ terms);
<a name="l02163"></a>02163 
<a name="l02190"></a>02190         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a2e1ef04d234928c64248ce7eaf73502a" title="Create a bound variable.">MkBound</a>(<span class="keywordtype">unsigned</span> index, SortPtr ty);
<a name="l02191"></a>02191     
<a name="l02206"></a>02206         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a>(
<a name="l02207"></a>02207             <span class="keywordtype">unsigned</span> weight,
<a name="l02208"></a>02208             array&lt;PatternPtr&gt;^ patterns,
<a name="l02209"></a>02209             array&lt;SortPtr&gt;^ types,
<a name="l02210"></a>02210             array&lt;Symbol^&gt;^ names,
<a name="l02211"></a>02211             TermPtr body
<a name="l02212"></a>02212             );
<a name="l02213"></a>02213 
<a name="l02228"></a>02228         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a>(
<a name="l02229"></a>02229             <span class="keywordtype">unsigned</span> weight,
<a name="l02230"></a>02230             array&lt;PatternPtr&gt;^ patterns,
<a name="l02231"></a>02231             array&lt;SortPtr&gt;^ types,
<a name="l02232"></a>02232             array&lt;String^&gt;^ names,
<a name="l02233"></a>02233             TermPtr body
<a name="l02234"></a>02234             );
<a name="l02235"></a>02235 
<a name="l02255"></a>02255         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a>(
<a name="l02256"></a>02256             <span class="keywordtype">unsigned</span>           weight,
<a name="l02257"></a>02257             array&lt;AppPtr&gt;^   bound,
<a name="l02258"></a>02258             array&lt;PatternPtr&gt;^ patterns,
<a name="l02259"></a>02259             TermPtr body
<a name="l02260"></a>02260             );
<a name="l02261"></a>02261 
<a name="l02269"></a>02269         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a>(
<a name="l02270"></a>02270             <span class="keywordtype">unsigned</span> weight,
<a name="l02271"></a>02271             array&lt;PatternPtr&gt;^ patterns,
<a name="l02272"></a>02272             array&lt;SortPtr&gt;^ types,
<a name="l02273"></a>02273             array&lt;Symbol^&gt;^ names,
<a name="l02274"></a>02274             TermPtr body
<a name="l02275"></a>02275             );
<a name="l02276"></a>02276 
<a name="l02277"></a>02277         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a>(
<a name="l02278"></a>02278             <span class="keywordtype">unsigned</span> weight,
<a name="l02279"></a>02279             array&lt;PatternPtr&gt;^ patterns,
<a name="l02280"></a>02280             array&lt;SortPtr&gt;^ types,
<a name="l02281"></a>02281             array&lt;String^&gt;^ names,
<a name="l02282"></a>02282             TermPtr body
<a name="l02283"></a>02283             );
<a name="l02284"></a>02284 
<a name="l02285"></a>02285         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a>(
<a name="l02286"></a>02286             <span class="keywordtype">unsigned</span>           weight,
<a name="l02287"></a>02287             array&lt;AppPtr&gt;^   bound,
<a name="l02288"></a>02288             array&lt;PatternPtr&gt;^ patterns,
<a name="l02289"></a>02289             TermPtr            body
<a name="l02290"></a>02290             );
<a name="l02291"></a>02291 
<a name="l02303"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c">02303</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c" title="Create a quantifier with no-pattern directives and symbols.">MkQuantifier</a>(
<a name="l02304"></a>02304             <span class="keywordtype">bool</span>                  is_forall,
<a name="l02305"></a>02305             <span class="keywordtype">unsigned</span>              weight,
<a name="l02306"></a>02306             array&lt;PatternPtr&gt;^    patterns,
<a name="l02307"></a>02307             array&lt;TermPtr&gt;^       no_patterns,
<a name="l02308"></a>02308             array&lt;SortPtr&gt;^       types,
<a name="l02309"></a>02309             array&lt;Symbol^&gt;^       names,
<a name="l02310"></a>02310             TermPtr               body
<a name="l02311"></a>02311             )
<a name="l02312"></a>02312         {
<a name="l02313"></a>02313             <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c" title="Create a quantifier with no-pattern directives and symbols.">MkQuantifier</a>(is_forall, weight, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, patterns, no_patterns, types, names, body);
<a name="l02314"></a>02314         }
<a name="l02315"></a>02315 
<a name="l02316"></a>02316 
<a name="l02317"></a>02317         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c" title="Create a quantifier with no-pattern directives and symbols.">MkQuantifier</a>(
<a name="l02318"></a>02318             <span class="keywordtype">bool</span>                  is_forall,
<a name="l02319"></a>02319             <span class="keywordtype">unsigned</span>              weight,
<a name="l02320"></a>02320             <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^               quantifier_id,
<a name="l02321"></a>02321             <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^               skolem_id,
<a name="l02322"></a>02322             array&lt;PatternPtr&gt;^    patterns,
<a name="l02323"></a>02323             array&lt;TermPtr&gt;^       no_patterns,
<a name="l02324"></a>02324             array&lt;SortPtr&gt;^       types,
<a name="l02325"></a>02325             array&lt;Symbol^&gt;^       names,
<a name="l02326"></a>02326             TermPtr                body
<a name="l02327"></a>02327             );
<a name="l02328"></a>02328 
<a name="l02329"></a>02329 
<a name="l02330"></a>02330 
<a name="l02342"></a>02342         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c" title="Create a quantifier with no-pattern directives and symbols.">MkQuantifier</a>(
<a name="l02343"></a>02343             <span class="keywordtype">bool</span>                  is_forall,
<a name="l02344"></a>02344             <span class="keywordtype">unsigned</span>              weight,
<a name="l02345"></a>02345             <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^               quantifier_id,
<a name="l02346"></a>02346             <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^               skolem_id,
<a name="l02347"></a>02347             array&lt;PatternPtr&gt;^    patterns,
<a name="l02348"></a>02348             array&lt;TermPtr&gt;^       no_patterns,
<a name="l02349"></a>02349             array&lt;TermPtr&gt;^       bound,
<a name="l02350"></a>02350             TermPtr               body
<a name="l02351"></a>02351             );
<a name="l02352"></a>02352 
<a name="l02353"></a>02353 
<a name="l02361"></a>02361 
<a name="l02366"></a>02366         <span class="keywordtype">unsigned</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ae810fc8c305ae442e0a516c1cb9f78a8" title="Return a unique identifier for t.">GetTermId</a>(TermPtr t);
<a name="l02367"></a>02367 
<a name="l02371"></a>02371         <span class="keywordtype">unsigned</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a30fc9cb5ea8660841b6912251b5c7574" title="Return a unique identifier for f.">GetFuncDeclId</a>(FuncDeclPtr f);
<a name="l02372"></a>02372 
<a name="l02376"></a>02376         <span class="keywordtype">unsigned</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#acb7747c8b17c86b75c4102f6a5adfafd" title="Return a unique identifier for s.">GetSortId</a>(SortPtr s);
<a name="l02377"></a>02377         
<a name="l02378"></a>02378         
<a name="l02384"></a>02384         <a class="code" href="group__mapi.html#ga05812818de02fb4b202d7513ce50745d" title="In Z3, a symbol can be represented using integers and strings (See GetSymbolKind)...">SymbolKind</a> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a0e5e137439c1194fe6ceadd130c32844" title="Return SymbolKind.Int if the symbol was constructed using MkIntSymbol, and SymbolKind...">GetSymbolKind</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s);
<a name="l02385"></a>02385 
<a name="l02393"></a>02393         <span class="keywordtype">int</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#afabdd4c7aa7001151713568aaf4e27b9" title="Return the symbol int value.">GetSymbolInt</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s);
<a name="l02394"></a>02394     
<a name="l02402"></a>02402         String^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a63af55d0bc85edc1a08938fe94d059c3" title="Return the symbol name.">GetSymbolString</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s);
<a name="l02403"></a>02403 
<a name="l02407"></a>02407         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a95167a48c7a40a4acf32631a527758da" title="Return true if the two given AST nodes are equal.">IsEq</a>(TermPtr t1, TermPtr t2);
<a name="l02408"></a>02408 
<a name="l02412"></a>02412         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a6e20e01d6d3f85406b9ba5091f2e60f7" title="Return true if t is well sorted.">IsWellSorted</a>(TermPtr t);
<a name="l02413"></a>02413 
<a name="l02417"></a>02417         <a class="code" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc" title="The different kinds of Z3 Terms.">TermKind</a> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa92cc97ea26a5d7ca06f7337a750c964" title="Return the kind of the given AST.">GetTermKind</a>(TermPtr a);
<a name="l02418"></a>02418 
<a name="l02424"></a>02424         <a class="code" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425" title="Different kinds of Z3 built-in declarations (See GetDeclKind).">DeclKind</a> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ab5bd163cb2dff9a325fd961d413a8c22" title="Return the kind of the built-in operator.">GetDeclKind</a>(FuncDeclPtr d);
<a name="l02425"></a>02425 
<a name="l02431"></a>02431         array&lt;IRawParameter^&gt;^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#accdc25299d9fe8c5a7fa0889c46cbdf5" title="Return auxiliary parameters associated with the built-in operator. For example, the...">GetDeclParameters</a>(FuncDeclPtr d);
<a name="l02432"></a>02432     
<a name="l02438"></a>02438         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a6aebc549137b2458e195ebe6d9d4c4ba" title="Return the declaration of a constant or function application.">GetAppDecl</a>(AppPtr a);
<a name="l02439"></a>02439         
<a name="l02444"></a>02444         array&lt;TermPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ab021d6b4e58c052472ec3cd6d2dd0fac" title="Return the arguments of an application. If t is an constant, then array is empty...">GetAppArgs</a>(AppPtr a);
<a name="l02445"></a>02445 
<a name="l02451"></a>02451         String^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>(TermPtr a);
<a name="l02452"></a>02452 
<a name="l02461"></a>02461         <span class="keywordtype">int</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa00bb4f5b7abc37cf6c24e1c8ce08f4a" title="Similar to GetNumeralString, but only succeeds if the value can fit in a machine...">GetNumeralInt</a>(TermPtr v);
<a name="l02462"></a>02462 
<a name="l02463"></a>02463         <span class="keywordtype">bool</span> TryGetNumeralInt(TermPtr v, [Out] <span class="keywordtype">int</span>% i);
<a name="l02464"></a>02464 
<a name="l02473"></a>02473         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ae40d08d8f9fc05ea8bb0b035f0da9f09" title="Similar to GetNumeralString, but only succeeds if the value can fit in a machine...">GetNumeralUInt</a>(TermPtr v);
<a name="l02474"></a>02474 
<a name="l02475"></a>02475         <span class="keywordtype">bool</span> TryGetNumeralUInt(TermPtr v, [Out] <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>% u);
<a name="l02476"></a>02476 
<a name="l02477"></a>02477 
<a name="l02486"></a>02486         <span class="keywordtype">unsigned</span> __int64 <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa78f20144c40600d63c87ebc8bd5d85e" title="Similar to GetNumeralString, but only succeeds if the value can fit in a machine...">GetNumeralUInt64</a>(TermPtr v);
<a name="l02487"></a>02487 
<a name="l02488"></a>02488         <span class="keywordtype">bool</span> TryGetNumeralUInt64(TermPtr v, [Out] <span class="keywordtype">unsigned</span> __int64% u);
<a name="l02489"></a>02489 
<a name="l02490"></a>02490 
<a name="l02498"></a>02498         __int64 <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a016d026fcaf6c2299687ae4407533390" title="Similar to GetNumeralString, but only succeeds if the value can fit in a machine...">GetNumeralInt64</a>(TermPtr v);
<a name="l02499"></a>02499 
<a name="l02500"></a>02500         <span class="keywordtype">bool</span> TryGetNumeralInt64(TermPtr v, [Out] __int64% i);
<a name="l02501"></a>02501 
<a name="l02511"></a>02511         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#af74f7a7602abaa3b7d6451f33439af63" title="Similar to GetNumeralString, but only succeeds if the value can fit in a machine...">TryGetNumeral</a>(TermPtr v, [Out] __int64% num, [Out] __int64% den);
<a name="l02512"></a>02512 
<a name="l02513"></a>02513         <span class="keywordtype">void</span> GetNumeral(TermPtr v, [Out] System::Numerics::BigInteger% num, [Out] System::Numerics::BigInteger% den);        
<a name="l02514"></a>02514 
<a name="l02520"></a>02520         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a74ec06b79df90539553d1c53c2a02bdd" title="Return the Boolean value of a truth constant. Return LBool::Undef if a is not a boolean...">GetBoolValue</a>(TermPtr a);
<a name="l02521"></a>02521 
<a name="l02522"></a>02522 
<a name="l02528"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a17499379d443ca6ee0bf3770d18135af">02528</a>         <span class="keywordtype">unsigned</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a17499379d443ca6ee0bf3770d18135af" title="Return the index of a de-Brujin bound variable.">GetVarIndex</a>(TermPtr a) {
<a name="l02529"></a>02529             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gaba865ef17f1692ab14dbd304987db411" title="Return index of de-Brujin bound variable.">Z3_get_index_value</a>(ctx(), get_ast(a));
<a name="l02530"></a>02530         }
<a name="l02531"></a>02531 
<a name="l02537"></a>02537         RawQuantifier^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4dc623c04dfdeaef8d17f88034aab270" title="Return components of a quantifier.">GetQuantifier</a>(TermPtr a);
<a name="l02538"></a>02538 
<a name="l02539"></a>02539 
<a name="l02545"></a>02545         array&lt;TermPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a029d7befda8b1da2f597b3c9d3b5b998" title="Return array of terms in the pattern.">GetPatternTerms</a>(PatternPtr p);
<a name="l02546"></a>02546 
<a name="l02550"></a>02550         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a7c62d9f2161dec8b726996082f05875c" title="Return the constant declaration name as a symbol.">GetDeclName</a>(FuncDeclPtr d);
<a name="l02551"></a>02551 
<a name="l02555"></a>02555         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a16e84dca2b1d23ce89a98276e943eb59" title="Return the type name as a symbol.">GetSortName</a>(SortPtr ty);
<a name="l02556"></a>02556 
<a name="l02562"></a>02562         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad563e3268d5034c9147c98190c4327d6" title="Return the type of an AST node.">GetSort</a>(TermPtr a);
<a name="l02563"></a>02563 
<a name="l02568"></a>02568         array&lt;SortPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a612c60dae8dbc7cc04ebf8a299d7f78d" title="Return the domain of a function declaration.">GetDomain</a>(FuncDeclPtr d);
<a name="l02569"></a>02569 
<a name="l02570"></a>02570 
<a name="l02577"></a>02577         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a84d2dfcc3f579dcce0820cad12686f42" title="Return the range of the given declaration.">GetRange</a>(FuncDeclPtr d);
<a name="l02578"></a>02578 
<a name="l02584"></a>02584         <a class="code" href="group__mapi.html#ga7664c6569cf130a5d166ec8c8dc27101" title="The different kinds of Z3 sorts (See GetSortKind).">SortKind</a> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a>(SortPtr t);
<a name="l02585"></a>02585 
<a name="l02594"></a>02594         <span class="keywordtype">unsigned</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a423fc3c6dda476f6799a85a2168c78b1" title="Return the size of the given bit-vector type.">GetBvSortSize</a>(SortPtr t);
<a name="l02595"></a>02595 
<a name="l02604"></a>02604         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ad230ba9177f3ca00d509b1ee4f1ab8a5" title="Return the domain of the given array type.">GetArraySortDomain</a>(SortPtr t);
<a name="l02605"></a>02605 
<a name="l02614"></a>02614         SortPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3de655e8182580662528e278b9bef566" title="Return the range of the given array type.">GetArraySortRange</a>(SortPtr t);
<a name="l02615"></a>02615 
<a name="l02625"></a>02625         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a8faadbc0b5b7aa7e1f5fb988eddb0467" title="Return the constructor declaration of the given tuple type.">GetTupleConstructor</a>(SortPtr t);
<a name="l02626"></a>02626     
<a name="l02636"></a>02636         array&lt;FuncDeclPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a91e7e6ddb2615bb55ee58ea57c34f308" title="Return the field declarations of a given tuple type.">GetTupleFields</a>(SortPtr t);
<a name="l02637"></a>02637 
<a name="l02644"></a>02644 
<a name="l02650"></a>02650         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a12f2bc414c2c1520880db1444edd72d1" title="Update the arguments of a term or quantifier.">UpdateTerm</a>(TermPtr t, array&lt;TermPtr&gt;^ new_args);
<a name="l02651"></a>02651 
<a name="l02659"></a>02659         
<a name="l02670"></a>02670         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Create a backtracking point.">Push</a>();
<a name="l02671"></a>02671     
<a name="l02686"></a>02686         <span class="keywordtype">void</span> Pop(<span class="keywordtype">unsigned</span> num_scopes);
<a name="l02687"></a>02687 
<a name="l02688"></a>02688         <span class="keywordtype">void</span> Pop() { Pop(1); }
<a name="l02689"></a>02689 
<a name="l02690"></a>02690         <span class="keywordtype">unsigned</span> GetNumScopes();
<a name="l02691"></a>02691 
<a name="l02692"></a>02692 
<a name="l02719"></a>02719         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a268029705dabf988d7655c85df1b548e" title="Persist a term during num_scopes of pops.">PersistTerm</a>(TermPtr t, <span class="keywordtype">unsigned</span> num_scopes);
<a name="l02720"></a>02720 
<a name="l02721"></a>02721 
<a name="l02734"></a>02734         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a48d8c58bf4484b54bf612a3b81526648" title="Assert a constraing into the logical context.">AssertCnstr</a>(TermPtr a);
<a name="l02735"></a>02735     
<a name="l02749"></a>02749         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aed51407e62b77b7bcc14d25ca8e320af" title="Check whether the given logical context is consistent or not.">CheckAndGetModel</a>([Out] RawModel^% m);
<a name="l02750"></a>02750     
<a name="l02757"></a>02757         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a>();
<a name="l02758"></a>02758 
<a name="l02781"></a>02781         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a6623753616cdabbfeb889ed4a31dfbc7" title="Check whether the given logical context is consistent or not with respect to auxiliary...">CheckAssumptions</a>([Out] RawModel^% m, 
<a name="l02782"></a>02782                                [In]  array&lt;TermPtr&gt;^ assumptions, 
<a name="l02783"></a>02783                                [Out] TermPtr% proof, 
<a name="l02784"></a>02784                                [Out] array&lt;TermPtr&gt;^% core);
<a name="l02785"></a>02785 
<a name="l02793"></a>02793         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4717aab1cfc427ec9c049c9ba743a006" title="Cancel the current search initiated using Check, CheckAndGetModel, or CheckAssumptions...">SoftCheckCancel</a>();
<a name="l02794"></a>02794         
<a name="l02795"></a>02795 
<a name="l02796"></a>02796 
<a name="l02816"></a>02816         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a680762fecac781975b588f102dd8ae3e" title="Retrieve congruence class representatives for terms.">GetImpliedEqualities</a>(
<a name="l02817"></a>02817             [In]  array&lt;TermPtr&gt;^ terms,
<a name="l02818"></a>02818             [Out] array&lt;unsigned&gt;^% class_ids
<a name="l02819"></a>02819             );
<a name="l02820"></a>02820 
<a name="l02821"></a>02821 
<a name="l02827"></a>02827         <a class="code" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e" title="Different failure kinds.">SearchFailureExplanation</a> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3c2e03935c06e79eb6c4b249b910307d" title="Obtain explanation for search failure.">GetSearchFailureExplanation</a>();
<a name="l02828"></a>02828 
<a name="l02829"></a>02829 
<a name="l02833"></a>02833         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a4db4d536f2203faa741073c01f61fb0e" title="Return conjunction of literals and formulas assigned to true in the current state...">GetAssignments</a>();
<a name="l02834"></a>02834 
<a name="l02838"></a>02838         LabeledLiterals^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ac91878a6a5fd8cb8173aed946528f42f" title="Retrieve set of labels set in current satisfying assignment.">GetRelevantLabels</a>();
<a name="l02839"></a>02839 
<a name="l02843"></a>02843         LabeledLiterals^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aed54018936a4d19c92a05d8c770d3c33" title="Retrieve set of literals satisfying the current assignment.">GetRelevantLiterals</a>();
<a name="l02844"></a>02844 
<a name="l02848"></a>02848         LabeledLiterals^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a9522ebeb37a88abbb1a4a1c4cf75ac9f" title="Retrieve set of guessed literals satisfying the current assignment.">GetGuessedLiterals</a>();
<a name="l02849"></a>02849 
<a name="l02856"></a>02856         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a712b529cbbcd86eb099bcb97289f9a77" title="Block the combination of remaining non-disabled labels.">BlockLiterals</a>(LabeledLiterals^ labels);
<a name="l02857"></a>02857 
<a name="l02861"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a21c01788a1c75b8e9ee86634aec4ca8c">02861</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a21c01788a1c75b8e9ee86634aec4ca8c" title="Obtain literal corresponding to index in list of literals.">GetLiteral</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_labeled_literals.html" title="Container for labeled literals.">LabeledLiterals</a>^ labels, <span class="keywordtype">unsigned</span> idx) {
<a name="l02862"></a>02862             <span class="keywordflow">return</span> labels-&gt;GetLiteral(idx);
<a name="l02863"></a>02863         }
<a name="l02864"></a>02864 
<a name="l02872"></a>02872         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aea36484f844217cc37a206be0fe565f6" title="Interface to simplifier.">Simplify</a>(TermPtr a);
<a name="l02873"></a>02873         
<a name="l02874"></a>02874     
<a name="l02881"></a>02881 
<a name="l02882"></a>02882 
<a name="l02893"></a>02893         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a17471e6be035651820a92e6c4e31d673" title="Select mode for the format used for pretty-printing AST nodes.">SetPrintMode</a>(<a class="code" href="group__mapi.html#ga8fcc700aeeee633213b4e5f433e5e12e" title="Z3 pretty printing modes used when pretty printing terms.">PrintMode</a> mode);
<a name="l02894"></a>02894 
<a name="l02898"></a>02898         String^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a08d99b52685eab1e9d5ac4d9223cb2be" title="Convert the given logical context into a string.">ToString</a>(AstPtr a);
<a name="l02899"></a>02899         
<a name="l02900"></a>02900         <span class="keywordtype">void</span> Display(System::IO::TextWriter^ w, AstPtr a);
<a name="l02901"></a>02901     
<a name="l02908"></a>02908         <span class="keyword">virtual</span> String^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a08d99b52685eab1e9d5ac4d9223cb2be" title="Convert the given logical context into a string.">ToString</a>() <span class="keyword">override</span>;
<a name="l02909"></a>02909 
<a name="l02910"></a>02910         <span class="keywordtype">void</span> Display(System::IO::TextWriter^ w);
<a name="l02911"></a>02911 
<a name="l02918"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a0c7570d3474aec2457249e00de34c51a">02918</a>         String^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a0c7570d3474aec2457249e00de34c51a" title="Convert the given logical context into a string.">StatisticsToString</a>() {
<a name="l02919"></a>02919             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> String(<a class="code" href="group__capi.html#ga660933fbbc1cd0dce85680d532fb56e0" title="Return runtime statistics as a string.">Z3_statistics_to_string</a>(ctx()));
<a name="l02920"></a>02920         }
<a name="l02921"></a>02921 
<a name="l02922"></a>02922         <span class="keywordtype">void</span> DisplayStatistics(System::IO::TextWriter^ w) {
<a name="l02923"></a>02923             w-&gt;Write(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a0c7570d3474aec2457249e00de34c51a" title="Convert the given logical context into a string.">StatisticsToString</a>());
<a name="l02924"></a>02924         }
<a name="l02925"></a>02925 
<a name="l02929"></a>02929         String^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a0805c579c20f25fec2c0f293259d9473" title="Convert the given benchmark into SMT-LIB formatted string.">BenchmarkToSmtlib</a>(String^ name,
<a name="l02930"></a>02930                                   String^ logic,
<a name="l02931"></a>02931                                   String^ status,
<a name="l02932"></a>02932                                   String^ attributes,
<a name="l02933"></a>02933                                   array&lt;TermPtr&gt;^ assumptions,
<a name="l02934"></a>02934                                   TermPtr formula);
<a name="l02935"></a>02935 
<a name="l02961"></a>02961         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a3d9995b5f0cd4395f93c9ad17a63d7cc" title="Parse the given string using the SMT-LIB parser.">ParseSmtlibString</a>(
<a name="l02962"></a>02962             String^ <span class="keywordtype">string</span>,
<a name="l02963"></a>02963             [In]  array&lt;SortPtr&gt;^     sorts,
<a name="l02964"></a>02964             [In]  array&lt;FuncDeclPtr&gt;^ decls,
<a name="l02965"></a>02965             [Out] array&lt;TermPtr&gt;^%    assumptions,            
<a name="l02966"></a>02966             [Out] array&lt;TermPtr&gt;^%    formulas,
<a name="l02967"></a>02967             [Out] array&lt;FuncDeclPtr&gt;^% new_decls,
<a name="l02968"></a>02968             [Out] array&lt;SortPtr&gt;^%    new_sorts,
<a name="l02969"></a>02969             [Out] String^% parser_out
<a name="l02970"></a>02970             );
<a name="l02971"></a>02971     
<a name="l02975"></a>02975         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a189844e560a2e30995b6d68823304932" title="Similar to ParseSmtlibString, but reads the benchmark from a file.">ParseSmtlibFile</a>(
<a name="l02976"></a>02976             String^             file,
<a name="l02977"></a>02977             [In]  array&lt;SortPtr&gt;^     sorts,
<a name="l02978"></a>02978             [In]  array&lt;FuncDeclPtr&gt;^ decls,
<a name="l02979"></a>02979             [Out] array&lt;TermPtr&gt;^%    assumptions,            
<a name="l02980"></a>02980             [Out] array&lt;TermPtr&gt;^%    formulas,
<a name="l02981"></a>02981             [Out] array&lt;FuncDeclPtr&gt;^% new_decls,
<a name="l02982"></a>02982             [Out] array&lt;SortPtr&gt;^%    new_sorts,
<a name="l02983"></a>02983             [Out] String^% parser_out
<a name="l02984"></a>02984             );
<a name="l02985"></a>02985 
<a name="l02986"></a>02986 
<a name="l02992"></a>02992         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ade46bed01c907e799528075996072637" title="Parse a string in the native Z3 format.">ParseZ3String</a>(String^ s);
<a name="l02993"></a>02993 
<a name="l02999"></a>02999         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#abb1e2e3a1d96aa625758845ed3b8d534" title="Parse a file containing formulas in Z3&amp;#39;s native format.">ParseZ3File</a>(String^ filename);
<a name="l03000"></a>03000 
<a name="l03006"></a>03006         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#afd791c9297c9a547017ba2cf0b94ee81" title="Parse a string in the SMT-LIB2 format.">ParseSmtlib2String</a>(String^ s, array&lt;SortPtr&gt;^ sorts, array&lt;FuncDeclPtr&gt;^ decls);
<a name="l03007"></a>03007 
<a name="l03013"></a>03013         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aedcfe737b097182e955e06099747630f" title="Parse a file containing formulas in SMT-LIB2 format.">ParseSmtlib2File</a>(String^ filename, array&lt;SortPtr&gt;^ sorts, array&lt;FuncDeclPtr&gt;^ decls);
<a name="l03014"></a>03014 
<a name="l03020"></a>03020         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a9d6d0233ca62b250f4ab0d7ffd34a021" title="Execute commands from a string in the SMT-LIB2 format.">ExecSmtlib2String</a>(String^ s, array&lt;SortPtr&gt;^ sorts, array&lt;FuncDeclPtr&gt;^ decls);
<a name="l03021"></a>03021 
<a name="l03027"></a>03027         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a41d7b23fa1f48ebaab07718ca78d7d1e" title="Execute commands from a file containing formulas in SMT-LIB2 format.">ExecSmtlib2File</a>(String^ filename, array&lt;SortPtr&gt;^ sorts, array&lt;FuncDeclPtr&gt;^ decls);
<a name="l03033"></a>03033         <span class="comment">/*{@*/</span>
<a name="l03034"></a>03034 
<a name="l03042"></a>03042         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a22af33e79aad8e443bfe2c249c6255ef" title="Register a Z3 error handler.">SetErrorHandler</a>(IErrorHandler^ h);
<a name="l03043"></a>03043 
<a name="l03047"></a>03047         <span class="keyword">static</span> String^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a8478b135914c2e8c78127a50361331c4" title="Return a string describing the given error code.">GetErrorMessage</a>(<a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> err);
<a name="l03048"></a>03048 
<a name="l03052"></a>03052         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a6bcc908b9ba41cd95dae64006321b34b" title="Free all resources allocated for Z3.">ResetMemory</a>();
<a name="l03053"></a>03053         
<a name="l03061"></a>03061     
<a name="l03065"></a>03065         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a7068a418e65d2a184e2275e72300afc1" title="Return Z3 version number information.">GetVersion</a>(
<a name="l03066"></a>03066             [Out] <span class="keywordtype">unsigned</span> % major, 
<a name="l03067"></a>03067             [Out] <span class="keywordtype">unsigned</span> % minor, 
<a name="l03068"></a>03068             [Out] <span class="keywordtype">unsigned</span> % build_number, 
<a name="l03069"></a>03069             [Out] <span class="keywordtype">unsigned</span> % revision_number);
<a name="l03077"></a>03077                 RawTheory^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#aa414182801e38192dfb8beed739bfe23" title="Create user theory.">MkTheory</a>(String^ name);
<a name="l03078"></a>03078 
<a name="l03079"></a>03079         <span class="keyword">internal</span>:
<a name="l03080"></a>03080         <span class="keyword">static</span> Dictionary&lt;GCHandle, RawContext^&gt;^ contexts;
<a name="l03081"></a>03081 
<a name="l03082"></a>03082         <span class="keyword">public</span>:
<a name="l03083"></a>03083 
<a name="l03088"></a>03088         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a6983043d863fc901bc3492ea4cfb4f6b" title="Register fixed-point rules.">RegisterRelation</a>(FuncDeclPtr relation);
<a name="l03089"></a>03089 
<a name="l03090"></a>03090         <span class="keywordtype">void</span> AddRule(TermPtr rule, Symbol^ name);
<a name="l03091"></a>03091 
<a name="l03098"></a>03098         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a606e29bd48b267e20d8d04388cec4e4a" title="post a query. The return value is LBool.True if the query is satisfiabl,e it is LBool...">Query</a>(TermPtr query);
<a name="l03099"></a>03099 
<a name="l03103"></a>03103         String^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#acb5ebbb59aa2cfb8846df0481720bf12" title="retrieve details on the search satus.">GetQueryStatus</a>();
<a name="l03104"></a>03104 
<a name="l03109"></a>03109         TermPtr <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#ab2ed8df926ca0b94a1f186a7b7e529de" title="retrieve formula that satisfies the previous query, assuming the return value was...">GetQueryAnswer</a>();
<a name="l03110"></a>03110 
<a name="l03111"></a>03111         String^ FixedpointToString(array&lt;TermPtr&gt;^ queries);
<a name="l03112"></a>03112 
<a name="l03113"></a>03113         array&lt;TermPtr&gt;^ SimplifyFixedpointRules(array&lt;TermPtr&gt;^ rules, array&lt;FuncDeclPtr&gt;^ output_predicates);
<a name="l03114"></a>03114 
<a name="l03115"></a>03115         <span class="comment">// functions for creating custom Fixedpoint relations.</span>
<a name="l03116"></a>03116     <span class="keyword">internal</span>:
<a name="l03117"></a>03117         <span class="keyword">static</span> <span class="keywordtype">void</span> fixedpoint_assign_callback(<span class="keywordtype">void</span>*, Z3_func_decl, <span class="keywordtype">unsigned</span>, Z3_ast <span class="keyword">const</span>[], <span class="keywordtype">unsigned</span>, Z3_ast <span class="keyword">const</span>[]);
<a name="l03118"></a>03118         <span class="keyword">static</span> <span class="keywordtype">void</span> fixedpoint_apply_callback(<span class="keywordtype">void</span>*, Z3_func_decl, <span class="keywordtype">unsigned</span>, Z3_ast <span class="keyword">const</span>[], Z3_ast*);
<a name="l03119"></a>03119         IntPtr m_fixedpoint_gch;
<a name="l03120"></a>03120     <span class="keyword">private</span>:
<a name="l03121"></a>03121         Action3&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, array&lt;TermPtr&gt;^&gt;^ m_fixedpoint_assign;
<a name="l03122"></a>03122         Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^           m_fixedpoint_apply;
<a name="l03123"></a>03123         <span class="keywordtype">void</span> init_fixedpoint_callbacks();
<a name="l03124"></a>03124     <span class="keyword">public</span>:
<a name="l03125"></a>03125         <span class="keyword">property</span> Action3&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, array&lt;TermPtr&gt;^&gt;^ FixedpointAssign {
<a name="l03126"></a>03126             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action3&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, array&lt;TermPtr&gt;^&gt;^ value) {
<a name="l03127"></a>03127                 m_fixedpoint_assign = value;
<a name="l03128"></a>03128                 init_fixedpoint_callbacks();
<a name="l03129"></a>03129             }
<a name="l03130"></a>03130         }
<a name="l03131"></a>03131         <span class="keyword">property</span> Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ FixedpointApply {
<a name="l03132"></a>03132             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ value) {
<a name="l03133"></a>03133                 m_fixedpoint_apply = value;
<a name="l03134"></a>03134                 init_fixedpoint_callbacks();
<a name="l03135"></a>03135             }
<a name="l03136"></a>03136         }
<a name="l03137"></a>03137         
<a name="l03138"></a>03138     };
<a name="l03139"></a>03139 
<a name="l03140"></a>03140     <span class="keyword">public ref class</span> RawTheory {
<a name="l03141"></a>03141         <span class="keyword">typedef</span> GCHandle GCHandle;
<a name="l03142"></a>03142         <span class="keyword">typedef</span> GCHandleType GCHandleType;
<a name="l03143"></a>03143     <span class="keyword">private</span>: 
<a name="l03144"></a>03144         Z3_theory    m_theory;
<a name="l03145"></a>03145         ref_context&amp; m_context;
<a name="l03146"></a>03146         String^      m_name;
<a name="l03147"></a>03147         <span class="keyword">static</span> Dictionary&lt;GCHandle,RawTheory^&gt;^ theories;
<a name="l03148"></a>03148     <span class="keyword">protected</span>:
<a name="l03149"></a>03149         !RawTheory() {}
<a name="l03150"></a>03150     <span class="keyword">public</span>:        
<a name="l03151"></a>03151         <span class="keyword">property</span> String^ Name { String^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_name; } }
<a name="l03152"></a>03152     <span class="keyword">internal</span>:
<a name="l03153"></a>03153         RawTheory(ref_context&amp; ctx, String^ name);
<a name="l03154"></a>03154         ~RawTheory();
<a name="l03155"></a>03155         
<a name="l03156"></a>03156         <span class="keyword">static</span> RawTheory^ GetTheory(Z3_theory th) {
<a name="l03157"></a>03157             Z3_theory_data td = <a class="code" href="group__capi.html#ga9f8a5c32a1cc523d23a561780824e3af" title="Return a pointer to the external data-structure supplied to the function Z3_mk_theory...">Z3_theory_get_ext_data</a>(th);
<a name="l03158"></a>03158             <span class="keywordflow">return</span> theories[GCHandle::FromIntPtr(IntPtr(td))];
<a name="l03159"></a>03159         }
<a name="l03160"></a>03160 
<a name="l03161"></a>03161 
<a name="l03162"></a>03162         <span class="comment">// Delete Handler</span>
<a name="l03163"></a>03163     <span class="keyword">private</span>:
<a name="l03164"></a>03164         Action0^ delete_handler;
<a name="l03165"></a>03165     <span class="keyword">internal</span>:
<a name="l03166"></a>03166         <span class="keyword">static</span> <span class="keywordtype">void</span> static_delete_callback(Z3_theory th);
<a name="l03167"></a>03167 
<a name="l03168"></a>03168     <span class="keyword">public</span>:
<a name="l03169"></a>03169         <span class="keyword">property</span> Action0^ DeleteHandler
<a name="l03170"></a>03170         {
<a name="l03171"></a>03171             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l03172"></a>03172             {
<a name="l03173"></a>03173                 delete_handler = value;
<a name="l03174"></a>03174             }
<a name="l03175"></a>03175         }
<a name="l03176"></a>03176 
<a name="l03177"></a>03177         <span class="comment">// ReduceEq</span>
<a name="l03178"></a>03178     <span class="keyword">internal</span>:
<a name="l03179"></a>03179         <span class="keyword">static</span> <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> reduce_eq_callback(Z3_theory th, Z3_ast a, Z3_ast b, Z3_ast* r);
<a name="l03180"></a>03180     <span class="keyword">private</span>:
<a name="l03181"></a>03181         Func2&lt;TermPtr, TermPtr, TermPtr&gt;^ reduce_eq;
<a name="l03182"></a>03182         <span class="keywordtype">void</span> set_reduce_eq(Func2&lt;TermPtr, TermPtr, TermPtr&gt;^ value);
<a name="l03183"></a>03183     <span class="keyword">public</span>:
<a name="l03184"></a>03184         <span class="keyword">property</span> Func2&lt;TermPtr, TermPtr, TermPtr&gt;^ ReduceEq {
<a name="l03185"></a>03185             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;TermPtr, TermPtr, TermPtr&gt;^ value) {
<a name="l03186"></a>03186                 set_reduce_eq(value);
<a name="l03187"></a>03187             }
<a name="l03188"></a>03188         }
<a name="l03189"></a>03189 
<a name="l03190"></a>03190 
<a name="l03191"></a>03191         <span class="comment">// ReduceApp</span>
<a name="l03192"></a>03192     <span class="keyword">private</span>:
<a name="l03193"></a>03193         Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ reduce_app;
<a name="l03194"></a>03194         <span class="keywordtype">void</span> set_reduce_app(Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ value);
<a name="l03195"></a>03195     <span class="keyword">public</span>:
<a name="l03196"></a>03196         <span class="keyword">property</span> Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ ReduceApp {
<a name="l03197"></a>03197             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ value) {
<a name="l03198"></a>03198                 set_reduce_app(value);
<a name="l03199"></a>03199             }
<a name="l03200"></a>03200         }
<a name="l03201"></a>03201     <span class="keyword">internal</span>:
<a name="l03202"></a>03202         <span class="keyword">static</span> <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> reduce_app_callback(Z3_theory th, Z3_func_decl f, <span class="keywordtype">unsigned</span> num_args, Z3_ast <span class="keyword">const</span> args[], Z3_ast* r);
<a name="l03203"></a>03203 
<a name="l03204"></a>03204     <span class="comment">// Reduce distinct</span>
<a name="l03205"></a>03205     <span class="keyword">private</span>:
<a name="l03206"></a>03206         Func1&lt;array&lt;TermPtr&gt;^, TermPtr&gt;^ reduce_distinct;
<a name="l03207"></a>03207         <span class="keywordtype">void</span> set_reduce_distinct(Func1&lt;array&lt;TermPtr&gt;^, TermPtr&gt;^ value);
<a name="l03208"></a>03208     <span class="keyword">internal</span>:
<a name="l03209"></a>03209         <span class="keyword">static</span> <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> reduce_distinct_callback(Z3_theory th, <span class="keywordtype">unsigned</span> n, Z3_ast <span class="keyword">const</span> args[], Z3_ast* r);
<a name="l03210"></a>03210     <span class="keyword">public</span>:
<a name="l03211"></a>03211         <span class="keyword">property</span> Func1&lt;array&lt;TermPtr&gt;^, TermPtr&gt;^ ReduceDistinct {
<a name="l03212"></a>03212             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func1&lt;array&lt;TermPtr&gt;^, TermPtr&gt;^ value) {
<a name="l03213"></a>03213                 set_reduce_distinct(value);
<a name="l03214"></a>03214             }
<a name="l03215"></a>03215         }
<a name="l03216"></a>03216 
<a name="l03217"></a>03217         <span class="comment">// NewRelevant</span>
<a name="l03218"></a>03218     <span class="keyword">internal</span>: 
<a name="l03219"></a>03219         Action&lt;TermPtr&gt;^ new_relevant;
<a name="l03220"></a>03220     <span class="keyword">private</span>: 
<a name="l03221"></a>03221         <span class="keywordtype">void</span> set_new_relevant(Action&lt;TermPtr&gt;^ value);
<a name="l03222"></a>03222     <span class="keyword">public</span>: 
<a name="l03223"></a>03223         <span class="keyword">property</span> Action&lt;TermPtr&gt;^ NewRelevant {
<a name="l03224"></a>03224             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;TermPtr&gt;^ value) {
<a name="l03225"></a>03225                 set_new_relevant(value);
<a name="l03226"></a>03226             }
<a name="l03227"></a>03227         }
<a name="l03228"></a>03228 
<a name="l03229"></a>03229         <span class="comment">// NewApp</span>
<a name="l03230"></a>03230     <span class="keyword">private</span>: 
<a name="l03231"></a>03231         <span class="keywordtype">void</span> set_new_app(Action&lt;TermPtr&gt;^ value);
<a name="l03232"></a>03232     <span class="keyword">internal</span>: 
<a name="l03233"></a>03233         Action&lt;TermPtr&gt;^ new_app;
<a name="l03234"></a>03234     <span class="keyword">public</span>: 
<a name="l03235"></a>03235         <span class="keyword">property</span> Action&lt;TermPtr&gt;^ NewApp {
<a name="l03236"></a>03236             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;TermPtr&gt;^ value) {
<a name="l03237"></a>03237                 set_new_app(value);
<a name="l03238"></a>03238             }
<a name="l03239"></a>03239         }
<a name="l03240"></a>03240 
<a name="l03241"></a>03241         <span class="comment">// NewElem</span>
<a name="l03242"></a>03242     <span class="keyword">private</span>: 
<a name="l03243"></a>03243         <span class="keywordtype">void</span> set_new_elem(Action&lt;TermPtr&gt;^ value);
<a name="l03244"></a>03244     <span class="keyword">internal</span>: 
<a name="l03245"></a>03245         Action&lt;TermPtr&gt;^ new_elem;
<a name="l03246"></a>03246     <span class="keyword">public</span>: 
<a name="l03247"></a>03247         <span class="keyword">property</span> Action&lt;TermPtr&gt;^ NewElem {
<a name="l03248"></a>03248             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;TermPtr&gt;^ value) {
<a name="l03249"></a>03249                 set_new_elem(value);
<a name="l03250"></a>03250             }
<a name="l03251"></a>03251         }
<a name="l03252"></a>03252         
<a name="l03253"></a>03253         <span class="comment">// InitSearch</span>
<a name="l03254"></a>03254     <span class="keyword">private</span>:
<a name="l03255"></a>03255         <span class="keywordtype">void</span> set_init_search(Action0^ value);
<a name="l03256"></a>03256     <span class="keyword">internal</span>:
<a name="l03257"></a>03257         Action0^ init_search;
<a name="l03258"></a>03258     <span class="keyword">public</span>: 
<a name="l03259"></a>03259         <span class="keyword">property</span> Action0^ InitSearch {
<a name="l03260"></a>03260             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) { set_init_search(value); }
<a name="l03261"></a>03261         }
<a name="l03262"></a>03262 
<a name="l03263"></a>03263         <span class="comment">// Push</span>
<a name="l03264"></a>03264     <span class="keyword">private</span>:
<a name="l03265"></a>03265         <span class="keywordtype">void</span> set_push(Action0^ value);
<a name="l03266"></a>03266     <span class="keyword">internal</span>:
<a name="l03267"></a>03267         Action0^ push;
<a name="l03268"></a>03268     <span class="keyword">public</span>: 
<a name="l03269"></a>03269         <span class="keyword">property</span> Action0^ Push {
<a name="l03270"></a>03270             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) { set_push(value); }
<a name="l03271"></a>03271         }
<a name="l03272"></a>03272 
<a name="l03273"></a>03273         <span class="comment">// Pop</span>
<a name="l03274"></a>03274     <span class="keyword">private</span>:
<a name="l03275"></a>03275         <span class="keywordtype">void</span> set_pop(Action0^ value);
<a name="l03276"></a>03276     <span class="keyword">internal</span>:
<a name="l03277"></a>03277         Action0^ pop;
<a name="l03278"></a>03278     <span class="keyword">public</span>: 
<a name="l03279"></a>03279         <span class="keyword">property</span> Action0^ Pop {
<a name="l03280"></a>03280             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) { set_pop(value); }
<a name="l03281"></a>03281         }
<a name="l03282"></a>03282 
<a name="l03283"></a>03283         <span class="comment">// Restart</span>
<a name="l03284"></a>03284     <span class="keyword">private</span>:
<a name="l03285"></a>03285         <span class="keywordtype">void</span> set_restart(Action0^ value);
<a name="l03286"></a>03286     <span class="keyword">internal</span>:
<a name="l03287"></a>03287         Action0^ restart;
<a name="l03288"></a>03288     <span class="keyword">public</span>: 
<a name="l03289"></a>03289         <span class="keyword">property</span> Action0^ Restart {
<a name="l03290"></a>03290             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) { set_restart(value); }
<a name="l03291"></a>03291         }
<a name="l03292"></a>03292 
<a name="l03293"></a>03293         <span class="comment">// Reset</span>
<a name="l03294"></a>03294     <span class="keyword">private</span>:
<a name="l03295"></a>03295         <span class="keywordtype">void</span> set_reset(Action0^ value);
<a name="l03296"></a>03296     <span class="keyword">internal</span>:
<a name="l03297"></a>03297         Action0^ reset;
<a name="l03298"></a>03298     <span class="keyword">public</span>: 
<a name="l03299"></a>03299         <span class="keyword">property</span> Action0^ Reset {
<a name="l03300"></a>03300             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) { set_reset(value); }
<a name="l03301"></a>03301         }
<a name="l03302"></a>03302 
<a name="l03303"></a>03303 
<a name="l03304"></a>03304         <span class="comment">// FinalCheck</span>
<a name="l03305"></a>03305     <span class="keyword">private</span>:
<a name="l03306"></a>03306         <span class="keywordtype">void</span> set_final_check(Func0&lt;bool&gt;^ value);
<a name="l03307"></a>03307     <span class="keyword">internal</span>:
<a name="l03308"></a>03308         Func0&lt;bool&gt;^ final_check;
<a name="l03309"></a>03309     <span class="keyword">public</span>: 
<a name="l03310"></a>03310         <span class="keyword">property</span> Func0&lt;bool&gt;^ FinalCheck {
<a name="l03311"></a>03311             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func0&lt;bool&gt;^ value) { set_final_check(value); }
<a name="l03312"></a>03312         }
<a name="l03313"></a>03313 
<a name="l03314"></a>03314 
<a name="l03315"></a>03315         <span class="comment">// NewEq</span>
<a name="l03316"></a>03316     <span class="keyword">private</span>:
<a name="l03317"></a>03317         <span class="keywordtype">void</span> set_new_eq(Action2&lt;TermPtr, TermPtr&gt;^ value);
<a name="l03318"></a>03318     <span class="keyword">internal</span>:
<a name="l03319"></a>03319         Action2&lt;TermPtr, TermPtr&gt;^ new_eq;
<a name="l03320"></a>03320     <span class="keyword">public</span>:
<a name="l03321"></a>03321         <span class="keyword">property</span> Action2&lt;TermPtr, TermPtr&gt;^ NewEq
<a name="l03322"></a>03322         {
<a name="l03323"></a>03323             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;TermPtr, TermPtr&gt;^ value) { set_new_eq(value); }
<a name="l03324"></a>03324         }
<a name="l03325"></a>03325 
<a name="l03326"></a>03326 
<a name="l03327"></a>03327         <span class="comment">// NewDiseq</span>
<a name="l03328"></a>03328     <span class="keyword">private</span>:
<a name="l03329"></a>03329         <span class="keywordtype">void</span> set_new_diseq(Action2&lt;TermPtr, TermPtr&gt;^ value);
<a name="l03330"></a>03330     <span class="keyword">internal</span>:
<a name="l03331"></a>03331         Action2&lt;TermPtr, TermPtr&gt;^ new_diseq;
<a name="l03332"></a>03332     <span class="keyword">public</span>:
<a name="l03333"></a>03333         <span class="keyword">property</span> Action2&lt;TermPtr, TermPtr&gt;^ NewDiseq
<a name="l03334"></a>03334         {
<a name="l03335"></a>03335             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;TermPtr, TermPtr&gt;^ value) { set_new_diseq(value); }
<a name="l03336"></a>03336         }
<a name="l03337"></a>03337 
<a name="l03338"></a>03338         <span class="comment">// NewAssignment</span>
<a name="l03339"></a>03339     <span class="keyword">internal</span>:
<a name="l03340"></a>03340         Action2&lt;TermPtr, bool&gt;^ new_assignment;
<a name="l03341"></a>03341     <span class="keyword">private</span>:
<a name="l03342"></a>03342         <span class="keywordtype">void</span> set_new_assignment(Action2&lt;TermPtr, bool&gt;^ value);
<a name="l03343"></a>03343     <span class="keyword">public</span>:
<a name="l03344"></a>03344         <span class="keyword">property</span> Action2&lt;TermPtr, bool&gt;^ NewAssignment {
<a name="l03345"></a>03345             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;TermPtr, bool&gt;^ value) {
<a name="l03346"></a>03346                 set_new_assignment(value);
<a name="l03347"></a>03347             }
<a name="l03348"></a>03348         }
<a name="l03349"></a>03349 
<a name="l03350"></a>03350         <span class="keywordtype">void</span> AssertTheoryAxiom(TermPtr ax)
<a name="l03351"></a>03351         {
<a name="l03352"></a>03352             <a class="code" href="group__capi.html#ga6ab97a5867aef0556c64bb29c72f9ced" title="Assert a theory axiom/lemmas during the search.">Z3_theory_assert_axiom</a>(m_theory, get_ast(ax));
<a name="l03353"></a>03353         }
<a name="l03354"></a>03354 
<a name="l03355"></a>03355         <span class="keywordtype">void</span> AssumeEq(TermPtr lhs, TermPtr rhs)
<a name="l03356"></a>03356         {
<a name="l03357"></a>03357             <a class="code" href="group__capi.html#ga277e6cd16cddc0c7315306151b9816ef" title="Inform to the logical context that lhs and rhs have the same interpretation in the...">Z3_theory_assume_eq</a>(m_theory, get_ast(lhs), get_ast(rhs));
<a name="l03358"></a>03358         }
<a name="l03359"></a>03359 
<a name="l03360"></a>03360         <span class="keywordtype">void</span> EnableTheoryAxiomSimplification(<span class="keywordtype">bool</span> flag)
<a name="l03361"></a>03361         {
<a name="l03362"></a>03362             <a class="code" href="group__capi.html#ga2cdc617cf02b74c0e59ad34afc7f433a" title="Enable/disable the simplification of theory axioms asserted using Z3_theory_assert_axiom...">Z3_theory_enable_axiom_simplification</a>(m_theory, flag);
<a name="l03363"></a>03363         }
<a name="l03364"></a>03364 
<a name="l03365"></a>03365         TermPtr GetEqcRoot(TermPtr n)
<a name="l03366"></a>03366         {
<a name="l03367"></a>03367             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gaf8b5b897959cbf30b20f7449cb02ebe3" title="Return the root of the equivalence class containing n.">Z3_theory_get_eqc_root</a>(m_theory, get_ast(n)));
<a name="l03368"></a>03368         }
<a name="l03369"></a>03369 
<a name="l03370"></a>03370         TermPtr GetEqcNext(TermPtr n)
<a name="l03371"></a>03371         {
<a name="l03372"></a>03372             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gab91ac2b25b88f92d51359c0185cf1357" title="Return the next element in the equivalence class containing n.">Z3_theory_get_eqc_next</a>(m_theory, get_ast(n)));
<a name="l03373"></a>03373         }
<a name="l03374"></a>03374 
<a name="l03375"></a>03375         
<a name="l03376"></a>03376         array&lt;TermPtr&gt;^ GetParents(TermPtr n) {
<a name="l03377"></a>03377             <span class="keywordtype">unsigned</span> np = <a class="code" href="group__capi.html#ga00cf5d469ac5f267cb92d221fd8bcfd4" title="Return the number of parents of n that are operators of the given theory.">Z3_theory_get_num_parents</a>(m_theory, get_ast(n));
<a name="l03378"></a>03378             array&lt;TermPtr&gt;^ result = <span class="keyword">gcnew</span> array&lt;TermPtr&gt;(np);
<a name="l03379"></a>03379             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; np; ++i)
<a name="l03380"></a>03380                 {
<a name="l03381"></a>03381                 result[i] = TermPtr(<a class="code" href="group__capi.html#ga9b3099dcf4f295cc05e6f94693e7be35" title="Return the i-th parent of n. See Z3_theory_get_num_parents.">Z3_theory_get_parent</a>(m_theory, get_ast(n), i));
<a name="l03382"></a>03382             }
<a name="l03383"></a>03383             <span class="keywordflow">return</span> result;
<a name="l03384"></a>03384         }
<a name="l03385"></a>03385 
<a name="l03386"></a>03386         <span class="keywordtype">bool</span> IsTheoryValue(TermPtr a)
<a name="l03387"></a>03387         {
<a name="l03388"></a>03388             <span class="keywordflow">return</span> 0 != <a class="code" href="group__capi.html#gaca57d0410f9303b524f2050ecf5c0061" title="Return Z3_TRUE if n is an interpreted theory value.">Z3_theory_is_value</a>(m_theory, get_ast(a));
<a name="l03389"></a>03389         }
<a name="l03390"></a>03390 
<a name="l03391"></a>03391         <span class="keywordtype">bool</span> IsTheoryDecl(FuncDeclPtr d)
<a name="l03392"></a>03392         {
<a name="l03393"></a>03393             <span class="keywordflow">return</span> 0 != <a class="code" href="group__capi.html#ga4836063495a93a0a64f7ee55bc57a020" title="Return Z3_TRUE if d is an interpreted theory declaration.">Z3_theory_is_decl</a>(m_theory, get_func_decl(d));
<a name="l03394"></a>03394         }
<a name="l03395"></a>03395 
<a name="l03396"></a>03396         array&lt;TermPtr&gt;^ GetElems()
<a name="l03397"></a>03397         {
<a name="l03398"></a>03398             <span class="keywordtype">unsigned</span> n = <a class="code" href="group__capi.html#ga3f2d2e577849a075129142d8007cf0da" title="Return the number of expressions of the given theory in the logical context. These...">Z3_theory_get_num_elems</a>(m_theory);
<a name="l03399"></a>03399             array&lt;TermPtr&gt;^ result = <span class="keyword">gcnew</span> array&lt;TermPtr&gt;(n);
<a name="l03400"></a>03400             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)
<a name="l03401"></a>03401             {
<a name="l03402"></a>03402                 result[i] = TermPtr(<a class="code" href="group__capi.html#ga666931824dd7e4f1c9abd9fdab1f5f81" title="Return the i-th elem of the given theory in the logical context.">Z3_theory_get_elem</a>(m_theory, i));
<a name="l03403"></a>03403             }
<a name="l03404"></a>03404             <span class="keywordflow">return</span> result;
<a name="l03405"></a>03405         }
<a name="l03406"></a>03406 
<a name="l03407"></a>03407         array&lt;TermPtr&gt;^ GetApps()
<a name="l03408"></a>03408         {
<a name="l03409"></a>03409             <span class="keywordtype">unsigned</span> n = <a class="code" href="group__capi.html#ga117c55aa5044b5706df0a1926b630857" title="Return the number of theory applications in the logical context. These are the expressions...">Z3_theory_get_num_apps</a>(m_theory);
<a name="l03410"></a>03410             array&lt;TermPtr&gt;^ result = <span class="keyword">gcnew</span> array&lt;TermPtr&gt;(n);
<a name="l03411"></a>03411             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)
<a name="l03412"></a>03412             {
<a name="l03413"></a>03413                 result[i] = TermPtr(<a class="code" href="group__capi.html#gac2ad9c9d6f677433ca27b4cf7466c56c" title="Return the i-th application of the given theory in the logical context.">Z3_theory_get_app</a>(m_theory, i));
<a name="l03414"></a>03414             }
<a name="l03415"></a>03415             <span class="keywordflow">return</span> result;
<a name="l03416"></a>03416         }
<a name="l03417"></a>03417 
<a name="l03418"></a>03418         SortPtr MkSort(Symbol^ s) 
<a name="l03419"></a>03419         {
<a name="l03420"></a>03420             <span class="keywordflow">return</span> SortPtr(<a class="code" href="group__capi.html#gaca80d3711728d0d492cd53ea6dda73a0" title="Create an interpreted theory sort.">Z3_theory_mk_sort</a>(m_context(), m_theory, s-&gt;get()));
<a name="l03421"></a>03421         }
<a name="l03422"></a>03422         
<a name="l03423"></a>03423         TermPtr MkValue(Symbol^ s, SortPtr srt) 
<a name="l03424"></a>03424         {
<a name="l03425"></a>03425             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga239d03127793eeff0bdffbe335eed83a" title="Create an interpreted theory constant value. Values are assumed to be different from...">Z3_theory_mk_value</a>(m_context(), m_theory, s-&gt;get(), get_sort(srt)));
<a name="l03426"></a>03426         }
<a name="l03427"></a>03427         
<a name="l03428"></a>03428         TermPtr MkConstant(Symbol^ s, SortPtr srt)
<a name="l03429"></a>03429         {
<a name="l03430"></a>03430             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gab91110cd869988342168cef30f311671" title="Create an interpreted constant for the given theory.">Z3_theory_mk_constant</a>(m_context(), m_theory, s-&gt;get(), get_sort(srt)));
<a name="l03431"></a>03431         }
<a name="l03432"></a>03432         
<a name="l03433"></a>03433         FuncDeclPtr MkFuncDecl(Symbol^ n, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l03434"></a>03434 
<a name="l03435"></a>03435         SortPtr MkSort(String^ s);
<a name="l03436"></a>03436         
<a name="l03437"></a>03437         TermPtr MkValue(String^ s, SortPtr srt); 
<a name="l03438"></a>03438         
<a name="l03439"></a>03439         TermPtr MkConstant(String^ s, SortPtr srt);
<a name="l03440"></a>03440         
<a name="l03441"></a>03441         FuncDeclPtr MkFuncDecl(String^ n, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l03442"></a>03442                 
<a name="l03443"></a>03443     };
<a name="l03444"></a>03444 
<a name="l03445"></a>03445 
<a name="l03446"></a>03446     <span class="keyword">ref class</span> Context;
<a name="l03447"></a>03447     <span class="keyword">ref class</span> Model;
<a name="l03448"></a>03448     <span class="keyword">ref class</span> Theory;
<a name="l03449"></a>03449 
<a name="l03450"></a>03450     <span class="keyword">public ref class</span> Ast : <span class="keyword">public</span> System::IComparable {
<a name="l03451"></a>03451     <span class="keyword">protected</span>:
<a name="l03452"></a>03452         AstPtr      m_ast;
<a name="l03453"></a>03453         RawContext^ m_ctx;
<a name="l03454"></a>03454         !Ast();
<a name="l03455"></a>03455     <span class="keyword">internal</span>:
<a name="l03456"></a>03456         Ast(RawContext^ c, AstPtr a);
<a name="l03457"></a>03457         AstPtr GetPtr() { <span class="keywordflow">return</span> m_ast; }
<a name="l03458"></a>03458         AstPtr operator()() { <span class="keywordflow">return</span> m_ast; }
<a name="l03459"></a>03459     <span class="keyword">public</span>:
<a name="l03460"></a>03460         ~Ast();
<a name="l03461"></a>03461 
<a name="l03465"></a>03465         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> Equals(Object^ obj) <span class="keyword">override</span>;
<a name="l03466"></a>03466 
<a name="l03470"></a>03470         <span class="keyword">virtual</span> <span class="keywordtype">int</span> GetHashCode() <span class="keyword">override</span>;
<a name="l03471"></a>03471 
<a name="l03475"></a>03475         <span class="keyword">virtual</span> String^ ToString() <span class="keyword">override</span>;
<a name="l03476"></a>03476 
<a name="l03480"></a>03480         <span class="keyword">virtual</span> <span class="keywordtype">int</span> CompareTo(Object^ other);
<a name="l03481"></a>03481 
<a name="l03485"></a>03485         <span class="comment">// virtual bool operator==(Object^ other);</span>
<a name="l03486"></a>03486 
<a name="l03487"></a>03487         <span class="comment">// virtual bool operator!=(Object^ other);</span>
<a name="l03488"></a>03488 
<a name="l03489"></a>03489         <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> GetId() { <span class="keywordflow">return</span> m_ctx-&gt;GetTermId(m_ast); }
<a name="l03490"></a>03490     };
<a name="l03491"></a>03491 
<a name="l03492"></a>03492     <span class="keyword">public ref class</span> Sort : <span class="keyword">public</span> Ast{
<a name="l03493"></a>03493     <span class="keyword">internal</span>:
<a name="l03494"></a>03494         Sort(RawContext^ c, SortPtr a) : Ast(c,a) {}
<a name="l03495"></a>03495     <span class="keyword">public</span>:
<a name="l03496"></a>03496         String^ GetName();
<a name="l03497"></a>03497         <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> GetId()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_ctx-&gt;GetSortId(m_ast); }
<a name="l03498"></a>03498     };
<a name="l03499"></a>03499 
<a name="l03500"></a>03500     <span class="keyword">public ref class</span> FuncDecl : <span class="keyword">public</span> Ast {
<a name="l03501"></a>03501     <span class="keyword">internal</span>:
<a name="l03502"></a>03502         FuncDecl(RawContext^ c, FuncDeclPtr a) : Ast(c,a) {}
<a name="l03503"></a>03503     <span class="keyword">public</span>:
<a name="l03504"></a>03504         String^ GetDeclName();
<a name="l03505"></a>03505         <a class="code" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425" title="Different kinds of Z3 built-in declarations (See GetDeclKind).">DeclKind</a> GetKind();
<a name="l03506"></a>03506         <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> GetId()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_ctx-&gt;GetFuncDeclId(m_ast); }
<a name="l03507"></a>03507     };
<a name="l03508"></a>03508 
<a name="l03509"></a>03509     <span class="keyword">public ref class</span> Term : <span class="keyword">public</span> Ast {
<a name="l03510"></a>03510     <span class="keyword">internal</span>:
<a name="l03511"></a>03511         Term(RawContext^ c, TermPtr a) : Ast(c,a) {}
<a name="l03512"></a>03512     <span class="keyword">public</span>:
<a name="l03518"></a>03518         <span class="keyword">static</span> Term^ operator!(Term^ t1);
<a name="l03519"></a>03519         <span class="keyword">static</span> Term^ operator&amp;(Term^ t1, Term^ t2);
<a name="l03520"></a>03520         <span class="keyword">static</span> Term^ operator|(Term^ t1, Term^ t2);
<a name="l03521"></a>03521         <span class="keyword">static</span> Term^ operator^(Term^ t1, Term^ t2);
<a name="l03527"></a>03527         <span class="keyword">static</span> Term^ operator+(Term^ t1, Term^ t2);
<a name="l03528"></a>03528         <span class="keyword">static</span> Term^ operator*(Term^ t1, Term^ t2);
<a name="l03529"></a>03529         <span class="keyword">static</span> Term^ operator/(Term^ t1, Term^ t2);
<a name="l03530"></a>03530         <span class="keyword">static</span> Term^ operator-(Term^ t1, Term^ t2);
<a name="l03531"></a>03531         <span class="keyword">static</span> Term^ operator&gt;(Term^ t1, Term^ t2);
<a name="l03532"></a>03532         <span class="keyword">static</span> Term^ operator&lt;(Term^ t1, Term^ t2);
<a name="l03533"></a>03533         <span class="keyword">static</span> Term^ operator&gt;=(Term^ t1, Term^ t2);
<a name="l03534"></a>03534         <span class="keyword">static</span> Term^ operator&lt;=(Term^ t1, Term^ t2);
<a name="l03535"></a>03535 
<a name="l03541"></a>03541         Term^ operator[](Term^ index);
<a name="l03542"></a>03542 
<a name="l03543"></a>03543         <a class="code" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc" title="The different kinds of Z3 Terms.">TermKind</a> GetKind();
<a name="l03544"></a>03544         FuncDecl^ GetAppDecl();
<a name="l03545"></a>03545         array&lt;Term^&gt;^ GetAppArgs();
<a name="l03546"></a>03546         Sort^ GetSort();
<a name="l03547"></a>03547         String^ GetNumeralString();
<a name="l03548"></a>03548         <span class="keywordtype">unsigned</span> GetVarIndex();
<a name="l03549"></a>03549         <span class="keyword">ref class</span> Quantifier^ GetQuantifier();
<a name="l03550"></a>03550     };
<a name="l03551"></a>03551     
<a name="l03552"></a>03552     <span class="keyword">public ref class</span> Pattern : <span class="keyword">public</span> Ast {
<a name="l03553"></a>03553     <span class="keyword">internal</span>:
<a name="l03554"></a>03554         Pattern(RawContext^ c, PatternPtr a) : Ast(c,a) {}
<a name="l03555"></a>03555     };
<a name="l03556"></a>03556 
<a name="l03557"></a>03557     <span class="keyword">public ref class</span> Quantifier {
<a name="l03558"></a>03558     <span class="keyword">public</span>:
<a name="l03559"></a>03559         <span class="keywordtype">bool</span>                  IsForall;
<a name="l03560"></a>03560         <span class="keywordtype">unsigned</span>              Weight;
<a name="l03561"></a>03561         array&lt;Pattern^&gt;^      Patterns;
<a name="l03562"></a>03562         array&lt;Term^&gt;^         NoPatterns;
<a name="l03563"></a>03563         array&lt;Sort^&gt;^         Sorts;
<a name="l03564"></a>03564         array&lt;Symbol^&gt;^       Names;
<a name="l03565"></a>03565         Term^                 Body;
<a name="l03566"></a>03566     };
<a name="l03567"></a>03567 
<a name="l03568"></a>03568     <span class="keyword">public ref class</span> ArrayValue {
<a name="l03569"></a>03569     <span class="keyword">public</span>:
<a name="l03570"></a>03570         array&lt;Term^&gt;^   Domain; 
<a name="l03571"></a>03571         array&lt;Term^&gt;^   Range;
<a name="l03572"></a>03572         Term^           ElseCase;
<a name="l03573"></a>03573     };
<a name="l03574"></a>03574 
<a name="l03575"></a>03575     <span class="keyword">public ref class</span> TermParameter : <span class="keyword">public</span> IParameter  { 
<a name="l03576"></a>03576         Term^ m_value;
<a name="l03577"></a>03577     <span class="keyword">internal</span>:
<a name="l03578"></a>03578         TermParameter(Term^ t) : m_value(t) {}
<a name="l03579"></a>03579     <span class="keyword">public</span>:
<a name="l03580"></a>03580         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value-&gt;ToString(); }
<a name="l03581"></a>03581         <span class="keyword">property</span>  Term^ GetTerm {  Term^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l03582"></a>03582     };
<a name="l03583"></a>03583 
<a name="l03584"></a>03584     <span class="keyword">public ref class</span> SortParameter : <span class="keyword">public</span> IParameter  { 
<a name="l03585"></a>03585         Sort^ m_value;
<a name="l03586"></a>03586     <span class="keyword">internal</span>:
<a name="l03587"></a>03587         SortParameter(Sort^ s): m_value(s) {}
<a name="l03588"></a>03588     <span class="keyword">public</span>:
<a name="l03589"></a>03589         <span class="keyword">property</span>  Sort^ GetSort {  Sort^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l03590"></a>03590         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value-&gt;ToString(); }
<a name="l03591"></a>03591     };
<a name="l03592"></a>03592 
<a name="l03593"></a>03593     <span class="keyword">public ref class</span> FuncDeclParameter : <span class="keyword">public</span> IParameter  { 
<a name="l03594"></a>03594         FuncDecl^ m_value;
<a name="l03595"></a>03595     <span class="keyword">internal</span>:
<a name="l03596"></a>03596         FuncDeclParameter(FuncDecl^ d): m_value(d) {}
<a name="l03597"></a>03597     <span class="keyword">public</span>:
<a name="l03598"></a>03598         <span class="keyword">property</span>  FuncDecl^ GetFuncDecl { FuncDecl^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l03599"></a>03599         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value-&gt;ToString(); } 
<a name="l03600"></a>03600     };
<a name="l03601"></a>03601 
<a name="l03605"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_term_proof.html">03605</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_term_proof.html" title="Term and optional proof object returned by user-simplifier.">TermProof</a> {
<a name="l03606"></a>03606         Term^ m_term;
<a name="l03607"></a>03607         Term^ m_proof; <span class="comment">// proof is optional, use null for absence of proofs.</span>
<a name="l03608"></a>03608     <span class="keyword">public</span>:
<a name="l03609"></a>03609         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_term_proof.html" title="Term and optional proof object returned by user-simplifier.">TermProof</a>(Term^ term, Term^ proof): m_term(term), m_proof(proof) {}
<a name="l03610"></a>03610         <span class="keyword">property</span> Term^ GetTerm { Term^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_term; } }
<a name="l03611"></a>03611         <span class="keyword">property</span> Term^ Proof { Term^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_proof; } }
<a name="l03612"></a>03612     };
<a name="l03613"></a>03613 
<a name="l03617"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html">03617</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html" title="Type safe contexts.">Context</a>  {
<a name="l03618"></a>03618         
<a name="l03620"></a>03620         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ m_ctx;
<a name="l03621"></a>03621 
<a name="l03622"></a>03622 
<a name="l03623"></a>03623     <span class="keyword">public</span>:
<a name="l03624"></a>03624         <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tptr, <span class="keyword">class</span> T&gt;
<a name="l03625"></a>03625         array&lt;Tptr&gt;^ CopyArray(array&lt;T^&gt;^ a) {
<a name="l03626"></a>03626             <span class="keywordflow">if</span> (!a) {
<a name="l03627"></a>03627                 <span class="keywordflow">return</span> <span class="keyword">gcnew</span> array&lt;Tptr&gt;(0);
<a name="l03628"></a>03628             }
<a name="l03629"></a>03629             <span class="keywordtype">int</span> len = a-&gt;Length;
<a name="l03630"></a>03630             array&lt;Tptr&gt;^ result = <span class="keyword">gcnew</span> array&lt;Tptr&gt;(len);
<a name="l03631"></a>03631             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i) {
<a name="l03632"></a>03632                 <span class="keywordflow">if</span> (a[i]) {
<a name="l03633"></a>03633                     result[i] = a[i]();
<a name="l03634"></a>03634                 }
<a name="l03635"></a>03635                 <span class="keywordflow">else</span> {
<a name="l03636"></a>03636                     result[i] = IntPtr(0);
<a name="l03637"></a>03637                 }
<a name="l03638"></a>03638             }
<a name="l03639"></a>03639             <span class="keywordflow">return</span> result;
<a name="l03640"></a>03640         }
<a name="l03641"></a>03641 
<a name="l03642"></a>03642         array&lt;SortPtr&gt;^ CopyArray(array&lt;Sort^&gt;^ a) {
<a name="l03643"></a>03643             <span class="keywordflow">return</span> CopyArray&lt;SortPtr, Sort&gt;(a);
<a name="l03644"></a>03644         }
<a name="l03645"></a>03645 
<a name="l03646"></a>03646         array&lt;FuncDeclPtr&gt;^ CopyArray(array&lt;FuncDecl^&gt;^ a) {
<a name="l03647"></a>03647             <span class="keywordflow">return</span> CopyArray&lt;FuncDeclPtr, FuncDecl&gt;(a);
<a name="l03648"></a>03648         }
<a name="l03649"></a>03649 
<a name="l03650"></a>03650         array&lt;TermPtr&gt;^ CopyArray(array&lt;Term^&gt;^ a) {
<a name="l03651"></a>03651             <span class="keywordflow">return</span> CopyArray&lt;TermPtr,Term&gt;(a);
<a name="l03652"></a>03652         }
<a name="l03653"></a>03653 
<a name="l03654"></a>03654         array&lt;PatternPtr&gt;^ CopyArray(array&lt;Pattern^&gt;^ a) {
<a name="l03655"></a>03655             <span class="keywordflow">return</span> CopyArray&lt;PatternPtr,Pattern&gt;(a);
<a name="l03656"></a>03656         }
<a name="l03657"></a>03657     <span class="keyword">internal</span>:
<a name="l03658"></a>03658 
<a name="l03659"></a>03659         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> TPtr&gt;
<a name="l03660"></a>03660         <span class="keyword">static</span> array&lt;T^&gt;^ CopyAstArray(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ ctx, array&lt;TPtr&gt;^ a) {
<a name="l03661"></a>03661             <span class="keywordflow">if</span> (!a) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l03662"></a>03662             <span class="keywordtype">int</span> len = a-&gt;Length;
<a name="l03663"></a>03663             array&lt;T^&gt;^ result = <span class="keyword">gcnew</span> array&lt;T^&gt;(len);
<a name="l03664"></a>03664 
<a name="l03665"></a>03665             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i) {
<a name="l03666"></a>03666                 <span class="keywordflow">if</span> (a[i] != IntPtr(0)) {
<a name="l03667"></a>03667                     result[i] = <span class="keyword">gcnew</span> T(ctx,a[i]);
<a name="l03668"></a>03668                 }
<a name="l03669"></a>03669                 <span class="keywordflow">else</span> {
<a name="l03670"></a>03670                     result[i] = <span class="keyword">nullptr</span>;
<a name="l03671"></a>03671                 }
<a name="l03672"></a>03672             }
<a name="l03673"></a>03673             <span class="keywordflow">return</span> result;
<a name="l03674"></a>03674         }
<a name="l03675"></a>03675 
<a name="l03676"></a>03676     <span class="keyword">public</span>:
<a name="l03677"></a>03677         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> TPtr&gt;
<a name="l03678"></a>03678         array&lt;T^&gt;^ CopyAstArray(array&lt;TPtr&gt;^ a) {
<a name="l03679"></a>03679             <span class="keywordflow">return</span> CopyAstArray&lt;T,TPtr&gt;(m_ctx, a);
<a name="l03680"></a>03680         }
<a name="l03681"></a>03681 
<a name="l03682"></a>03682 
<a name="l03683"></a>03683         array&lt;Sort^&gt;^ CopySortArray(array&lt;SortPtr&gt;^ a) {
<a name="l03684"></a>03684             <span class="keywordflow">return</span> CopyAstArray&lt;Sort, SortPtr&gt;(a);
<a name="l03685"></a>03685         }
<a name="l03686"></a>03686 
<a name="l03687"></a>03687         array&lt;Term^&gt;^ CopyTermArray(array&lt;TermPtr&gt;^ a) {
<a name="l03688"></a>03688             <span class="keywordflow">return</span> CopyAstArray&lt;Term, TermPtr&gt;(a);
<a name="l03689"></a>03689         }
<a name="l03690"></a>03690 
<a name="l03691"></a>03691         array&lt;FuncDecl^&gt;^ CopyFuncDeclArray(array&lt;FuncDeclPtr&gt;^ a) {
<a name="l03692"></a>03692             <span class="keywordflow">return</span> CopyAstArray&lt;FuncDecl, FuncDeclPtr&gt;(a);
<a name="l03693"></a>03693         }
<a name="l03694"></a>03694     <span class="keyword">internal</span>:
<a name="l03695"></a>03695         <span class="keyword">static</span> array&lt;Term^&gt;^ CopyTermArray(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ ctx, array&lt;TermPtr&gt;^ a) {
<a name="l03696"></a>03696             <span class="keywordflow">return</span> CopyAstArray&lt;Term, TermPtr&gt;(ctx, a);
<a name="l03697"></a>03697         }
<a name="l03698"></a>03698 
<a name="l03699"></a>03699         <span class="keyword">static</span> array&lt;Sort^&gt;^ CopySortArray(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ ctx, array&lt;SortPtr&gt;^ a) {
<a name="l03700"></a>03700             <span class="keywordflow">return</span> CopyAstArray&lt;Sort, SortPtr&gt;(ctx, a);
<a name="l03701"></a>03701         }
<a name="l03702"></a>03702         <span class="keyword">static</span> Quantifier^ GetQuantifier(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ ctx, Term^ term);
<a name="l03703"></a>03703 
<a name="l03704"></a>03704     <span class="keyword">internal</span>:
<a name="l03705"></a>03705         <span class="keyword">property</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ GetContext { <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_ctx; } }
<a name="l03706"></a>03706 
<a name="l03708"></a>03708 
<a name="l03709"></a>03709 
<a name="l03710"></a>03710     <span class="keyword">public</span>:
<a name="l03723"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a7540648fc201ffee17e0cdea0888a6f7">03723</a>         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a7540648fc201ffee17e0cdea0888a6f7" title="Create a type safe version of a context.">Context</a>() { m_ctx = <span class="keyword">gcnew</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>(); }
<a name="l03724"></a>03724 
<a name="l03725"></a>03725         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a7540648fc201ffee17e0cdea0888a6f7" title="Create a type safe version of a context.">Context</a>(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_config.html" title="Configuration.">Config</a>^ config) : m_ctx(gcnew <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>(config)) {}
<a name="l03726"></a>03726 
<a name="l03727"></a>03727         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a7540648fc201ffee17e0cdea0888a6f7" title="Create a type safe version of a context.">Context</a>(Config^ config, ReferenceCounted^ rc) : m_ctx(gcnew RawContext(config, rc)) {}
<a name="l03728"></a>03728 
<a name="l03732"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a744ae2a046b90c3685f19b9edb14ad08">03732</a>         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a744ae2a046b90c3685f19b9edb14ad08" title="Set the context from an externally created context.">SetContext</a>(Z3_context ctx){ m_ctx-&gt;SetContext(ctx); }
<a name="l03733"></a>03733 
<a name="l03737"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#ad2cdbdf8ca6efd618beb4f0c416e02f9">03737</a>         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#ad2cdbdf8ca6efd618beb4f0c416e02f9" title="Dispose method for type safe contexts.">~Context</a>() { m_ctx-&gt;Reset(); }
<a name="l03738"></a>03738 
<a name="l03745"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#ae767eef7c521b644401e58a4adfb11a6">03745</a>         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#ae767eef7c521b644401e58a4adfb11a6" title="Enable low-level debug tracing.">EnableDebugTrace</a>(String^ tag) { m_ctx-&gt;EnableDebugTrace(tag); }
<a name="l03746"></a>03746 
<a name="l03754"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a74d274e8e6fc3ccc4ac39a375c0cc536">03754</a>         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a74d274e8e6fc3ccc4ac39a375c0cc536" title="Enable or disable warning messages sent to the console out/error.">ToggleWarningMessages</a>(<span class="keywordtype">bool</span> enabled) { m_ctx-&gt;ToggleWarningMessages(enabled); }
<a name="l03755"></a>03755 
<a name="l03756"></a>03756         <span class="keywordtype">void</span> UpdateParamValue(String^ param_id, String^ value) { m_ctx-&gt;UpdateParamValue(param_id, value); }
<a name="l03757"></a>03757 
<a name="l03758"></a>03758         String^ GetParamValue(String^ param_id) {
<a name="l03759"></a>03759             <span class="keywordflow">return</span> m_ctx-&gt;GetParamValue(param_id);
<a name="l03760"></a>03760         }
<a name="l03761"></a>03761 
<a name="l03766"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a925fd320cf1476d3b08d70f169c6790d">03766</a>         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a925fd320cf1476d3b08d70f169c6790d" title="Configure the SMTLIB logic to be used in the given logical context.">SetLogic</a>(String^ logic) { <span class="keywordflow">return</span> m_ctx-&gt;SetLogic(logic); }
<a name="l03767"></a>03767 
<a name="l03772"></a>03772         <a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ MkSymbol(<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> m_ctx-&gt;MkSymbol(i); }
<a name="l03773"></a>03773 
<a name="l03774"></a>03774         Symbol^ MkSymbol(String^ s) { <span class="keywordflow">return</span> m_ctx-&gt;MkSymbol(s); }
<a name="l03781"></a>03781 
<a name="l03787"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a5a3ac3b1e5482150708ba24cddaf1f4d">03787</a>         Term^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a5a3ac3b1e5482150708ba24cddaf1f4d" title="Update the arguments of a term or quantifier.">UpdateTerm</a>(Term^ t, array&lt;Term^&gt;^ new_args) {
<a name="l03788"></a>03788             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;UpdateTerm(t(), CopyArray(new_args)));
<a name="l03789"></a>03789         }
<a name="l03790"></a>03790         
<a name="l03797"></a>03797         <span class="keywordtype">void</span> Push() { m_ctx-&gt;Push(); }
<a name="l03798"></a>03798         <span class="keywordtype">void</span> Pop(<span class="keywordtype">unsigned</span> num_scopes) { m_ctx-&gt;Pop(num_scopes); }
<a name="l03799"></a>03799         <span class="keywordtype">void</span> Pop() { Pop(1); }
<a name="l03800"></a>03800         <span class="keywordtype">unsigned</span> GetNumScopes() { <span class="keywordflow">return</span> m_ctx-&gt;GetNumScopes(); }
<a name="l03801"></a>03801         <span class="keywordtype">void</span> PersistTerm(Term^ t, <span class="keywordtype">unsigned</span> num_scopes) { 
<a name="l03802"></a>03802             m_ctx-&gt;PersistTerm(t(), num_scopes); 
<a name="l03803"></a>03803         }
<a name="l03804"></a>03804         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> Check() { <span class="keywordflow">return</span> m_ctx-&gt;Check(); }
<a name="l03805"></a>03805         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> CheckAndGetModel([Out] Model^% m);
<a name="l03806"></a>03806         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> CheckAssumptions([Out] Model^% m, 
<a name="l03807"></a>03807                                [In]  array&lt;Term^&gt;^ assumptions, 
<a name="l03808"></a>03808                                [Out] Term^% proof, 
<a name="l03809"></a>03809                                [Out] array&lt;Term^&gt;^% core);
<a name="l03810"></a>03810         <span class="keywordtype">void</span> SoftCheckCancel();
<a name="l03811"></a>03811 
<a name="l03812"></a>03812         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> GetImpliedEqualities(
<a name="l03813"></a>03813             [In]  array&lt;Term^&gt;^ terms,
<a name="l03814"></a>03814             [Out] array&lt;unsigned&gt;^% class_ids);
<a name="l03815"></a>03815 
<a name="l03816"></a>03816         <a class="code" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e" title="Different failure kinds.">SearchFailureExplanation</a> GetSearchFailureExplanation() { <span class="keywordflow">return</span> m_ctx-&gt;GetSearchFailureExplanation(); }
<a name="l03817"></a>03817         LabeledLiterals^ GetRelevantLabels() { <span class="keywordflow">return</span> m_ctx-&gt;GetRelevantLabels(); }
<a name="l03818"></a>03818         LabeledLiterals^ GetRelevantLiterals() { <span class="keywordflow">return</span> m_ctx-&gt;GetRelevantLiterals(); }
<a name="l03819"></a>03819         LabeledLiterals^ GetGuessedLiterals() { <span class="keywordflow">return</span> m_ctx-&gt;GetGuessedLiterals(); }
<a name="l03820"></a>03820         <span class="keywordtype">void</span> BlockLiterals(LabeledLiterals^ lbls) { m_ctx-&gt;BlockLiterals(lbls); }
<a name="l03821"></a>03821         Term^ GetLiteral(LabeledLiterals^ lbls, <span class="keywordtype">unsigned</span> idx) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;GetLiteral(lbls, idx)); }
<a name="l03822"></a>03822         Term^ Simplify(Term^ a) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;Simplify(a())); }
<a name="l03823"></a>03823         <span class="keywordtype">void</span> AssertCnstr(Term^ a) { m_ctx-&gt;AssertCnstr(a()); }
<a name="l03826"></a>03826         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_ctx-&gt;ToString(); }
<a name="l03827"></a>03827 
<a name="l03828"></a>03828         <span class="keywordtype">void</span> Display(System::IO::TextWriter^ w) { m_ctx-&gt;Display(w); }
<a name="l03829"></a>03829         Term^ GetAssignments() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;GetAssignments()); }
<a name="l03830"></a>03830         String^ StatisticsToString() { <span class="keywordflow">return</span> m_ctx-&gt;StatisticsToString(); }
<a name="l03831"></a>03831         <span class="keywordtype">void</span> DisplayStatistics(System::IO::TextWriter^ w) { m_ctx-&gt;DisplayStatistics(w); }
<a name="l03832"></a>03832 
<a name="l03836"></a>03836         String^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a5d16d7cb12df6994c0dda71a36922fbf" title="Convert the given benchmark into SMT-LIB formatted string.">BenchmarkToSmtlib</a>(String^ name,
<a name="l03837"></a>03837                                   String^ logic,
<a name="l03838"></a>03838                                   String^ status,
<a name="l03839"></a>03839                                   String^ attributes,
<a name="l03840"></a>03840                                   array&lt;Term^&gt;^ assumptions,
<a name="l03841"></a>03841                                   Term^ formula);
<a name="l03842"></a>03842 
<a name="l03843"></a>03843         <span class="keywordtype">void</span> ParseSmtlibString(
<a name="l03844"></a>03844             String^            <span class="keywordtype">string</span>,
<a name="l03845"></a>03845             [In]  array&lt;Sort^&gt;^     sorts,
<a name="l03846"></a>03846             [In]  array&lt;FuncDecl^&gt;^ decls,
<a name="l03847"></a>03847             [Out] array&lt;Term^&gt;^%    assumptions,            
<a name="l03848"></a>03848             [Out] array&lt;Term^&gt;^%    formulas,
<a name="l03849"></a>03849             [Out] array&lt;FuncDecl^&gt;^% new_decls,
<a name="l03850"></a>03850             [Out] array&lt;Sort^&gt;^%    new_sorts,
<a name="l03851"></a>03851             [Out] String^% parser_out
<a name="l03852"></a>03852             );
<a name="l03853"></a>03853                                          
<a name="l03854"></a>03854 
<a name="l03855"></a>03855         <span class="keywordtype">void</span> ParseSmtlibFile(
<a name="l03856"></a>03856             String^ file,
<a name="l03857"></a>03857             [In]  array&lt;Sort^&gt;^     sorts,
<a name="l03858"></a>03858             [In]  array&lt;FuncDecl^&gt;^ decls,
<a name="l03859"></a>03859             [Out] array&lt;Term^&gt;^%    assumptions,            
<a name="l03860"></a>03860             [Out] array&lt;Term^&gt;^%    formulas,
<a name="l03861"></a>03861             [Out] array&lt;FuncDecl^&gt;^% new_decls,
<a name="l03862"></a>03862             [Out] array&lt;Sort^&gt;^%    new_sorts,
<a name="l03863"></a>03863             [Out] String^% parser_out
<a name="l03864"></a>03864             );
<a name="l03865"></a>03865 
<a name="l03866"></a>03866 
<a name="l03867"></a>03867         Term^ ParseZ3String(String^ s) {
<a name="l03868"></a>03868             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ParseZ3String(s));
<a name="l03869"></a>03869         }
<a name="l03870"></a>03870 
<a name="l03871"></a>03871         Term^ ParseZ3File(String^ s) {
<a name="l03872"></a>03872             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ParseZ3File(s));
<a name="l03873"></a>03873         }
<a name="l03874"></a>03874 
<a name="l03875"></a>03875         Term^ ParseSmtlib2String(String^ s, array&lt;Sort^&gt;^ sorts, array&lt;FuncDecl^&gt;^ decls) {
<a name="l03876"></a>03876             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ParseSmtlib2String(s, CopyArray(sorts), CopyArray(decls)));
<a name="l03877"></a>03877         }
<a name="l03878"></a>03878 
<a name="l03879"></a>03879         Term^ ParseSmtlib2File(String^ s, array&lt;Sort^&gt;^ sorts, array&lt;FuncDecl^&gt;^ decls) {
<a name="l03880"></a>03880             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ParseSmtlib2File(s, CopyArray(sorts), CopyArray(decls)));
<a name="l03881"></a>03881         }
<a name="l03882"></a>03882 
<a name="l03883"></a>03883         Term^ ExecSmtlib2String(String^ s, array&lt;Sort^&gt;^ sorts, array&lt;FuncDecl^&gt;^ decls) {
<a name="l03884"></a>03884             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ExecSmtlib2String(s, CopyArray(sorts), CopyArray(decls)));
<a name="l03885"></a>03885         }
<a name="l03886"></a>03886 
<a name="l03887"></a>03887         Term^ ExecSmtlib2File(String^ s, array&lt;Sort^&gt;^ sorts, array&lt;FuncDecl^&gt;^ decls) {
<a name="l03888"></a>03888             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ExecSmtlib2File(s, CopyArray(sorts), CopyArray(decls)));
<a name="l03889"></a>03889         }
<a name="l03890"></a>03890 
<a name="l03891"></a>03891         <span class="keyword">static</span> <span class="keywordtype">void</span> SetErrorHandler(IErrorHandler^ h) {
<a name="l03892"></a>03892             <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a22af33e79aad8e443bfe2c249c6255ef" title="Register a Z3 error handler.">RawContext::SetErrorHandler</a>(h);
<a name="l03893"></a>03893         }
<a name="l03894"></a>03894 
<a name="l03895"></a>03895         <span class="keyword">static</span> String^ GetErrorMessage(<a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> err) {
<a name="l03896"></a>03896             <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a8478b135914c2e8c78127a50361331c4" title="Return a string describing the given error code.">RawContext::GetErrorMessage</a>(err);
<a name="l03897"></a>03897         }
<a name="l03898"></a>03898 
<a name="l03899"></a>03899         <span class="keyword">static</span> <span class="keywordtype">void</span> ResetMemory() {
<a name="l03900"></a>03900             <a class="code" href="class_microsoft_1_1_z3_v3_1_1_raw_context.html#a6bcc908b9ba41cd95dae64006321b34b" title="Free all resources allocated for Z3.">RawContext::ResetMemory</a>();
<a name="l03901"></a>03901         }
<a name="l03902"></a>03902 
<a name="l03903"></a>03903         
<a name="l03904"></a>03904         <span class="keywordtype">void</span> SetPrintMode(<a class="code" href="group__mapi.html#ga8fcc700aeeee633213b4e5f433e5e12e" title="Z3 pretty printing modes used when pretty printing terms.">PrintMode</a> mode) { m_ctx-&gt;SetPrintMode(mode); }
<a name="l03905"></a>03905 
<a name="l03906"></a>03906         String^ ToString(Ast^ a) { <span class="keywordflow">return</span> m_ctx-&gt;ToString(a()); }
<a name="l03907"></a>03907         
<a name="l03908"></a>03908         <span class="keywordtype">void</span> Display(System::IO::TextWriter^ w, Ast^ a) { m_ctx-&gt;Display(w, a()); }
<a name="l03909"></a>03909 
<a name="l03910"></a>03910 
<a name="l03911"></a>03911         Sort^ MkIntSort() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkIntSort()); }
<a name="l03912"></a>03912         Sort^ MkBoolSort() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkBoolSort()); }
<a name="l03913"></a>03913         Sort^ MkSort(Symbol^ s) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkSort(s)); }
<a name="l03914"></a>03914         Sort^ MkSort(String^ s) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkSort(s)); }
<a name="l03915"></a>03915         Sort^ MkSort(<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkSort(i)); }   
<a name="l03916"></a>03916         Sort^ MkFiniteDomainSort(String^ s, <span class="keywordtype">unsigned</span> __int64 domain_size) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx, m_ctx-&gt;MkFiniteDomainSort(s, domain_size)); }
<a name="l03917"></a>03917         Sort^ MkRealSort() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkRealSort()); } 
<a name="l03918"></a>03918         Sort^ MkBvSort(<span class="keywordtype">unsigned</span> sz) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkBvSort(sz)); }
<a name="l03919"></a>03919         Sort^ MkArraySort(Sort^ domain, Sort^ range) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkArraySort(domain(), range())); }
<a name="l03920"></a>03920 
<a name="l03921"></a>03921         Sort^ MkTupleSort(
<a name="l03922"></a>03922             Symbol^               mk_tuple_name, 
<a name="l03923"></a>03923             array&lt;Symbol^&gt;^       field_names,
<a name="l03924"></a>03924             array&lt;Sort^&gt;^       field_types,
<a name="l03925"></a>03925             [Out] FuncDecl^%         mk_tuple_decl,
<a name="l03926"></a>03926             [In, Out] array&lt;FuncDecl^&gt;^  proj_decl
<a name="l03927"></a>03927             );
<a name="l03928"></a>03928 
<a name="l03929"></a>03929         Sort^ MkTupleSort(
<a name="l03930"></a>03930             String^               mk_tuple_name, 
<a name="l03931"></a>03931             array&lt;String^&gt;^       field_names,
<a name="l03932"></a>03932             array&lt;Sort^&gt;^       field_types,
<a name="l03933"></a>03933             [Out] FuncDecl^%         mk_tuple_decl,
<a name="l03934"></a>03934             [In, Out] array&lt;FuncDecl^&gt;^  proj_decl
<a name="l03935"></a>03935             );
<a name="l03936"></a>03936         
<a name="l03937"></a>03937         Sort^ MkEnumerationSort(
<a name="l03938"></a>03938             String^             name,
<a name="l03939"></a>03939             array&lt;String^&gt;^     enum_names,
<a name="l03940"></a>03940             array&lt;FuncDecl^&gt;^ enum_consts,
<a name="l03941"></a>03941             array&lt;FuncDecl^&gt;^ enum_testers);
<a name="l03942"></a>03942 
<a name="l03943"></a>03943         Sort^ MkListSort(
<a name="l03944"></a>03944             String^ name,
<a name="l03945"></a>03945             Sort^ elem_sort,
<a name="l03946"></a>03946             [Out] FuncDecl^% nil_decl,
<a name="l03947"></a>03947             [Out] FuncDecl^% is_nil_decl,
<a name="l03948"></a>03948             [Out] FuncDecl^% cons_decl,
<a name="l03949"></a>03949             [Out] FuncDecl^% is_cons_decl,
<a name="l03950"></a>03950             [Out] FuncDecl^% head_decl,
<a name="l03951"></a>03951             [Out] FuncDecl^% tail_decl
<a name="l03952"></a>03952             );
<a name="l03953"></a>03953         
<a name="l03954"></a>03954         Constructor^ MkConstructor(
<a name="l03955"></a>03955             String^ name,
<a name="l03956"></a>03956             String^ tester,
<a name="l03957"></a>03957             array&lt;String^&gt;^ field_names,
<a name="l03958"></a>03958             array&lt;Sort^&gt;^ field_sorts,
<a name="l03959"></a>03959             array&lt;unsigned&gt;^ field_refs
<a name="l03960"></a>03960             );
<a name="l03961"></a>03961 
<a name="l03962"></a>03962         
<a name="l03963"></a>03963         FuncDecl^ GetConstructor(Constructor^ c);
<a name="l03964"></a>03964 
<a name="l03965"></a>03965         FuncDecl^ GetTester(Constructor^ c);
<a name="l03966"></a>03966 
<a name="l03967"></a>03967         array&lt;FuncDecl^&gt;^ GetAccessors(Constructor^ c);
<a name="l03968"></a>03968 
<a name="l03973"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#ace7e5666615a724df78e10093a19e70f">03973</a>         Sort^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#ace7e5666615a724df78e10093a19e70f" title="create datatype sort.">MkDataType</a>(
<a name="l03974"></a>03974             String^ name,
<a name="l03975"></a>03975             array&lt;Constructor^&gt;^ constructors
<a name="l03976"></a>03976             ) {
<a name="l03977"></a>03977             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx, m_ctx-&gt;MkDataType(name, constructors));
<a name="l03978"></a>03978         }
<a name="l03979"></a>03979 
<a name="l03984"></a><a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a9888fb987071bd35392f5d6b33353f31">03984</a>         array&lt;Sort^&gt;^ <a class="code" href="class_microsoft_1_1_z3_v3_1_1_context.html#a9888fb987071bd35392f5d6b33353f31" title="create datatype sort.">MkDataTypes</a>(
<a name="l03985"></a>03985             array&lt;String^&gt;^ names,
<a name="l03986"></a>03986             array&lt;array&lt;Constructor^&gt;^&gt;^ constructors
<a name="l03987"></a>03987             ) {
<a name="l03988"></a>03988             <span class="keywordflow">return</span> CopySortArray(m_ctx-&gt;MkDataTypes(names, constructors));
<a name="l03989"></a>03989         }
<a name="l03990"></a>03990 
<a name="l03991"></a>03991 
<a name="l03992"></a>03992         FuncDecl^ MkFuncDecl(<a class="code" href="class_microsoft_1_1_z3_v3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s, array&lt;Sort^&gt;^ domain, Sort^ range) {
<a name="l03993"></a>03993             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, CopyArray(domain), range()));
<a name="l03994"></a>03994         }
<a name="l03995"></a>03995 
<a name="l03996"></a>03996         FuncDecl^ MkFuncDecl(String^ s, array&lt;Sort^&gt;^ domain, Sort^ range) {
<a name="l03997"></a>03997             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, CopyArray(domain), range()));
<a name="l03998"></a>03998         }
<a name="l03999"></a>03999 
<a name="l04000"></a>04000         FuncDecl^ MkConstDecl(Symbol^ s, Sort^ ty) {
<a name="l04001"></a>04001             <span class="keywordflow">return</span> MkFuncDecl(s, <span class="keyword">gcnew</span> array&lt;Sort^&gt;(0), ty);
<a name="l04002"></a>04002         }
<a name="l04003"></a>04003         FuncDecl^ MkFuncDecl(Symbol^ s, Sort^ domain, Sort^ range) {
<a name="l04004"></a>04004             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, domain(), range()));
<a name="l04005"></a>04005         }
<a name="l04006"></a>04006         FuncDecl^ MkFuncDecl(Symbol^ s, Sort^ d1, Sort^ d2, Sort^ range) {
<a name="l04007"></a>04007             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, d1(), d2(), range()));            
<a name="l04008"></a>04008         }
<a name="l04009"></a>04009         FuncDecl^ MkConstDecl(String^ s, Sort^ ty) {
<a name="l04010"></a>04010             <span class="keywordflow">return</span> MkFuncDecl(s, <span class="keyword">gcnew</span> array&lt;Sort^&gt;(0), ty);
<a name="l04011"></a>04011         }
<a name="l04012"></a>04012         FuncDecl^ MkFuncDecl(String^ s, Sort^ domain, Sort^ range) {
<a name="l04013"></a>04013             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, domain(), range()));
<a name="l04014"></a>04014         }
<a name="l04015"></a>04015         FuncDecl^ MkFuncDecl(String^ s, Sort^ d1, Sort^ d2, Sort^ range) {
<a name="l04016"></a>04016             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, d1(), d2(), range()));            
<a name="l04017"></a>04017         }
<a name="l04018"></a>04018         Term^ MkApp(FuncDecl^ d, array&lt;Term^&gt;^ args) {
<a name="l04019"></a>04019             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkApp(d(), CopyArray(args)));
<a name="l04020"></a>04020         }
<a name="l04021"></a>04021         Term^ MkApp(FuncDecl^ d, Term^ arg) {
<a name="l04022"></a>04022             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkApp(d(), arg()));
<a name="l04023"></a>04023         }
<a name="l04024"></a>04024         Term^ MkApp(FuncDecl^ d, Term^ arg1, Term^ arg2) {
<a name="l04025"></a>04025             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkApp(d(), arg1(), arg2()));
<a name="l04026"></a>04026         }
<a name="l04027"></a>04027         Term^ MkApp(FuncDecl^ d, Term^ arg1, Term^ arg2, Term^ arg3) {
<a name="l04028"></a>04028             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkApp(d(), arg1(), arg2(), arg3()));
<a name="l04029"></a>04029         }
<a name="l04030"></a>04030         Term^ MkConst(FuncDecl^ d) {
<a name="l04031"></a>04031             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkConst(d()));
<a name="l04032"></a>04032         }
<a name="l04033"></a>04033         Term^ MkConst(String^ s, Sort^ ty) {
<a name="l04034"></a>04034             <span class="keywordflow">return</span> <span class="keyword">gcnew</span>  Term(m_ctx,m_ctx-&gt;MkConst(s,ty()));
<a name="l04035"></a>04035         }
<a name="l04036"></a>04036         Term^ MkConst(Symbol^ s, Sort^ ty) {
<a name="l04037"></a>04037             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkConst(s, ty()));
<a name="l04038"></a>04038         }
<a name="l04039"></a>04039         FuncDecl^ MkFreshFuncDecl(String^ prefix, array&lt;Sort^&gt;^ domain, Sort^ range) {
<a name="l04040"></a>04040             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFreshFuncDecl(prefix, CopyArray(domain), range()));
<a name="l04041"></a>04041         }
<a name="l04042"></a>04042         Term^ MkFreshConst(String^ prefix, Sort^ ty) {
<a name="l04043"></a>04043             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkFreshConst(prefix, ty()));
<a name="l04044"></a>04044         }
<a name="l04045"></a>04045         Term^ MkTrue() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkTrue()); }
<a name="l04046"></a>04046         Term^ MkFalse() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkFalse()); }
<a name="l04047"></a>04047         Term^ MkLabel(Symbol^ name, <span class="keywordtype">bool</span> pos, Term^ fml) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkLabel(name, pos, fml())); }
<a name="l04048"></a>04048 
<a name="l04049"></a>04049         Term^ MkEq(Term^ l, Term^ r) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkEq(l(), r())); }
<a name="l04050"></a>04050         Term^ MkDistinct(array&lt;Term^&gt;^ args) {
<a name="l04051"></a>04051             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkDistinct(CopyArray(args))); 
<a name="l04052"></a>04052         }
<a name="l04053"></a>04053         Term^ MkNot(Term^ arg) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNot(arg())); }
<a name="l04054"></a>04054         Term^ MkIte(Term^ t1, Term^ t2, Term^ t3) {
<a name="l04055"></a>04055             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkIte(t1(), t2(), t3()));
<a name="l04056"></a>04056         }
<a name="l04057"></a>04057         Term^ MkIff(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkIff(t1(), t2()));  }
<a name="l04058"></a>04058         Term^ MkImplies(Term^ t1, Term^ t2) {<span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkImplies(t1(), t2()));}
<a name="l04059"></a>04059         Term^ MkXor(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkXor(t1(), t2())); }
<a name="l04060"></a>04060         Term^ MkAnd(array&lt;Term^&gt;^ args) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkAnd(CopyArray(args))); }
<a name="l04061"></a>04061         Term^ MkAnd(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkAnd(t1(), t2())); }
<a name="l04062"></a>04062         Term^ MkOr(array&lt;Term^&gt;^ args) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkOr(CopyArray(args))); }
<a name="l04063"></a>04063         Term^ MkOr(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkOr(t1(), t2())); }
<a name="l04064"></a>04064         Term^ MkAdd(array&lt;Term^&gt;^ args) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkAdd(CopyArray(args))); }
<a name="l04065"></a>04065         Term^ MkAdd(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkAdd(t1(), t2())); }
<a name="l04066"></a>04066         Term^ MkMul(array&lt;Term^&gt;^ args) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkMul(CopyArray(args))); }
<a name="l04067"></a>04067         Term^ MkMul(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkMul(t1(), t2())); }
<a name="l04068"></a>04068         Term^ MkSub(array&lt;Term^&gt;^ args) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSub(CopyArray(args))); }
<a name="l04069"></a>04069         Term^ MkSub(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSub(t1(), t2())); }
<a name="l04070"></a>04070         Term^ MkUnaryMinus(Term^ arg) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkUnaryMinus(arg())); }
<a name="l04071"></a>04071         Term^ MkDiv(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkDiv(t1(), t2())); }
<a name="l04072"></a>04072         Term^ MkMod(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkMod(t1(), t2())); }
<a name="l04073"></a>04073         Term^ MkRem(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkRem(t1(), t2())); }
<a name="l04074"></a>04074         Term^ MkToReal(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkToReal(t1())); }
<a name="l04075"></a>04075         Term^ MkToInt(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkToInt(t1())); }
<a name="l04076"></a>04076         Term^ MkIsInt(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkIsInt(t1())); }
<a name="l04077"></a>04077         Term^ MkLt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkLt(t1(), t2())); }
<a name="l04078"></a>04078         Term^ MkLe(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkLe(t1(), t2())); }
<a name="l04079"></a>04079         Term^ MkGt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkGt(t1(), t2())); }
<a name="l04080"></a>04080         Term^ MkGe(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkGe(t1(), t2())); }
<a name="l04081"></a>04081         Term^ MkBvNot(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvNot(t1())); }
<a name="l04082"></a>04082         Term^ MkBvReduceAnd(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvReduceAnd(t1())); }
<a name="l04083"></a>04083         Term^ MkBvRedcueOr(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvReduceOr(t1())); }
<a name="l04084"></a>04084         Term^ MkBvAnd(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvAnd(t1(), t2())); }
<a name="l04085"></a>04085         Term^ MkBvOr(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvOr(t1(), t2())); }
<a name="l04086"></a>04086         Term^ MkBvXor(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvXor(t1(), t2())); }
<a name="l04087"></a>04087         Term^ MkBvNand(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvNand(t1(), t2())); }
<a name="l04088"></a>04088         Term^ MkBvNor(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvNor(t1(), t2())); }
<a name="l04089"></a>04089         Term^ MkBvXnor(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvXnor(t1(), t2())); }
<a name="l04090"></a>04090         Term^ MkBvNeg(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvNeg(t1())); }
<a name="l04091"></a>04091         Term^ MkBvAdd(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvAdd(t1(), t2())); }
<a name="l04092"></a>04092         Term^ MkBvSub(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSub(t1(), t2())); }
<a name="l04093"></a>04093         Term^ MkBvMul(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvMul(t1(), t2())); }
<a name="l04094"></a>04094         Term^ MkBvUdiv(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUdiv(t1(), t2())); }
<a name="l04095"></a>04095         Term^ MkBvSdiv(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSdiv(t1(), t2())); }
<a name="l04096"></a>04096         Term^ MkBvUrem(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUrem(t1(), t2())); }
<a name="l04097"></a>04097         Term^ MkBvSrem(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSrem(t1(), t2())); }
<a name="l04098"></a>04098         Term^ MkBvSmod(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSmod(t1(), t2())); }
<a name="l04099"></a>04099         Term^ MkBvUlt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUlt(t1(), t2())); }
<a name="l04100"></a>04100         Term^ MkBvSlt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSlt(t1(), t2())); }
<a name="l04101"></a>04101         Term^ MkBvUle(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUle(t1(), t2())); }
<a name="l04102"></a>04102         Term^ MkBvSle(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSle(t1(), t2())); }
<a name="l04103"></a>04103         Term^ MkBvUge(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUge(t1(), t2())); }
<a name="l04104"></a>04104         Term^ MkBvSge(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSge(t1(), t2())); }
<a name="l04105"></a>04105         Term^ MkBvUgt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUgt(t1(), t2())); }
<a name="l04106"></a>04106         Term^ MkBvSgt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSgt(t1(), t2())); }
<a name="l04107"></a>04107         Term^ MkBvConcat(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvConcat(t1(), t2())); }
<a name="l04108"></a>04108         Term^ MkBvExtract(<span class="keywordtype">unsigned</span> high, <span class="keywordtype">unsigned</span> low, Term^ t) {
<a name="l04109"></a>04109             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvExtract(high, low, t()));
<a name="l04110"></a>04110         }
<a name="l04111"></a>04111         Term^ MkBvSignExt(<span class="keywordtype">unsigned</span> i, Term^ t) {
<a name="l04112"></a>04112             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSignExt(i, t()));
<a name="l04113"></a>04113         }
<a name="l04114"></a>04114         Term^ MkBvZeroExt(<span class="keywordtype">unsigned</span> i, Term^ t) {
<a name="l04115"></a>04115             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvZeroExt(i, t()));
<a name="l04116"></a>04116         }
<a name="l04117"></a>04117         Term^ MkBvRepeat(<span class="keywordtype">unsigned</span> i, Term^ t) {
<a name="l04118"></a>04118             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvRepeat(i, t()));
<a name="l04119"></a>04119         }
<a name="l04120"></a>04120         Term^ MkBvShl(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvShl(t1(), t2())); }
<a name="l04121"></a>04121         Term^ MkBvLshr(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvLshr(t1(), t2())); }
<a name="l04122"></a>04122         Term^ MkBvAshr(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvAshr(t1(), t2())); }
<a name="l04123"></a>04123         Term^ MkBvRotateLeft(<span class="keywordtype">unsigned</span> i, Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvRotateLeft(i,t1())); }
<a name="l04124"></a>04124         Term^ MkBvRotateRight(<span class="keywordtype">unsigned</span> i, Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvRotateRight(i,t1()));  }
<a name="l04125"></a>04125         Term^ MkBvRotateLeft(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvRotateLeft(t1(), t2())); }
<a name="l04126"></a>04126         Term^ MkBvRotateRight(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvRotateRight(t1(), t2()));  }
<a name="l04127"></a>04127         Term^ MkBv2Int(Term^ t1, <span class="keywordtype">bool</span> is_signed) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;MkBv2Int(t1(), is_signed)); }
<a name="l04128"></a>04128         Term^ MkInt2Bv(<span class="keywordtype">unsigned</span> n, Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;MkInt2Bv(n, t1())); }
<a name="l04129"></a>04129         Term^ MkBvAddNoOverflow(Term^ t1, Term^ t2, <span class="keywordtype">bool</span> is_signed) { 
<a name="l04130"></a>04130             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvAddNoOverflow(t1(), t2(), is_signed)); 
<a name="l04131"></a>04131         }
<a name="l04132"></a>04132         Term^ MkBvAddNoUnderflow(Term^ t1, Term^ t2) { 
<a name="l04133"></a>04133             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvAddNoUnderflow(t1(), t2())); 
<a name="l04134"></a>04134         }
<a name="l04135"></a>04135         Term^ MkBvSubNoOverflow(Term^ t1, Term^ t2) { 
<a name="l04136"></a>04136             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSubNoOverflow(t1(), t2())); 
<a name="l04137"></a>04137         }
<a name="l04138"></a>04138         Term^ MkBvSubNoUnderflow(Term^ t1, Term^ t2, <span class="keywordtype">bool</span> is_signed) { 
<a name="l04139"></a>04139             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSubNoUnderflow(t1(), t2(), is_signed)); 
<a name="l04140"></a>04140         }
<a name="l04141"></a>04141         Term^ MkBvSDivNoOverflow(Term^ t1, Term^ t2) { 
<a name="l04142"></a>04142             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSDivNoOverflow(t1(), t2())); 
<a name="l04143"></a>04143         }
<a name="l04144"></a>04144         Term^ MkBvNegNoOverflow(Term^ t1) { 
<a name="l04145"></a>04145             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvNegNoOverflow(t1())); 
<a name="l04146"></a>04146         }
<a name="l04147"></a>04147         Term^ MkBvMulNoOverflow(Term^ t1, Term^ t2, <span class="keywordtype">bool</span> is_signed) { 
<a name="l04148"></a>04148             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvMulNoOverflow(t1(), t2(), is_signed)); 
<a name="l04149"></a>04149         }
<a name="l04150"></a>04150         Term^ MkBvMulNoUnderflow(Term^ t1, Term^ t2) { 
<a name="l04151"></a>04151             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvMulNoUnderflow(t1(), t2())); 
<a name="l04152"></a>04152         }
<a name="l04153"></a>04153         Term^ MkArraySelect(Term^ a, Term^ i) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkArraySelect(a(), i()));  }
<a name="l04154"></a>04154         Term^ MkArrayStore(Term^ a, Term^ i, Term^ v) {
<a name="l04155"></a>04155             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkArrayStore(a(), i(), v()));
<a name="l04156"></a>04156         }
<a name="l04157"></a>04157         Term^ MkArrayMap(FuncDecl^ f, array&lt;Term^&gt;^ args) {
<a name="l04158"></a>04158             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;MkArrayMap(f(), CopyArray(args)));
<a name="l04159"></a>04159         }
<a name="l04160"></a>04160         Term^ MkArrayConst(Sort^ domain, Term^ v) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkArrayConst(domain(), v())); }
<a name="l04161"></a>04161         Term^ MkArrayDefault(Term^ a) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkArrayDefault(a())); }
<a name="l04162"></a>04162         Sort^ MkSetSort(Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkSetSort(ty())); }
<a name="l04163"></a>04163         Term^ MkEmptySet(Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkEmptySet(ty())); }
<a name="l04164"></a>04164         Term^ MkFullSet(Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkFullSet(ty())); }
<a name="l04165"></a>04165         Term^ MkSetAdd(Term^ <span class="keyword">set</span>, Term^ elem) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetAdd(<span class="keyword">set</span>(), elem())); }
<a name="l04166"></a>04166         Term^ MkSetDel(Term^ <span class="keyword">set</span>, Term^ elem) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetDel(<span class="keyword">set</span>(), elem())); }
<a name="l04167"></a>04167         Term^ MkSetUnion(array&lt;Term^&gt;^ sets) {
<a name="l04168"></a>04168             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetUnion(CopyArray(sets)));
<a name="l04169"></a>04169         }
<a name="l04170"></a>04170         Term^ MkSetUnion(Term^ set1, Term^ set2) {
<a name="l04171"></a>04171             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetUnion(set1(), set2()));
<a name="l04172"></a>04172         }
<a name="l04173"></a>04173         Term^ MkSetIntersect(array&lt;Term^&gt;^ sets) {
<a name="l04174"></a>04174             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetIntersect(CopyArray(sets)));
<a name="l04175"></a>04175         }
<a name="l04176"></a>04176         Term^ MkSetIntersect(Term^ set1, Term^ set2) {
<a name="l04177"></a>04177             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetIntersect(set1(), set2()));
<a name="l04178"></a>04178         }
<a name="l04179"></a>04179         Term^ MkSetDifference(Term^ t1, Term^ t2) {
<a name="l04180"></a>04180             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetDifference(t1(), t2()));
<a name="l04181"></a>04181         }
<a name="l04182"></a>04182         Term^ MkSetComplement(Term^ arg) {
<a name="l04183"></a>04183             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetComplement(arg()));
<a name="l04184"></a>04184         }
<a name="l04185"></a>04185         Term^ MkSetMember(Term^ elem, Term^ <span class="keyword">set</span>) {
<a name="l04186"></a>04186             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetMember(elem(), <span class="keyword">set</span>()));
<a name="l04187"></a>04187         }
<a name="l04188"></a>04188         Term^ MkSetSubset(Term^ t1, Term^ t2) {
<a name="l04189"></a>04189             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetSubset(t1(), t2()));
<a name="l04190"></a>04190         }
<a name="l04191"></a>04191         
<a name="l04192"></a>04192         FuncDecl^ MkInjectiveFunction(String^ name, array&lt;Sort^&gt;^ domain, Sort^ range) {
<a name="l04193"></a>04193             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkInjectiveFunction(name, CopyArray(domain), range()));
<a name="l04194"></a>04194         }
<a name="l04195"></a>04195         FuncDecl^ MkInjectiveFunction(Symbol^ name, array&lt;Sort^&gt;^ domain, Sort^ range) {
<a name="l04196"></a>04196             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkInjectiveFunction(name, CopyArray(domain), range()));
<a name="l04197"></a>04197         }
<a name="l04198"></a>04198 
<a name="l04199"></a>04199         Term^ MkNumeral(String^ numeral, Sort^ ty) {
<a name="l04200"></a>04200             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNumeral(numeral, ty()));
<a name="l04201"></a>04201         }
<a name="l04202"></a>04202         Term^ MkNumeral(<span class="keywordtype">int</span> n, Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNumeral(n, ty()));  }
<a name="l04203"></a>04203         Term^ MkNumeral(<span class="keywordtype">unsigned</span> n, Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNumeral(n, ty())); }
<a name="l04204"></a>04204         Term^ MkNumeral(__int64 n, Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNumeral(n, ty())); }
<a name="l04205"></a>04205         Term^ MkNumeral(<span class="keywordtype">unsigned</span> __int64 n, Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNumeral(n, ty())); }
<a name="l04206"></a>04206 
<a name="l04207"></a>04207         Term^ MkIntNumeral(String^ n) { <span class="keywordflow">return</span> MkNumeral(n, MkIntSort()); }
<a name="l04208"></a>04208         Term^ MkIntNumeral(<span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> MkNumeral(n, MkIntSort()); }
<a name="l04209"></a>04209         Term^ MkIntNumeral(<span class="keywordtype">unsigned</span> n) { <span class="keywordflow">return</span> MkNumeral(n, MkIntSort()); }
<a name="l04210"></a>04210         Term^ MkIntNumeral(__int64 n) { <span class="keywordflow">return</span> MkNumeral(n, MkIntSort()); }
<a name="l04211"></a>04211         Term^ MkIntNumeral(<span class="keywordtype">unsigned</span> __int64 n) { <span class="keywordflow">return</span> MkNumeral(n, MkIntSort()); }
<a name="l04212"></a>04212         
<a name="l04213"></a>04213         Term^ MkRealNumeral(String^ n) { <span class="keywordflow">return</span> MkNumeral(n, MkRealSort()); }
<a name="l04214"></a>04214         Term^ MkRealNumeral(<span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> MkNumeral(n, MkRealSort()); }
<a name="l04215"></a>04215         Term^ MkRealNumeral(<span class="keywordtype">unsigned</span> n) { <span class="keywordflow">return</span> MkNumeral(n, MkRealSort()); }
<a name="l04216"></a>04216         Term^ MkRealNumeral(__int64 n) { <span class="keywordflow">return</span> MkNumeral(n, MkRealSort()); }
<a name="l04217"></a>04217         Term^ MkRealNumeral(<span class="keywordtype">unsigned</span> __int64 n) { <span class="keywordflow">return</span> MkNumeral(n, MkRealSort()); }
<a name="l04218"></a>04218 
<a name="l04219"></a>04219         Pattern^ MkPattern(array&lt;Term^&gt;^ terms) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Pattern(m_ctx,m_ctx-&gt;MkPattern(CopyArray(terms))); }
<a name="l04220"></a>04220         Term^ MkBound(<span class="keywordtype">unsigned</span> index, Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBound(index, ty())); }
<a name="l04221"></a>04221 
<a name="l04222"></a>04222         Term^ MkForall(
<a name="l04223"></a>04223             <span class="keywordtype">unsigned</span> weight,
<a name="l04224"></a>04224             array&lt;Pattern^&gt;^ patterns,
<a name="l04225"></a>04225             array&lt;Sort^&gt;^ types,
<a name="l04226"></a>04226             array&lt;Symbol^&gt;^ names,
<a name="l04227"></a>04227             Term^ body
<a name="l04228"></a>04228             ) {
<a name="l04229"></a>04229             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkForall(weight, CopyArray(patterns), CopyArray(types), names, body()));
<a name="l04230"></a>04230         }
<a name="l04231"></a>04231 
<a name="l04232"></a>04232         Term^ MkForall(
<a name="l04233"></a>04233             <span class="keywordtype">unsigned</span> weight,
<a name="l04234"></a>04234             array&lt;Pattern^&gt;^ patterns,
<a name="l04235"></a>04235             array&lt;Sort^&gt;^ types,
<a name="l04236"></a>04236             array&lt;String^&gt;^ names,
<a name="l04237"></a>04237             Term^ body
<a name="l04238"></a>04238             ) {
<a name="l04239"></a>04239             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkForall(weight, CopyArray(patterns), CopyArray(types), names, body()));
<a name="l04240"></a>04240         }
<a name="l04241"></a>04241 
<a name="l04242"></a>04242         Term^ MkForall(
<a name="l04243"></a>04243             <span class="keywordtype">unsigned</span>           weight,
<a name="l04244"></a>04244             array&lt;Term^&gt;^   bound,
<a name="l04245"></a>04245             array&lt;Pattern^&gt;^ patterns,
<a name="l04246"></a>04246             Term^ body
<a name="l04247"></a>04247             ) {
<a name="l04248"></a>04248             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkForall(weight, CopyArray(bound), CopyArray(patterns), body()));
<a name="l04249"></a>04249         }
<a name="l04250"></a>04250 
<a name="l04251"></a>04251 
<a name="l04252"></a>04252         Term^ MkExists(
<a name="l04253"></a>04253             <span class="keywordtype">unsigned</span> weight,
<a name="l04254"></a>04254             array&lt;Pattern^&gt;^ patterns,
<a name="l04255"></a>04255             array&lt;Sort^&gt;^ types,
<a name="l04256"></a>04256             array&lt;Symbol^&gt;^ names,
<a name="l04257"></a>04257             Term^ body
<a name="l04258"></a>04258             ) {
<a name="l04259"></a>04259             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkExists(weight, CopyArray(patterns), CopyArray(types), names, body()));
<a name="l04260"></a>04260         }
<a name="l04261"></a>04261 
<a name="l04262"></a>04262         Term^ MkExists(
<a name="l04263"></a>04263             <span class="keywordtype">unsigned</span> weight,
<a name="l04264"></a>04264             array&lt;Pattern^&gt;^ patterns,
<a name="l04265"></a>04265             array&lt;Sort^&gt;^ types,
<a name="l04266"></a>04266             array&lt;String^&gt;^ names,
<a name="l04267"></a>04267             Term^ body
<a name="l04268"></a>04268             ) {
<a name="l04269"></a>04269             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkExists(weight, CopyArray(patterns), CopyArray(types), names, body()));
<a name="l04270"></a>04270         }
<a name="l04271"></a>04271 
<a name="l04272"></a>04272         Term^ MkExists(
<a name="l04273"></a>04273             <span class="keywordtype">unsigned</span>           weight,
<a name="l04274"></a>04274             array&lt;Term^&gt;^   bound,
<a name="l04275"></a>04275             array&lt;Pattern^&gt;^ patterns,
<a name="l04276"></a>04276             Term^            body
<a name="l04277"></a>04277             ) {
<a name="l04278"></a>04278             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkExists(weight, CopyArray(bound), CopyArray(patterns), body()));
<a name="l04279"></a>04279         }
<a name="l04280"></a>04280 
<a name="l04281"></a>04281 
<a name="l04282"></a>04282 
<a name="l04283"></a>04283         Term^ MkQuantifier(
<a name="l04284"></a>04284             <span class="keywordtype">bool</span>             is_forall,
<a name="l04285"></a>04285             <span class="keywordtype">unsigned</span>         weight,
<a name="l04286"></a>04286             array&lt;Pattern^&gt;^ patterns,
<a name="l04287"></a>04287             array&lt;Term^&gt;^    no_patterns,
<a name="l04288"></a>04288             array&lt;Sort^&gt;^    types,
<a name="l04289"></a>04289             array&lt;Symbol^&gt;^  names,
<a name="l04290"></a>04290             Term^            body
<a name="l04291"></a>04291             ) {
<a name="l04292"></a>04292             <span class="keywordflow">return</span> MkQuantifier(is_forall, weight, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, patterns, no_patterns, types, names, body);
<a name="l04293"></a>04293         }
<a name="l04294"></a>04294 
<a name="l04295"></a>04295         Term^ MkQuantifier(
<a name="l04296"></a>04296             <span class="keywordtype">bool</span>             is_forall,
<a name="l04297"></a>04297             <span class="keywordtype">unsigned</span>         weight,
<a name="l04298"></a>04298             Symbol^          quantifier_id,
<a name="l04299"></a>04299             Symbol^          skolem_id,
<a name="l04300"></a>04300             array&lt;Pattern^&gt;^ patterns,
<a name="l04301"></a>04301             array&lt;Term^&gt;^    no_patterns,
<a name="l04302"></a>04302             array&lt;Sort^&gt;^    types,
<a name="l04303"></a>04303             array&lt;Symbol^&gt;^  names,
<a name="l04304"></a>04304             Term^            body
<a name="l04305"></a>04305             ) {
<a name="l04306"></a>04306             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkQuantifier(
<a name="l04307"></a>04307                                      is_forall, weight, 
<a name="l04308"></a>04308                                      quantifier_id, skolem_id,
<a name="l04309"></a>04309                                      CopyArray(patterns),
<a name="l04310"></a>04310                                      CopyArray(no_patterns),
<a name="l04311"></a>04311                                      CopyArray(types),
<a name="l04312"></a>04312                                      names,
<a name="l04313"></a>04313                                      body()));
<a name="l04314"></a>04314         }
<a name="l04315"></a>04315 
<a name="l04316"></a>04316         Term^ MkQuantifier(
<a name="l04317"></a>04317             <span class="keywordtype">bool</span>             is_forall,
<a name="l04318"></a>04318             <span class="keywordtype">unsigned</span>         weight,
<a name="l04319"></a>04319             Symbol^          quantifier_id,
<a name="l04320"></a>04320             Symbol^          skolem_id,
<a name="l04321"></a>04321             array&lt;Pattern^&gt;^ patterns,
<a name="l04322"></a>04322             array&lt;Term^&gt;^    no_patterns,
<a name="l04323"></a>04323             array&lt;Term^&gt;^    bound,
<a name="l04324"></a>04324             Term^            body
<a name="l04325"></a>04325             ) {
<a name="l04326"></a>04326             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkQuantifier(
<a name="l04327"></a>04327                                      is_forall, weight, 
<a name="l04328"></a>04328                                      quantifier_id, skolem_id,
<a name="l04329"></a>04329                                      CopyArray(patterns),
<a name="l04330"></a>04330                                      CopyArray(no_patterns),
<a name="l04331"></a>04331                                      CopyArray(bound),
<a name="l04332"></a>04332                                      body()));
<a name="l04333"></a>04333         }
<a name="l04334"></a>04334 
<a name="l04335"></a>04335         <a class="code" href="group__mapi.html#ga05812818de02fb4b202d7513ce50745d" title="In Z3, a symbol can be represented using integers and strings (See GetSymbolKind)...">SymbolKind</a> GetSymbolKind(Symbol^ s) { <span class="keywordflow">return</span> m_ctx-&gt;GetSymbolKind(s); }
<a name="l04336"></a>04336         <span class="keywordtype">int</span> GetSymbolInt(Symbol^ s) { <span class="keywordflow">return</span> m_ctx-&gt;GetSymbolInt(s); }
<a name="l04337"></a>04337         String^ GetSymbolString(Symbol^ s) { <span class="keywordflow">return</span> m_ctx-&gt;GetSymbolString(s); }
<a name="l04338"></a>04338         <span class="keywordtype">bool</span> IsEq(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> m_ctx-&gt;IsEq(t1(), t2()); }
<a name="l04339"></a>04339         <span class="keywordtype">bool</span> IsWellSorted(Term^ t) { <span class="keywordflow">return</span> m_ctx-&gt;IsWellSorted(t()); }
<a name="l04340"></a>04340         <a class="code" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc" title="The different kinds of Z3 Terms.">TermKind</a> GetTermKind(Term^ a) { <span class="keywordflow">return</span> m_ctx-&gt;GetTermKind(a()); }
<a name="l04341"></a>04341         <a class="code" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425" title="Different kinds of Z3 built-in declarations (See GetDeclKind).">DeclKind</a> GetDeclKind(FuncDecl^ d) { <span class="keywordflow">return</span> m_ctx-&gt;GetDeclKind(d()); }
<a name="l04342"></a>04342         array&lt;IParameter^&gt;^ GetDeclParameters(FuncDecl^ d);
<a name="l04343"></a>04343         FuncDecl^ GetAppDecl(Term^ a) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;GetAppDecl(a())); }
<a name="l04344"></a>04344         array&lt;Term^&gt;^ GetAppArgs(Term^ a) { <span class="keywordflow">return</span> CopyTermArray(m_ctx-&gt;GetAppArgs(a())); }
<a name="l04345"></a>04345         String^ GetNumeralString(Term^ a) { <span class="keywordflow">return</span> m_ctx-&gt;GetNumeralString(a()); }
<a name="l04346"></a>04346         <span class="keywordtype">int</span> GetNumeralInt(Term^ v) { <span class="keywordflow">return</span> m_ctx-&gt;GetNumeralInt(v()); }
<a name="l04347"></a>04347         <span class="keywordtype">bool</span> TryGetNumeralInt(Term^ v, [Out] <span class="keywordtype">int</span>% i) { <span class="keywordflow">return</span> m_ctx-&gt;TryGetNumeralInt(v(), i); }
<a name="l04348"></a>04348         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GetNumeralUInt(Term^ v) { <span class="keywordflow">return</span> m_ctx-&gt;GetNumeralUInt(v()); }
<a name="l04349"></a>04349         <span class="keywordtype">bool</span> TryGetNumeralUInt(Term^ v, [Out] <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>% u) { <span class="keywordflow">return</span> m_ctx-&gt;TryGetNumeralUInt(v(), u); }
<a name="l04350"></a>04350         __int64 GetNumeralInt64(Term^ v) { <span class="keywordflow">return</span> m_ctx-&gt;GetNumeralInt64(v()); }
<a name="l04351"></a>04351         <span class="keywordtype">bool</span> TryGetNumeralInt64(Term^ v, [Out] __int64% i) { <span class="keywordflow">return</span> m_ctx-&gt;TryGetNumeralInt64(v(), i); }
<a name="l04352"></a>04352         <span class="keywordtype">unsigned</span> __int64 GetNumeralUInt64(Term^ v) { <span class="keywordflow">return</span> m_ctx-&gt;GetNumeralUInt64(v()); }
<a name="l04353"></a>04353         <span class="keywordtype">bool</span> TryGetNumeralUInt64(Term^ v, [Out] <span class="keywordtype">unsigned</span> __int64% u) { <span class="keywordflow">return</span> m_ctx-&gt;TryGetNumeralUInt64(v(), u); }
<a name="l04354"></a>04354         <span class="keywordtype">bool</span> TryGetNumeral(Term^ v, [Out] __int64% num, [Out] __int64% den) { <span class="keywordflow">return</span> m_ctx-&gt;TryGetNumeral(v(), num, den); }
<a name="l04355"></a>04355         <span class="keywordtype">void</span> GetNumeral(Term^ v, [Out] System::Numerics::BigInteger% num, [Out] System::Numerics::BigInteger% den) {
<a name="l04356"></a>04356             m_ctx-&gt;GetNumeral(v(), num, den);
<a name="l04357"></a>04357         }
<a name="l04358"></a>04358 
<a name="l04359"></a>04359         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> GetBoolValue(Term^ v) { <span class="keywordflow">return</span> m_ctx-&gt;GetBoolValue(v()); }
<a name="l04360"></a>04360 
<a name="l04361"></a>04361         <span class="keywordtype">unsigned</span> GetVarIndex(Term^ a) { <span class="keywordflow">return</span> m_ctx-&gt;GetVarIndex(a()); }
<a name="l04362"></a>04362         Quantifier^ GetQuantifier(Term^ a) { <span class="keywordflow">return</span> GetQuantifier(m_ctx, a); }
<a name="l04363"></a>04363 
<a name="l04364"></a>04364         array&lt;Term^&gt;^ GetPatternTerms(Pattern^ p) { <span class="keywordflow">return</span> CopyTermArray(m_ctx-&gt;GetPatternTerms(p())); }
<a name="l04365"></a>04365         Symbol^ GetDeclName(FuncDecl^ d) { <span class="keywordflow">return</span> m_ctx-&gt;GetDeclName(d()); }
<a name="l04366"></a>04366         Symbol^ GetSortName(Sort^ ty) { <span class="keywordflow">return</span> m_ctx-&gt;GetSortName(ty()); }
<a name="l04367"></a>04367         Sort^ GetSort(Term^ a) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;GetSort(a())); }
<a name="l04368"></a>04368         array&lt;Sort^&gt;^ GetDomain(FuncDecl^ d) { <span class="keywordflow">return</span> CopySortArray(m_ctx-&gt;GetDomain(d())); }
<a name="l04369"></a>04369         Sort^ GetRange(FuncDecl^ d) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;GetRange(d())); }
<a name="l04370"></a>04370         <a class="code" href="group__mapi.html#ga7664c6569cf130a5d166ec8c8dc27101" title="The different kinds of Z3 sorts (See GetSortKind).">SortKind</a> GetSortKind(Sort^ t) { <span class="keywordflow">return</span> m_ctx-&gt;GetSortKind(t()); }
<a name="l04371"></a>04371         <span class="keywordtype">unsigned</span> GetBvSortSize(Sort^ t) { <span class="keywordflow">return</span> m_ctx-&gt;GetBvSortSize(t()); }
<a name="l04372"></a>04372         Sort^ GetArraySortDomain(Sort^ t) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;GetArraySortDomain(t())); }
<a name="l04373"></a>04373         Sort^ GetArraySortRange(Sort^ t) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;GetArraySortRange(t())); }
<a name="l04374"></a>04374         FuncDecl^ GetTupleConstructor(Sort^ t) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;GetTupleConstructor(t())); }
<a name="l04375"></a>04375         array&lt;FuncDecl^&gt;^ GetTupleFields(Sort^ t) { <span class="keywordflow">return</span> CopyFuncDeclArray(m_ctx-&gt;GetTupleFields(t())); }
<a name="l04376"></a>04376 
<a name="l04377"></a>04377         Theory^ MkTheory(String^ name);
<a name="l04378"></a>04378                 
<a name="l04379"></a>04379         <span class="keywordtype">void</span> RegisterRelation(FuncDecl^ r) { m_ctx-&gt;RegisterRelation(r()); }
<a name="l04380"></a>04380 
<a name="l04381"></a>04381         <span class="keywordtype">void</span> AddRule(Term^ rule, Symbol^ name) { m_ctx-&gt;AddRule(rule(), name); }
<a name="l04382"></a>04382 
<a name="l04383"></a>04383         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> Query(Term^ query) { <span class="keywordflow">return</span> m_ctx-&gt;Query(query()); }
<a name="l04384"></a>04384 
<a name="l04385"></a>04385         String^ GetQueryStatus() { <span class="keywordflow">return</span> m_ctx-&gt;GetQueryStatus(); }
<a name="l04386"></a>04386 
<a name="l04387"></a>04387         Term^ GetQueryAnswer() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;GetQueryAnswer()); }
<a name="l04388"></a>04388 
<a name="l04389"></a>04389         String^ FixedpointkToString(array&lt;Term^&gt;^ queries) {
<a name="l04390"></a>04390             <span class="keywordflow">return</span> m_ctx-&gt;FixedpointToString(CopyArray(queries)); 
<a name="l04391"></a>04391         }
<a name="l04392"></a>04392         array&lt;Term^&gt;^ SimplifyFixedpointRules(array&lt;Term^&gt;^ rules, array&lt;FuncDecl^&gt;^ output_predicates) {
<a name="l04393"></a>04393             <span class="keywordflow">return</span> CopyTermArray(m_ctx-&gt;SimplifyFixedpointRules(CopyArray(rules), CopyArray(output_predicates)));
<a name="l04394"></a>04394         }
<a name="l04395"></a>04395         <span class="comment">// functions for creating custom Fixedpoint relations.</span>
<a name="l04396"></a>04396 
<a name="l04397"></a>04397     <span class="keyword">private</span>:
<a name="l04398"></a>04398         Action3&lt;FuncDecl^, array&lt;Term^&gt;^, array&lt;Term^&gt;^&gt;^ m_assign_callback;
<a name="l04399"></a>04399         <span class="keywordtype">void</span> AssignCallbackAux(FuncDeclPtr f, array&lt;TermPtr&gt;^ args, array&lt;TermPtr&gt;^ outs) {
<a name="l04400"></a>04400             m_assign_callback(<span class="keyword">gcnew</span> FuncDecl(m_ctx, f), CopyAstArray&lt;Term, TermPtr&gt;(args), CopyAstArray&lt;Term, TermPtr&gt;(outs));
<a name="l04401"></a>04401         }
<a name="l04402"></a>04402         Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ m_apply_callback;
<a name="l04403"></a>04403         TermPtr ApplyCallbackAux(FuncDeclPtr f, array&lt;TermPtr&gt;^ args) {
<a name="l04404"></a>04404             <span class="keywordflow">return</span> m_apply_callback(<span class="keyword">gcnew</span> FuncDecl(m_ctx, f), CopyAstArray&lt;Term, TermPtr&gt;(args))();
<a name="l04405"></a>04405         }
<a name="l04406"></a>04406     <span class="keyword">public</span>:
<a name="l04407"></a>04407         <span class="keyword">property</span> Action3&lt;FuncDecl^, array&lt;Term^&gt;^, array&lt;Term^&gt;^&gt;^ FixedpointAssign {
<a name="l04408"></a>04408             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action3&lt;FuncDecl^, array&lt;Term^&gt;^, array&lt;Term^&gt;^&gt;^ value) {
<a name="l04409"></a>04409                 m_assign_callback = value;
<a name="l04410"></a>04410                 m_ctx-&gt;FixedpointAssign = <span class="keyword">gcnew</span> Action3&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, array&lt;TermPtr&gt;^&gt;(<span class="keyword">this</span>,&amp;Context::AssignCallbackAux);
<a name="l04411"></a>04411             }
<a name="l04412"></a>04412         }
<a name="l04413"></a>04413         <span class="keyword">property</span> Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ FixedpointApply {
<a name="l04414"></a>04414             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ value) {
<a name="l04415"></a>04415                 m_apply_callback = value;
<a name="l04416"></a>04416                 m_ctx-&gt;FixedpointApply = <span class="keyword">gcnew</span> Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;(<span class="keyword">this</span>,&amp;Context::ApplyCallbackAux);
<a name="l04417"></a>04417             }
<a name="l04418"></a>04418         }
<a name="l04419"></a>04419     };
<a name="l04420"></a>04420 
<a name="l04421"></a>04421     <span class="keyword">public ref class</span> FunctionEntry {
<a name="l04422"></a>04422     <span class="keyword">public</span>:
<a name="l04423"></a>04423         array&lt;Term^&gt;^ Arguments;
<a name="l04424"></a>04424         Term^         Result;
<a name="l04425"></a>04425     };
<a name="l04426"></a>04426 
<a name="l04427"></a>04427     <span class="keyword">public ref class</span> FunctionGraph {
<a name="l04428"></a>04428     <span class="keyword">public</span>:
<a name="l04429"></a>04429         FuncDecl^        Declaration;
<a name="l04430"></a>04430         array&lt;FunctionEntry^&gt;^ Entries;
<a name="l04431"></a>04431         Term^               Else;
<a name="l04432"></a>04432     };
<a name="l04433"></a>04433 
<a name="l04434"></a>04434 
<a name="l04435"></a>04435     <span class="keyword">public ref class</span> Model {
<a name="l04436"></a>04436         RawModel^ m_model;
<a name="l04437"></a>04437         Context^ m_ctx;
<a name="l04438"></a>04438 
<a name="l04439"></a>04439         ArrayValue^ Mk(RawArrayValue^ av);
<a name="l04440"></a>04440         FunctionEntry^ Mk(RawFunctionEntry^ fe);
<a name="l04441"></a>04441         FunctionGraph^ Mk(RawFunctionGraph^ fg);
<a name="l04442"></a>04442         Dictionary&lt;FuncDecl^, FunctionGraph^&gt;^ Mk(Dictionary&lt;FuncDeclPtr, RawFunctionGraph^&gt;^ fgs);
<a name="l04443"></a>04443 
<a name="l04444"></a>04444     <span class="keyword">internal</span>:
<a name="l04445"></a>04445         <span class="keyword">property</span> Context^ GetContext { Context^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_ctx; }}
<a name="l04446"></a>04446         <span class="keyword">property</span> RawModel^ GetModel { RawModel^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_model; }}
<a name="l04447"></a>04447 
<a name="l04448"></a>04448         Model(RawModel^ m, Context^ c) : m_model(m), m_ctx(c) {}
<a name="l04449"></a>04449 
<a name="l04450"></a>04450     <span class="keyword">public</span>:
<a name="l04451"></a>04451         ~Model() { m_model-&gt;Reset(); }
<a name="l04452"></a>04452 
<a name="l04453"></a>04453         array&lt;FuncDecl^&gt;^ GetModelConstants() {
<a name="l04454"></a>04454             <span class="keywordflow">return</span> m_ctx-&gt;CopyFuncDeclArray(m_model-&gt;GetModelConstants());
<a name="l04455"></a>04455         }
<a name="l04456"></a>04456 
<a name="l04457"></a>04457         <span class="keywordtype">bool</span> TryGetArrayValue(Term^ a, [Out] ArrayValue^% av);
<a name="l04458"></a>04458 
<a name="l04459"></a>04459         Dictionary&lt;FuncDecl^, FunctionGraph^&gt;^ GetFunctionGraphs() { <span class="keywordflow">return</span> Mk(m_model-&gt;GetFunctionGraphs()); }
<a name="l04460"></a>04460 
<a name="l04461"></a>04461         Term^ Eval(Term^ t) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx-&gt;GetContext, m_model-&gt;Eval(t())); }
<a name="l04462"></a>04462 
<a name="l04463"></a>04463         Term^ Eval(FuncDecl^ d, array&lt;Term^&gt;^ args) {
<a name="l04464"></a>04464             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx-&gt;GetContext, m_model-&gt;Eval(d(), m_ctx-&gt;CopyArray(args)));
<a name="l04465"></a>04465         }
<a name="l04466"></a>04466 
<a name="l04467"></a>04467         <span class="keywordtype">void</span> Display(System::IO::TextWriter^ w) { m_model-&gt;Display(w); }
<a name="l04468"></a>04468 
<a name="l04469"></a>04469     };
<a name="l04470"></a>04470 
<a name="l04471"></a>04471     <span class="keyword">public ref class</span> Theory
<a name="l04472"></a>04472     {
<a name="l04473"></a>04473         Context^ m_context;
<a name="l04474"></a>04474         RawTheory^ m_theory;
<a name="l04475"></a>04475 
<a name="l04476"></a>04476     <span class="keyword">public</span>:
<a name="l04477"></a>04477         <span class="keyword">property</span> String^ Name { String^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_theory-&gt;Name; } }
<a name="l04478"></a>04478 
<a name="l04479"></a>04479     <span class="keyword">internal</span>: 
<a name="l04480"></a>04480         Theory(Context^ ctx, String^ name)
<a name="l04481"></a>04481         {
<a name="l04482"></a>04482             m_context = ctx;
<a name="l04483"></a>04483             m_theory = <span class="keyword">gcnew</span> RawTheory(ctx-&gt;GetContext-&gt;ref_context(), name);
<a name="l04484"></a>04484         }
<a name="l04485"></a>04485 
<a name="l04486"></a>04486     <span class="keyword">private</span>:
<a name="l04487"></a>04487         array&lt;Term^&gt;^ MkTerms(array&lt;TermPtr&gt;^ ts)
<a name="l04488"></a>04488         {
<a name="l04489"></a>04489             <span class="keywordflow">return</span> m_context-&gt;CopyAstArray&lt;Term, TermPtr&gt;(ts);
<a name="l04490"></a>04490         }
<a name="l04491"></a>04491         Term^ MkTerm(TermPtr t) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_context-&gt;GetContext, t); }
<a name="l04492"></a>04492         FuncDecl^ MkFuncDecl(FuncDeclPtr f) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_context-&gt;GetContext, f); }
<a name="l04493"></a>04493 
<a name="l04494"></a>04494         TermPtr GetTermPtr(Term^ t)
<a name="l04495"></a>04495         {
<a name="l04496"></a>04496             <span class="keywordflow">if</span> (t) <span class="keywordflow">return</span> t();
<a name="l04497"></a>04497             <span class="keywordflow">return</span> IntPtr::Zero;
<a name="l04498"></a>04498         }
<a name="l04499"></a>04499 
<a name="l04500"></a>04500     <span class="keyword">public</span>:
<a name="l04501"></a>04501         <span class="keyword">property</span> Action0^ DeleteHandler
<a name="l04502"></a>04502         {
<a name="l04503"></a>04503             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) 
<a name="l04504"></a>04504             {
<a name="l04505"></a>04505                 m_theory-&gt;DeleteHandler = value;
<a name="l04506"></a>04506             }
<a name="l04507"></a>04507         }
<a name="l04508"></a>04508     <span class="keyword">private</span>:
<a name="l04509"></a>04509         Func2&lt;Term^, Term^, Term^&gt;^ reduce_eq;
<a name="l04510"></a>04510         TermPtr ReduceEqAux(TermPtr a, TermPtr b) {
<a name="l04511"></a>04511             <span class="keywordflow">return</span> GetTermPtr(reduce_eq(MkTerm(a), MkTerm(b)));
<a name="l04512"></a>04512         }
<a name="l04513"></a>04513     <span class="keyword">public</span>:
<a name="l04514"></a>04514         <span class="keyword">property</span> Func2&lt;Term^, Term^, Term^&gt;^ ReduceEq
<a name="l04515"></a>04515             {
<a name="l04516"></a>04516                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;Term^, Term^, Term^&gt;^ value)
<a name="l04517"></a>04517                 {
<a name="l04518"></a>04518                     reduce_eq = value;
<a name="l04519"></a>04519                     m_theory-&gt;ReduceEq = <span class="keyword">gcnew</span> Func2&lt;TermPtr,TermPtr,TermPtr&gt;(<span class="keyword">this</span>,&amp;Theory::ReduceEqAux);
<a name="l04520"></a>04520                 }
<a name="l04521"></a>04521             }
<a name="l04522"></a>04522     <span class="keyword">private</span>:
<a name="l04523"></a>04523         Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ reduce_app;
<a name="l04524"></a>04524         TermPtr ReduceAppAux(FuncDeclPtr a, array&lt;TermPtr&gt;^ b) {
<a name="l04525"></a>04525             <span class="keywordflow">return</span> GetTermPtr(reduce_app(MkFuncDecl(a), MkTerms(b)));
<a name="l04526"></a>04526         }
<a name="l04527"></a>04527     <span class="keyword">public</span>:
<a name="l04528"></a>04528         <span class="keyword">property</span> Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ ReduceApp
<a name="l04529"></a>04529             {
<a name="l04530"></a>04530                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ value)
<a name="l04531"></a>04531                 {
<a name="l04532"></a>04532                     reduce_app = value;
<a name="l04533"></a>04533                     m_theory-&gt;ReduceApp = <span class="keyword">gcnew</span> Func2&lt;FuncDeclPtr,array&lt;TermPtr&gt;^,TermPtr&gt;(<span class="keyword">this</span>,&amp;Theory::ReduceAppAux);
<a name="l04534"></a>04534                 }
<a name="l04535"></a>04535             }
<a name="l04536"></a>04536     <span class="keyword">private</span>:
<a name="l04537"></a>04537         Func1&lt;array&lt;Term^&gt;^, Term^&gt;^ reduce_distinct;
<a name="l04538"></a>04538         TermPtr ReduceDistinctAux(array&lt;TermPtr&gt;^ args) {
<a name="l04539"></a>04539             <span class="keywordflow">return</span> GetTermPtr(reduce_distinct(MkTerms(args)));
<a name="l04540"></a>04540         }
<a name="l04541"></a>04541         
<a name="l04542"></a>04542     <span class="keyword">public</span>:
<a name="l04543"></a>04543         <span class="keyword">property</span> Func1&lt;array&lt;Term^&gt;^, Term^&gt;^ ReduceDistinct
<a name="l04544"></a>04544             {
<a name="l04545"></a>04545                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Func1&lt;array&lt;Term^&gt;^, Term^&gt;^ value)
<a name="l04546"></a>04546                 {
<a name="l04547"></a>04547                     reduce_distinct = value;
<a name="l04548"></a>04548                     m_theory-&gt;ReduceDistinct = <span class="keyword">gcnew</span> Func1&lt;array&lt;TermPtr&gt;^,TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::ReduceDistinctAux);
<a name="l04549"></a>04549                 }
<a name="l04550"></a>04550             }
<a name="l04551"></a>04551     <span class="keyword">private</span>:
<a name="l04552"></a>04552         Action&lt;Term^&gt;^ new_app;
<a name="l04553"></a>04553         <span class="keywordtype">void</span> NewAppAux(TermPtr a) { <span class="keywordflow">return</span> new_app(MkTerm(a)); }
<a name="l04554"></a>04554     <span class="keyword">public</span>:
<a name="l04555"></a>04555         <span class="keyword">property</span> Action&lt;Term^&gt;^ NewApp
<a name="l04556"></a>04556         {
<a name="l04557"></a>04557             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;Term^&gt;^ value)
<a name="l04558"></a>04558             {
<a name="l04559"></a>04559                 new_app = value;
<a name="l04560"></a>04560                 m_theory-&gt;NewApp = <span class="keyword">gcnew</span> Action&lt;TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::NewAppAux);
<a name="l04561"></a>04561             }
<a name="l04562"></a>04562         }
<a name="l04563"></a>04563     <span class="keyword">private</span>:
<a name="l04564"></a>04564         Action&lt;Term^&gt;^ new_elem;
<a name="l04565"></a>04565         <span class="keywordtype">void</span> NewElemAux(TermPtr a) { <span class="keywordflow">return</span> new_elem(MkTerm(a)); }
<a name="l04566"></a>04566     <span class="keyword">public</span>:
<a name="l04567"></a>04567         <span class="keyword">property</span> Action&lt;Term^&gt;^ NewElem
<a name="l04568"></a>04568         {
<a name="l04569"></a>04569             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;Term^&gt;^ value)
<a name="l04570"></a>04570             {
<a name="l04571"></a>04571                 new_elem = value;
<a name="l04572"></a>04572                 m_theory-&gt;NewElem = <span class="keyword">gcnew</span> Action&lt;TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::NewElemAux);
<a name="l04573"></a>04573             }
<a name="l04574"></a>04574         }
<a name="l04575"></a>04575         <span class="keyword">property</span> Action0^ InitSearch
<a name="l04576"></a>04576         {
<a name="l04577"></a>04577             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l04578"></a>04578             {
<a name="l04579"></a>04579                 m_theory-&gt;InitSearch = value;
<a name="l04580"></a>04580             }
<a name="l04581"></a>04581         }
<a name="l04582"></a>04582         <span class="keyword">property</span> Action0^ Push
<a name="l04583"></a>04583         {
<a name="l04584"></a>04584             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l04585"></a>04585             {
<a name="l04586"></a>04586                 m_theory-&gt;Push = value;
<a name="l04587"></a>04587             }
<a name="l04588"></a>04588         }
<a name="l04589"></a>04589         <span class="keyword">property</span> Action0^ Pop
<a name="l04590"></a>04590         {
<a name="l04591"></a>04591             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l04592"></a>04592             {
<a name="l04593"></a>04593                 m_theory-&gt;Pop = value;
<a name="l04594"></a>04594             }
<a name="l04595"></a>04595         }
<a name="l04596"></a>04596         <span class="keyword">property</span> Action0^ Reset
<a name="l04597"></a>04597         {
<a name="l04598"></a>04598             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l04599"></a>04599             {
<a name="l04600"></a>04600                 m_theory-&gt;Reset = value;
<a name="l04601"></a>04601             }
<a name="l04602"></a>04602         }
<a name="l04603"></a>04603         <span class="keyword">property</span> Action0^ Restart
<a name="l04604"></a>04604         {
<a name="l04605"></a>04605             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l04606"></a>04606             {
<a name="l04607"></a>04607                 m_theory-&gt;Restart = value;
<a name="l04608"></a>04608             }
<a name="l04609"></a>04609         }
<a name="l04610"></a>04610 
<a name="l04611"></a>04611         <span class="keyword">property</span> Func0&lt;bool&gt;^ FinalCheck
<a name="l04612"></a>04612         {
<a name="l04613"></a>04613             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func0&lt;bool&gt;^ value)
<a name="l04614"></a>04614             {
<a name="l04615"></a>04615                 m_theory-&gt;FinalCheck = value;
<a name="l04616"></a>04616             }
<a name="l04617"></a>04617         }
<a name="l04618"></a>04618     <span class="keyword">private</span>:
<a name="l04619"></a>04619         Action2&lt;Term^,Term^&gt;^ new_eq;
<a name="l04620"></a>04620         <span class="keywordtype">void</span> NewEqAux(TermPtr a, TermPtr b) {
<a name="l04621"></a>04621             new_eq(MkTerm(a), MkTerm(b));
<a name="l04622"></a>04622         }
<a name="l04623"></a>04623     <span class="keyword">public</span>:
<a name="l04624"></a>04624         <span class="keyword">property</span> Action2&lt;Term^, Term^&gt;^ NewEq
<a name="l04625"></a>04625             {
<a name="l04626"></a>04626                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;Term^, Term^&gt;^  value) 
<a name="l04627"></a>04627                 {
<a name="l04628"></a>04628                     new_eq = value;
<a name="l04629"></a>04629                     m_theory-&gt;NewEq = <span class="keyword">gcnew</span> Action2&lt;TermPtr,TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::NewEqAux);
<a name="l04630"></a>04630                 }
<a name="l04631"></a>04631             }
<a name="l04632"></a>04632     <span class="keyword">private</span>:
<a name="l04633"></a>04633         Action2&lt;Term^,Term^&gt;^ new_diseq;
<a name="l04634"></a>04634         <span class="keywordtype">void</span> NewDiseqAux(TermPtr a, TermPtr b) {
<a name="l04635"></a>04635             new_diseq(MkTerm(a), MkTerm(b));
<a name="l04636"></a>04636         }
<a name="l04637"></a>04637     <span class="keyword">public</span>:
<a name="l04638"></a>04638         <span class="keyword">property</span> Action2&lt;Term^, Term^&gt;^ NewDiseq
<a name="l04639"></a>04639             {
<a name="l04640"></a>04640                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;Term^, Term^&gt;^  value) 
<a name="l04641"></a>04641                 {
<a name="l04642"></a>04642                     new_diseq = value;
<a name="l04643"></a>04643                     m_theory-&gt;NewDiseq = <span class="keyword">gcnew</span> Action2&lt;TermPtr,TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::NewDiseqAux);
<a name="l04644"></a>04644                 }
<a name="l04645"></a>04645             }
<a name="l04646"></a>04646     <span class="keyword">private</span>:
<a name="l04647"></a>04647         Action2&lt;Term^,bool&gt;^ new_assignment;
<a name="l04648"></a>04648         <span class="keywordtype">void</span> NewAssignmentAux(TermPtr a, <span class="keywordtype">bool</span> b) {
<a name="l04649"></a>04649             new_assignment(MkTerm(a), b);
<a name="l04650"></a>04650         }
<a name="l04651"></a>04651     <span class="keyword">public</span>:
<a name="l04652"></a>04652         <span class="keyword">property</span> Action2&lt;Term^, bool&gt;^ NewAssignment
<a name="l04653"></a>04653             {
<a name="l04654"></a>04654                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;Term^, bool&gt;^  value) 
<a name="l04655"></a>04655                 {
<a name="l04656"></a>04656                     new_assignment = value;
<a name="l04657"></a>04657                     m_theory-&gt;NewAssignment = <span class="keyword">gcnew</span> Action2&lt;TermPtr,bool&gt;(<span class="keyword">this</span>, &amp;Theory::NewAssignmentAux);
<a name="l04658"></a>04658                 }
<a name="l04659"></a>04659             }
<a name="l04660"></a>04660     <span class="keyword">private</span>:
<a name="l04661"></a>04661         Action&lt;Term^&gt;^ new_relevant;
<a name="l04662"></a>04662         <span class="keywordtype">void</span> NewRelevantAux(TermPtr a) { new_relevant(MkTerm(a)); }
<a name="l04663"></a>04663     <span class="keyword">public</span>:
<a name="l04664"></a>04664         <span class="keyword">property</span> Action&lt;Term^&gt;^ NewRelevant
<a name="l04665"></a>04665         {
<a name="l04666"></a>04666             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;Term^&gt;^ value) {
<a name="l04667"></a>04667                 new_relevant = value;
<a name="l04668"></a>04668                 m_theory-&gt;NewRelevant = <span class="keyword">gcnew</span> Action&lt;TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::NewRelevantAux);
<a name="l04669"></a>04669             }
<a name="l04670"></a>04670         }
<a name="l04671"></a>04671         
<a name="l04672"></a>04672         <span class="keywordtype">void</span> AssertTheoryAxiom(Term^ ax)
<a name="l04673"></a>04673         {
<a name="l04674"></a>04674             m_theory-&gt;AssertTheoryAxiom(ax());
<a name="l04675"></a>04675         }
<a name="l04676"></a>04676 
<a name="l04677"></a>04677         <span class="keywordtype">void</span> AssumeEq(Term^ lhs, Term^ rhs)
<a name="l04678"></a>04678         {
<a name="l04679"></a>04679             m_theory-&gt;AssumeEq(lhs(), rhs());
<a name="l04680"></a>04680         }
<a name="l04681"></a>04681 
<a name="l04682"></a>04682 
<a name="l04683"></a>04683         <span class="keywordtype">void</span> EnableTheoryAxiomSimplification(<span class="keywordtype">bool</span> flag)
<a name="l04684"></a>04684         {
<a name="l04685"></a>04685             m_theory-&gt;EnableTheoryAxiomSimplification(flag);
<a name="l04686"></a>04686         }
<a name="l04687"></a>04687 
<a name="l04688"></a>04688         Term^ GetEqcRoot(Term^ n)
<a name="l04689"></a>04689         {
<a name="l04690"></a>04690             <span class="keywordflow">return</span> MkTerm(m_theory-&gt;GetEqcRoot(n()));
<a name="l04691"></a>04691         }
<a name="l04692"></a>04692 
<a name="l04693"></a>04693         Term^ GetEqcNext(Term^ n)
<a name="l04694"></a>04694         {
<a name="l04695"></a>04695             <span class="keywordflow">return</span> MkTerm(m_theory-&gt;GetEqcNext(n()));
<a name="l04696"></a>04696         }
<a name="l04697"></a>04697 
<a name="l04698"></a>04698         array&lt;Term^&gt;^ GetParents(Term^ n)
<a name="l04699"></a>04699         {
<a name="l04700"></a>04700             <span class="keywordflow">return</span> MkTerms(m_theory-&gt;GetParents(n()));
<a name="l04701"></a>04701         }
<a name="l04702"></a>04702 
<a name="l04703"></a>04703         <span class="keywordtype">bool</span> IsTheoryValue(Term^ a)
<a name="l04704"></a>04704         {
<a name="l04705"></a>04705             <span class="keywordflow">return</span> m_theory-&gt;IsTheoryValue(a());
<a name="l04706"></a>04706         }
<a name="l04707"></a>04707 
<a name="l04708"></a>04708         <span class="keywordtype">bool</span> IsTheoryDecl(FuncDecl^ d)
<a name="l04709"></a>04709         {
<a name="l04710"></a>04710             <span class="keywordflow">return</span> m_theory-&gt;IsTheoryDecl(d());
<a name="l04711"></a>04711         }
<a name="l04712"></a>04712 
<a name="l04713"></a>04713         array&lt;Term^&gt;^ GetElems()
<a name="l04714"></a>04714         {
<a name="l04715"></a>04715             <span class="keywordflow">return</span> MkTerms(m_theory-&gt;GetElems());
<a name="l04716"></a>04716         }
<a name="l04717"></a>04717 
<a name="l04718"></a>04718         array&lt;Term^&gt;^ GetApps()
<a name="l04719"></a>04719         {
<a name="l04720"></a>04720             <span class="keywordflow">return</span> MkTerms(m_theory-&gt;GetApps());
<a name="l04721"></a>04721         }
<a name="l04722"></a>04722 
<a name="l04723"></a>04723 
<a name="l04724"></a>04724         Sort^ MkSort(Symbol^ s) 
<a name="l04725"></a>04725             {
<a name="l04726"></a>04726                 <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_context-&gt;GetContext,m_theory-&gt;MkSort(s));
<a name="l04727"></a>04727             }
<a name="l04728"></a>04728         
<a name="l04729"></a>04729         Term^ MkValue(Symbol^ s, Sort^ srt) 
<a name="l04730"></a>04730             {
<a name="l04731"></a>04731                 <span class="keywordflow">return</span> MkTerm(m_theory-&gt;MkValue(s, srt()));
<a name="l04732"></a>04732             }
<a name="l04733"></a>04733         
<a name="l04734"></a>04734         Term^ MkConstant(Symbol^ s, Sort^ srt)
<a name="l04735"></a>04735             {
<a name="l04736"></a>04736                 <span class="keywordflow">return</span> MkTerm(m_theory-&gt;MkConstant(s, srt()));
<a name="l04737"></a>04737             }
<a name="l04738"></a>04738         
<a name="l04739"></a>04739         FuncDecl^ MkFuncDecl(Symbol^ n, array&lt;Sort^&gt;^ domain, Sort^ range)
<a name="l04740"></a>04740             {
<a name="l04741"></a>04741                 array&lt;SortPtr&gt;^ dom = <span class="keyword">gcnew</span> array&lt;SortPtr&gt;(domain-&gt;Length);
<a name="l04742"></a>04742                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; domain-&gt;Length; ++i) dom[i] = domain[i]();
<a name="l04743"></a>04743                 <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_context-&gt;GetContext, m_theory-&gt;MkFuncDecl(n, dom, range()));
<a name="l04744"></a>04744             }
<a name="l04745"></a>04745 
<a name="l04746"></a>04746         Sort^ MkSort(String^ s) 
<a name="l04747"></a>04747             {
<a name="l04748"></a>04748                 <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_context-&gt;GetContext,m_theory-&gt;MkSort(s));
<a name="l04749"></a>04749             }
<a name="l04750"></a>04750         
<a name="l04751"></a>04751         Term^ MkValue(String^ s, Sort^ srt) 
<a name="l04752"></a>04752             {
<a name="l04753"></a>04753                 <span class="keywordflow">return</span> MkTerm(m_theory-&gt;MkValue(s, srt()));
<a name="l04754"></a>04754             }
<a name="l04755"></a>04755         
<a name="l04756"></a>04756         Term^ MkConstant(String^ s, Sort^ srt)
<a name="l04757"></a>04757             {
<a name="l04758"></a>04758                 <span class="keywordflow">return</span> MkTerm(m_theory-&gt;MkConstant(s, srt()));
<a name="l04759"></a>04759             }
<a name="l04760"></a>04760         
<a name="l04761"></a>04761         FuncDecl^ MkFuncDecl(String^ n, array&lt;Sort^&gt;^ domain, Sort^ range)
<a name="l04762"></a>04762             {
<a name="l04763"></a>04763                 <span class="keywordflow">return</span> this-&gt;MkFuncDecl(m_context-&gt;MkSymbol(n), domain, range);
<a name="l04764"></a>04764             }
<a name="l04765"></a>04765         
<a name="l04766"></a>04766 
<a name="l04767"></a>04767     };
<a name="l04768"></a>04768 
<a name="l04769"></a>04769 
<a name="l04772"></a>04772 };
<a name="l04773"></a>04773 };
<a name="l04774"></a>04774 
<a name="l04775"></a>04775 <span class="preprocessor">#endif</span>
</pre></div></div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Aug 9 16:34:43 2012
</BODY>
</HTML>
