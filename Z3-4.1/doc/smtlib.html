 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">

<table>
<tr>
<th style="width:120px"><a style="border=0px" class="el" href="index.html"><img border="0" src="z3.png" alt="Z3" /></a></th>
<th style="width:100%">
<div id="nav">
<ul>
<li><a href="download.html">Download</a></li>
<li>/</li>
<li><a href="documentation.html#tutorial">Tutorials</a></li>
<li>/</li>
<li><a href="documentation.html">Documentation</a></li>
<li>/</li>
<li><a href="mail.html">Contact</a></li>
<li>/</li>
<li><a href="faq.html">FAQ</a></li>
<li>/</li>
<li><a href="awards.html">Awards</a></li>
<li>/</li>
<li><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx">RiSE</a></li>
</ul>
</div>
</th>
<th style="width:120px">
<a style="border=0px" class="el" href="http://research.microsoft.com"><img border="0" src="logo_msr.gif" alt="Microsoft Research" />
</th>
</tr>
</table>

<!-- <p> -->
<!-- <img align="middle" src="z3.png" alt="Z3" /> -->
<!-- <table class="centered-small"> -->
<!--   <tr> -->
<!--     <th><a href="index.html"><span>Home</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="documentation.html"><span>Docs</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="download.html"><span>Download</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="mail.html"><span>Mail</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="faq.html"><span>FAQ</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="awards.html"><span>Awards</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com"><span>MSR</span></a></th> -->
<!--   </tr> -->
<!-- </table> -->
<!-- </p> -->

<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">


<h1><a class="anchor" id="smtlib">SMT-LIB format </a></h1><p>The SMT-LIB input format is described on the SMT-LIB web site: <a href="http://www.smtlib.org" class="el">SMT-LIB input format</a>.</p>
<p>The Native Z3 format re-uses the function names used in SMT-LIB. A table of the relevant function names is summarized in the documentation for <a class="el" href="group__theories.html">Z3 theories</a>.</p>
<h2><a class="anchor" id="smtlibext">
SMT-LIB Extensions</a></h2>
<p>Z3 uses a few extensions to SMT-LIB. These are described in the following.</p>
<h3><a class="anchor" id="smtlibpatterns">
Pattern Definitions.</a></h3>
<p>Z3 uses an extension for pattern annotation. It is found in some SMT-LIB benchmarks, but is not widely documented. The annotation <code>:pat</code> is used to annotate quantifiers. It is a hint for Z3 (and other SMT solvers) on how to instantiate the universally quantified formula.</p>
<p>The grammar is </p>
<div class="fragment"><pre class="fragment">  [PATTERN_ANNOTATION] ::= :pat { [EXPR]+ }
</pre></div><p>Example:</p>
<div class="fragment"><pre class="fragment">  (forall (?ind__1 Int) (?val__1 Int)
         (implies (= (Is_BOOLEAN ?val__1) Smt.true) 
                     (= (Is_REFANY_BOOLEAN_MAP (store1 ?map__3 ?ind__1 ?val__1))  Smt.true))
         :pat {(store1 ?map__3 ?ind__1 ?val__1)}))
</pre></div><p>Z3 will instantiate this quantifier whenever it can find an instance of the pattern <code> (store1 ?map__3 ?ind__1 ?val__1)</code> <code>:pat</code> may contain more than one expression. In this case, we say it is a multi-pattern, and the quantifier will only be instantiated if Z3 can simultaneously match all of them. The concept of patterns and multi-patterns was introduced in the Simplify theorem prover. The engine used for pattern instantiation is explained in our <a href="http://research.microsoft.com/projects/z3/cade07.pdf">paper on efficient E-matching</a>.</p>
<h3><a class="anchor" id="smtlibweights">
Weight annotations</a></h3>
<p>The Simplify input format allows annotating quantifiers with weights. These weights influence the priority of quantifier instantiation. The corresponding annotation in SMT-LIB is <code>:weight</code> followed by an unsigned integer annotation.</p>
<p>The grammar is </p>
<div class="fragment"><pre class="fragment">  [WEIGHT_ANNOTATION] ::= :weight { [INT] }
</pre></div><p>Example:</p>
<div class="fragment"><pre class="fragment">   (benchmark weight
    :logic AUFLIRA
    :extrapreds ((P Int Int))
    :formula (forall (x Int) (P x 0) :weight { 12 })
   )
</pre></div><h3><a class="anchor" id="smtlib_labels">
Labels</a></h3>
<p>Similarly to the Simplify input format you can annotate Boolean expressions as labels. You can use integers and identifiers to name labels. The syntax is:</p>
<div class="fragment"><pre class="fragment">  [LABEL_EXPR] ::= (lblpos [NAME] [EXPR])
                |  (lblneg [NAME] [EXPR])
  [NAME]       ::= INT | ID
</pre></div><p>The following example contains two labels. </p>
<div class="fragment"><pre class="fragment">  (benchmark labels
   :logic QF_AUFLIA
   :extrafuns ((start_correct <span class="keywordtype">bool</span>) (A Int) (B Int) (f <span class="keywordtype">bool</span> Int))
   :extrafuns ((ReallyLastGeneratedExit_correct bool) 
                (x@0 Int) (x@1 Int)(x@2 Int) (y@1 Int)
                (t@0 Int) (tt@0 bool) (x Int) (y Int) (A-2-end_correct bool) (B-2-end_correct bool)
                (A_correct bool) (B_correct bool) (y@0 Int) (t Int) (end_correct bool)
                (a Int) (b Int)
                )
  :formula
   (and (= (f (&lt; A B)) 5)
     (or start_correct 
        (not (or start_correct
          (not (or (not (= a b)) (not (equiv tt@0 (= a b)))
          (lblneg 190 (not tt@0)) (not (lblpos 106 true))))
     ))))
   )
</pre></div><h3><a class="anchor" id="smtlibsort_defs">
Sort Definitions</a></h3>
<p>There is a construct for defining sort names. </p>
<div class="fragment"><pre class="fragment">  :define_sorts ((IntArray  (array Int Int)))
</pre></div><p> introduces the name <code>IntArray</code> which can be used instead of the compound sort <code>(array Int Int)</code>.</p>
<p>Then, the term <code>(const[IntArray] 0)</code> can be used for the array of integers where all indices map to 0.</p>
<h3><a class="anchor" id="smtlibdatatypes">
Data-types</a></h3>
<p>The <code>:datatypes</code> attribute lets you define recursive data-types such as lists. </p>
<div class="fragment"><pre class="fragment">  (benchmark data 
   :status unsat 
   :datatypes ((list (cons (car Int) (cdr list)) nil))
 
   :extrafuns ((a list) (b list) (c list))

   :formula (and (= a (cons 10 b)) (not (= (car a) 10)))
  )
</pre></div><p>Tuples and records are just special cases (non-recursive data-types): </p>
<div class="fragment"><pre class="fragment">  (benchmark data 
   :status unsat 
   :datatypes ((tuple (mk (first Int) (second Int))))
   :extrafuns ((a tuple) (b tuple))
   :formula  (and (= (first a) (first b))
                   (= (second a) (second b))
                   (not (= a b)))
  )
</pre></div><p>You can declare mutually recursive data-types </p>
<div class="fragment"><pre class="fragment">   :datatypes ((tree (node (children list)) (leaf (val Int)))
               (list (cons (car tree) (cdr list)) nil))
</pre></div><p>The grammar is:</p>
<div class="fragment"><pre class="fragment">  [DATATYPE_DECLS] ::= :datatypes ( [DATATYPE]+ )
  [DATATYPE] ::= ( [ID] [CONSTRUCTOR_DECL]+ )
  [CONSTRUCTOR_DECL] ::= [ID] | ( [ID] [SORT]+)
</pre></div><h3><a class="anchor" id="smtlibarrays">
Arrays</a></h3>
<p>Z3 provides a few extensions to the theory of arrays. The theoretical basis is explained in <a href="http://research.microsoft.com/apps/pubs/?id=102329">MSR-TR-121</a>.</p>
<p>The extensions comprise of operations:</p>
<div class="fragment"><pre class="fragment">  (<span class="keywordflow">default</span>[array_type] a) 
       Access the <span class="keywordflow">default</span> element of an array.
       <span class="keywordflow">default</span> takes one argument, an array <span class="charliteral">&#39;a&#39;</span>, and 
       returns a value in the range of the array.
       If the model <span class="keywordflow">for</span> <span class="charliteral">&#39;a&#39;</span> maps all but a finite 
        number of domain elements to the same value <span class="charliteral">&#39;v&#39;</span>, then 
       <span class="stringliteral">&#39;(default[array_type] a)&#39;</span> will produce the value <span class="charliteral">&#39;v&#39;</span>.

  (<span class="keyword">const</span>[array_type] v) 
       Produce an array that maps everything to the value <span class="charliteral">&#39;v&#39;</span>.

  (map[unary_function_symbol] a)
  (map[binary_function_symbol] a b)
  (map[ternary_function_symbol] a b c)
       Produce an array such that, respectively:

        (forall (i Index) (= (select (map[unary_f] a) i) (unary_f (select a i))))

        (forall (i Index) (= (select (map[binary_f] a b) i) (binary_f (select a i) (select b i)))

        (forall (i Index) (= (select (map[ternary_f] a b c) i) (unary_f (select a i) (select b i) (select c i))))
</pre></div><p>The following example uses <code>default</code>, <code>const</code> and <code>map</code>. </p>
<div class="fragment"><pre class="fragment">  (benchmark additive_bags
  :status unsat  
  :define_sorts ((IntArray  (array Int Int)))
  :extrafuns ((add_int Int Int Int) (bag IntArray))
  :assumption (forall (x Int) (y Int) (= (add_int x y) (+ x y)) :pat{ (add_int x y) })

  :formula (and (not (= (default[IntArray] bag) 0))
                (= (map[add_int] bag bag) bag))

  :formula (and (not (= (const[IntArray] 0) bag))
                (= (map[add_int] bag bag) bag))
  )
</pre></div> </div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Aug 9 16:34:44 2012
</BODY>
</HTML>
