 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">

<table>
<tr>
<th style="width:120px"><a style="border=0px" class="el" href="index.html"><img border="0" src="z3.png" alt="Z3" /></a></th>
<th style="width:100%">
<div id="nav">
<ul>
<li><a href="download.html">Download</a></li>
<li>/</li>
<li><a href="documentation.html#tutorial">Tutorials</a></li>
<li>/</li>
<li><a href="documentation.html">Documentation</a></li>
<li>/</li>
<li><a href="mail.html">Contact</a></li>
<li>/</li>
<li><a href="faq.html">FAQ</a></li>
<li>/</li>
<li><a href="awards.html">Awards</a></li>
<li>/</li>
<li><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx">RiSE</a></li>
</ul>
</div>
</th>
<th style="width:120px">
<a style="border=0px" class="el" href="http://research.microsoft.com"><img border="0" src="logo_msr.gif" alt="Microsoft Research" />
</th>
</tr>
</table>

<!-- <p> -->
<!-- <img align="middle" src="z3.png" alt="Z3" /> -->
<!-- <table class="centered-small"> -->
<!--   <tr> -->
<!--     <th><a href="index.html"><span>Home</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="documentation.html"><span>Docs</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="download.html"><span>Download</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="mail.html"><span>Mail</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="faq.html"><span>FAQ</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="awards.html"><span>Awards</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com"><span>MSR</span></a></th> -->
<!--   </tr> -->
<!-- </table> -->
<!-- </p> -->

<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">


<h1><a class="anchor" id="config">INI parameters </a></h1><ul>
<li><code>ARITH_ADAPTIVE:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARITH_ADAPTIVE_ASSERTION_THRESHOLD:</code> <em>double</em>, default: <code>0.2</code>, Delay arithmetic atoms if the num-arith-conflicts/total-conflicts &lt; threshold.</li>
</ul>
<ul>
<li><code>ARITH_ADAPTIVE_GCD:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARITH_ADAPTIVE_PROPAGATION_THRESHOLD:</code> <em>double</em>, default: <code>0.4</code>, Disable arithmetic theory propagation if the num-arith-conflicts/total-conflicts &lt; threshold.</li>
</ul>
<ul>
<li><code>ARITH_ADD_BINARY_BOUNDS:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARITH_BLANDS_RULE_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>1000</code> </li>
</ul>
<ul>
<li><code>ARITH_BRANCH_CUT_RATIO:</code> <em>unsigned</em> <em>integer</em>, default: <code>2</code> </li>
</ul>
<ul>
<li><code>ARITH_DUMP_LEMMAS:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARITH_EAGER_EQ_AXIOMS:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>ARITH_EAGER_GCD:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARITH_EQ_BOUNDS:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARITH_EUCLIDEAN_SOLVER:</code> <em>boolean</em>, default: <code>false</code>, .</li>
</ul>
<ul>
<li><code>ARITH_EXPAND_EQS:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARITH_FORCE_SIMPLEX:</code> <em>boolean</em>, default: <code>false</code>, force Z3 to use simplex solver..</li>
</ul>
<ul>
<li><code>ARITH_GCD_TEST:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>ARITH_IGNORE_INT:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARITH_LAZY_ADAPTER:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARITH_LAZY_PIVOTING:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code> </li>
</ul>
<ul>
<li><code>ARITH_MAX_LEMMA_SIZE:</code> <em>unsigned</em> <em>integer</em>, default: <code>128</code> </li>
</ul>
<ul>
<li><code>ARITH_PROCESS_ALL_EQS:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARITH_PROPAGATE_EQS:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>ARITH_PROPAGATION_MODE:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>2</code> </li>
</ul>
<ul>
<li><code>ARITH_PROPAGATION_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code> </li>
</ul>
<ul>
<li><code>ARITH_PROP_STRATEGY:</code> <em>unsigned</em> <em>integer</em>, max: <code>1</code>, default: <code>1</code>, Propagation strategy: 0 - use agility measures based on ration of theory conflicts, 1 - propagate proportional to ratio of theory conflicts (default).</li>
</ul>
<ul>
<li><code>ARITH_RANDOM_INITIAL_VALUE:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARITH_RANDOM_LOWER:</code> <em>integer</em>, default: <code>-1000</code> </li>
</ul>
<ul>
<li><code>ARITH_RANDOM_SEED:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code> </li>
</ul>
<ul>
<li><code>ARITH_RANDOM_UPPER:</code> <em>integer</em>, default: <code>1000</code> </li>
</ul>
<ul>
<li><code>ARITH_REFLECT:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>ARITH_SKIP_BIG_COEFFS:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>ARITH_SMALL_LEMMA_SIZE:</code> <em>unsigned</em> <em>integer</em>, default: <code>16</code> </li>
</ul>
<ul>
<li><code>ARITH_SOLVER:</code> <em>integer</em>, min: <code>0</code>, max: <code>3</code>, default: <code>2</code>, select arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination.</li>
</ul>
<ul>
<li><code>ARITH_STRONGER_LEMMAS:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>ARRAY_ALWAYS_PROP_UPWARD:</code> <em>boolean</em>, default: <code>true</code>, Disable the built-in filter upwards propagation.</li>
</ul>
<ul>
<li><code>ARRAY_CANONIZE:</code> <em>boolean</em>, default: <code>false</code>, Normalize arrays into normal form during simplification.</li>
</ul>
<ul>
<li><code>ARRAY_CG:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARRAY_DELAY_EXP_AXIOM:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>ARRAY_EXTENSIONAL:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>ARRAY_LAZINESS:</code> <em>unsigned</em> <em>integer</em>, default: <code>1</code> </li>
</ul>
<ul>
<li><code>ARRAY_LAZY_IEQ:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ARRAY_LAZY_IEQ_DELAY:</code> <em>unsigned</em> <em>integer</em>, default: <code>10</code> </li>
</ul>
<ul>
<li><code>ARRAY_SOLVER:</code> <em>integer</em>, min: <code>0</code>, max: <code>3</code>, default: <code>3</code>, 0 - no array, 1 - simple, 2 - model based, 3 - full.</li>
</ul>
<ul>
<li><code>ARRAY_WEAK:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>ASYNC_COMMANDS:</code> <em>boolean</em>, default: <code>true</code>, enable/disable support for asynchronous commands in the Simplify front-end..</li>
</ul>
<ul>
<li><code>AT_LABELS_CEX:</code> <em>boolean</em>, default: <code>false</code>, only use labels that contain '@' when building multiple counterexamples.</li>
</ul>
<ul>
<li><code>AUTO_CONFIG:</code> <em>boolean</em>, default: <code>true</code>, use heuristics to set Z3 configuration parameters, it is only available for the SMT-LIB input format.</li>
</ul>
<ul>
<li><code>BB_EAGER:</code> <em>boolean</em>, default: <code>false</code>, eager bit blasting.</li>
</ul>
<ul>
<li><code>BB_EXT_GATES:</code> <em>boolean</em>, default: <code>false</code>, use extended gates during bit-blasting.</li>
</ul>
<ul>
<li><code>BB_QUANTIFIERS:</code> <em>boolean</em>, default: <code>false</code>, convert bit-vectors to Booleans in quantifiers.</li>
</ul>
<ul>
<li><code>BIN_CLAUSES:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>BIT2INT:</code> <em>boolean</em>, default: <code>false</code>, hoist bit2int conversions over arithmetical expressions.</li>
</ul>
<ul>
<li><code>BV2INT_DISTRIBUTE:</code> <em>boolean</em>, default: <code>true</code>, if true, then int2bv is distributed over arithmetical operators..</li>
</ul>
<ul>
<li><code>BV_BLAST_MAX_SIZE:</code> <em>unsigned</em> <em>integer</em>, default: <code>2147483647</code>, Maximal size for bit-vectors to blast.</li>
</ul>
<ul>
<li><code>BV_CC:</code> <em>boolean</em>, default: <code>false</code>, enable congruence closure for BV operators.</li>
</ul>
<ul>
<li><code>BV_ENABLE_INT2BV_PROPAGATION:</code> <em>boolean</em>, default: <code>false</code>, enable full (potentially expensive) propagation for int2bv and bv2int.</li>
</ul>
<ul>
<li><code>BV_LAZY_LE:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>BV_MAX_SHARING:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>BV_REFLECT:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>BV_SOLVER:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>1</code>, 0 - no bv, 1 - simple.</li>
</ul>
<ul>
<li><code>CASE_SPLIT:</code> <em>integer</em>, min: <code>0</code>, max: <code>5</code>, default: <code>1</code>, 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal.</li>
</ul>
<ul>
<li><code>CHECK_AT_LABELS:</code> <em>boolean</em>, default: <code>false</code>, check that labels containing '@' are used correctly to only produce unique counter examples.</li>
</ul>
<ul>
<li><code>CHECK_PROOF:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>CNF_FACTOR:</code> <em>unsigned</em> <em>integer</em>, default: <code>4</code>, the maximum number of clauses that can be created when converting a subformula.</li>
</ul>
<ul>
<li><code>CNF_MODE:</code> <em>integer</em>, min: <code>0</code>, max: <code>3</code>, default: <code>0</code>, CNF translation mode: 0 - disabled, 1 - quantifiers in CNF, 2 - 0 + opportunistic, 3 - full.</li>
</ul>
<ul>
<li><code>CONTEXT_SIMPLIFIER:</code> <em>boolean</em>, default: <code>false</code>, Simplify Boolean sub-expressions if they already appear in context.</li>
</ul>
<ul>
<li><code>DACK:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>1</code>, 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution..</li>
</ul>
<ul>
<li><code>DACK_EQ:</code> <em>boolean</em>, default: <code>false</code>, enable dynamic ackermannization for transtivity of equalities.</li>
</ul>
<ul>
<li><code>DACK_FACTOR:</code> <em>double</em>, default: <code>0.1</code>, number of instance per conflict.</li>
</ul>
<ul>
<li><code>DACK_GC:</code> <em>unsigned</em> <em>integer</em>, default: <code>2000</code>, Dynamic ackermannization garbage collection frequency (per conflict)..</li>
</ul>
<ul>
<li><code>DACK_GC_INV_DECAY:</code> <em>double</em>, default: <code>0.8</code> </li>
</ul>
<ul>
<li><code>DACK_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>10</code>, number of times the congruence rule must be used before Leibniz's axiom is expanded.</li>
</ul>
<ul>
<li><code>DEFAULT_QID:</code> <em>boolean</em>, default: <code>false</code>, create a default quantifier id based on its position, the id is used to report profiling information (see QI_PROFILE).</li>
</ul>
<ul>
<li><code>DELAY_UNITS:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>DELAY_UNITS_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>32</code> </li>
</ul>
<ul>
<li><code>DER:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>DISPLAY_CONFIG:</code> <em>boolean</em>, default: <code>false</code>, display configuration used by Z3.</li>
</ul>
<ul>
<li><code>DISPLAY_DOT_PROOF:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>DISPLAY_ERROR_FOR_VISUAL_STUDIO:</code> <em>boolean</em>, default: <code>false</code>, display error messages in Visual Studio format.</li>
</ul>
<ul>
<li><code>DISPLAY_FEATURES:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>DISPLAY_PROOF:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>DISPLAY_UNSAT_CORE:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>DISTRIBUTE_FORALL:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>DL_ALL_OR_NOTHING_DELTAS:</code> <em>boolean</em>, default: <code>false</code>, compile rules so that it is enough for the delta relation in union and widening operations to determine only whether the updated relation was modified or not.</li>
</ul>
<ul>
<li><code>DL_COMPILE_WITH_WIDENING:</code> <em>boolean</em>, default: <code>false</code>, widening will be used to compile recursive rules.</li>
</ul>
<ul>
<li><code>DL_DBG_FPR_NONEMPTY_RELATION_SIGNATURE:</code> <em>boolean</em>, default: <code>false</code>, if true, finite_product_relation will attempt to avoid creating inner relation with empty signature by putting in half of the table columns, if it would have been empty otherwise.</li>
</ul>
<ul>
<li><code>DL_DEFAULT_RELATION:</code> <em>symbol</em>, default: external_relation, default relation implementation: 'external_relation', 'pentagon'.</li>
</ul>
<ul>
<li><code>DL_DEFAULT_TABLE:</code> <em>symbol</em>, default: sparse, default table implementation: 'hashtable', 'bitvector', 'sparse' 'interval'.</li>
</ul>
<ul>
<li><code>DL_DEFAULT_TABLE_CHECKED:</code> <em>boolean</em>, default: <code>false</code>, if true, the detault table will be DL_DEFAULT_TABLE inside a wrapper that checks that its results are the same as of DL_DEFAULT_TABLE_CHECKER table.</li>
</ul>
<ul>
<li><code>DL_DEFAULT_TABLE_CHECKER:</code> <em>symbol</em>, default: sparse, see DL_DEFAULT_TABLE_CHECKED.</li>
</ul>
<ul>
<li><code>DL_EAGER_EMPTINESS_CHECKING:</code> <em>boolean</em>, default: <code>true</code>, emptiness of affected relations will be checked after each instruction, so that we may ommit unnecessary instructions.</li>
</ul>
<ul>
<li><code>DL_ENGINE:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, Underlying Datalog engine. (0) Datalog table based bottom-up, (1) PDR.</li>
</ul>
<ul>
<li><code>DL_EXPLANATIONS_ON_RELATION_LEVEL:</code> <em>boolean</em>, default: <code>false</code>, if true, explanations are generated as history of each relation, rather than per fact (DL_GENERATE_EXPLANATIONS must be set to true for this option to have any effect).</li>
</ul>
<ul>
<li><code>DL_FIX_UNBOUND_VARS:</code> <em>boolean</em>, default: <code>false</code>, fix unbound variables in tail.</li>
</ul>
<ul>
<li><code>DL_GENERATE_EXPLANATIONS:</code> <em>boolean</em>, default: <code>false</code>, if true, signature of relations will be extended to contain explanations for facts.</li>
</ul>
<ul>
<li><code>DL_INITIAL_RESTART_TIMEOUT:</code> <em>unsigned</em> <em>integer</em>, min: <code>1</code>, default: <code>0</code>, length of saturation run before the first restart (in ms); zero means no restarts.</li>
</ul>
<ul>
<li><code>DL_MAGIC_SETS_FOR_QUERIES:</code> <em>boolean</em>, default: <code>false</code>, magic set transformation will be used for queries.</li>
</ul>
<ul>
<li><code>DL_OUTPUT_PROFILE:</code> <em>boolean</em>, default: <code>false</code>, determines whether profile informations should be output when outputting Datalog rules or instructions.</li>
</ul>
<ul>
<li><code>DL_OUTPUT_TUPLES:</code> <em>boolean</em>, default: <code>true</code>, determines whether tuples for output predicates should be output.</li>
</ul>
<ul>
<li><code>DL_PDR_BFS_MODEL_SEARCH:</code> <em>boolean</em>, default: <code>true</code>, use BFS strategey for expanding model search.</li>
</ul>
<ul>
<li><code>DL_PDR_CACHE_MODE:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, use symbolic (1) or explicit cache (2) for model search.</li>
</ul>
<ul>
<li><code>DL_PDR_INDUCTIVE_REACHABILITY_CHECK:</code> <em>boolean</em>, default: <code>false</code>, assume negation of the cube on the previous level when checking for reachability (not only during cube weakening).</li>
</ul>
<ul>
<li><code>DL_PDR_INITIAL_SATURATION_TIMEOUT:</code> <em>unsigned</em> <em>integer</em>, default: <code>400</code>, number of millisedonds to run datalog saturation on PDR problem instance.</li>
</ul>
<ul>
<li><code>DL_PDR_MAX_NUM_CONTEXTS:</code> <em>unsigned</em> <em>integer</em>, default: <code>500</code>, maximal number of contexts to create for PDR.</li>
</ul>
<ul>
<li><code>DL_PDR_USE_FARKAS:</code> <em>boolean</em>, default: <code>false</code>, true if lemma generator based on farkas lemma should be used in PDR.</li>
</ul>
<ul>
<li><code>DL_PDR_USE_FARKAS_MODEL:</code> <em>boolean</em>, default: <code>false</code>, enable using Farkas generalization through model propagation.</li>
</ul>
<ul>
<li><code>DL_PDR_USE_FARKAS_PROPERTIES:</code> <em>boolean</em>, default: <code>false</code>, true if lemma generator fbased on farkas lemma should be used in PDR for predicates from transformer.</li>
</ul>
<ul>
<li><code>DL_PDR_USE_INDUCTIVE_GENERALIZER:</code> <em>boolean</em>, default: <code>true</code>, use inductive generalization of model.</li>
</ul>
<ul>
<li><code>DL_PDR_USE_MULTI_CORE_GENERALIZER:</code> <em>boolean</em>, default: <code>false</code>, extract multiple cores for blocking states.</li>
</ul>
<ul>
<li><code>DL_PDR_USE_PRECOND_GENERALIZER:</code> <em>boolean</em>, default: <code>false</code>, true if pre-conditions are to be generalized by selected weakest pre-condition.</li>
</ul>
<ul>
<li><code>DL_PROFILE_MILLISECONDS_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, instructions and rules that took less than the threshold will not be printed when printed the instruction/rule list.</li>
</ul>
<ul>
<li><code>DL_RESTART_TIMEOUT_QUOTIENT:</code> <em>unsigned</em> <em>integer</em>, min: <code>1</code>, default: <code>4</code>, restart timeout will be multiplied by this number after each restart.</li>
</ul>
<ul>
<li><code>DL_SIMILARITY_COMPRESSOR:</code> <em>boolean</em>, default: <code>true</code>, rules that difer only in values of constants will be merged into a single rule.</li>
</ul>
<ul>
<li><code>DL_SIMILARITY_COMPRESSOR_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, min: <code>2</code>, default: <code>11</code>, if DL_SIMILARITY_COMPRESSOR is on, this value determines how many similar rules there must be in order for them to be merged.</li>
</ul>
<ul>
<li><code>DL_SMT_RELATION_GROUND_RECURSIVE:</code> <em>boolean</em>, default: <code>true</code>, Ensure recursive relation is ground in union.</li>
</ul>
<ul>
<li><code>DL_UNBOUND_COMPRESSOR:</code> <em>boolean</em>, default: <code>true</code>, auxiliary relations will be introduced to avoid unbound variables in rule heads.</li>
</ul>
<ul>
<li><code>DL_USE_MAP_NAMES:</code> <em>boolean</em>, default: <code>true</code>, use names from map files when displaying tuples.</li>
</ul>
<ul>
<li><code>DT_LAZY_SPLITS:</code> <em>unsigned</em> <em>integer</em>, default: <code>1</code>, How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy.</li>
</ul>
<ul>
<li><code>DUMP_GOAL_AS_SMT:</code> <em>boolean</em>, default: <code>false</code>, write goal back to output in SMT format.</li>
</ul>
<ul>
<li><code>ELIM_AND:</code> <em>boolean</em>, default: <code>true</code>, represent (and a b) as (not (or (not a) (not b))).</li>
</ul>
<ul>
<li><code>ELIM_BOUNDS:</code> <em>boolean</em>, default: <code>false</code>, cheap Fourier-Motzkin.</li>
</ul>
<ul>
<li><code>ELIM_NLARITH_QUANTIFIERS:</code> <em>boolean</em>, default: <code>false</code>, Eliminate non-linear quantifiers.</li>
</ul>
<ul>
<li><code>ELIM_QUANTIFIERS:</code> <em>boolean</em>, default: <code>false</code>, Use quantifier elimination procedures on Boolean, Bit-vector, Arithmetic and Array variables.</li>
</ul>
<ul>
<li><code>ELIM_TERM_ITE:</code> <em>boolean</em>, default: <code>false</code>, eliminate term if-then-else in the preprocessor.</li>
</ul>
<ul>
<li><code>EMATCHING:</code> <em>boolean</em>, default: <code>true</code>, E-Matching based quantifier instantiation.</li>
</ul>
<ul>
<li><code>ENGINE:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, 0: SMT solver, 1: Superposition prover, 2: EPR solver, true.</li>
</ul>
<ul>
<li><code>EQ_PROPAGATION:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>HI_DIV0:</code> <em>boolean</em>, default: <code>true</code>, if true, then Z3 uses the usual hardware interpretation for division (rem, mod) by zero. Otherwise, these operations are considered uninterpreted..</li>
</ul>
<ul>
<li><code>IGNORE_BAD_PATTERNS:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>IGNORE_SETPARAMETER:</code> <em>boolean</em>, default: <code>false</code>, ignore (SETPARAMETER ...) commands in Simplify format input.</li>
</ul>
<ul>
<li><code>INSTRUCTION_MAX:</code> <em>double</em>, default: <code>0</code>, set the (approximate) maximal number of instructions per invocation of check.</li>
</ul>
<ul>
<li><code>INST_GEN:</code> <em>boolean</em>, default: <code>false</code>, Enable Instantiation Generation solver (disables other quantifier reasoning).</li>
</ul>
<ul>
<li><code>INTERACTIVE:</code> <em>boolean</em>, default: <code>false</code>, enable interactive mode using Simplify input format.</li>
</ul>
<ul>
<li><code>INTERNALIZER_NNF:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>LEMMA_GC_FACTOR:</code> <em>double</em>, default: <code>1.1</code>, used by geometric strategy.</li>
</ul>
<ul>
<li><code>LEMMA_GC_HALF:</code> <em>boolean</em>, default: <code>false</code>, true for simple gc algorithm (delete approx. half of the clauses).</li>
</ul>
<ul>
<li><code>LEMMA_GC_INITIAL:</code> <em>unsigned</em> <em>integer</em>, default: <code>5000</code>, lemma initial gc frequency (in number of conflicts), used by fixed or geometric strategies.</li>
</ul>
<ul>
<li><code>LEMMA_GC_NEW_CLAUSE_ACTIVITY:</code> <em>unsigned</em> <em>integer</em>, default: <code>10</code> </li>
</ul>
<ul>
<li><code>LEMMA_GC_NEW_CLAUSE_RELEVANCY:</code> <em>unsigned</em> <em>integer</em>, default: <code>45</code> </li>
</ul>
<ul>
<li><code>LEMMA_GC_NEW_OLD_RATIO:</code> <em>unsigned</em> <em>integer</em>, default: <code>16</code> </li>
</ul>
<ul>
<li><code>LEMMA_GC_OLD_CLAUSE_ACTIVITY:</code> <em>unsigned</em> <em>integer</em>, default: <code>500</code> </li>
</ul>
<ul>
<li><code>LEMMA_GC_OLD_CLAUSE_RELEVANCY:</code> <em>unsigned</em> <em>integer</em>, default: <code>500</code> </li>
</ul>
<ul>
<li><code>LEMMA_GC_STRATEGY:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, 0 - fixed, 1 - geometric, 2 - at every restart.</li>
</ul>
<ul>
<li><code>LIFT_ITE:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, ite term lifting: 0 - no lifting, 1 - conservative, 2 - full.</li>
</ul>
<ul>
<li><code>LOOKAHEAD_DISEQ:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>MACRO_FINDER:</code> <em>boolean</em>, default: <code>false</code>, try to find universally quantified formulas that can be viewed as macros.</li>
</ul>
<ul>
<li><code>MAX_CONFLICTS:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code>, maximum number of conflicts.</li>
</ul>
<ul>
<li><code>MAX_COUNTEREXAMPLES:</code> <em>unsigned</em> <em>integer</em>, default: <code>1</code>, set the maximum number of counterexamples when using Simplify front end.</li>
</ul>
<ul>
<li><code>MBQI:</code> <em>boolean</em>, default: <code>true</code>, Model Based Quantifier Instantiation (MBQI).</li>
</ul>
<ul>
<li><code>MBQI_FORCE_TEMPLATE:</code> <em>unsigned</em> <em>integer</em>, default: <code>10</code>, Some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight &gt;= MBQI_FORCE_TEMPLATE are forced to be used as a template.</li>
</ul>
<ul>
<li><code>MBQI_MAX_CEXS:</code> <em>unsigned</em> <em>integer</em>, default: <code>1</code>, Initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation.</li>
</ul>
<ul>
<li><code>MBQI_MAX_CEXS_INCR:</code> <em>unsigned</em> <em>integer</em>, default: <code>1</code>, Increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI.</li>
</ul>
<ul>
<li><code>MBQI_MAX_ITERATIONS:</code> <em>unsigned</em> <em>integer</em>, default: <code>1000</code>, Maximum number of rounds of MBQI.</li>
</ul>
<ul>
<li><code>MBQI_TRACE:</code> <em>boolean</em>, default: <code>false</code>, Generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied..</li>
</ul>
<ul>
<li><code>MEMORY_HIGH_WATERMARK:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, set high watermark for memory consumption (in megabytes).</li>
</ul>
<ul>
<li><code>MEMORY_MAX_SIZE:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, set hard upper limit for memory consumption (in megabytes).</li>
</ul>
<ul>
<li><code>MINIMIZE_LEMMAS:</code> <em>boolean</em>, default: <code>true</code>, enable/disable lemma minimization algorithm.</li>
</ul>
<ul>
<li><code>MODEL:</code> <em>boolean</em>, default: <code>true</code>, enable/disable model construction.</li>
</ul>
<ul>
<li><code>MODEL_COMPACT:</code> <em>boolean</em>, default: <code>false</code>, try to compact function graph (i.e., function interpretations that are lookup tables.</li>
</ul>
<ul>
<li><code>MODEL_COMPLETION:</code> <em>boolean</em>, default: <code>false</code>, assigns an interptetation to symbols that do not have one in the current model, when evaluating expressions in the current model.</li>
</ul>
<ul>
<li><code>MODEL_DISPLAY_ARG_SORT:</code> <em>boolean</em>, default: <code>true</code>, display the sort of each argument when printing function interpretations.</li>
</ul>
<ul>
<li><code>MODEL_HIDE_UNUSED_PARTITIONS:</code> <em>boolean</em>, default: <code>true</code>, hide unused partitions, some partitions are associated with internal terms/formulas created by Z3.</li>
</ul>
<ul>
<li><code>MODEL_ON_FINAL_CHECK:</code> <em>boolean</em>, default: <code>false</code>, display candidate model (in the standard output) whenever Z3 hits a final check.</li>
</ul>
<ul>
<li><code>MODEL_ON_TIMEOUT:</code> <em>boolean</em>, default: <code>false</code>, after hitting soft-timeout or memory high watermark, generate a candidate model.</li>
</ul>
<ul>
<li><code>MODEL_PARTIAL:</code> <em>boolean</em>, default: <code>false</code>, enable/disable partial function interpretations.</li>
</ul>
<ul>
<li><code>MODEL_V1:</code> <em>boolean</em>, default: <code>false</code>, use Z3 version 1.x pretty printer.</li>
</ul>
<ul>
<li><code>MODEL_V2:</code> <em>boolean</em>, default: <code>false</code>, use Z3 version 2.x (x &lt;= 16) pretty printer.</li>
</ul>
<ul>
<li><code>MODEL_VALIDATE:</code> <em>boolean</em>, default: <code>false</code>, validate the model.</li>
</ul>
<ul>
<li><code>NEW_CORE2TH_EQ:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>NG_LIFT_ITE:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, ite (non-ground) term lifting: 0 - no lifting, 1 - conservative, 2 - full.</li>
</ul>
<ul>
<li><code>NL_ARITH:</code> <em>boolean</em>, default: <code>true</code>, enable/disable non linear arithmetic support. This option is ignored when ARITH_SOLVER != 2..</li>
</ul>
<ul>
<li><code>NL_ARITH_BRANCHING:</code> <em>boolean</em>, default: <code>true</code>, enable/disable branching on integer variables in non linear clusters.</li>
</ul>
<ul>
<li><code>NL_ARITH_GB:</code> <em>boolean</em>, default: <code>true</code>, enable/disable Grobner Basis computation. This option is ignored when NL_ARITH=false.</li>
</ul>
<ul>
<li><code>NL_ARITH_GB_EQS:</code> <em>boolean</em>, default: <code>false</code>, enable/disable equations in the Grobner Basis to be copied to the Simplex tableau..</li>
</ul>
<ul>
<li><code>NL_ARITH_GB_PERTURBATE:</code> <em>boolean</em>, default: <code>true</code>, enable/disable perturbation of the variable order in GB when searching for new polynomials..</li>
</ul>
<ul>
<li><code>NL_ARITH_GB_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>512</code>, Grobner basis computation can be very expensive. This is a threshold on the number of new equalities that can be generated..</li>
</ul>
<ul>
<li><code>NL_ARITH_MAX_DEGREE:</code> <em>unsigned</em> <em>integer</em>, default: <code>6</code>, max degree for internalizing new monomials..</li>
</ul>
<ul>
<li><code>NL_ARITH_ROUNDS:</code> <em>unsigned</em> <em>integer</em>, default: <code>1024</code>, threshold for number of (nested) final checks for non linear arithmetic..</li>
</ul>
<ul>
<li><code>NNF_FACTOR:</code> <em>unsigned</em> <em>integer</em>, default: <code>4</code>, the maximum growth factor during NNF translation (auxiliary definitions are introduced if the threshold is reached).</li>
</ul>
<ul>
<li><code>NNF_IGNORE_LABELS:</code> <em>boolean</em>, default: <code>false</code>, remove/ignore labels in the input formula, this option is ignored if proofs are enabled.</li>
</ul>
<ul>
<li><code>NNF_MODE:</code> <em>integer</em>, min: <code>0</code>, max: <code>3</code>, default: <code>0</code>, NNF translation mode: 0 - skolem normal form, 1 - 0 + quantifiers in NNF, 2 - 1 + opportunistic, 3 - full.</li>
</ul>
<ul>
<li><code>NNF_SK_HACK:</code> <em>boolean</em>, default: <code>false</code>, hack for VCC.</li>
</ul>
<ul>
<li><code>ORDER:</code> <em>integer</em>, min: <code>0</code>, max: <code>1</code>, default: <code>0</code>, Term ordering: 0 - KBO, 1 - LPO.</li>
</ul>
<ul>
<li><code>ORDER_VAR_WEIGHT:</code> <em>unsigned</em> <em>integer</em>, default: <code>1</code>, weight of variables in term orderings (e.g., KBO).</li>
</ul>
<ul>
<li><code>ORDER_WEIGHTS:</code> <em>list</em> <em>of</em> <em>pairs:</em> <em>symbols(strings)</em> <em>x</em> <em>unsigned</em>, describe a (partial) assignment of weights to function symbols for term orderings (e.g., KBO). The assigment is a list of pairs of the form f:n where f is a string and n is a natural. Example: WEIGHTS="(f:1, g:2, h:3)".</li>
</ul>
<ul>
<li><code>PHASE_SELECTION:</code> <em>integer</em>, min: <code>0</code>, max: <code>6</code>, default: <code>3</code>, phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences.</li>
</ul>
<ul>
<li><code>PI_ARITH:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>1</code>, 0 - do not infer patterns with arithmetic terms, 1 - use patterns with arithmetic terms if there is no other pattern, 2 - always use patterns with arithmetic terms..</li>
</ul>
<ul>
<li><code>PI_ARITH_WEIGHT:</code> <em>unsigned</em> <em>integer</em>, default: <code>5</code>, default weight for quantifiers where the only available pattern has nested arithmetic terms..</li>
</ul>
<ul>
<li><code>PI_AVOID_SKOLEMS:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>PI_BLOCK_LOOOP_PATTERNS:</code> <em>boolean</em>, default: <code>true</code>, block looping patterns during pattern inference.</li>
</ul>
<ul>
<li><code>PI_MAX_MULTI_PATTERNS:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, when patterns are not provided, the prover uses a heuristic to infer them. This option sets the threshold on the number of extra multi-patterns that can be created. By default, the prover creates at most one multi-pattern when there is no unary pattern.</li>
</ul>
<ul>
<li><code>PI_NON_NESTED_ARITH_WEIGHT:</code> <em>unsigned</em> <em>integer</em>, default: <code>10</code>, default weight for quantifiers where the only available pattern has non nested arithmetic terms..</li>
</ul>
<ul>
<li><code>PI_NOPAT_WEIGHT:</code> <em>integer</em>, default: <code>-1</code>, set weight of quantifiers without patterns, if negative the weight is not changed..</li>
</ul>
<ul>
<li><code>PI_PULL_QUANTIFIERS:</code> <em>boolean</em>, default: <code>true</code>, pull nested quantifiers, if no pattern was found..</li>
</ul>
<ul>
<li><code>PI_USE_DATABASE:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>PI_WARNINGS:</code> <em>boolean</em>, default: <code>false</code>, enable/disable warning messages in the pattern inference module..</li>
</ul>
<ul>
<li><code>PP_BOUNDED:</code> <em>boolean</em>, default: <code>false</code>, ignore characters exceeding max widht.</li>
</ul>
<ul>
<li><code>PP_BV_LITERALS:</code> <em>boolean</em>, default: <code>true</code>, use Bit-Vector literals (e.g, x0F and b0101) during pretty printing.</li>
</ul>
<ul>
<li><code>PP_BV_NEG:</code> <em>boolean</em>, default: <code>false</code>, use bvneg when displaying Bit-Vector literals where the most significant bit is 1.</li>
</ul>
<ul>
<li><code>PP_DECIMAL:</code> <em>boolean</em>, default: <code>false</code>, pretty print real numbers using decimal notation (the output may be truncated). Z3 adds a '?' if the value is not precise.</li>
</ul>
<ul>
<li><code>PP_DECIMAL_PRECISION:</code> <em>unsigned</em> <em>integer</em>, default: <code>10</code>, maximum number of decimal places to be used when PP_DECIMAL=true.</li>
</ul>
<ul>
<li><code>PP_FIXED_INDENT:</code> <em>boolean</em>, default: <code>false</code>, use a fixed indentation for applications.</li>
</ul>
<ul>
<li><code>PP_FLAT_ASSOC:</code> <em>boolean</em>, default: <code>true</code>, flat associative operators (when pretty printing SMT2 terms/formulas).</li>
</ul>
<ul>
<li><code>PP_MAX_DEPTH:</code> <em>unsigned</em> <em>integer</em>, default: <code>5</code>, max. term depth (when pretty printing SMT2 terms/formulas).</li>
</ul>
<ul>
<li><code>PP_MAX_INDENT:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code>, max. indentation in pretty printer.</li>
</ul>
<ul>
<li><code>PP_MAX_NUM_LINES:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code>, max. number of lines to be displayed in pretty printer.</li>
</ul>
<ul>
<li><code>PP_MAX_RIBBON:</code> <em>unsigned</em> <em>integer</em>, default: <code>80</code>, max. ribbon (width - indentation) in pretty printer.</li>
</ul>
<ul>
<li><code>PP_MAX_WIDTH:</code> <em>unsigned</em> <em>integer</em>, default: <code>80</code>, max. width in pretty printer.</li>
</ul>
<ul>
<li><code>PP_MIN_ALIAS_SIZE:</code> <em>unsigned</em> <em>integer</em>, default: <code>10</code>, min. size for creating an alias for a shared term (when pretty printing SMT2 terms/formulas).</li>
</ul>
<ul>
<li><code>PP_SIMPLIFY_IMPLIES:</code> <em>boolean</em>, default: <code>false</code>, simplify nested implications for pretty printing.</li>
</ul>
<ul>
<li><code>PP_SINGLE_LINE:</code> <em>boolean</em>, default: <code>false</code>, ignore line breaks when true.</li>
</ul>
<ul>
<li><code>PRECEDENCE:</code> <em>list</em> <em>of</em> <em>symbols</em> <em></em>(strings), describe a (partial) precedence for the term ordering used in the Superposition Calculus module. The precedence is lists of function symbols. Example: PRECEDENCE="(f, g, h)".</li>
</ul>
<ul>
<li><code>PRECEDENCE_GEN:</code> <em>list</em> <em>of</em> <em>symbols</em> <em></em>(strings), describe how a total precedence order is generated. The generator is a sequence of simple (partial) orders with an optional '-' (indicating the next (partial) order should be inverted). The available simple (partial) orders are: user (the order specified by precedence); arity; interpreted (interpreted function symbols are considered smaller); definition (defined function symbols are considered bigger); frequency; arbitrary (total arbitrary order generated by Z3). Example: PRECEDENCE_GEN="user interpreted - arity arbitraty".</li>
</ul>
<ul>
<li><code>PRE_DEMODULATOR:</code> <em>boolean</em>, default: <code>false</code>, apply demodulators during preprocessing step.</li>
</ul>
<ul>
<li><code>PRE_SIMPLIFIER:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>PRE_SIMPLIFY_EXPR:</code> <em>boolean</em>, default: <code>false</code>, pre-simplify expressions when created over the API (example: -x -&gt; (* -1 x)).</li>
</ul>
<ul>
<li><code>PROFILE_RES_SUB:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>PROGRESS_SAMPLING_FREQ:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, frequency for progress output in miliseconds.</li>
</ul>
<ul>
<li><code>PROOF_MODE:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, select proof generation mode: 0 - disabled, 1 - coarse grain, 2 - fine grain.</li>
</ul>
<ul>
<li><code>PROPAGATE_BOOLEANS:</code> <em>boolean</em>, default: <code>false</code>, propagate boolean values during preprocessing step.</li>
</ul>
<ul>
<li><code>PROPAGATE_VALUES:</code> <em>boolean</em>, default: <code>true</code>, propagate values during preprocessing step.</li>
</ul>
<ul>
<li><code>PULL_CHEAP_ITE_TREES:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>PULL_NESTED_QUANTIFIERS:</code> <em>boolean</em>, default: <code>false</code>, eliminate nested quantifiers by moving nested quantified variables to the outermost quantifier, it is unnecessary if the formula is converted into CNF.</li>
</ul>
<ul>
<li><code>QI_CONSERVATIVE_FINAL_CHECK:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>QI_COST:</code> <em>string</em>, default: (+ weight generation), The cost function for quantifier instantiation.</li>
</ul>
<ul>
<li><code>QI_EAGER_THRESHOLD:</code> <em>double</em>, default: <code>10</code>, Threshold for eager quantifier instantiation.</li>
</ul>
<ul>
<li><code>QI_LAZY_INSTANTIATION:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>QI_LAZY_QUICK_CHECKER:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>QI_LAZY_THRESHOLD:</code> <em>double</em>, default: <code>20</code>, Threshold for lazy quantifier instantiation.</li>
</ul>
<ul>
<li><code>QI_MAX_EAGER_MULTI_PATTERNS:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, Specify the number of extra multi patterns that are processed eagerly. By default, the prover use at most one multi-pattern eagerly when there is no unary pattern. This value should be smaller than or equal to PI_MAX_MULTI_PATTERNS.</li>
</ul>
<ul>
<li><code>QI_MAX_INSTANCES:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code> </li>
</ul>
<ul>
<li><code>QI_MAX_LAZY_MULTI_PATTERN_MATCHING:</code> <em>unsigned</em> <em>integer</em>, default: <code>2</code>, Maximum number of rounds of matching in a branch for delayed multipatterns. A multipattern is delayed based on the value of QI_MAX_EAGER_MULTI_PATTERNS.</li>
</ul>
<ul>
<li><code>QI_NEW_GEN:</code> <em>string</em>, default: cost, The function for calculating the generation of newly constructed terms.</li>
</ul>
<ul>
<li><code>QI_PROFILE:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>QI_PROFILE_FREQ:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code> </li>
</ul>
<ul>
<li><code>QI_PROMOTE_UNSAT:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>QI_QUICK_CHECKER:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, 0 - do not use (cheap) model checker, 1 - instantiate instances unsatisfied by current model, 2 - 1 + instantiate instances not satisfied by current model.</li>
</ul>
<ul>
<li><code>QUASI_MACROS:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>RANDOM_CASE_SPLIT_FREQ:</code> <em>percentage</em>, default: <code>0.01</code>, frequency of random case splits.</li>
</ul>
<ul>
<li><code>RANDOM_INITIAL_ACTIVITY:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>1</code> </li>
</ul>
<ul>
<li><code>RANDOM_SEED:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, random seed for Z3.</li>
</ul>
<ul>
<li><code>RECENT_LEMMA_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>100</code> </li>
</ul>
<ul>
<li><code>REDUCE_ARGS:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>REFINE_INJ_AXIOM:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>RELEVANCY:</code> <em>unsigned</em> <em>integer</em>, default: <code>2</code>, relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant.</li>
</ul>
<ul>
<li><code>RELEVANCY_LEMMA:</code> <em>boolean</em>, default: <code>false</code>, true if lemmas are used to propagate relevancy.</li>
</ul>
<ul>
<li><code>REL_CASE_SPLIT_ORDER:</code> <em>unsigned</em> <em>integer</em>, max: <code>2</code>, default: <code>0</code>, structural (relevancy) splitting order: 0 - left-to-right (default), 1 - random, 2 - right-to-left.</li>
</ul>
<ul>
<li><code>RESTART_ADAPTIVE:</code> <em>boolean</em>, default: <code>true</code>, disable restarts based on the search 'agility'.</li>
</ul>
<ul>
<li><code>RESTART_AGILITY_THRESHOLD:</code> <em>percentage</em>, default: <code>0.18</code> </li>
</ul>
<ul>
<li><code>RESTART_FACTOR:</code> <em>double</em>, default: <code>1.1</code>, when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the currect restart threshold.</li>
</ul>
<ul>
<li><code>RESTART_INITIAL:</code> <em>unsigned</em> <em>integer</em>, default: <code>100</code>, inital restart frequency in number of conflicts, it is also the unit for the luby sequence.</li>
</ul>
<ul>
<li><code>RESTART_STRATEGY:</code> <em>integer</em>, min: <code>0</code>, max: <code>4</code>, default: <code>1</code>, 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic.</li>
</ul>
<ul>
<li><code>RESTRICTED_QUASI_MACROS:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>SIMPLIFY_CLAUSES:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>SMTLIB2_COMPLIANT:</code> <em>boolean</em>, default: <code>true</code> </li>
</ul>
<ul>
<li><code>SMTLIB_CATEGORY:</code> <em>string</em>, default: , additional category info to add to SMTLIB benchmark.</li>
</ul>
<ul>
<li><code>SMTLIB_DUMP_LEMMAS:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>SMTLIB_LOGIC:</code> <em>string</em>, default: AUFLIA, Name used for the :logic field when generating SMT-LIB benchmarks.</li>
</ul>
<ul>
<li><code>SMTLIB_SOURCE_INFO:</code> <em>string</em>, default: , additional source info to add to SMTLIB benchmark.</li>
</ul>
<ul>
<li><code>SMTLIB_TRACE_PATH:</code> <em>string</em>, default: , path for converting Z3 formulas to SMTLIB benchmarks.</li>
</ul>
<ul>
<li><code>SOFT_TIMEOUT:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, set approximate timeout for each solver query (milliseconds), the value 0 represents no timeout.</li>
</ul>
<ul>
<li><code>SOLVER:</code> <em>boolean</em>, default: <code>false</code>, enable solver during preprocessing step.</li>
</ul>
<ul>
<li><code>SPC_BS:</code> <em>boolean</em>, default: <code>true</code>, Enable/disable backward subsumption in the superposition engine.</li>
</ul>
<ul>
<li><code>SPC_ES:</code> <em>boolean</em>, default: <code>true</code>, Enable/disable equality resolution in the superposition engine.</li>
</ul>
<ul>
<li><code>SPC_FACTOR_SUBSUMPTION_INDEX_OPT:</code> <em>double</em>, default: <code>1.5</code>, after each optimization the threshold for optimization is increased by this factor. See INITIAL_SUBSUMPTION_INDEX_OPT..</li>
</ul>
<ul>
<li><code>SPC_INITIAL_SUBSUMPTION_INDEX_OPT:</code> <em>unsigned</em> <em>integer</em>, default: <code>1000</code>, after how many processed clauses the subsumption index is optimized..</li>
</ul>
<ul>
<li><code>SPC_MAX_SUBSUMPTION_INDEX_FEATURES:</code> <em>unsigned</em> <em>integer</em>, default: <code>32</code>, maximum number of features to be used for subsumption index..</li>
</ul>
<ul>
<li><code>SPC_MIN_FUNC_FREQ_SUBSUMPTION_INDEX:</code> <em>unsigned</em> <em>integer</em>, default: <code>100</code>, minimal number of occurrences (in clauses) for a function symbol to be considered for subsumption indexing..</li>
</ul>
<ul>
<li><code>SPC_NUM_ITERATIONS:</code> <em>unsigned</em> <em>integer</em>, default: <code>1000</code> </li>
</ul>
<ul>
<li><code>SPC_TRACE:</code> <em>boolean</em>, default: <code>false</code> </li>
</ul>
<ul>
<li><code>STATISTICS:</code> <em>boolean</em>, default: <code>false</code>, display statistics.</li>
</ul>
<ul>
<li><code>STRONG_CONTEXT_SIMPLIFIER:</code> <em>boolean</em>, default: <code>false</code>, Simplify Boolean sub-expressions by using full satisfiability queries.</li>
</ul>
<ul>
<li><code>TICK:</code> <em>unsigned</em> <em>integer</em>, default: <code>1000</code> </li>
</ul>
<ul>
<li><code>TRACE:</code> <em>boolean</em>, default: <code>false</code>, enable tracing for the Axiom Profiler tool.</li>
</ul>
<ul>
<li><code>TRACE_FILE_NAME:</code> <em>string</em>, default: z3.log, tracing file name.</li>
</ul>
<ul>
<li><code>TYPE_CHECK:</code> <em>boolean</em>, default: <code>true</code>, enable/disable type checker.</li>
</ul>
<ul>
<li><code>USER_THEORY_PERSIST_AXIOMS:</code> <em>boolean</em>, default: <code>false</code>, Persist user axioms to the base level.</li>
</ul>
<ul>
<li><code>USER_THEORY_PREPROCESS_AXIOMS:</code> <em>boolean</em>, default: <code>false</code>, Apply full pre-processing to user theory axioms.</li>
</ul>
<ul>
<li><code>VERBOSE:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, be verbose, where the value is the verbosity level.</li>
</ul>
<ul>
<li><code>WARNING:</code> <em>boolean</em>, default: <code>true</code>, enable/disable warning messages.</li>
</ul>
<ul>
<li><code>WELL_SORTED_CHECK:</code> <em>boolean</em>, default: <code>true</code>, enable/disable type checker.</li>
</ul>
<ul>
<li><code>Z3_SOLVER_LL_PP:</code> <em>boolean</em>, default: <code>false</code>, pretty print asserted constraints using low-level printer (Z3 input format specific).</li>
</ul>
<ul>
<li><code>Z3_SOLVER_SMT_PP:</code> <em>boolean</em>, default: <code>false</code>, pretty print asserted constraints using SMT printer (Z3 input format specific). </li>
</ul>
</div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Aug 9 16:34:44 2012
</BODY>
</HTML>
