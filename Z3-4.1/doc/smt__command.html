 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">
<table class="centered-small">
  <tr>
    <th><a href="index.html"><span>Home</span></a></th>
    <th> &bull; </th>
    <th><a href="documentation.html"><span>Docs</span></a></th>
    <th> &bull; </th>
    <th><a href="download.html"><span>Download</span></a></th>
    <th> &bull; </th>
    <th><a href="mail.html"><span>Mail</span></a></th>
    <th> &bull; </th>
    <th><a href="faq.html"><span>FAQ</span></a></th>
    <th> &bull; </th>
    <th><a href="awards.html"><span>Awards</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com"><span>MSR</span></a></th>
  </tr>
</table>
<p class="Z3Title"><img align="middle" src="z3.png" alt="Z3" /> An Efficient Theorem Prover</p>
<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">


<h1><a class="anchor" id="smt_command">SMT-LIB2 </a></h1><p>The SMT-LIB2 input format is described on the SMT-LIB web site: <a href="http://www.smtlib.org" class="el">SMT-LIB2 input format</a>.</p>
<h2><a class="anchor" id="smt2_usage">
Usage</a></h2>
<p>Invoke the interactive mode by starting Z3 using the <code>smt2</code> mode and using the interactive prompt <code>si</code>. </p>
<div class="fragment"><pre class="fragment">
    z3.exe /smt2 /si
  </pre></div><h2><a class="anchor" id="smt2_extensions">
Extensions</a></h2>
<p>Z3 supports a few extensions. The extensions include:</p>
<ul>
<li>Definition of recursive data-types. The syntax is described in <a class="el" href="smtlib.html#smtlibdatatypes">Data-types</a>.</li>
</ul>
<ul>
<li>Model queries <code>(get-info model)</code> retrieves the current model. It can be used after a call to <code>(check-sat)</code> that returns either <code>sat</code> or <code>unknown</code>. You have to configure Z3 with the option <code>MODEL=true</code> for this to work.</li>
</ul>
<ul>
<li>A simplifier is available for simple algebraic simplifications. It can also perform quantifier elimination if quantifier one of the quantifier elimination options is turned on.</li>
</ul>
<ul>
<li>An evaluator, that assumes a current model is available. So you can invoke the evaluator after a call to <code>(check-sat)</code> that returns either <code>sat</code> or <code>unknown</code>. You have to configure Z3 with the option <code>MODEL=true</code> for this to work.</li>
</ul>
<ul>
<li>Definition of macros that take arguments. You can define a macro that takes arguments using scheme inspired syntax of the form: <code>(define (plus-macro (x Int) (y Int)) (+ x y))</code>.</li>
</ul>
<ul>
<li>The command <code>(next-sat)</code> identifies the next satisfiable assignment.</li>
</ul>
<h2><a class="anchor" id="smt2_help">
Commands</a></h2>
<p>All available commands are listed when you type <code>help</code> from the command prompt.</p>
<div class="fragment"><pre class="fragment">
help
; :help " available commands:
  </pre></div><h2><a class="anchor" id="smt2_examples">
Examples</a></h2>
<h3><a class="anchor" id="smt2_arithmetic_example">
Arithmetic and un-interpreted functions</a></h3>
<p>This example illustrates the use of models, arithmetic and un-interpreted functions. </p>
<div class="fragment"><pre class="fragment">
  z3.exe /si /smt2 MODEL=true

  (declare-funs ((x Int) (y Int) (z Int)))
; success
  (assert (&gt;= (* 2 x) (+ y z)))
; success
  (declare-funs ((f Int Int) (g Int Int Int)))
; success
  (assert (&lt; (f x) (g x x)))
; success
  (assert (&gt; (f y) (g x x)))
; success
  check-sat
; sat
  (get-info model)
; (:model (z3_model
; z -&gt; 0
; y -&gt; -38
; x -&gt; 0
; g -&gt; {
;   0 0 -&gt; 0
;   else -&gt; 0
; }
; f -&gt; {
;   0 -&gt; -1
;   -38 -&gt; 1
;   else -&gt; -1
; }
; ))
  push
; success
  (assert (= x y))
; success
  check-sat
; unsat
  pop
; success
  quit
; </pre></div><h3><a class="anchor" id="smt2_datatype_example">
Recursive data-types</a></h3>
<p>This example illustrates recursive data-types and the evaluator.</p>
<div class="fragment"><pre class="fragment">
  z3.exe /si /smt2 MODEL=true

  (declare-datatypes ((list (nil) (cons (hd Int) (tl list)))))
; success
  (declare-funs  ((l1 list) (l2 list) (l3 list)))
; success
  (declare-funs ((x Int) (y Int)))
; success
  (assert (not (= l1 nil)))
; success
  (assert (not (= l2 nil)))
; success
  push
; success
  (assert (= (hd l1) (hd l2)))
; success
  (assert (= (tl l1) (tl l2)))
; success
  push
; success
  (assert (not (= l1 l2)))
; success
  check-sat
; unsat
  pop
; success
  check-sat
; sat
  get-sat-assertions
; (let ((?x32 (tl l1)))
; (let (($x45 (is_nil ?x32)))
; (let (($x41 (is_cons l2)))
; (let (($x37 (is_cons l1)))
; (let ((?x33 (tl l2)))
; (let (($x34 (= ?x32 ?x33)))
; (let ((?x30 (hd l2)))
; (let ((?x29 (hd l1)))
; (let (($x31 (= ?x29 ?x30)))
; (let (($x26 (= l2 nil)))
; (let (($x27 (not $x26)))
; (let (($x5 (= l1 nil)))
; (let (($x6 (not $x5)))
; (and $x6 $x27 $x31 $x34 (not (is_nil l1)) $x37 (not (is_nil l2)) $x41 $x45))))))))))))))
  (eval l1)
; (cons 0 nil)
  (eval l2)
; (cons 0 nil)
  pop
; success
  check-sat
; sat
  get-sat-assertions
; (let (($x26 (= l2 nil)))
; (let (($x27 (not $x26)))
; (let (($x5 (= l1 nil)))
; (let (($x6 (not $x5)))
; (and $x6 $x27)))))
  (eval l1)
; (cons 0 nil)
  (eval l2)
; (let ((?x46 (cons 0 nil)))
; (cons 1 ?x46))
  (declare-datatypes ((opt (None) (Some (list olist))) (olist (Nil) (Cons (ohd Int) (otl opt)))))   ; mutually recursive data-types
; success
</pre></div><h3><a class="anchor" id="smt2_next_sat_example">
Using next-sat</a></h3>
<p>This example illustrates the use of <code>next-sat</code> to get different satisfying assignments. </p>
<div class="fragment"><pre class="fragment">
  z3.exe /si /smt2

  (declare-preds ((p) (q) (r) (s) (t)))
; success
  (assert (or p q))
; success
  (assert (implies p (not r)))
; success
  (assert (iff t s))
; success
  (check-sat)
; sat
  (get-sat-assertions)
; (let (($x25 (not r)))
; (and $x25 (not s) (not t) (not q) p))
  (next-sat)
; sat
  (get-sat-assertions)
; (let (($x25 (not r)))
; (and p $x25 s t (not q)))
  (next-sat)
; sat
  (get-sat-assertions)
; (let (($x25 (not r)))
; (let (($x27 (not p)))
; (and t s $x27 q $x25)))
  (next-sat)
; sat
  (get-sat-assertions)
; (let (($x25 (not r)))
; (let (($x27 (not p)))
; (let (($x34 (not t)))
; (let (($x33 (not s)))
; (and $x33 $x34 $x27 q $x25)))))
  (next-sat)
; unsat
</pre></div><h3><a class="anchor" id="smt2_array_example">
Arrays and array extensions</a></h3>
<p>This example illustrates basic use of array and the extensions to arrays offered in Z3.</p>
<div class="fragment"><pre class="fragment">
  z3.exe /si /smt2 MODEL=true

  (define-sorts ((A (Array Int Int))))
; success
  (declare-funs ((x Int) (y Int) (z Int)))
; success
  (declare-funs ((a1 A) (a2 A) (a3 A)))
; success
  (push) ; illustrate select-store
; success
  (assert (= (select a1 x) x))
; success
  (assert (= (store a1 x y) a1))
; success
  (check-sat)
; sat
  (get-info model)
; (:model (z3_model
; y -&gt; 1
; a1 -&gt; as-array[k!0]
; x -&gt; 1
; k!0 -&gt; {
;   1 -&gt; 1
;   else -&gt; 0
; }
; ))
  (assert (not (= x y)))
; success
  (check-sat)
; unsat
  (pop)
; success
  (define all1_array (const[A] 1))
; success
  (simplify (select all1_array x))
; 1
  (define-sorts ((IntSet (Array Int Bool))))
; success
  (declare-funs ((and_fn Bool Bool Bool) (or_fn Bool Bool Bool) (not_fn Bool Bool)))
; success
  (declare-funs ((a IntSet) (b IntSet) (c IntSet)))
; success
  (assert (forall (x Bool) (y Bool) (iff (and_fn x y) (and x y))))
; success
  (assert (forall (x Bool) (y Bool) (iff (or_fn x y)  (or x y))))
; success
  (assert (forall (x Bool) (iff (not_fn x) (not x))))
; success
  (push) ; illustrate map
; success
  (assert (not (= (map[and_fn] a b) (map[not_fn] (map[or_fn] (map[not_fn] b) (map[not_fn] a))))))
; success
  (check-sat)
; unsat
  (pop)
; success
  (push) 
; success
  (assert (and (select (map[and_fn] a b) x) (not (select a x))))
; success
  (check-sat)
; unsat
  (pop)
; success
  (push) 
; success
  (assert (and (select (map[or_fn] a b) x) (not (select a x))))
; success
  (check-sat)
; sat
  (get-info model)
; (:model (z3_model
; b -&gt; as-array[k!2]
; a -&gt; as-array[k!1]
; x -&gt; 0
; k!3 -&gt; {
;   0 -&gt; true
;   else -&gt; false
; }
; or_fn -&gt; {
;   false false -&gt; false
;   false true -&gt; true
;   else -&gt; (or #0 #1)
; }
; and_fn -&gt; {
;   (not (or (not #0) (not #1)))
; }
; k!1 -&gt; {
;   false
; }
; not_fn -&gt; {
;   (not #0)
; }
; k!2 -&gt; {
;   0 -&gt; true
;   else -&gt; false
; }
; ))
  (assert (and (not (select b x))))
; success
  (check-sat)
; unsat
  (get-info model) ; unsat, so there is no model.
; (:model "there is no model at the current scope")
  (pop)  
; success
  (push) ; illustrate default
; success
  (assert (= (default[A] a1) 1))
; success
  (assert (not (= a1 (const[A] 1))))  
; success
  (check-sat)
; sat
  (model) ; short for (get-info model)
; :model (z3_model
; a1 -&gt; as-array[k!9]
; and_fn -&gt; {
;   (not (or (not #0) (not #1)))
; }
; or_fn -&gt; {
;   (or #0 #1)
; }
; k!9 -&gt; {
;   0 -&gt; 2
;   else -&gt; 1
; }
; not_fn -&gt; {
;   (not #0)
; }
; k!10 -&gt; {
;   1
; }
; )
  (assert (= (default[A] a2) 1))
; success
  (assert (not (= a1 a2)))
; success
  (check-sat)
; sat
  (model)
; :model (z3_model
; a2 -&gt; as-array[k!18]
; a1 -&gt; as-array[k!16]
; k!16 -&gt; {
;   3 -&gt; 4
;   0 -&gt; 2
;   else -&gt; 1
; }
; and_fn -&gt; {
;   (not (or (not #0) (not #1)))
; }
; k!17 -&gt; {
;   1
; }
; or_fn -&gt; {
;   (or #0 #1)
; }
; k!18 -&gt; {
;   3 -&gt; 5
;   else -&gt; 1
; }
; not_fn -&gt; {
;   (not #0)
; }
; )
  (pop)
; success
  quit
; </pre></div><h3><a class="anchor" id="smt2_simple">
An example with arithmetic</a></h3>
<p>Thanks to Aaron Stump for the example.</p>
<div class="fragment"><pre class="fragment">
  z3.exe /si /smt2 MODEL=true

  (set-logic QF_LIA)
; success
  (declare-funs ((w Int) (x Int) (y Int) (z Int)))
; success
  (assert (&gt; x y))
; success
  (assert (&gt; y z))
; success
  (push)
; success
  (assert (&gt; z x))
; success
  (check-sat)
; unsat
  (get-info "statistics")
; (:all-statistics "add rows:        2
; arith conflicts: 1
; assert lower:    2
; assert upper:    1
; conflicts:       1
; pivots:          2
; max. heap size:     0.375248 Mbytes")
  (pop)
; success
  (push)
; success
  (check-sat (= x w))
; (error "line 11 column 21: assumptions must be boolean constants (e.g., p1, p2, q1)")
  (get-sat-assertions "stdout")
; (and (not (&lt;= (+ x (* (~ 1) y)) 0)) (not (&lt;= (+ y (* (~ 1) z)) 0)))
  (exit)
; </pre></div><h3><a class="anchor" id="smt2_proof_mode">
A propositional example with proof objects.</a></h3>
<div class="fragment"><pre class="fragment">
  z3.exe /si /smt2 MODEL=true PROOF_MODE=1

  (set-logic QF_UF)
; success
  (declare-preds ((p) (q)))
; success
  (assert (implies p q))
; success
  (push)
; success
  (check-sat)
; sat
  (get-sat-assertions)
; (and (not q) (not p))
  (pop)
; success
  (assert p)
; success
  (push)
; success
  (check-sat)
; sat
  (get-sat-assertions)
; (and p q)
  (pop)
; success
  (assert (not q))
; success
  (push)
; success
  (check-sat)
; unsat
  (get-proof "stdout")
; (let (($x33 (not q)))
; (let ((@x34 (asserted $x33)))
; (let ((@x31 (asserted p)))
; (let (($x27 (or (not p) q)))
; (let ((@x32 (mp (asserted (=&gt;  p q)) (|rewrite*| (=  (=&gt;  p q) $x27)) $x27)))
; (|unit-resolution| (|unit-resolution| @x32 @x31 q) @x34 false))))))
  (pop)
; success
</pre></div><h3><a class="anchor" id="smt2_core">
An example with core extraction.</a></h3>
<div class="fragment"><pre class="fragment">
  z3.exe /si /smt2 

  (declare-preds ((p) (q) (r) (s)))
; success
  (set-option enable-cores)
; success
  (assert (or p q))
; success
  (assert (implies r s))
; success
  (assert (implies s (iff q r)))
; success
  (assert (or r p))
; success
  (assert (or r s))
; success
  (assert (not (and r q)))
; success
  (assert (not (and s p)))
; success
  (check-sat)
; unsat
  (get-unsat-core)
; ((or p q)
; (=&gt;  r s)
; (or r p)
; (or r s)
; (not (and r q))
; (not (and s p)))
</pre></div><h3><a class="anchor" id="smt2_bv">
An example using bit-vectors.</a></h3>
<p>The example illustrates the use of macros with arguments. It also illustrates the use of bit-vectors. It checks that <code>x &amp; (x - 1)</code> is zero iff and only if <code>x</code> is a power of 2 (or zero).</p>
<div class="fragment"><pre class="fragment">
  z3.exe /si /smt2 MODEL=true

  (define (is-power-of-two (x BitVec[32])) (= bv0[32] (bvand x (bvsub x bv1[32]))))
; success
  (define (check-power-of-two (x BitVec[32]) (sh BitVec[32])) (= x (bvshl bv1[32] sh)))
; success
  (define (check-power-of-two-1 (x BitVec[32]) (sh BitVec[32])) (let (sh1 (bvshl sh bv1[32])) (or (check-power-of-two x sh1) (check-power-of-two x (bvadd bv1 sh1)))))
; success
  (define (check-power-of-two-2 (x BitVec[32]) (sh BitVec[32])) (let (sh1 (bvshl sh bv1[32])) (or (check-power-of-two-1 x sh1) (check-power-of-two-1 x (bvadd bv1[32] sh1)))))
; success
  (define (check-power-of-two-3 (x BitVec[32]) (sh BitVec[32])) (let (sh1 (bvshl sh bv1[32])) (or (check-power-of-two-2 x sh1) (check-power-of-two-2 x (bvadd bv1[32] sh1)))))
; success
  (define (check-power-of-two-4 (x BitVec[32]) (sh BitVec[32])) (let (sh1 (bvshl sh bv1[32])) (or (check-power-of-two-3 x sh1) (check-power-of-two-3 x (bvadd bv1[32] sh1)))))
; success
  (define (check-power-of-two-5 (x BitVec[32]) (sh BitVec[32])) (let (sh1 (bvshl sh bv1[32])) (or (check-power-of-two-4 x sh1) (check-power-of-two-4 x (bvadd bv1[32] sh1)))))
; success
  (declare-funs ((x BitVec[32]) (y BitVec[32]) (z BitVec[32])))
; success
  (push)
; success
  (assert (not (implies (is-power-of-two x) (check-power-of-two-5 x bv0[32]))))
; success
  (check-sat)
; sat
  (get-info model)
; (:model (z3_model
; x -&gt; bv0[32]
; ))
  (push)
; success
  (define is-zero-on-zero (implies (is-power-of-two x) (not (= bv0 x))))
; success
  (assert (not is-zero-on-zero))
; success
  (check-sat)
; sat
  (get-info model)
; (:model (z3_model
; x -&gt; bv0[32]
; ))
  (pop)
; success
  (define (check-power-of-two-6 (x BitVec[32]) (sh BitVec[32])) (let (sh1 (bvshl sh bv1[32])) (or (check-power-of-two-5 x sh1) (check-power-of-two-5 x (bvadd bv1[32] sh1)))))
; success
  (assert (not (implies (is-power-of-two x) (check-power-of-two-6 x bv0[32]))))
; success
  (check-sat)
; unsat
  (pop)
; success
</pre></div> </div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Tue Nov 29 15:21:50 2011
</BODY>
</HTML>
