 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">

<table>
<tr>
<th style="width:120px"><a style="border=0px" class="el" href="index.html"><img border="0" src="z3.png" alt="Z3" /></a></th>
<th style="width:100%">
<div id="nav">
<ul>
<li><a href="download.html">Download</a></li>
<li>/</li>
<li><a href="documentation.html#tutorial">Tutorials</a></li>
<li>/</li>
<li><a href="documentation.html">Documentation</a></li>
<li>/</li>
<li><a href="mail.html">Contact</a></li>
<li>/</li>
<li><a href="faq.html">FAQ</a></li>
<li>/</li>
<li><a href="awards.html">Awards</a></li>
<li>/</li>
<li><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx">RiSE</a></li>
</ul>
</div>
</th>
<th style="width:120px">
<a style="border=0px" class="el" href="http://research.microsoft.com"><img border="0" src="logo_msr.gif" alt="Microsoft Research" />
</th>
</tr>
</table>

<!-- <p> -->
<!-- <img align="middle" src="z3.png" alt="Z3" /> -->
<!-- <table class="centered-small"> -->
<!--   <tr> -->
<!--     <th><a href="index.html"><span>Home</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="documentation.html"><span>Docs</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="download.html"><span>Download</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="mail.html"><span>Mail</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="faq.html"><span>FAQ</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="awards.html"><span>Awards</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com"><span>MSR</span></a></th> -->
<!--   </tr> -->
<!-- </table> -->
<!-- </p> -->

<!-- Generated by Doxygen 1.6.3 -->
<h1>iZ3/doc/iz3.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00002"></a>00002 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00003"></a>00003 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &quot;iz3.h&quot;</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="keywordtype">int</span> usage(<span class="keyword">const</span> <span class="keywordtype">char</span> **argv){
<a name="l00011"></a>00011   std::cerr &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; [options] file.smt&quot;</span> &lt;&lt; std::endl;
<a name="l00012"></a>00012   std::cerr &lt;&lt; std::endl;
<a name="l00013"></a>00013   std::cerr &lt;&lt; <span class="stringliteral">&quot;options:&quot;</span> &lt;&lt; std::endl;
<a name="l00014"></a>00014   std::cerr &lt;&lt; <span class="stringliteral">&quot;  -t,--tree        tree interpolation&quot;</span> &lt;&lt; std::endl;
<a name="l00015"></a>00015   std::cerr &lt;&lt; <span class="stringliteral">&quot;  -c,--check       check result&quot;</span> &lt;&lt; std::endl;
<a name="l00016"></a>00016   std::cerr &lt;&lt; <span class="stringliteral">&quot;  -p,--profile     profile execution&quot;</span> &lt;&lt; std::endl;
<a name="l00017"></a>00017   std::cerr &lt;&lt; <span class="stringliteral">&quot;  -w,--weak        weak interpolants&quot;</span> &lt;&lt; std::endl;
<a name="l00018"></a>00018   std::cerr &lt;&lt; <span class="stringliteral">&quot;  -f,--flat        ouput flat formulas&quot;</span> &lt;&lt; std::endl;
<a name="l00019"></a>00019   std::cerr &lt;&lt; <span class="stringliteral">&quot;  -o &lt;file&gt;        ouput to SMT-LIB file&quot;</span> &lt;&lt; std::endl;
<a name="l00020"></a>00020   std::cerr &lt;&lt; std::endl;
<a name="l00021"></a>00021   <span class="keywordflow">return</span> 1;
<a name="l00022"></a>00022 }
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> **argv) {
<a name="l00025"></a>00025     
<a name="l00026"></a>00026   <span class="keywordtype">bool</span> tree_mode = <span class="keyword">false</span>;
<a name="l00027"></a>00027   <span class="keywordtype">bool</span> check_mode = <span class="keyword">false</span>;
<a name="l00028"></a>00028   <span class="keywordtype">bool</span> profile_mode = <span class="keyword">false</span>;
<a name="l00029"></a>00029   <span class="keywordtype">bool</span> incremental_mode = <span class="keyword">false</span>;
<a name="l00030"></a>00030   std::string output_file;
<a name="l00031"></a>00031   <span class="keywordtype">bool</span> flat_mode = <span class="keyword">false</span>;
<a name="l00032"></a>00032 
<a name="l00033"></a>00033   Z3_config cfg = <a class="code" href="group__capi.html#ga7d6c40d9b79fe8a8851cc8540970787f" title="Create a configuration.">Z3_mk_config</a>();
<a name="l00034"></a>00034   <a class="code" href="group__iz3.html#gabcc9921f5d18d53cb578ad6d442279f0">Z3_interpolation_options</a> options = <a class="code" href="group__iz3.html#ga42609de0dc7ac4fec77cdd767c7440d3">Z3_mk_interpolation_options</a>();
<a name="l00035"></a>00035 
<a name="l00036"></a>00036   <span class="comment">/* Parse the command line */</span>
<a name="l00037"></a>00037   <span class="keywordtype">int</span> argn = 1;
<a name="l00038"></a>00038   <span class="keywordflow">while</span>(argn &lt; argc-1){
<a name="l00039"></a>00039     std::string flag = argv[argn];
<a name="l00040"></a>00040     <span class="keywordflow">if</span>(flag[0] == <span class="charliteral">&#39;-&#39;</span>){
<a name="l00041"></a>00041       <span class="keywordflow">if</span>(flag == <span class="stringliteral">&quot;-t&quot;</span> || flag == <span class="stringliteral">&quot;--tree&quot;</span>)
<a name="l00042"></a>00042         tree_mode = <span class="keyword">true</span>;
<a name="l00043"></a>00043       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == <span class="stringliteral">&quot;-c&quot;</span> || flag == <span class="stringliteral">&quot;--check&quot;</span>)
<a name="l00044"></a>00044         check_mode = <span class="keyword">true</span>;
<a name="l00045"></a>00045       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == <span class="stringliteral">&quot;-p&quot;</span> || flag == <span class="stringliteral">&quot;--profile&quot;</span>)
<a name="l00046"></a>00046         profile_mode = <span class="keyword">true</span>;
<a name="l00047"></a>00047       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == <span class="stringliteral">&quot;-w&quot;</span> || flag == <span class="stringliteral">&quot;--weak&quot;</span>)
<a name="l00048"></a>00048         <a class="code" href="group__iz3.html#ga43fc5cd3272ef4bbc3b473069726ce41">Z3_set_interpolation_option</a>(options,<span class="stringliteral">&quot;weak&quot;</span>,<span class="stringliteral">&quot;1&quot;</span>);
<a name="l00049"></a>00049       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == <span class="stringliteral">&quot;-i&quot;</span> || flag == <span class="stringliteral">&quot;--incremental&quot;</span>)
<a name="l00050"></a>00050         incremental_mode = <span class="keyword">true</span>;
<a name="l00051"></a>00051       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == <span class="stringliteral">&quot;-o&quot;</span>){
<a name="l00052"></a>00052         argn++;
<a name="l00053"></a>00053         <span class="keywordflow">if</span>(argn &gt;= argc) <span class="keywordflow">return</span> usage(argv);
<a name="l00054"></a>00054         output_file = argv[argn];
<a name="l00055"></a>00055       }
<a name="l00056"></a>00056       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == <span class="stringliteral">&quot;-f&quot;</span> || flag == <span class="stringliteral">&quot;--flat&quot;</span>)
<a name="l00057"></a>00057         flat_mode = <span class="keyword">true</span>;
<a name="l00058"></a>00058       <span class="keywordflow">else</span>
<a name="l00059"></a>00059         <span class="keywordflow">return</span> usage(argv);
<a name="l00060"></a>00060     }
<a name="l00061"></a>00061     argn++;
<a name="l00062"></a>00062   }
<a name="l00063"></a>00063   <span class="keywordflow">if</span>(argn != argc-1)
<a name="l00064"></a>00064     <span class="keywordflow">return</span> usage(argv);
<a name="l00065"></a>00065   <span class="keyword">const</span> <span class="keywordtype">char</span> *filename = argv[argn];
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 
<a name="l00068"></a>00068   <span class="comment">/* Create a Z3 context to contain formulas */</span>
<a name="l00069"></a>00069   Z3_context ctx = <a class="code" href="group__iz3.html#ga46b4025a380ada3e22bc8c2c4dfe525c">Z3_mk_interpolation_context</a>(cfg);
<a name="l00070"></a>00070 
<a name="l00071"></a>00071   <span class="keywordflow">if</span>(!flat_mode)
<a name="l00072"></a>00072     <a class="code" href="group__capi.html#ga20d66dac19b6d6a06537843d0e25f761" title="Select mode for the format used for pretty-printing AST nodes.">Z3_set_ast_print_mode</a>(ctx,Z3_PRINT_SMTLIB_COMPLIANT);
<a name="l00073"></a>00073   
<a name="l00074"></a>00074   <span class="comment">/* Read an interpolation problem */</span>
<a name="l00075"></a>00075 
<a name="l00076"></a>00076   <span class="keywordtype">int</span> num;
<a name="l00077"></a>00077   Z3_ast *constraints;
<a name="l00078"></a>00078   <span class="keywordtype">int</span> *parents = 0;
<a name="l00079"></a>00079   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__maxsat__ex.html#gaad9796c174f7ef5d226cd169f2520fd5" title="Exit gracefully in case of error.">error</a>;
<a name="l00080"></a>00080   <span class="keywordtype">bool</span> ok;
<a name="l00081"></a>00081 
<a name="l00082"></a>00082   ok = <a class="code" href="group__iz3.html#gaa03ff16afe9a62a7274d898b688d5bfb">Z3_read_interpolation_problem</a>(ctx, &amp;num, &amp;constraints, tree_mode ? &amp;parents : 0, filename, &amp;error);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   <span class="comment">/* If parse failed, print the error message */</span>
<a name="l00085"></a>00085 
<a name="l00086"></a>00086   <span class="keywordflow">if</span>(!ok){
<a name="l00087"></a>00087     std::cerr &lt;&lt; error &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00088"></a>00088     <span class="keywordflow">return</span> 1;
<a name="l00089"></a>00089   }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091   <span class="comment">/* if we get only one formula, and it is a conjunction, split it into conjuncts. */</span>
<a name="l00092"></a>00092   <span class="keywordflow">if</span>(!tree_mode &amp;&amp; num == 1){
<a name="l00093"></a>00093     Z3_app app = <a class="code" href="group__capi.html#gaf9345fd0822d7e9928dd4ab14a09765b" title="Convert an ast into an APP_AST. This is just type casting.">Z3_to_app</a>(ctx,constraints[0]);
<a name="l00094"></a>00094     Z3_func_decl func = <a class="code" href="group__capi.html#ga4ffab51c30484a32edc65194573cfd28" title="Return the declaration of a constant or function application.">Z3_get_app_decl</a>(ctx,app);
<a name="l00095"></a>00095     <a class="code" href="group__capi.html#ga1fe4399e5468621e2a799a680c6667cd" title="The different kinds of interpreted function kinds.">Z3_decl_kind</a> dk = <a class="code" href="group__capi.html#ga8cc3224c9b9f2149550701275207bedf" title="Return declaration kind corresponding to declaration.">Z3_get_decl_kind</a>(ctx,func);
<a name="l00096"></a>00096     <span class="keywordflow">if</span>(dk == Z3_OP_AND){
<a name="l00097"></a>00097       <span class="keywordtype">int</span> nconjs = <a class="code" href="group__capi.html#gae8ad520b79b46c323863bacffa0e12c0" title="Return the number of argument of an application. If t is an constant, then the number...">Z3_get_app_num_args</a>(ctx,app);
<a name="l00098"></a>00098       <span class="keywordflow">if</span>(nconjs &gt; 1){
<a name="l00099"></a>00099         std::cout &lt;&lt; <span class="stringliteral">&quot;Splitting formula into &quot;</span> &lt;&lt; nconjs &lt;&lt; <span class="stringliteral">&quot; conjuncts...\n&quot;</span>;
<a name="l00100"></a>00100         num = nconjs;
<a name="l00101"></a>00101         constraints = <span class="keyword">new</span> Z3_ast[num];
<a name="l00102"></a>00102         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; num; k++)
<a name="l00103"></a>00103           constraints[k] = <a class="code" href="group__capi.html#ga49a576b11f9f6ca4a94670e538a84c6b" title="Return the i-th argument of the given application.">Z3_get_app_arg</a>(ctx,app,k);
<a name="l00104"></a>00104       }
<a name="l00105"></a>00105     }
<a name="l00106"></a>00106   }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 
<a name="l00109"></a>00109   <span class="comment">/* Compute an interpolant, or get a model. */</span>
<a name="l00110"></a>00110 
<a name="l00111"></a>00111   Z3_ast *interpolants = (Z3_ast *)malloc((num-1) * <span class="keyword">sizeof</span>(Z3_ast));
<a name="l00112"></a>00112   Z3_model model = 0;
<a name="l00113"></a>00113   <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> result;
<a name="l00114"></a>00114 
<a name="l00115"></a>00115   <span class="keywordflow">if</span>(!incremental_mode){
<a name="l00116"></a>00116     <span class="comment">/* In non-incremental mode, we just pass the constraints. */</span>
<a name="l00117"></a>00117     result = <a class="code" href="group__iz3.html#ga4d715a5e8307642f82c3a76de789a3f0">Z3_interpolate</a>(ctx, num, constraints, parents,  options, interpolants, &amp;model);
<a name="l00118"></a>00118   }
<a name="l00119"></a>00119   <span class="keywordflow">else</span> {
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     <span class="comment">/* This is a somewhat useless demonstration of incremental mode.</span>
<a name="l00122"></a>00122 <span class="comment">      Here, we assert the constraints in the context, then pass them to</span>
<a name="l00123"></a>00123 <span class="comment">      iZ3 in an array, so iZ3 knows the sequence. Note it&#39;s safe to pass</span>
<a name="l00124"></a>00124 <span class="comment">      &quot;true&quot;, even though we haven&#39;t techically asserted if. */</span>
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     <a class="code" href="group__capi.html#gad651ad68c7a060cbb5616349233cb10f" title="Create a backtracking point.">Z3_push</a>(ctx);
<a name="l00127"></a>00127     std::vector&lt;Z3_ast&gt; asserted(num);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     <span class="comment">/* We start with nothing asserted. */</span>
<a name="l00130"></a>00130     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num; i++)
<a name="l00131"></a>00131       asserted[i] = <a class="code" href="group__capi.html#gae898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(ctx);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133     <span class="comment">/* Now we assert the constrints one at a time until UNSAT. */</span>
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num; i++){
<a name="l00136"></a>00136       asserted[i] = constraints[i];
<a name="l00137"></a>00137       <a class="code" href="group__capi.html#ga1a05ff73a564ae7256a2257048a4680a" title="Assert a constraint into the logical context.">Z3_assert_cnstr</a>(ctx,constraints[i]);  <span class="comment">// assert one constraint</span>
<a name="l00138"></a>00138       result = <a class="code" href="group__iz3.html#ga4d715a5e8307642f82c3a76de789a3f0">Z3_interpolate</a>(ctx, num, &amp;asserted[0], parents,  options, interpolants, &amp;model, 0, <span class="keyword">true</span>);
<a name="l00139"></a>00139       <span class="keywordflow">if</span>(result == Z3_L_FALSE){
<a name="l00140"></a>00140         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j = 0; j &lt; num-1; j++)
<a name="l00141"></a>00141           <span class="comment">/* Since we want the interpolant formulas to survive a &quot;pop&quot;, we</span>
<a name="l00142"></a>00142 <span class="comment">            &quot;persist&quot; them here. */</span>
<a name="l00143"></a>00143           <a class="code" href="group__capi.html#gaa2d548abec8f6f479e29a9a6b5baefc0" title="Persist AST through num_scopes pops. This function is only relevant if c was created...">Z3_persist_ast</a>(ctx,interpolants[j],1);
<a name="l00144"></a>00144         <span class="keywordflow">break</span>;
<a name="l00145"></a>00145       }
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147     <a class="code" href="group__capi.html#gab2b3a542006c86c8d86dc37872f88b61" title="Backtrack.">Z3_pop</a>(ctx,1);
<a name="l00148"></a>00148   }
<a name="l00149"></a>00149   
<a name="l00150"></a>00150   <span class="keywordflow">switch</span> (result) {
<a name="l00151"></a>00151   
<a name="l00152"></a>00152     <span class="comment">/* If UNSAT, print the interpolants */</span>
<a name="l00153"></a>00153   <span class="keywordflow">case</span> Z3_L_FALSE:
<a name="l00154"></a>00154     printf(<span class="stringliteral">&quot;unsat\n&quot;</span>);
<a name="l00155"></a>00155     <span class="keywordflow">if</span>(output_file.empty()){
<a name="l00156"></a>00156       printf(<span class="stringliteral">&quot;interpolant:\n&quot;</span>);
<a name="l00157"></a>00157       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num-1; i++)
<a name="l00158"></a>00158         printf(<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__capi.html#gab1aa4b78298fe00b3167bf7bfd88aea3" title="Convert the given AST node into a string.">Z3_ast_to_string</a>(ctx, interpolants[i]));
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160     <span class="keywordflow">else</span> {
<a name="l00161"></a>00161       <a class="code" href="group__iz3.html#gaced78789e531fb6d85f1d14c7f71e092">Z3_write_interpolation_problem</a>(ctx,num-1,interpolants,0,output_file.c_str());
<a name="l00162"></a>00162       printf(<span class="stringliteral">&quot;interpolant written to %s\n&quot;</span>,output_file.c_str());
<a name="l00163"></a>00163     }
<a name="l00164"></a>00164     <span class="keywordflow">if</span>(check_mode){
<a name="l00165"></a>00165       std::cout &lt;&lt; <span class="stringliteral">&quot;Checking interpolant...\n&quot;</span>;
<a name="l00166"></a>00166       <span class="keywordtype">bool</span> chk;
<a name="l00167"></a>00167       chk = <a class="code" href="group__iz3.html#ga5be6b22f5a05000cdb75a93f04a607b5">Z3_check_interpolant</a>(ctx,num,constraints,parents,interpolants,&amp;error);  
<a name="l00168"></a>00168       <span class="keywordflow">if</span>(chk)
<a name="l00169"></a>00169         std::cout &lt;&lt; <span class="stringliteral">&quot;Interpolant is correct\n&quot;</span>;
<a name="l00170"></a>00170       <span class="keywordflow">else</span> {
<a name="l00171"></a>00171         std::cout &lt;&lt; <span class="stringliteral">&quot;Interpolant is incorrect\n&quot;</span>;
<a name="l00172"></a>00172         std::cout &lt;&lt; error;
<a name="l00173"></a>00173         <span class="keywordflow">return</span> 1;
<a name="l00174"></a>00174       }
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176     <span class="keywordflow">break</span>;
<a name="l00177"></a>00177   <span class="keywordflow">case</span> Z3_L_UNDEF:
<a name="l00178"></a>00178     printf(<span class="stringliteral">&quot;fail\n&quot;</span>);
<a name="l00179"></a>00179     <span class="keywordflow">break</span>;
<a name="l00180"></a>00180   <span class="keywordflow">case</span> Z3_L_TRUE:
<a name="l00181"></a>00181     printf(<span class="stringliteral">&quot;sat\n&quot;</span>);
<a name="l00182"></a>00182     printf(<span class="stringliteral">&quot;model:\n%s\n&quot;</span>, <a class="code" href="group__capi.html#gaf36d49862a8c0d20dd5e6508eef5f8af" title="Convert the given model into a string.">Z3_model_to_string</a>(ctx, model));
<a name="l00183"></a>00183     <span class="keywordflow">break</span>;
<a name="l00184"></a>00184   }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   <span class="keywordflow">if</span>(profile_mode)
<a name="l00187"></a>00187     std::cout &lt;&lt; <a class="code" href="group__iz3.html#gad0f95f6c7c3a937994e2ce237c020b3d">Z3_interpolation_profile</a>(ctx);
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <span class="comment">/* Delete the model if there is one */</span>
<a name="l00190"></a>00190   
<a name="l00191"></a>00191   <span class="keywordflow">if</span> (model)
<a name="l00192"></a>00192     <a class="code" href="group__capi.html#ga0cc98d3ce68047f873e119bccaabdbee" title="Delete a model object.">Z3_del_model</a>(ctx, model);
<a name="l00193"></a>00193   
<a name="l00194"></a>00194   <span class="comment">/* Delete logical context. */</span>
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   <a class="code" href="group__capi.html#ga556eae80ed43ab13e1e7dc3b38c35200" title="Delete the given logical context.">Z3_del_context</a>(ctx);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   <span class="keywordflow">return</span> 0;
<a name="l00199"></a>00199 }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="preprocessor">#if 0</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span>
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="keywordtype">int</span> test(){
<a name="l00207"></a>00207   <span class="keywordtype">int</span> i;
<a name="l00208"></a>00208 
<a name="l00209"></a>00209   <span class="comment">/* Create a Z3 context to contain formulas */</span>
<a name="l00210"></a>00210 
<a name="l00211"></a>00211   Z3_config cfg = <a class="code" href="group__capi.html#ga7d6c40d9b79fe8a8851cc8540970787f" title="Create a configuration.">Z3_mk_config</a>();
<a name="l00212"></a>00212   Z3_context ctx = iz3_mk_context(cfg);
<a name="l00213"></a>00213     
<a name="l00214"></a>00214   <span class="keywordtype">int</span> num = 2;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216   Z3_ast *constraints = (Z3_ast *)malloc(num * <span class="keyword">sizeof</span>(Z3_ast));
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 <span class="preprocessor">#if 1</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span>  Z3_sort arr = <a class="code" href="group__capi.html#gafe617994cce1b516f46128e448c84445" title="Create an array type.">Z3_mk_array_sort</a>(ctx,<a class="code" href="group__capi.html#ga6cd426ab5748653b77d389fd3eac1015" title="Create the integer type.">Z3_mk_int_sort</a>(ctx),<a class="code" href="group__capi.html#gacdc73510b69a010b71793d429015f342" title="Create the Boolean type.">Z3_mk_bool_sort</a>(ctx)); 
<a name="l00220"></a>00220   Z3_symbol  as  = <a class="code" href="group__capi.html#ga6b9ed981ba0180962928394fe828b0a7" title="Create a Z3 symbol using a C string.">Z3_mk_string_symbol</a>(ctx, <span class="stringliteral">&quot;a&quot;</span>);
<a name="l00221"></a>00221   Z3_symbol  bs  = <a class="code" href="group__capi.html#ga6b9ed981ba0180962928394fe828b0a7" title="Create a Z3 symbol using a C string.">Z3_mk_string_symbol</a>(ctx, <span class="stringliteral">&quot;b&quot;</span>);
<a name="l00222"></a>00222   Z3_symbol  xs  = <a class="code" href="group__capi.html#ga6b9ed981ba0180962928394fe828b0a7" title="Create a Z3 symbol using a C string.">Z3_mk_string_symbol</a>(ctx, <span class="stringliteral">&quot;x&quot;</span>);
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   Z3_ast a = <a class="code" href="group__capi.html#ga093c9703393f33ae282ec5e8729354ef" title="Declare and create a constant.">Z3_mk_const</a>(ctx,as,arr);
<a name="l00225"></a>00225   Z3_ast b = <a class="code" href="group__capi.html#ga093c9703393f33ae282ec5e8729354ef" title="Declare and create a constant.">Z3_mk_const</a>(ctx,bs,arr);
<a name="l00226"></a>00226   Z3_ast x = <a class="code" href="group__capi.html#ga093c9703393f33ae282ec5e8729354ef" title="Declare and create a constant.">Z3_mk_const</a>(ctx,xs,<a class="code" href="group__capi.html#ga6cd426ab5748653b77d389fd3eac1015" title="Create the integer type.">Z3_mk_int_sort</a>(ctx));
<a name="l00227"></a>00227   
<a name="l00228"></a>00228   Z3_ast c1 = <a class="code" href="group__capi.html#ga95a19ce675b70e22bb0401f7137af37c" title="Create an AST node representing l = r.">Z3_mk_eq</a>(ctx,a,<a class="code" href="group__capi.html#gae305a4f54b4a64f7e5973ae6ccb13593" title="Array update.">Z3_mk_store</a>(ctx,b,x,<a class="code" href="group__capi.html#gae898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(ctx)));
<a name="l00229"></a>00229   Z3_ast c2 = <a class="code" href="group__capi.html#ga3329538091996eb7b3dc677760a61072" title="Create an AST node representing not(a).">Z3_mk_not</a>(ctx,<a class="code" href="group__capi.html#ga38f423f3683379e7f597a7fe59eccb67" title="Array read. The argument a is the array and i is the index of the array that gets...">Z3_mk_select</a>(ctx,a,x));
<a name="l00230"></a>00230 <span class="preprocessor">#else</span>
<a name="l00231"></a>00231 <span class="preprocessor"></span>  Z3_symbol  xs  = <a class="code" href="group__capi.html#ga6b9ed981ba0180962928394fe828b0a7" title="Create a Z3 symbol using a C string.">Z3_mk_string_symbol</a>(ctx, <span class="stringliteral">&quot;x&quot;</span>);
<a name="l00232"></a>00232   Z3_ast x = <a class="code" href="group__capi.html#ga093c9703393f33ae282ec5e8729354ef" title="Declare and create a constant.">Z3_mk_const</a>(ctx,xs,<a class="code" href="group__capi.html#gacdc73510b69a010b71793d429015f342" title="Create the Boolean type.">Z3_mk_bool_sort</a>(ctx));
<a name="l00233"></a>00233   Z3_ast c1 = <a class="code" href="group__capi.html#ga95a19ce675b70e22bb0401f7137af37c" title="Create an AST node representing l = r.">Z3_mk_eq</a>(ctx,x,<a class="code" href="group__capi.html#gae898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(ctx));
<a name="l00234"></a>00234   Z3_ast c2 = <a class="code" href="group__capi.html#ga95a19ce675b70e22bb0401f7137af37c" title="Create an AST node representing l = r.">Z3_mk_eq</a>(ctx,x,<a class="code" href="group__capi.html#ga5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(ctx));
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="preprocessor">#endif</span>
<a name="l00237"></a>00237 <span class="preprocessor"></span>
<a name="l00238"></a>00238   constraints[0] = c1;
<a name="l00239"></a>00239   constraints[1] = c2;
<a name="l00240"></a>00240   
<a name="l00241"></a>00241   <span class="comment">/* print out the result for grins. */</span>
<a name="l00242"></a>00242 
<a name="l00243"></a>00243   <span class="comment">// Z3_string smtout = Z3_benchmark_to_smtlib_string (ctx, &quot;foo&quot;, &quot;QFLIA&quot;, &quot;sat&quot;, &quot;&quot;, num, constraints, Z3_mk_true(ctx));</span>
<a name="l00244"></a>00244 
<a name="l00245"></a>00245   <span class="comment">// Z3_string smtout = Z3_ast_to_string(ctx,constraints[0]);</span>
<a name="l00246"></a>00246   <span class="comment">// Z3_string smtout = Z3_context_to_string(ctx);</span>
<a name="l00247"></a>00247   <span class="comment">// puts(smtout);</span>
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   iz3_print(ctx,num,constraints,<span class="stringliteral">&quot;iZ3temp.smt&quot;</span>);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   <span class="comment">/* Make room for interpolants. */</span>
<a name="l00252"></a>00252 
<a name="l00253"></a>00253   Z3_ast *interpolants = (Z3_ast *)malloc((num-1) * <span class="keyword">sizeof</span>(Z3_ast));
<a name="l00254"></a>00254 
<a name="l00255"></a>00255   <span class="comment">/* Make room for the model. */</span>
<a name="l00256"></a>00256 
<a name="l00257"></a>00257   Z3_model model = 0;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <span class="comment">/* Call the prover */</span>
<a name="l00260"></a>00260 
<a name="l00261"></a>00261   <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> result = iz3_interpolate(ctx, num, constraints, interpolants, &amp;model);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263   <span class="keywordflow">switch</span> (result) {
<a name="l00264"></a>00264   
<a name="l00265"></a>00265     <span class="comment">/* If UNSAT, print the interpolants */</span>
<a name="l00266"></a>00266   <span class="keywordflow">case</span> Z3_L_FALSE:
<a name="l00267"></a>00267     printf(<span class="stringliteral">&quot;unsat, interpolants:\n&quot;</span>);
<a name="l00268"></a>00268     <span class="keywordflow">for</span>(i = 0; i &lt; num-1; i++)
<a name="l00269"></a>00269       printf(<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__capi.html#gab1aa4b78298fe00b3167bf7bfd88aea3" title="Convert the given AST node into a string.">Z3_ast_to_string</a>(ctx, interpolants[i]));
<a name="l00270"></a>00270     <span class="keywordflow">break</span>;
<a name="l00271"></a>00271   <span class="keywordflow">case</span> Z3_L_UNDEF:
<a name="l00272"></a>00272     printf(<span class="stringliteral">&quot;fail\n&quot;</span>);
<a name="l00273"></a>00273     <span class="keywordflow">break</span>;
<a name="l00274"></a>00274   <span class="keywordflow">case</span> Z3_L_TRUE:
<a name="l00275"></a>00275     printf(<span class="stringliteral">&quot;sat\n&quot;</span>);
<a name="l00276"></a>00276     printf(<span class="stringliteral">&quot;model:\n%s\n&quot;</span>, <a class="code" href="group__capi.html#gaf36d49862a8c0d20dd5e6508eef5f8af" title="Convert the given model into a string.">Z3_model_to_string</a>(ctx, model));
<a name="l00277"></a>00277     <span class="keywordflow">break</span>;
<a name="l00278"></a>00278   }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280   <span class="comment">/* Delete the model if there is one */</span>
<a name="l00281"></a>00281   
<a name="l00282"></a>00282   <span class="keywordflow">if</span> (model)
<a name="l00283"></a>00283     <a class="code" href="group__capi.html#ga0cc98d3ce68047f873e119bccaabdbee" title="Delete a model object.">Z3_del_model</a>(ctx, model);
<a name="l00284"></a>00284   
<a name="l00285"></a>00285   <span class="comment">/* Delete logical context (note, we call iz3_del_context, not</span>
<a name="l00286"></a>00286 <span class="comment">     Z3_del_context */</span>
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   iz3_del_context(ctx);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="keywordflow">return</span> 1;
<a name="l00291"></a>00291 }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="keyword">struct </span>z3_error {
<a name="l00294"></a>00294   <a class="code" href="group__capi.html#gaa9f9e7b1b5b81381fab96debbaaa638f" title="Z3 error codes (See Z3_get_error_code).">Z3_error_code</a> c;
<a name="l00295"></a>00295   z3_error(<a class="code" href="group__capi.html#gaa9f9e7b1b5b81381fab96debbaaa638f" title="Z3 error codes (See Z3_get_error_code).">Z3_error_code</a> _c) : c(_c) {}
<a name="l00296"></a>00296 };
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00299"></a>00299   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__capi__ex.html#gaa6d66d26409a97ec721d1fe6814757c9" title="Low tech exceptions.">throw_z3_error</a>(<a class="code" href="group__capi.html#gaa9f9e7b1b5b81381fab96debbaaa638f" title="Z3 error codes (See Z3_get_error_code).">Z3_error_code</a> c){
<a name="l00300"></a>00300     <span class="keywordflow">throw</span> z3_error(c);
<a name="l00301"></a>00301   }
<a name="l00302"></a>00302 }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> **argv) {
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   <span class="comment">/* Create a Z3 context to contain formulas */</span>
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   Z3_config cfg = <a class="code" href="group__capi.html#ga7d6c40d9b79fe8a8851cc8540970787f" title="Create a configuration.">Z3_mk_config</a>();
<a name="l00309"></a>00309   Z3_context ctx = iz3_mk_context(cfg);
<a name="l00310"></a>00310   <a class="code" href="group__capi.html#gadaa12e9990f37b0c1e2bf1dd502dbf39" title="Register a Z3 error handler.">Z3_set_error_handler</a>(ctx, <a class="code" href="group__capi__ex.html#gaa6d66d26409a97ec721d1fe6814757c9" title="Low tech exceptions.">throw_z3_error</a>);
<a name="l00311"></a>00311     
<a name="l00312"></a>00312   <span class="comment">/* Make some constraints, by parsing an smtlib formatted file given as arg 1 */</span>
<a name="l00313"></a>00313 
<a name="l00314"></a>00314   <span class="keywordflow">try</span> {
<a name="l00315"></a>00315     <a class="code" href="group__capi.html#gaa63fb1ecc49057f28aa6e0c328491eb3" title="Similar to Z3_parse_smtlib_string, but reads the benchmark from a file.">Z3_parse_smtlib_file</a>(ctx, argv[1], 0, 0, 0, 0, 0, 0);
<a name="l00316"></a>00316   }
<a name="l00317"></a>00317   <span class="keywordflow">catch</span>(<span class="keyword">const</span> z3_error &amp;err){
<a name="l00318"></a>00318     std::cerr &lt;&lt; <span class="stringliteral">&quot;Z3 error: &quot;</span> &lt;&lt; <a class="code" href="group__capi.html#gaf06357c49299efb8a0bdaeb3bc96c6d6" title="Return a string describing the given error code.">Z3_get_error_msg</a>(err.c) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00319"></a>00319     std::cerr &lt;&lt; <a class="code" href="group__capi.html#gaf595a7ac994547d11525cc1b21083c76" title="Retrieve that last error message information generated from parsing.">Z3_get_smtlib_error</a>(ctx) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00320"></a>00320     <span class="keywordflow">return</span>(1);
<a name="l00321"></a>00321   } 
<a name="l00322"></a>00322 
<a name="l00323"></a>00323   <span class="comment">/* Get the constraints from the parser. */</span>
<a name="l00324"></a>00324 
<a name="l00325"></a>00325   <span class="keywordtype">int</span> num = <a class="code" href="group__capi.html#ga5dd0dfb9ec1fcc7edba1e86a6ff98a77" title="Return the number of SMTLIB formulas parsed by the last call to Z3_parse_smtlib_string...">Z3_get_smtlib_num_formulas</a>(ctx);
<a name="l00326"></a>00326 
<a name="l00327"></a>00327   <span class="keywordflow">if</span>(num == 0){
<a name="l00328"></a>00328     std::cerr &lt;&lt; <span class="stringliteral">&quot;iZ3 error: File contains no formulas.\n&quot;</span>;
<a name="l00329"></a>00329     <span class="keywordflow">return</span> 1;
<a name="l00330"></a>00330   }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 
<a name="l00333"></a>00333   Z3_ast *constraints = (Z3_ast *)malloc(num * <span class="keyword">sizeof</span>(Z3_ast));
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="keywordtype">int</span> i;
<a name="l00336"></a>00336   <span class="keywordflow">for</span> (i = 0; i &lt; num; i++)
<a name="l00337"></a>00337     constraints[i] = <a class="code" href="group__capi.html#ga0ac42d0fa1874e4e773c89a56066f242" title="Return the i-th formula parsed by the last call to Z3_parse_smtlib_string or Z3_parse_smtlib_file...">Z3_get_smtlib_formula</a>(ctx, i);
<a name="l00338"></a>00338 
<a name="l00339"></a>00339   <span class="comment">/* if we get only one formula, and it is a conjunction, split it into conjuncts. */</span>
<a name="l00340"></a>00340   <span class="keywordflow">if</span>(num == 1){
<a name="l00341"></a>00341     Z3_app app = <a class="code" href="group__capi.html#gaf9345fd0822d7e9928dd4ab14a09765b" title="Convert an ast into an APP_AST. This is just type casting.">Z3_to_app</a>(ctx,constraints[0]);
<a name="l00342"></a>00342     Z3_func_decl func = <a class="code" href="group__capi.html#ga4ffab51c30484a32edc65194573cfd28" title="Return the declaration of a constant or function application.">Z3_get_app_decl</a>(ctx,app);
<a name="l00343"></a>00343     <a class="code" href="group__capi.html#ga1fe4399e5468621e2a799a680c6667cd" title="The different kinds of interpreted function kinds.">Z3_decl_kind</a> dk = <a class="code" href="group__capi.html#ga8cc3224c9b9f2149550701275207bedf" title="Return declaration kind corresponding to declaration.">Z3_get_decl_kind</a>(ctx,func);
<a name="l00344"></a>00344     <span class="keywordflow">if</span>(dk == Z3_OP_AND){
<a name="l00345"></a>00345       <span class="keywordtype">int</span> nconjs = <a class="code" href="group__capi.html#gae8ad520b79b46c323863bacffa0e12c0" title="Return the number of argument of an application. If t is an constant, then the number...">Z3_get_app_num_args</a>(ctx,app);
<a name="l00346"></a>00346       <span class="keywordflow">if</span>(nconjs &gt; 1){
<a name="l00347"></a>00347         std::cout &lt;&lt; <span class="stringliteral">&quot;Splitting formula into &quot;</span> &lt;&lt; nconjs &lt;&lt; <span class="stringliteral">&quot; conjuncts...\n&quot;</span>;
<a name="l00348"></a>00348         num = nconjs;
<a name="l00349"></a>00349         constraints = <span class="keyword">new</span> Z3_ast[num];
<a name="l00350"></a>00350         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; num; k++)
<a name="l00351"></a>00351           constraints[k] = <a class="code" href="group__capi.html#ga49a576b11f9f6ca4a94670e538a84c6b" title="Return the i-th argument of the given application.">Z3_get_app_arg</a>(ctx,app,k);
<a name="l00352"></a>00352       }
<a name="l00353"></a>00353     }
<a name="l00354"></a>00354   }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 
<a name="l00357"></a>00357   <span class="comment">/* print out the result for grins. */</span>
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   <span class="comment">// Z3_string smtout = Z3_benchmark_to_smtlib_string (ctx, &quot;foo&quot;, &quot;QFLIA&quot;, &quot;sat&quot;, &quot;&quot;, num, constraints, Z3_mk_true(ctx));</span>
<a name="l00360"></a>00360 
<a name="l00361"></a>00361   <span class="comment">// Z3_string smtout = Z3_ast_to_string(ctx,constraints[0]);</span>
<a name="l00362"></a>00362   <span class="comment">// Z3_string smtout = Z3_context_to_string(ctx);</span>
<a name="l00363"></a>00363   <span class="comment">// puts(smtout);</span>
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   <span class="comment">// iz3_print(ctx,num,constraints,&quot;iZ3temp.smt&quot;);</span>
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   <span class="comment">/* Make room for interpolants. */</span>
<a name="l00368"></a>00368 
<a name="l00369"></a>00369   Z3_ast *interpolants = (Z3_ast *)malloc((num-1) * <span class="keyword">sizeof</span>(Z3_ast));
<a name="l00370"></a>00370 
<a name="l00371"></a>00371   <span class="comment">/* Make room for the model. */</span>
<a name="l00372"></a>00372 
<a name="l00373"></a>00373   Z3_model model = 0;
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="comment">/* Call the prover */</span>
<a name="l00376"></a>00376 
<a name="l00377"></a>00377   <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> result = iz3_interpolate(ctx, num, constraints, interpolants, &amp;model);
<a name="l00378"></a>00378 
<a name="l00379"></a>00379   <span class="keywordflow">switch</span> (result) {
<a name="l00380"></a>00380   
<a name="l00381"></a>00381     <span class="comment">/* If UNSAT, print the interpolants */</span>
<a name="l00382"></a>00382   <span class="keywordflow">case</span> Z3_L_FALSE:
<a name="l00383"></a>00383     printf(<span class="stringliteral">&quot;unsat, interpolants:\n&quot;</span>);
<a name="l00384"></a>00384     <span class="keywordflow">for</span>(i = 0; i &lt; num-1; i++)
<a name="l00385"></a>00385       printf(<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__capi.html#gab1aa4b78298fe00b3167bf7bfd88aea3" title="Convert the given AST node into a string.">Z3_ast_to_string</a>(ctx, interpolants[i]));
<a name="l00386"></a>00386     std::cout &lt;&lt; <span class="stringliteral">&quot;Checking interpolants...\n&quot;</span>;
<a name="l00387"></a>00387     <span class="keyword">const</span> <span class="keywordtype">char</span> *error;
<a name="l00388"></a>00388     <span class="keywordflow">if</span>(iZ3_check_interpolant(ctx, num, constraints, 0, interpolants, &amp;error))
<a name="l00389"></a>00389       std::cout &lt;&lt; <span class="stringliteral">&quot;Interpolant is correct\n&quot;</span>;
<a name="l00390"></a>00390     <span class="keywordflow">else</span> {
<a name="l00391"></a>00391       std::cout &lt;&lt; <span class="stringliteral">&quot;Interpolant is incorrect\n&quot;</span>;
<a name="l00392"></a>00392       std::cout &lt;&lt; error &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00393"></a>00393     }
<a name="l00394"></a>00394     <span class="keywordflow">break</span>;
<a name="l00395"></a>00395   <span class="keywordflow">case</span> Z3_L_UNDEF:
<a name="l00396"></a>00396     printf(<span class="stringliteral">&quot;fail\n&quot;</span>);
<a name="l00397"></a>00397     <span class="keywordflow">break</span>;
<a name="l00398"></a>00398   <span class="keywordflow">case</span> Z3_L_TRUE:
<a name="l00399"></a>00399     printf(<span class="stringliteral">&quot;sat\n&quot;</span>);
<a name="l00400"></a>00400     printf(<span class="stringliteral">&quot;model:\n%s\n&quot;</span>, <a class="code" href="group__capi.html#gaf36d49862a8c0d20dd5e6508eef5f8af" title="Convert the given model into a string.">Z3_model_to_string</a>(ctx, model));
<a name="l00401"></a>00401     <span class="keywordflow">break</span>;
<a name="l00402"></a>00402   }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404   <span class="comment">/* Delete the model if there is one */</span>
<a name="l00405"></a>00405   
<a name="l00406"></a>00406   <span class="keywordflow">if</span> (model)
<a name="l00407"></a>00407     <a class="code" href="group__capi.html#ga0cc98d3ce68047f873e119bccaabdbee" title="Delete a model object.">Z3_del_model</a>(ctx, model);
<a name="l00408"></a>00408   
<a name="l00409"></a>00409   <span class="comment">/* Delete logical context (note, we call iz3_del_context, not</span>
<a name="l00410"></a>00410 <span class="comment">     Z3_del_context */</span>
<a name="l00411"></a>00411 
<a name="l00412"></a>00412   iz3_del_context(ctx);
<a name="l00413"></a>00413 
<a name="l00414"></a>00414   <span class="keywordflow">return</span> 0;
<a name="l00415"></a>00415 }
<a name="l00416"></a>00416 
<a name="l00417"></a>00417 <span class="preprocessor">#endif</span>
</pre></div></div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Aug 9 16:34:42 2012
</BODY>
</HTML>
