 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">
<table class="centered-small">
  <tr>
    <th><a href="index.html"><span>Home</span></a></th>
    <th> &bull; </th>
    <th><a href="documentation.html"><span>Docs</span></a></th>
    <th> &bull; </th>
    <th><a href="download.html"><span>Download</span></a></th>
    <th> &bull; </th>
    <th><a href="mail.html"><span>Mail</span></a></th>
    <th> &bull; </th>
    <th><a href="faq.html"><span>FAQ</span></a></th>
    <th> &bull; </th>
    <th><a href="awards.html"><span>Awards</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com"><span>MSR</span></a></th>
  </tr>
</table>
<p class="Z3Title"><img align="middle" src="z3.png" alt="Z3" /> An Efficient Theorem Prover</p>
<!-- Generated by Doxygen 1.6.3 -->
<h1>Microsoft.Z3/Microsoft.Z3.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*++</span>
<a name="l00002"></a>00002 <span class="comment">Copyright (c) 2007 Microsoft Corporation</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">Module Name:</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">    Microsoft.Z3.h</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">Abstract:</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">    Z3 Managed API.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">Author:</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    Nikolaj Bjorner (nbjorner)</span>
<a name="l00015"></a>00015 <span class="comment">    Leonardo de Moura (leonardo) 2007-06-8</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">Notes:</span>
<a name="l00018"></a>00018 <span class="comment">    </span>
<a name="l00019"></a>00019 <span class="comment">--*/</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#ifndef _MICROSOFT_Z3_H__</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#define _MICROSOFT_Z3_H__</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span>
<a name="l00024"></a>00024 <span class="keyword">struct </span>_Z3_model {};
<a name="l00025"></a>00025 <span class="keyword">struct </span>_Z3_config {};
<a name="l00026"></a>00026 <span class="keyword">struct </span>_Z3_context {};
<a name="l00027"></a>00027 <span class="keyword">struct </span>_Z3_func_decl {};
<a name="l00028"></a>00028 <span class="keyword">struct </span>_Z3_app {};
<a name="l00029"></a>00029 <span class="keyword">struct </span>_Z3_sort {};
<a name="l00030"></a>00030 <span class="keyword">struct </span>_Z3_symbol {};
<a name="l00031"></a>00031 <span class="keyword">struct </span>_Z3_ast {};
<a name="l00032"></a>00032 <span class="keyword">struct </span>_Z3_literals {};
<a name="l00033"></a>00033 <span class="keyword">struct </span>_Z3_pattern {};
<a name="l00034"></a>00034 <span class="keyword">struct </span>_Z3_constructor {};
<a name="l00035"></a>00035 <span class="keyword">struct </span>_Z3_constructor_list {};
<a name="l00036"></a>00036 <span class="keyword">typedef</span> _Z3_literals *Z3_literals;
<a name="l00037"></a>00037 <span class="keyword">struct </span>_Z3_theory {};
<a name="l00038"></a>00038 <span class="keyword">struct </span>_Z3_ast_vector {};
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="keyword">using namespace </span>System;
<a name="l00041"></a>00041 <span class="keyword">using namespace </span>System::Collections::Generic;
<a name="l00042"></a>00042 <span class="keyword">using namespace </span>System::Runtime::InteropServices;
<a name="l00043"></a>00043 <span class="keyword">using namespace </span>System::Numerics;
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;..\lib\z3.h&quot;</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="keyword">namespace </span>Microsoft {
<a name="l00049"></a>00049 <span class="keyword">namespace </span>Z3 {
<a name="l00050"></a>00050 
<a name="l00051"></a>00051     <span class="keyword">class </span>ref_context {
<a name="l00052"></a>00052         <span class="keywordtype">unsigned</span>   m_count;
<a name="l00053"></a>00053         <span class="keywordtype">bool</span>       m_owned;
<a name="l00054"></a>00054         <span class="keywordtype">bool</span>       m_scoped;
<a name="l00055"></a>00055         Z3_context m_ctx;
<a name="l00056"></a>00056         ref_context(Z3_context ctx, <span class="keywordtype">bool</span> owned, <span class="keywordtype">bool</span> scoped): m_count(1), m_owned(owned), m_scoped(scoped), m_ctx(ctx) {}
<a name="l00057"></a>00057     <span class="keyword">public</span>:
<a name="l00058"></a>00058         <span class="keyword">static</span> ref_context* mk(Z3_context ctx, <span class="keywordtype">bool</span> owned, <span class="keywordtype">bool</span> scoped);
<a name="l00059"></a>00059         <span class="keywordtype">void</span> dec_ref();
<a name="l00060"></a>00060         <span class="keywordtype">void</span> inc_ref();
<a name="l00061"></a>00061         Z3_context operator()() { <span class="keywordflow">return</span> m_ctx; }
<a name="l00062"></a>00062         ~ref_context() {}
<a name="l00063"></a>00063         <span class="keywordtype">bool</span> is_ref_counted()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !is_scoped(); }
<a name="l00064"></a>00064         <span class="keywordtype">bool</span> is_scoped()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_scoped; }
<a name="l00065"></a>00065     };
<a name="l00066"></a>00066 
<a name="l00071"></a>00071 
<a name="l00072"></a>00072     <span class="keyword">public ref class</span> Z3Log {
<a name="l00073"></a>00073         <span class="keyword">static</span> <span class="keywordtype">bool</span> m_open = <span class="keyword">false</span>;
<a name="l00074"></a>00074     <span class="keyword">public</span>:
<a name="l00082"></a>00082         <span class="keyword">static</span> <span class="keywordtype">bool</span> Open(String^ filename);
<a name="l00083"></a>00083 
<a name="l00087"></a>00087         <span class="keyword">static</span> <span class="keywordtype">bool</span> IsOpen() { <span class="keywordflow">return</span> m_open; }
<a name="l00088"></a>00088         
<a name="l00094"></a>00094         <span class="keyword">static</span> <span class="keywordtype">void</span> Append(String^ <span class="keywordtype">string</span>);
<a name="l00095"></a>00095         
<a name="l00101"></a>00101         <span class="keyword">static</span> <span class="keywordtype">void</span> Close();
<a name="l00102"></a>00102     };
<a name="l00103"></a>00103     
<a name="l00113"></a><a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html">00113</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a> {
<a name="l00114"></a>00114         Z3_context   m_ctx;
<a name="l00115"></a>00115         Z3_symbol    m_symbol;
<a name="l00116"></a>00116     <span class="keyword">internal</span>:
<a name="l00117"></a>00117         <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>(Z3_context c, Z3_symbol s) : m_ctx(c), m_symbol(s) { }
<a name="l00118"></a>00118         Z3_symbol <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_symbol; }      
<a name="l00119"></a>00119     <span class="keyword">public</span>:
<a name="l00120"></a>00120         <span class="keyword">virtual</span> String^ ToString() <span class="keyword">override</span>;
<a name="l00121"></a>00121     };
<a name="l00122"></a>00122 
<a name="l00131"></a><a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179">00131</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a>
<a name="l00132"></a>00132     {
<a name="l00133"></a>00133         True,
<a name="l00134"></a>00134         False,
<a name="l00135"></a>00135         Undef
<a name="l00136"></a>00136     };
<a name="l00137"></a>00137 
<a name="l00163"></a><a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f">00163</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> 
<a name="l00164"></a>00164     {
<a name="l00165"></a>00165         Ok,
<a name="l00166"></a>00166         TypeError,
<a name="l00167"></a>00167         IndexOutOfBounds,
<a name="l00168"></a>00168         InvalidArgument,
<a name="l00169"></a>00169         ParserError,
<a name="l00170"></a>00170         NoParser,
<a name="l00171"></a>00171         InvalidPattern,
<a name="l00172"></a>00172         InternalFatal,
<a name="l00173"></a>00173         InvalidUsage,
<a name="l00174"></a>00174         FileAccessError,
<a name="l00175"></a>00175         NonDisposedConfig,
<a name="l00176"></a>00176         NonDisposedContext,
<a name="l00177"></a>00177         NonDisposedLiterals,
<a name="l00178"></a>00178         NonDisposedModel
<a name="l00179"></a>00179     };
<a name="l00180"></a>00180 
<a name="l00189"></a><a class="code" href="group__mapi.html#ga8fcc700aeeee633213b4e5f433e5e12e">00189</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga8fcc700aeeee633213b4e5f433e5e12e" title="Z3 pretty printing modes used when pretty printing terms.">PrintMode</a> 
<a name="l00190"></a>00190     {
<a name="l00191"></a>00191         SmtlibFull,
<a name="l00192"></a>00192         LowLevel,
<a name="l00193"></a>00193         SmtlibCompliant,
<a name="l00194"></a>00194         Smtlib2Compliant
<a name="l00195"></a>00195     };
<a name="l00196"></a>00196 
<a name="l00203"></a><a class="code" href="class_microsoft_1_1_z3_1_1_z3_error.html">00203</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a> : Exception {
<a name="l00204"></a>00204     <span class="keyword">public</span>:
<a name="l00205"></a>00205         <a class="code" href="class_microsoft_1_1_z3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a>(<a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> c) { Code = c; InternalCode = 0; }
<a name="l00206"></a>00206         <a class="code" href="class_microsoft_1_1_z3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a>(<span class="keywordtype">int</span> i) { Code = ErrorCode::Ok; InternalCode = i; }
<a name="l00207"></a>00207         <a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> Code;
<a name="l00208"></a>00208         <span class="keywordtype">int</span>       InternalCode;
<a name="l00209"></a>00209     };
<a name="l00210"></a>00210 
<a name="l00211"></a>00211     
<a name="l00213"></a>00213     <span class="keyword">typedef</span> IntPtr AstPtr;
<a name="l00214"></a>00214     <span class="keyword">typedef</span> IntPtr SortPtr;
<a name="l00215"></a>00215     <span class="keyword">typedef</span> IntPtr FuncDeclPtr;
<a name="l00216"></a>00216     <span class="keyword">typedef</span> IntPtr TermPtr;
<a name="l00217"></a>00217     <span class="keyword">typedef</span> IntPtr PatternPtr;
<a name="l00218"></a>00218     <span class="keyword">typedef</span> IntPtr AppPtr;
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 
<a name="l00221"></a>00221     Z3_func_decl get_func_decl(FuncDeclPtr t) { 
<a name="l00222"></a>00222         <span class="keywordflow">if</span> (t == IntPtr::Zero) {
<a name="l00223"></a>00223             <span class="keywordflow">throw</span> <span class="keyword">gcnew</span> <a class="code" href="class_microsoft_1_1_z3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a>(ErrorCode::InvalidArgument);
<a name="l00224"></a>00224         }
<a name="l00225"></a>00225         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Z3_func_decl<span class="keyword">&gt;</span>(t.ToPointer()); 
<a name="l00226"></a>00226     }
<a name="l00227"></a>00227     Z3_ast get_ast(TermPtr t) { 
<a name="l00228"></a>00228         <span class="keywordflow">if</span> (t == IntPtr::Zero) {
<a name="l00229"></a>00229             <span class="keywordflow">throw</span> <span class="keyword">gcnew</span> Z3Error(ErrorCode::InvalidArgument);
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Z3_ast<span class="keyword">&gt;</span>(t.ToPointer()); 
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233     Z3_sort get_sort(SortPtr t) { 
<a name="l00234"></a>00234         <span class="keywordflow">if</span> (t == IntPtr::Zero) {
<a name="l00235"></a>00235             <span class="keywordflow">throw</span> <span class="keyword">gcnew</span> Z3Error(ErrorCode::InvalidArgument);
<a name="l00236"></a>00236         }
<a name="l00237"></a>00237         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Z3_sort<span class="keyword">&gt;</span>(t.ToPointer()); 
<a name="l00238"></a>00238     }
<a name="l00239"></a>00239     Z3_app get_const_ast(AppPtr c) { 
<a name="l00240"></a>00240         <span class="keywordflow">if</span> (c == IntPtr::Zero) {
<a name="l00241"></a>00241             <span class="keywordflow">throw</span> <span class="keyword">gcnew</span> Z3Error(ErrorCode::InvalidArgument);
<a name="l00242"></a>00242         }
<a name="l00243"></a>00243         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Z3_app<span class="keyword">&gt;</span>(c.ToPointer()); 
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245     Z3_pattern get_pattern(PatternPtr p) { 
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (p == IntPtr::Zero) {
<a name="l00247"></a>00247             <span class="keywordflow">throw</span> <span class="keyword">gcnew</span> Z3Error(ErrorCode::InvalidArgument);
<a name="l00248"></a>00248         }
<a name="l00249"></a>00249         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Z3_pattern<span class="keyword">&gt;</span>(p.ToPointer()); 
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251 
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     
<a name="l00262"></a><a class="code" href="group__mapi.html#ga05812818de02fb4b202d7513ce50745d">00262</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga05812818de02fb4b202d7513ce50745d" title="In Z3, a symbol can be represented using integers and strings (See GetSymbolKind)...">SymbolKind</a> 
<a name="l00263"></a>00263     {
<a name="l00264"></a>00264         Int, 
<a name="l00265"></a>00265         String
<a name="l00266"></a>00266     };
<a name="l00267"></a>00267 
<a name="l00271"></a><a class="code" href="group__mapi.html#ga7664c6569cf130a5d166ec8c8dc27101">00271</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga7664c6569cf130a5d166ec8c8dc27101" title="The different kinds of Z3 sorts (See GetSortKind).">SortKind</a> 
<a name="l00272"></a>00272     {
<a name="l00273"></a>00273         Uninterpreted,
<a name="l00274"></a>00274         Bool,
<a name="l00275"></a>00275         Int,
<a name="l00276"></a>00276         Real,
<a name="l00277"></a>00277         BitVector,
<a name="l00278"></a>00278         Array,
<a name="l00279"></a>00279         Datatype,
<a name="l00280"></a>00280         Unknown
<a name="l00281"></a>00281     };
<a name="l00282"></a>00282 
<a name="l00296"></a><a class="code" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e">00296</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e" title="Different failure kinds.">SearchFailureExplanation</a>
<a name="l00297"></a>00297     {
<a name="l00298"></a>00298         NoFailure,
<a name="l00299"></a>00299         Unknown,
<a name="l00300"></a>00300         TimeOut,
<a name="l00301"></a>00301         MemOut,
<a name="l00302"></a>00302         UserCanceled,
<a name="l00303"></a>00303         MaxConflicts,
<a name="l00304"></a>00304         Theory,
<a name="l00305"></a>00305         Quantifiers
<a name="l00306"></a>00306     };
<a name="l00307"></a>00307 
<a name="l00317"></a><a class="code" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc">00317</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc" title="The different kinds of Z3 Terms.">TermKind</a> 
<a name="l00318"></a>00318     {
<a name="l00319"></a>00319         Numeral,
<a name="l00320"></a>00320         App,
<a name="l00321"></a>00321         Var,
<a name="l00322"></a>00322         Quantifier,
<a name="l00323"></a>00323         Unknown
<a name="l00324"></a>00324     };
<a name="l00325"></a>00325     
<a name="l00326"></a>00326 
<a name="l00330"></a><a class="code" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425">00330</a>     <span class="keyword">public enum class</span> <a class="code" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425" title="Different kinds of Z3 built-in declarations (See GetDeclKind).">DeclKind</a> 
<a name="l00331"></a>00331     {
<a name="l00332"></a>00332         <span class="comment">// Basic operators</span>
<a name="l00333"></a>00333         True,
<a name="l00334"></a>00334         False,
<a name="l00335"></a>00335         Eq,
<a name="l00336"></a>00336         Distinct,
<a name="l00337"></a>00337         Ite,
<a name="l00338"></a>00338         And,
<a name="l00339"></a>00339         Or,
<a name="l00340"></a>00340         Iff,
<a name="l00341"></a>00341         Xor,
<a name="l00342"></a>00342         Not,
<a name="l00343"></a>00343         Implies,
<a name="l00344"></a>00344         <span class="comment">// Arithmetic</span>
<a name="l00345"></a>00345         ArithNum,
<a name="l00346"></a>00346         Le,
<a name="l00347"></a>00347         Ge,
<a name="l00348"></a>00348         Lt,
<a name="l00349"></a>00349         Gt,
<a name="l00350"></a>00350         Add,
<a name="l00351"></a>00351         Sub,
<a name="l00352"></a>00352         Uminus,
<a name="l00353"></a>00353         Mul,
<a name="l00354"></a>00354         Div,
<a name="l00355"></a>00355         IDiv,
<a name="l00356"></a>00356         Rem,
<a name="l00357"></a>00357         Mod,
<a name="l00358"></a>00358         ToReal,
<a name="l00359"></a>00359         ToInt,
<a name="l00360"></a>00360         IsInt,
<a name="l00361"></a>00361         <span class="comment">// Arrays</span>
<a name="l00362"></a>00362         Store,
<a name="l00363"></a>00363         Select,
<a name="l00364"></a>00364         ConstArray,
<a name="l00365"></a>00365         DefaultArray,
<a name="l00366"></a>00366         MapArray,
<a name="l00367"></a>00367         Union,
<a name="l00368"></a>00368         Intersect,
<a name="l00369"></a>00369         Difference,
<a name="l00370"></a>00370         Complement,
<a name="l00371"></a>00371         Subset,
<a name="l00372"></a>00372         AsArray,
<a name="l00373"></a>00373         <span class="comment">// Bit-vectors.            </span>
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         BitNum,
<a name="l00376"></a>00376         Bit1,
<a name="l00377"></a>00377         Bit0,
<a name="l00378"></a>00378         BNeg,
<a name="l00379"></a>00379         BAdd,
<a name="l00380"></a>00380         BSub,
<a name="l00381"></a>00381         BMul,
<a name="l00382"></a>00382         BSDiv,
<a name="l00383"></a>00383         BUDiv,
<a name="l00384"></a>00384         BSRem,
<a name="l00385"></a>00385         BURem,
<a name="l00386"></a>00386         BSMod,
<a name="l00387"></a>00387 
<a name="l00388"></a>00388         BSDiv0,
<a name="l00389"></a>00389         BUDiv0,
<a name="l00390"></a>00390         BSRem0,
<a name="l00391"></a>00391         BURem0,
<a name="l00392"></a>00392         BSMod0,
<a name="l00393"></a>00393         BULeq,
<a name="l00394"></a>00394         BSLeq,
<a name="l00395"></a>00395         BUGeq,
<a name="l00396"></a>00396         BSGeq,
<a name="l00397"></a>00397         BULt,
<a name="l00398"></a>00398         BSLt,
<a name="l00399"></a>00399         BUGt,
<a name="l00400"></a>00400         BSGt,
<a name="l00401"></a>00401         BAnd,
<a name="l00402"></a>00402         BOr,
<a name="l00403"></a>00403         BNot,
<a name="l00404"></a>00404         BXor,
<a name="l00405"></a>00405         BNand,
<a name="l00406"></a>00406         BNor,
<a name="l00407"></a>00407         BXnor,
<a name="l00408"></a>00408         BConcat,
<a name="l00409"></a>00409         BSignExt,
<a name="l00410"></a>00410         BZeroExt,
<a name="l00411"></a>00411         BExtract,
<a name="l00412"></a>00412         BRepeat,
<a name="l00413"></a>00413         BRedOr,
<a name="l00414"></a>00414         BRedAnd,
<a name="l00415"></a>00415         BComp,
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         BShl,
<a name="l00418"></a>00418         BLShr,
<a name="l00419"></a>00419         BAShr,
<a name="l00420"></a>00420         BRotateLeft,
<a name="l00421"></a>00421         BRotateRight,
<a name="l00422"></a>00422         BExtRotateLeft,
<a name="l00423"></a>00423         BExtRotateRight,
<a name="l00424"></a>00424         BInt2Bv,
<a name="l00425"></a>00425         BBv2Int,
<a name="l00426"></a>00426         BCarry,
<a name="l00427"></a>00427         BXor3,
<a name="l00428"></a>00428 
<a name="l00429"></a>00429         PrAsserted,
<a name="l00430"></a>00430         PrGoal,
<a name="l00431"></a>00431         PrModusPonens,
<a name="l00432"></a>00432         PrReflexivity,
<a name="l00433"></a>00433         PrTransitivity,
<a name="l00434"></a>00434         PrTransitivityStar,
<a name="l00435"></a>00435         PrSymmetry,
<a name="l00436"></a>00436         PrMonotonicity,
<a name="l00437"></a>00437         PrQuantIntro,
<a name="l00438"></a>00438         PrDistributivity,
<a name="l00439"></a>00439         PrAndElim,
<a name="l00440"></a>00440         PrNotOrElim,
<a name="l00441"></a>00441         PrRewrite,
<a name="l00442"></a>00442         PrRewriteStar,
<a name="l00443"></a>00443         PrPullQuant,
<a name="l00444"></a>00444         PrPullQuantStar,
<a name="l00445"></a>00445         PrPushQuant,
<a name="l00446"></a>00446         PrElimUnusedVars,
<a name="l00447"></a>00447         PrDer,
<a name="l00448"></a>00448         PrQuantInst,
<a name="l00449"></a>00449         PrHypothesis,
<a name="l00450"></a>00450         PrLemma,
<a name="l00451"></a>00451         PrUnitResolution,
<a name="l00452"></a>00452         PrIffTrue,
<a name="l00453"></a>00453         PrIffFalse,
<a name="l00454"></a>00454         PrCommutativity,
<a name="l00455"></a>00455         PrDefAxiom,
<a name="l00456"></a>00456         PrDefIntro,
<a name="l00457"></a>00457         PrApplyDef,
<a name="l00458"></a>00458         PrIffOeq,            
<a name="l00459"></a>00459         PrNnfPos,
<a name="l00460"></a>00460         PrNnfNeg,
<a name="l00461"></a>00461         PrNnfStar,
<a name="l00462"></a>00462         PrSkolemize,
<a name="l00463"></a>00463         PrCnfStar,
<a name="l00464"></a>00464         PrModusPonensOeq,
<a name="l00465"></a>00465         PrThLemma,
<a name="l00466"></a>00466 
<a name="l00467"></a>00467         RaStore,
<a name="l00468"></a>00468         RaEmpty,
<a name="l00469"></a>00469         RaIsEmpty,
<a name="l00470"></a>00470         RaJoin,
<a name="l00471"></a>00471         RaUnion,
<a name="l00472"></a>00472         RaWiden,
<a name="l00473"></a>00473         RaProject,
<a name="l00474"></a>00474         RaFilter,
<a name="l00475"></a>00475         RaNegationFilter,
<a name="l00476"></a>00476         RaRename,
<a name="l00477"></a>00477         RaComplement,
<a name="l00478"></a>00478         RaSelect,
<a name="l00479"></a>00479         RaClone,
<a name="l00480"></a>00480 
<a name="l00481"></a>00481         Label,
<a name="l00482"></a>00482         LabelLit,
<a name="l00483"></a>00483         Uninterpreted            
<a name="l00484"></a>00484     };
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 
<a name="l00494"></a><a class="code" href="interface_microsoft_1_1_z3_1_1_i_error_handler.html">00494</a>     <span class="keyword">public interface class</span> <a class="code" href="interface_microsoft_1_1_z3_1_1_i_error_handler.html" title="IErrorHandler is an abstract (interface) class for passing an error handler.">IErrorHandler</a> 
<a name="l00495"></a>00495     {
<a name="l00496"></a>00496     <span class="keyword">public</span>:
<a name="l00497"></a>00497         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Handler(<a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> code) = 0;
<a name="l00498"></a>00498     };
<a name="l00499"></a>00499 
<a name="l00501"></a>00501     <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> ToLBool(<a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> b) {
<a name="l00502"></a>00502         <span class="keywordflow">switch</span>(b) {
<a name="l00503"></a>00503         <span class="keywordflow">case</span> Z3_L_FALSE: <span class="keywordflow">return</span> LBool::False; 
<a name="l00504"></a>00504         <span class="keywordflow">case</span> Z3_L_TRUE:  <span class="keywordflow">return</span> LBool::True; 
<a name="l00505"></a>00505         <span class="keywordflow">default</span>:         <span class="keywordflow">return</span> LBool::Undef; 
<a name="l00506"></a>00506         }
<a name="l00507"></a>00507     }
<a name="l00509"></a>00509 
<a name="l00517"></a><a class="code" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">00517</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_labeled_literals.html" title="Container for labeled literals.">LabeledLiterals</a> {
<a name="l00518"></a>00518         ref_context&amp; m_context;
<a name="l00519"></a>00519         Z3_literals  m_labels;
<a name="l00520"></a>00520     <span class="keyword">internal</span>:
<a name="l00521"></a>00521         <a class="code" href="class_microsoft_1_1_z3_1_1_labeled_literals.html" title="Container for labeled literals.">LabeledLiterals</a>(ref_context&amp; ctx, Z3_literals lbls): m_context(ctx), m_labels(lbls) { ctx.inc_ref(); }
<a name="l00522"></a>00522         Z3_literals Get() { <span class="keywordflow">return</span> m_labels; }
<a name="l00523"></a>00523         TermPtr GetLiteral(<span class="keywordtype">unsigned</span> idx) { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga515a79517c3c80da345027846eea2a81" title="Retrieve literal expression at idx.">Z3_get_literal</a>(m_context(), m_labels, idx)); }
<a name="l00524"></a>00524     <span class="keyword">protected</span>:
<a name="l00525"></a>00525         !<a class="code" href="class_microsoft_1_1_z3_1_1_labeled_literals.html" title="Container for labeled literals.">LabeledLiterals</a>(); 
<a name="l00526"></a>00526     <span class="keyword">public</span>:
<a name="l00527"></a>00527         ~<a class="code" href="class_microsoft_1_1_z3_1_1_labeled_literals.html" title="Container for labeled literals.">LabeledLiterals</a>() { <span class="keywordflow">if</span> (m_labels) { <a class="code" href="group__capi.html#ga3224882c7224ee76787c8e48ecc0a7ae" title="Delete a labels context.">Z3_del_literals</a>(m_context(), m_labels); } m_labels = 0; m_context.dec_ref(); }
<a name="l00528"></a>00528         <span class="keywordtype">unsigned</span> GetNumLabels() { <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gaae868f4ef6939b95d9c0ba2eb3d1e913" title="Retrieve the number of label symbols that were returned.">Z3_get_num_literals</a>(m_context(), m_labels); }
<a name="l00529"></a>00529         <span class="keywordtype">void</span> Disable(<span class="keywordtype">unsigned</span> idx) { <a class="code" href="group__capi.html#ga9e7d5cb3fe2b88c5938668c93fa6a4ff" title="Disable label.">Z3_disable_literal</a>(m_context(), m_labels, idx); }
<a name="l00530"></a>00530         <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ GetLabel(<span class="keywordtype">unsigned</span> idx) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>(m_context(), <a class="code" href="group__capi.html#gaf0ecf0a7282aba9556e7c34bbe332568" title="Retrieve label symbol at idx.">Z3_get_label_symbol</a>(m_context(), m_labels, idx)); }
<a name="l00531"></a>00531     };
<a name="l00532"></a>00532 
<a name="l00533"></a>00533 
<a name="l00539"></a><a class="code" href="class_microsoft_1_1_z3_1_1_constructor.html">00539</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a> {
<a name="l00540"></a>00540         ref_context&amp;          m_context;
<a name="l00541"></a>00541         Z3_constructor      m_constructor;
<a name="l00542"></a>00542         FuncDeclPtr         m_constructor_decl;
<a name="l00543"></a>00543         FuncDeclPtr         m_tester;
<a name="l00544"></a>00544         array&lt;FuncDeclPtr&gt;^ m_accessors;
<a name="l00545"></a>00545 
<a name="l00546"></a>00546         !<a class="code" href="class_microsoft_1_1_z3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>();
<a name="l00547"></a>00547 
<a name="l00548"></a>00548     <span class="keyword">internal</span>:
<a name="l00549"></a>00549         String^          m_name;
<a name="l00550"></a>00550         String^          m_tester_name;
<a name="l00551"></a>00551         array&lt;String^&gt;^  m_field_names;
<a name="l00552"></a>00552         array&lt;SortPtr&gt;^  m_field_sorts;
<a name="l00553"></a>00553         array&lt;unsigned&gt;^ m_field_refs;
<a name="l00554"></a>00554 
<a name="l00555"></a>00555         <a class="code" href="class_microsoft_1_1_z3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>(
<a name="l00556"></a>00556             ref_context&amp;     context,
<a name="l00557"></a>00557             String^          name,
<a name="l00558"></a>00558             String^          tester,
<a name="l00559"></a>00559             array&lt;String^&gt;^  field_names,
<a name="l00560"></a>00560             array&lt;SortPtr&gt;^  field_sorts,
<a name="l00561"></a>00561             array&lt;unsigned&gt;^ field_refs
<a name="l00562"></a>00562             );
<a name="l00563"></a>00563 
<a name="l00564"></a>00564         Z3_constructor Query();
<a name="l00565"></a>00565         Z3_constructor Get();
<a name="l00566"></a>00566         FuncDeclPtr GetConstructor();
<a name="l00567"></a>00567         FuncDeclPtr GetTester();
<a name="l00568"></a>00568         array&lt;FuncDeclPtr&gt;^ GetAccessors();
<a name="l00569"></a>00569     <span class="keyword">public</span>:    
<a name="l00570"></a>00570         ~<a class="code" href="class_microsoft_1_1_z3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>();   
<a name="l00571"></a>00571     };
<a name="l00572"></a>00572 
<a name="l00573"></a>00573     
<a name="l00574"></a>00574 
<a name="l00586"></a><a class="code" href="class_microsoft_1_1_z3_1_1_config.html">00586</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_config.html" title="Configuration.">Config</a>
<a name="l00587"></a>00587     {
<a name="l00589"></a>00589         Z3_config m_config;
<a name="l00591"></a>00591     <span class="keyword">internal</span>:
<a name="l00593"></a>00593         Z3_config <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_config; }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596     <span class="keyword">protected</span>:
<a name="l00597"></a>00597         !<a class="code" href="class_microsoft_1_1_z3_1_1_config.html#a539a941e29cde8d13e413c515d9801cd" title="Create configuration context.">Config</a>();
<a name="l00598"></a>00598 
<a name="l00599"></a>00599     <span class="keyword">public</span>:
<a name="l00607"></a>00607         <a class="code" href="class_microsoft_1_1_z3_1_1_config.html#a539a941e29cde8d13e413c515d9801cd" title="Create configuration context.">Config</a>();
<a name="l00608"></a>00608 
<a name="l00610"></a>00610         <a class="code" href="class_microsoft_1_1_z3_1_1_config.html#a54dfba499c9d9e1003d4c9bcbe6ad1c5" title="Configuration destructor.">~Config</a>();
<a name="l00611"></a>00611         
<a name="l00621"></a>00621         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_config.html#a58c38c04f7b5d1553ff23d28b29dbcd9" title="Set parameter to specified value.">SetParamValue</a>(String^ name, String^ value);
<a name="l00622"></a>00622     };
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 
<a name="l00628"></a><a class="code" href="interface_microsoft_1_1_z3_1_1_i_raw_parameter.html">00628</a>     <span class="keyword">public interface class</span> <a class="code" href="interface_microsoft_1_1_z3_1_1_i_raw_parameter.html" title="Z3 Parameter values.">IRawParameter</a> {  };
<a name="l00629"></a>00629     <span class="keyword">public interface class</span> IParameter {  };
<a name="l00630"></a>00630 
<a name="l00631"></a>00631     <span class="keyword">public ref class</span> IntParameter : <span class="keyword">public</span> IRawParameter, <span class="keyword">public</span> IParameter { 
<a name="l00632"></a>00632         <span class="keywordtype">int</span> m_value;
<a name="l00633"></a>00633     <span class="keyword">internal</span>:
<a name="l00634"></a>00634         IntParameter(<span class="keywordtype">int</span> i) : m_value(i) {}
<a name="l00635"></a>00635     <span class="keyword">public</span>:
<a name="l00636"></a>00636         <span class="keyword">property</span> <span class="keywordtype">int</span> Int { <span class="keywordtype">int</span> <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00637"></a>00637         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value.ToString(); }
<a name="l00638"></a>00638     };
<a name="l00639"></a>00639 
<a name="l00640"></a>00640     <span class="keyword">public ref class</span> DoubleParameter : <span class="keyword">public</span> IRawParameter, <span class="keyword">public</span> IParameter  { 
<a name="l00641"></a>00641         <span class="keywordtype">double</span> m_value;
<a name="l00642"></a>00642     <span class="keyword">internal</span>:
<a name="l00643"></a>00643         DoubleParameter(<span class="keywordtype">double</span> i) : m_value(i) {}
<a name="l00644"></a>00644     <span class="keyword">public</span>:
<a name="l00645"></a>00645         <span class="keyword">property</span> <span class="keywordtype">double</span> Double { <span class="keywordtype">double</span> <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00646"></a>00646         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value.ToString(); }
<a name="l00647"></a>00647     };
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     <span class="keyword">public ref class</span> RationalParameter : <span class="keyword">public</span> IRawParameter, <span class="keyword">public</span> IParameter  { 
<a name="l00650"></a>00650         String^ m_value;
<a name="l00651"></a>00651     <span class="keyword">internal</span>:
<a name="l00652"></a>00652         RationalParameter(String^ s): m_value(s) {}
<a name="l00653"></a>00653     <span class="keyword">public</span>:
<a name="l00654"></a>00654         <span class="keyword">property</span>  String^ GetRational {  String^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00655"></a>00655         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value; }
<a name="l00656"></a>00656     };
<a name="l00657"></a>00657 
<a name="l00658"></a>00658     <span class="keyword">public ref class</span> SymbolParameter : <span class="keyword">public</span> IRawParameter, <span class="keyword">public</span> IParameter  { 
<a name="l00659"></a>00659         Symbol^ m_value;
<a name="l00660"></a>00660     <span class="keyword">internal</span>:
<a name="l00661"></a>00661         SymbolParameter(Symbol^ s): m_value(s) {}
<a name="l00662"></a>00662     <span class="keyword">public</span>:
<a name="l00663"></a>00663         <span class="keyword">property</span>  Symbol^ GetSymbol {  Symbol^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00664"></a>00664     };
<a name="l00665"></a>00665 
<a name="l00666"></a>00666     <span class="keyword">public ref class</span> TermPtrParameter : <span class="keyword">public</span> IRawParameter  { 
<a name="l00667"></a>00667         TermPtr m_value;
<a name="l00668"></a>00668     <span class="keyword">internal</span>:
<a name="l00669"></a>00669         TermPtrParameter(TermPtr t) : m_value(t) {}
<a name="l00670"></a>00670     <span class="keyword">public</span>:
<a name="l00671"></a>00671         <span class="keyword">property</span> TermPtr GetTerm {  TermPtr <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00672"></a>00672     };
<a name="l00673"></a>00673 
<a name="l00674"></a>00674     <span class="keyword">public ref class</span> SortPtrParameter : <span class="keyword">public</span> IRawParameter  { 
<a name="l00675"></a>00675         SortPtr m_value;
<a name="l00676"></a>00676     <span class="keyword">internal</span>:
<a name="l00677"></a>00677         SortPtrParameter(SortPtr t) : m_value(t) {}
<a name="l00678"></a>00678     <span class="keyword">public</span>:
<a name="l00679"></a>00679         <span class="keyword">property</span>  SortPtr GetSort {  SortPtr <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00680"></a>00680     };
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     <span class="keyword">public ref class</span> FuncDeclPtrParameter : <span class="keyword">public</span> IRawParameter  { 
<a name="l00683"></a>00683         FuncDeclPtr m_value;
<a name="l00684"></a>00684     <span class="keyword">internal</span>:
<a name="l00685"></a>00685         FuncDeclPtrParameter(FuncDeclPtr t) : m_value(t) {}
<a name="l00686"></a>00686     <span class="keyword">public</span>:
<a name="l00687"></a>00687         <span class="keyword">property</span>  FuncDeclPtr GetFuncDecl {  FuncDeclPtr <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l00688"></a>00688     };
<a name="l00689"></a>00689 
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 
<a name="l00692"></a>00692 
<a name="l00696"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_array_value.html">00696</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_array_value.html" title="Z3 Array Value object.">RawArrayValue</a> {
<a name="l00697"></a>00697     <span class="keyword">public</span>:
<a name="l00698"></a>00698         array&lt;TermPtr&gt;^   Domain; 
<a name="l00699"></a>00699         array&lt;TermPtr&gt;^   Range;
<a name="l00700"></a>00700         TermPtr           ElseCase;
<a name="l00701"></a>00701     };
<a name="l00702"></a>00702 
<a name="l00709"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_function_entry.html">00709</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_function_entry.html" title="Z3 Function entry object.">RawFunctionEntry</a> {
<a name="l00710"></a>00710     <span class="keyword">public</span>:
<a name="l00711"></a>00711         array&lt;TermPtr&gt;^ Arguments;
<a name="l00712"></a>00712         TermPtr         Result;
<a name="l00713"></a>00713     };
<a name="l00714"></a>00714 
<a name="l00729"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_function_graph.html">00729</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_function_graph.html" title="Z3 Function graph object.">RawFunctionGraph</a> {
<a name="l00730"></a>00730     <span class="keyword">public</span>:
<a name="l00731"></a>00731         FuncDeclPtr               Declaration;
<a name="l00732"></a>00732         array&lt;RawFunctionEntry^&gt;^ Entries;
<a name="l00733"></a>00733         TermPtr                   Else;
<a name="l00734"></a>00734     };
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     <span class="keyword">public ref class</span> RawQuantifier {
<a name="l00737"></a>00737     <span class="keyword">public</span>:
<a name="l00738"></a>00738         <span class="keywordtype">bool</span>               IsForall;
<a name="l00739"></a>00739         <span class="keywordtype">unsigned</span>           Weight;
<a name="l00740"></a>00740         array&lt;PatternPtr&gt;^ Patterns;
<a name="l00741"></a>00741         array&lt;TermPtr&gt;^    NoPatterns;
<a name="l00742"></a>00742         array&lt;SortPtr&gt;^    Sorts;
<a name="l00743"></a>00743         array&lt;Symbol^&gt;^    Names;
<a name="l00744"></a>00744         TermPtr            Body;
<a name="l00745"></a>00745     };
<a name="l00746"></a>00746 
<a name="l00747"></a>00747     <span class="keyword">ref class</span> RawModel;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     <span class="keyword">public</span> delegate <span class="keywordtype">void</span> Action0();
<a name="l00750"></a>00750 
<a name="l00751"></a>00751     <span class="keyword">generic</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S&gt;
<a name="l00752"></a>00752         <span class="keyword">public</span> delegate <span class="keywordtype">void</span> Action2(
<a name="l00753"></a>00753             T obj1, 
<a name="l00754"></a>00754             S obj2
<a name="l00755"></a>00755             );
<a name="l00756"></a>00756     <span class="keyword">generic</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S, <span class="keyword">typename</span> U&gt;
<a name="l00757"></a>00757         <span class="keyword">public</span> delegate <span class="keywordtype">void</span> Action3(
<a name="l00758"></a>00758             T obj1, 
<a name="l00759"></a>00759             S obj2,
<a name="l00760"></a>00760             U obj3
<a name="l00761"></a>00761             );
<a name="l00762"></a>00762 
<a name="l00763"></a>00763 
<a name="l00764"></a>00764     <span class="keyword">generic</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00765"></a>00765         <span class="keyword">public</span> delegate T Func0();
<a name="l00766"></a>00766     
<a name="l00767"></a>00767     <span class="keyword">generic</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S&gt;
<a name="l00768"></a>00768         <span class="keyword">public</span> delegate S Func1(
<a name="l00769"></a>00769             T obj
<a name="l00770"></a>00770             );
<a name="l00771"></a>00771     
<a name="l00772"></a>00772     <span class="keyword">generic</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S, <span class="keyword">typename</span> U&gt;
<a name="l00773"></a>00773         <span class="keyword">public</span> delegate U Func2(
<a name="l00774"></a>00774             T obj1,
<a name="l00775"></a>00775             S obj2
<a name="l00776"></a>00776             );
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 
<a name="l00782"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html">00782</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html" title="Z3 RawModel object.">RawModel</a> {
<a name="l00783"></a>00783         ref_context&amp; m_context;
<a name="l00784"></a>00784         Z3_model     m_model;
<a name="l00785"></a>00785         Dictionary&lt;FuncDeclPtr, RawFunctionGraph^&gt;^ m_graphs;
<a name="l00786"></a>00786     <span class="keyword">internal</span>:           
<a name="l00787"></a>00787         <a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html" title="Z3 RawModel object.">RawModel</a>(ref_context&amp; c, Z3_model m) : m_context(c), m_model(m), m_graphs(<span class="keyword">nullptr</span>) { c.inc_ref(); }
<a name="l00788"></a>00788 
<a name="l00789"></a>00789         <span class="keywordtype">void</span> Reset();
<a name="l00790"></a>00790     <span class="keyword">protected</span>:
<a name="l00791"></a>00791         !<a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html" title="Z3 RawModel object.">RawModel</a>();
<a name="l00792"></a>00792     <span class="keyword">public</span>:
<a name="l00793"></a>00793         ~<a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html" title="Z3 RawModel object.">RawModel</a>();
<a name="l00794"></a>00794 
<a name="l00795"></a>00795 
<a name="l00799"></a>00799         array&lt;FuncDeclPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html#af0fb784251b4fffac765eae0407d357e" title="Return the constants assigned by the given model.">GetModelConstants</a>();
<a name="l00800"></a>00800            
<a name="l00807"></a>00807         Dictionary&lt;FuncDeclPtr, RawFunctionGraph^&gt;^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html#a396820d1169832b11b9fa7a7b33fea0c" title="Return the function interpretations in the given model.">GetFunctionGraphs</a>();
<a name="l00808"></a>00808 
<a name="l00831"></a>00831         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html#ab660c31d8c3b6fc624f86dbd6d171d10" title="Evaluate the AST node t in the given model.">Eval</a>(TermPtr);
<a name="l00832"></a>00832 
<a name="l00833"></a>00833         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html#ab660c31d8c3b6fc624f86dbd6d171d10" title="Evaluate the AST node t in the given model.">Eval</a>(FuncDeclPtr, array&lt;TermPtr&gt;^ args);
<a name="l00834"></a>00834 
<a name="l00835"></a>00835         
<a name="l00839"></a>00839         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html#a82cd22745e05b27b028a26c21423664e" title="Return decomposed sequence of stores as an array value.">TryGetArrayValue</a>(TermPtr a,[Out] <a class="code" href="class_microsoft_1_1_z3_1_1_raw_array_value.html" title="Z3 Array Value object.">RawArrayValue</a>^% av);
<a name="l00840"></a>00840 
<a name="l00844"></a>00844         <span class="keyword">virtual</span> String^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html#a08d99b52685eab1e9d5ac4d9223cb2be" title="Convert the given model into a string.">ToString</a>() <span class="keyword">override</span>;
<a name="l00845"></a>00845 
<a name="l00849"></a>00849         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_model.html#aaf8bef9b1d9ed1692886459d39821267" title="Display model to TextWriter.">Display</a>(System::IO::TextWriter^ w);
<a name="l00850"></a>00850 
<a name="l00851"></a>00851     };
<a name="l00852"></a>00852 
<a name="l00853"></a>00853     <span class="keyword">public ref class</span> ReferenceCounted {};
<a name="l00854"></a>00854 
<a name="l00855"></a>00855     <span class="keyword">public ref class</span> TermProofPtr {
<a name="l00856"></a>00856         TermPtr m_term;
<a name="l00857"></a>00857         TermPtr m_proof; <span class="comment">// proof is optional, use IntPtr::Zero for absence of proofs.</span>
<a name="l00858"></a>00858     <span class="keyword">public</span>:
<a name="l00859"></a>00859         TermProofPtr(TermPtr term, TermPtr proof): m_term(term), m_proof(proof) {}
<a name="l00860"></a>00860         <span class="keyword">property</span> TermPtr GetTerm { TermPtr <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_term; } }
<a name="l00861"></a>00861         <span class="keyword">property</span> TermPtr Proof { TermPtr <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_proof; } }
<a name="l00862"></a>00862     };
<a name="l00863"></a>00863 
<a name="l00864"></a>00864     <span class="keyword">ref class</span> RawTheory;
<a name="l00868"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html">00868</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a> : <span class="keyword">public</span> MarshalByRefObject
<a name="l00869"></a>00869     {        
<a name="l00870"></a>00870         ref_context* m_context;        
<a name="l00871"></a>00871         <span class="keywordtype">bool</span>         m_disposed;
<a name="l00872"></a>00872         <span class="keyword">static</span> List&lt;KeyValuePair&lt;AstPtr,RawContext^&gt; &gt;^  s_todec;
<a name="l00873"></a>00873         <span class="keyword">static</span> IntPtr^ s_monitor;
<a name="l00874"></a>00874         <span class="keyword">static</span> <span class="keywordtype">bool</span>    s_nonempty;
<a name="l00875"></a>00875 
<a name="l00876"></a>00876         <span class="keywordtype">void</span> Init();
<a name="l00877"></a>00877     <span class="keyword">internal</span>:
<a name="l00878"></a>00878         <span class="keyword">static</span> <a class="code" href="interface_microsoft_1_1_z3_1_1_i_error_handler.html" title="IErrorHandler is an abstract (interface) class for passing an error handler.">IErrorHandler</a>^ m_error_handler = <span class="keyword">nullptr</span>;
<a name="l00879"></a>00879 
<a name="l00880"></a>00880         Z3_context ctx() { <span class="keywordflow">return</span> (*m_context)(); }
<a name="l00881"></a>00881         ref_context&amp; ref_context() { <span class="keywordflow">return</span> *m_context; }
<a name="l00882"></a>00882 
<a name="l00890"></a>00890         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab8387be0b117e56351f808dbb8b0e808" title="Increment and decrement reference counters on terms, sorts and declarations.">IncRef</a>(AstPtr ast);
<a name="l00891"></a>00891 
<a name="l00892"></a>00892         <span class="keywordtype">void</span> EnqueueDecRef(AstPtr ast);
<a name="l00893"></a>00893 
<a name="l00894"></a>00894     <span class="keyword">protected</span>:
<a name="l00895"></a>00895 
<a name="l00896"></a>00896         !<a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>();
<a name="l00897"></a>00897     <span class="keyword">public</span>: 
<a name="l00909"></a>00909         <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_config.html" title="Configuration.">Config</a>^ config); 
<a name="l00910"></a>00910 
<a name="l00929"></a>00929         <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_config.html" title="Configuration.">Config</a>^ config, ReferenceCounted^ rc);
<a name="l00930"></a>00930 
<a name="l00931"></a>00931         <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>();
<a name="l00932"></a>00932 
<a name="l00933"></a>00933         <span class="keywordtype">void</span> SetContext(Z3_context ctx);
<a name="l00934"></a>00934 
<a name="l00935"></a>00935         <span class="keywordtype">void</span> Reset();
<a name="l00936"></a>00936 
<a name="l00937"></a>00937         ~<a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>();
<a name="l00938"></a>00938 
<a name="l00943"></a>00943         
<a name="l00949"></a>00949         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae767eef7c521b644401e58a4adfb11a6" title="Enable low-level debug tracing.">EnableDebugTrace</a>(String^ tag);
<a name="l00950"></a>00950 
<a name="l00957"></a>00957         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a74d274e8e6fc3ccc4ac39a375c0cc536" title="Enable or disable warning messages sent to the console out/error.">ToggleWarningMessages</a>(<span class="keywordtype">bool</span> enabled);
<a name="l00958"></a>00958 
<a name="l00973"></a>00973         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9e7467b18eba9cc3dc04495a7c51d1fa" title="Update a mutable configuration parameter.">UpdateParamValue</a>(String^ param_id, String^ value);
<a name="l00974"></a>00974 
<a name="l00981"></a>00981         String^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a23eedc7261b7af0d10d69bbb392d203d" title="Get a configuration parameter.">GetParamValue</a>(String^ param_id);
<a name="l00982"></a>00982 
<a name="l00987"></a>00987         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a925fd320cf1476d3b08d70f169c6790d" title="Configure the SMTLIB logic to be used in the given logical context.">SetLogic</a>(String^ logic);
<a name="l00988"></a>00988 
<a name="l01002"></a>01002         <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4e1f9e0325bac5897d7d4099eca72ed0" title="Create a Z3 symbol using an intege or a string.">MkSymbol</a>(<span class="keywordtype">int</span> i);
<a name="l01003"></a>01003 
<a name="l01004"></a>01004         <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4e1f9e0325bac5897d7d4099eca72ed0" title="Create a Z3 symbol using an intege or a string.">MkSymbol</a>(String^ s);
<a name="l01011"></a>01011         
<a name="l01017"></a>01017         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5111a4b70cadfbdb76491c889b57a312" title="Create a free (uninterpreted) type using the given name (symbol).">MkSort</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s);
<a name="l01018"></a>01018 
<a name="l01019"></a>01019         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5111a4b70cadfbdb76491c889b57a312" title="Create a free (uninterpreted) type using the given name (symbol).">MkSort</a>(String^ s); 
<a name="l01020"></a>01020 
<a name="l01021"></a>01021         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5111a4b70cadfbdb76491c889b57a312" title="Create a free (uninterpreted) type using the given name (symbol).">MkSort</a>(<span class="keywordtype">int</span> i);
<a name="l01022"></a>01022 
<a name="l01023"></a>01023 
<a name="l01029"></a>01029         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5a24352b12189b45134064790859850a" title="Create the boolean type.">MkBoolSort</a>();
<a name="l01030"></a>01030 
<a name="l01040"></a>01040         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>();
<a name="l01041"></a>01041 
<a name="l01048"></a>01048         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>();
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 
<a name="l01058"></a>01058         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#adf17186c4a5ece22ff7d95d1b6722e7d" title="Create a bit-vector type of the given size.">MkBvSort</a>(<span class="keywordtype">unsigned</span> sz);
<a name="l01059"></a>01059 
<a name="l01072"></a>01072         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a>(SortPtr domain, SortPtr range);
<a name="l01073"></a>01073 
<a name="l01081"></a>01081         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a73705995afcb9e00c07338fbfc9b4b49" title="Create a named finite domain sort.">MkFiniteDomainSort</a>(String^ name, <span class="keywordtype">unsigned</span> __int64 domain_size);
<a name="l01082"></a>01082 
<a name="l01083"></a>01083 
<a name="l01098"></a>01098         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#af75bb103fc493958385de9c849482df9" title="Create a tuple type.">MkTupleSort</a>(
<a name="l01099"></a>01099             <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^               mk_tuple_name, 
<a name="l01100"></a>01100             array&lt;Symbol^&gt;^       field_names,
<a name="l01101"></a>01101             array&lt;SortPtr&gt;^       field_types,
<a name="l01102"></a>01102             [Out] FuncDeclPtr%         mk_tuple_decl,
<a name="l01103"></a>01103             [In] [Out] array&lt;FuncDeclPtr&gt;^  proj_decl
<a name="l01104"></a>01104             );
<a name="l01105"></a>01105 
<a name="l01106"></a>01106         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#af75bb103fc493958385de9c849482df9" title="Create a tuple type.">MkTupleSort</a>(
<a name="l01107"></a>01107             String^               mk_tuple_name, 
<a name="l01108"></a>01108             array&lt;String^&gt;^       field_names,
<a name="l01109"></a>01109             array&lt;SortPtr&gt;^       field_types,
<a name="l01110"></a>01110             [Out] FuncDeclPtr%         mk_tuple_decl,
<a name="l01111"></a>01111             [In, Out] array&lt;FuncDeclPtr&gt;^  proj_decl
<a name="l01112"></a>01112             );
<a name="l01113"></a>01113 
<a name="l01123"></a>01123         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a72b2b9b3967c4638276bdccbdb0c9471" title="create an enumeration type.">MkEnumerationSort</a>(
<a name="l01124"></a>01124             String^             name,
<a name="l01125"></a>01125             array&lt;String^&gt;^     enum_names,
<a name="l01126"></a>01126             array&lt;FuncDeclPtr&gt;^ enum_consts,
<a name="l01127"></a>01127             array&lt;FuncDeclPtr&gt;^ enum_testers);
<a name="l01128"></a>01128 
<a name="l01142"></a>01142         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4d98cdbaeab75d52989ffbd655312dc6" title="create list sort.">MkListSort</a>(
<a name="l01143"></a>01143             String^ name,
<a name="l01144"></a>01144             SortPtr elem_sort,
<a name="l01145"></a>01145             [Out] FuncDeclPtr% nil_decl,
<a name="l01146"></a>01146             [Out] FuncDeclPtr% is_nil_decl,
<a name="l01147"></a>01147             [Out] FuncDeclPtr% cons_decl,
<a name="l01148"></a>01148             [Out] FuncDeclPtr% is_cons_decl,
<a name="l01149"></a>01149             [Out] FuncDeclPtr% head_decl,
<a name="l01150"></a>01150             [Out] FuncDeclPtr% tail_decl
<a name="l01151"></a>01151             );
<a name="l01152"></a>01152         
<a name="l01153"></a>01153 
<a name="l01170"></a>01170         <a class="code" href="class_microsoft_1_1_z3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a30d1032d60ebd18e9d99d5c4191ab7b8" title="create constructor object for datatype declarations. The object must be disposed...">MkConstructor</a>(
<a name="l01171"></a>01171             String^ name,
<a name="l01172"></a>01172             String^ tester,
<a name="l01173"></a>01173             array&lt;String^&gt;^ field_names,
<a name="l01174"></a>01174             array&lt;SortPtr&gt;^ field_sorts,
<a name="l01175"></a>01175             array&lt;unsigned&gt;^ field_refs
<a name="l01176"></a>01176             );
<a name="l01177"></a>01177 
<a name="l01181"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad778d157f274c72a2e88b806b41df89c">01181</a>         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad778d157f274c72a2e88b806b41df89c" title="retrieve constructor function declaration.">GetConstructor</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>^ c) { <span class="keywordflow">return</span> c-&gt;GetConstructor(); }
<a name="l01182"></a>01182 
<a name="l01186"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a97a7320cd3d9a7d77f52bf789f5c8839">01186</a>         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a97a7320cd3d9a7d77f52bf789f5c8839" title="retrieve test function for constructor.">GetTester</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>^ c) { <span class="keywordflow">return</span> c-&gt;GetTester(); }
<a name="l01187"></a>01187 
<a name="l01191"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab3ed56054afb442b0c26b073104c330e">01191</a>         array&lt;FuncDeclPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab3ed56054afb442b0c26b073104c330e" title="retrieve accessors for datatype.">GetAccessors</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_constructor.html" title="Container for constructor declarations.">Constructor</a>^ c) { <span class="keywordflow">return</span> c-&gt;GetAccessors(); }
<a name="l01192"></a>01192 
<a name="l01196"></a>01196         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#adb386d1976b2c6587844fe995444c46f" title="create datatype sort.">MkDataType</a>(
<a name="l01197"></a>01197             String^ name,
<a name="l01198"></a>01198             array&lt;Constructor^&gt;^ constructors
<a name="l01199"></a>01199             );
<a name="l01200"></a>01200 
<a name="l01201"></a>01201         
<a name="l01208"></a>01208         array&lt;SortPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa44dbeb0d3495a206820ffa9ce249a0a" title="create datatype sorts.">MkDataTypes</a>(
<a name="l01209"></a>01209             array&lt;String^&gt;^ names,
<a name="l01210"></a>01210             array&lt;array&lt;Constructor^&gt;^&gt;^ constructors
<a name="l01211"></a>01211             );
<a name="l01212"></a>01212 
<a name="l01220"></a>01220 
<a name="l01235"></a>01235         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l01236"></a>01236 
<a name="l01237"></a>01237         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(String^ s, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l01238"></a>01238 
<a name="l01239"></a>01239         FuncDeclPtr MkConstDecl(<a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s, SortPtr ty) {
<a name="l01240"></a>01240             <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(s, <span class="keyword">gcnew</span> array&lt;SortPtr&gt;(0), ty);
<a name="l01241"></a>01241         }
<a name="l01242"></a>01242         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(Symbol^ s, SortPtr domain, SortPtr range);
<a name="l01243"></a>01243 
<a name="l01244"></a>01244         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(Symbol^ s, SortPtr d1, SortPtr d2, SortPtr range);
<a name="l01245"></a>01245 
<a name="l01246"></a>01246         FuncDeclPtr MkConstDecl(String^ s, SortPtr ty) {
<a name="l01247"></a>01247             <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(s, <span class="keyword">gcnew</span> array&lt;SortPtr&gt;(0), ty);
<a name="l01248"></a>01248         }
<a name="l01249"></a>01249         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(String^ s, SortPtr domain, SortPtr range);
<a name="l01250"></a>01250 
<a name="l01251"></a>01251         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a>(String^ s, SortPtr d1, SortPtr d2, SortPtr range);
<a name="l01252"></a>01252 
<a name="l01253"></a>01253     
<a name="l01259"></a>01259         AppPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a>(FuncDeclPtr d, array&lt;TermPtr&gt;^ args);
<a name="l01260"></a>01260         AppPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a>(FuncDeclPtr d, TermPtr arg);
<a name="l01261"></a>01261         AppPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a>(FuncDeclPtr d, TermPtr arg1, TermPtr arg2);
<a name="l01262"></a>01262         AppPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a>(FuncDeclPtr d, TermPtr arg1, TermPtr arg2, TermPtr arg3);
<a name="l01263"></a>01263 
<a name="l01270"></a>01270         AppPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4119e0d04b9b4b8e95969e261b06aab7" title="Declare and create a constant.">MkConst</a>(FuncDeclPtr d);
<a name="l01271"></a>01271         AppPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4119e0d04b9b4b8e95969e261b06aab7" title="Declare and create a constant.">MkConst</a>(String^ s, SortPtr ty);
<a name="l01272"></a>01272         AppPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4119e0d04b9b4b8e95969e261b06aab7" title="Declare and create a constant.">MkConst</a>(Symbol^ s, SortPtr ty);
<a name="l01273"></a>01273 
<a name="l01274"></a>01274 
<a name="l01282"></a>01282         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5251d6fc152aea96eac0e9e702dad707" title="Declare a fresh constant or function.">MkFreshFuncDecl</a>(String^ prefix, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l01283"></a>01283     
<a name="l01290"></a>01290         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aabc8469e3803c5413a1a69c7cd001672" title="Declare and create a fresh constant.">MkFreshConst</a>(String^ prefix, SortPtr ty);
<a name="l01291"></a>01291 
<a name="l01296"></a>01296         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aebcce24f39e8ce68930346c48ac5a57f" title="Create labeled formula.">MkLabel</a>(Symbol^ name, <span class="keywordtype">bool</span> pos, TermPtr fml);
<a name="l01297"></a>01297     
<a name="l01301"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab462a1d684499a2265ee02801dfcb4f4">01301</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab462a1d684499a2265ee02801dfcb4f4" title="Create an AST node representing true.">MkTrue</a>() { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gae898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(ctx())); }
<a name="l01302"></a>01302 
<a name="l01303"></a>01303 
<a name="l01307"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4c138a08931900ebb7396484a6294cff">01307</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4c138a08931900ebb7396484a6294cff" title="Create an AST node representing false.">MkFalse</a>() { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(ctx())); }
<a name="l01308"></a>01308 
<a name="l01309"></a>01309     
<a name="l01315"></a>01315         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab5b455baaffd7f2bf2a9508f801819de" title="Create an AST node representing l = r.">MkEq</a>(TermPtr l, TermPtr r);
<a name="l01316"></a>01316 
<a name="l01317"></a>01317 
<a name="l01328"></a>01328         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a89bdd6aba66dab2a90592cea3263eb74" title="Create an AST node representing distinct(args[0], ..., args[args.Length-1]).">MkDistinct</a>(array&lt;TermPtr&gt;^ args);
<a name="l01329"></a>01329 
<a name="l01330"></a>01330 
<a name="l01336"></a>01336         <span class="keyword">virtual</span> TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#afc672bf3d4167000f8511454ef05a83d" title="Create an AST node representing not(a).">MkNot</a>(TermPtr arg);
<a name="l01337"></a>01337     
<a name="l01345"></a>01345         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4c1882945cd1a8462070e5d92e7a6b93" title="Create an AST node representing an if-then-else: ite(t1, t2, t3).">MkIte</a>(TermPtr t1, TermPtr t2, TermPtr t3);
<a name="l01346"></a>01346 
<a name="l01352"></a>01352         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#af0019c9b938cbfc228d538500e25ab1f" title="Create an AST node representing t1 iff t2.">MkIff</a>(TermPtr t1, TermPtr t2);
<a name="l01353"></a>01353 
<a name="l01359"></a>01359         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#afcbf82213943aa0a30efb51dbf81b7dd" title="Create an AST node representing t1 implies t2.">MkImplies</a>(TermPtr t1, TermPtr t2);
<a name="l01360"></a>01360     
<a name="l01366"></a>01366         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a80631b59bd60e34b88cdc676274334b0" title="Create an AST node representing t1 xor t2.">MkXor</a>(TermPtr t1, TermPtr t2);
<a name="l01367"></a>01367     
<a name="l01375"></a>01375         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8793a422c6c2d7b34000cc0032a4cdc4" title="Create an AST node representing args[0] and ... and args[args.Length-1].">MkAnd</a>(array&lt;TermPtr&gt;^ args);
<a name="l01376"></a>01376         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8793a422c6c2d7b34000cc0032a4cdc4" title="Create an AST node representing args[0] and ... and args[args.Length-1].">MkAnd</a>(TermPtr arg1, TermPtr arg2);
<a name="l01377"></a>01377     
<a name="l01385"></a>01385         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a72a8f73bed309b8924dd49eba903bb24" title="Create an AST node representing args[0] or ... or args[args.Length-1].">MkOr</a>(array&lt;TermPtr&gt;^ args);
<a name="l01386"></a>01386         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a72a8f73bed309b8924dd49eba903bb24" title="Create an AST node representing args[0] or ... or args[args.Length-1].">MkOr</a>(TermPtr arg1, TermPtr arg2);
<a name="l01387"></a>01387 
<a name="l01395"></a>01395         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5668c488c12e405f662807b4f47860da" title="Create an AST node representing args[0] + ... + args[args.Length-1].">MkAdd</a>(array&lt;TermPtr&gt;^ args);
<a name="l01396"></a>01396         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5668c488c12e405f662807b4f47860da" title="Create an AST node representing args[0] + ... + args[args.Length-1].">MkAdd</a>(TermPtr arg1, TermPtr arg2);
<a name="l01397"></a>01397 
<a name="l01406"></a>01406         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa20eacf8d7fa0e446c1081e5ff01de77" title="Create an AST node representing args[0] * ... * args[args.Length-1].">MkMul</a>(array&lt;TermPtr&gt;^ args);
<a name="l01407"></a>01407         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa20eacf8d7fa0e446c1081e5ff01de77" title="Create an AST node representing args[0] * ... * args[args.Length-1].">MkMul</a>(TermPtr arg1, TermPtr arg2);
<a name="l01408"></a>01408     
<a name="l01416"></a>01416         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a01178a7c619ac2bd6c2e4d4f3da743d2" title="Create an AST node representing args[0] - ... - args[args.Length - 1].">MkSub</a>(array&lt;TermPtr&gt;^ args);
<a name="l01417"></a>01417         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a01178a7c619ac2bd6c2e4d4f3da743d2" title="Create an AST node representing args[0] - ... - args[args.Length - 1].">MkSub</a>(TermPtr arg1, TermPtr arg2);
<a name="l01418"></a>01418 
<a name="l01424"></a>01424         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4314bcfc4435b1f79028bc11b8774c28" title="Create an AST node representing - arg.">MkUnaryMinus</a>(TermPtr arg);
<a name="l01425"></a>01425 
<a name="l01431"></a>01431         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae7f8e2e8eb754c5a87fa3faa51ff8baf" title="Create integer or real division.">MkDiv</a>(TermPtr arg1, TermPtr arg2);
<a name="l01432"></a>01432 
<a name="l01438"></a>01438         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5a9f33467a473c739edac3721e0d56ea" title="Create integer modulus.">MkMod</a>(TermPtr arg1, TermPtr arg2);
<a name="l01439"></a>01439 
<a name="l01445"></a>01445         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5e8abfb87c0e9eb2be93a85af185038e" title="Create integer remainder.">MkRem</a>(TermPtr arg1, TermPtr arg2);
<a name="l01446"></a>01446 
<a name="l01452"></a>01452         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aecac3390e05c8743587c5bed03338b84" title="Create coercion from integer to real.">MkToReal</a>(TermPtr arg);
<a name="l01453"></a>01453 
<a name="l01459"></a>01459         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a89955af727ba82dbb38b734befd37cdc" title="Create coercion from real to integer (floor).">MkToInt</a>(TermPtr arg);
<a name="l01460"></a>01460 
<a name="l01466"></a>01466         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a71f742709784da4b25d39a72d4cd3b69" title="Check if real is an integer value.">MkIsInt</a>(TermPtr arg);
<a name="l01467"></a>01467 
<a name="l01468"></a>01468 
<a name="l01469"></a>01469 
<a name="l01475"></a>01475         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa817a455803ab79b220b0182b48e2ae5" title="Create less than.">MkLt</a>(TermPtr arg1, TermPtr arg2);
<a name="l01476"></a>01476 
<a name="l01482"></a>01482         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa4993b3a46531ed7c4924d64185344d2" title="Create less than or equal to.">MkLe</a>(TermPtr arg1, TermPtr arg2);
<a name="l01483"></a>01483 
<a name="l01489"></a>01489         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5935871bfbeda8fcd6bc467d8d49afc2" title="Create greater than.">MkGt</a>(TermPtr arg1, TermPtr arg2);
<a name="l01490"></a>01490 
<a name="l01496"></a>01496         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a7a08b71116843992a1078d9df3889f09" title="Create greater than or equal to.">MkGe</a>(TermPtr arg1, TermPtr arg2);
<a name="l01497"></a>01497 
<a name="l01503"></a>01503         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a45b8b6397e45ac3fc6b38e873eed9d33" title="Bitwise negation.">MkBvNot</a>(TermPtr t1);
<a name="l01504"></a>01504 
<a name="l01510"></a>01510         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4487dd1d501cb49fa5f4d046e28ae650" title="Take conjunction of bits in vector.">MkBvReduceAnd</a>(TermPtr t1);
<a name="l01511"></a>01511 
<a name="l01517"></a>01517         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab00941985b6e6675b2304831aa4845c0" title="Take disjunction of bits in vector.">MkBvReduceOr</a>(TermPtr t1);
<a name="l01518"></a>01518 
<a name="l01524"></a>01524         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aadd6a00031fb92a88ca6c177d4d75509" title="Bitwise and.">MkBvAnd</a>(TermPtr t1, TermPtr t2);
<a name="l01525"></a>01525 
<a name="l01531"></a>01531         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a472170308fc0ce228ad1ee1b683811cd" title="Bitwise or.">MkBvOr</a>(TermPtr t1, TermPtr t2);
<a name="l01532"></a>01532 
<a name="l01538"></a>01538         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a684ce5c64067b6d5d4cddfbfe32789b4" title="Bitwise exclusive-or.">MkBvXor</a>(TermPtr t1, TermPtr t2);
<a name="l01539"></a>01539 
<a name="l01545"></a>01545         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a5d58dfc570dde7e49faab8ed4dcfbfc7" title="Bitwise nand.">MkBvNand</a>(TermPtr t1, TermPtr t2);
<a name="l01546"></a>01546 
<a name="l01552"></a>01552         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa486a9f49b3fc395f37b56f0975a243b" title="Bitwise nor.">MkBvNor</a>(TermPtr t1, TermPtr t2);
<a name="l01553"></a>01553 
<a name="l01559"></a>01559         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0112b7f61d18dcd15369566cdcf4b05f" title="Bitwise xnor.">MkBvXnor</a>(TermPtr t1, TermPtr t2);
<a name="l01560"></a>01560 
<a name="l01566"></a>01566         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae21724e2d70e5aec94cfa59726565063" title="Standard two&amp;#39;s complement unary minus.">MkBvNeg</a>(TermPtr t1);
<a name="l01567"></a>01567     
<a name="l01573"></a>01573         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a30237a1d6603428640b6db89d5d157fa" title="Standard two&amp;#39;s complement addition.">MkBvAdd</a>(TermPtr t1, TermPtr t2);
<a name="l01574"></a>01574 
<a name="l01580"></a>01580         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea836bb8f5dcec3f401d77538e31e248" title="Standard two&amp;#39;s complement subtraction.">MkBvSub</a>(TermPtr t1, TermPtr t2);
<a name="l01581"></a>01581     
<a name="l01587"></a>01587         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae5585802bf0ff4f5188bfbe1fd361470" title="Standard two&amp;#39;s complement multiplication.">MkBvMul</a>(TermPtr t1, TermPtr t2);
<a name="l01588"></a>01588 
<a name="l01598"></a>01598         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a98ee5b832fa8f1a44998a2541bf4114c" title="Unsigned division.">MkBvUdiv</a>(TermPtr t1, TermPtr t2);
<a name="l01599"></a>01599 
<a name="l01613"></a>01613         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae96a3f936b75c53d7ab8eed094eb7b94" title="Two&amp;#39;s complement signed division.">MkBvSdiv</a>(TermPtr t1, TermPtr t2);
<a name="l01614"></a>01614 
<a name="l01624"></a>01624         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a30f13a71debd51968bc2129eaa26121d" title="Unsigned remainder.">MkBvUrem</a>(TermPtr t1, TermPtr t2);
<a name="l01625"></a>01625 
<a name="l01638"></a>01638         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a1db91c0489ac65927dc14613e0b2225b" title="Two&amp;#39;s complement signed remainder (sign follows dividend).">MkBvSrem</a>(TermPtr t1, TermPtr t2);
<a name="l01639"></a>01639 
<a name="l01649"></a>01649         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a094b16beaa982ef3500633b3482d2603" title="Two&amp;#39;s complement signed remainder (sign follows divisor).">MkBvSmod</a>(TermPtr t1, TermPtr t2);
<a name="l01650"></a>01650 
<a name="l01656"></a>01656         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a71e25df68e31503191875d9348c9f823" title="Unsigned less than.">MkBvUlt</a>(TermPtr t1, TermPtr t2);
<a name="l01657"></a>01657     
<a name="l01671"></a>01671         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8352294e2808ce534fc83ec39bca8fbd" title="Two&amp;#39;s complement signed less than.">MkBvSlt</a>(TermPtr t1, TermPtr t2);
<a name="l01672"></a>01672 
<a name="l01678"></a>01678         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa434742064f523ecf5a7e13a113df86b" title="Unsigned less than or equal to.">MkBvUle</a>(TermPtr t1, TermPtr t2);
<a name="l01679"></a>01679 
<a name="l01685"></a>01685         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac37363c17a7308be4ca999068da16fbb" title="Two&amp;#39;s complement signed less than or equal to.">MkBvSle</a>(TermPtr t1, TermPtr t2);
<a name="l01686"></a>01686 
<a name="l01692"></a>01692         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#acb5149b9f7b1d823cd93ed6f43db5a17" title="Unsigned greater than or equal to.">MkBvUge</a>(TermPtr t1, TermPtr t2);
<a name="l01693"></a>01693 
<a name="l01699"></a>01699         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a27a2d12f9e8d5639fa86b4d0997e2b17" title="Two&amp;#39;s complement signed greater than or equal to.">MkBvSge</a>(TermPtr t1, TermPtr t2);
<a name="l01700"></a>01700 
<a name="l01706"></a>01706         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#afcb8b1208ec0cc2c1579c29158b3815e" title="Unsigned greater than.">MkBvUgt</a>(TermPtr t1, TermPtr t2);
<a name="l01707"></a>01707 
<a name="l01713"></a>01713         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a013910a4fa70b37878520b4400b1c107" title="Two&amp;#39;s complement signed greater than.">MkBvSgt</a>(TermPtr t1, TermPtr t2);
<a name="l01714"></a>01714 
<a name="l01723"></a>01723         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#afaba9154d1be03ec6d738951e94d37cb" title="Concatenate the given bit-vectors.">MkBvConcat</a>(TermPtr t1, TermPtr t2);
<a name="l01724"></a>01724     
<a name="l01732"></a>01732         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac2c8940627f740c9ec3b637ef2031887" title="Extract the bits high down to low from a bitvector of size m to yield a new bitvector...">MkBvExtract</a>(<span class="keywordtype">unsigned</span> high, <span class="keywordtype">unsigned</span> low, TermPtr t);
<a name="l01733"></a>01733 
<a name="l01741"></a>01741         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#af94e12dbe34a66f358baebe8ef6848fc" title="Sign-extend of the given bit-vector to the (signed) equivalent bitvector of size...">MkBvSignExt</a>(<span class="keywordtype">unsigned</span> i, TermPtr t);
<a name="l01742"></a>01742 
<a name="l01750"></a>01750         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#add245de4256b820ef7d66ce58fd43385" title="Extend the given bit-vector with zeros to the (unsigned) equivalent bitvector of...">MkBvZeroExt</a>(<span class="keywordtype">unsigned</span> i, TermPtr t);
<a name="l01751"></a>01751 
<a name="l01757"></a>01757         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#afa18939e43ef603b1bdfac2cdbefd4f0" title="Repeat the bit-vector i times.">MkBvRepeat</a>(<span class="keywordtype">unsigned</span> i, TermPtr t);
<a name="l01758"></a>01758 
<a name="l01767"></a>01767         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a484c128e627a79c8af7fcbb531b0ba39" title="Shift left.">MkBvShl</a>(TermPtr t1, TermPtr t2);
<a name="l01768"></a>01768 
<a name="l01777"></a>01777         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2de5b050301845c2fa902a8a910db8ed" title="Logical shift right.">MkBvLshr</a>(TermPtr t1, TermPtr t2);
<a name="l01778"></a>01778 
<a name="l01788"></a>01788         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4e8836887c24503234e99a94dd31a660" title="Arithmetic shift right.">MkBvAshr</a>(TermPtr t1, TermPtr t2);
<a name="l01789"></a>01789     
<a name="l01795"></a>01795         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#adecfc831ae6c9135828e3095b27a4956" title="Rotate bits of t1 to the left i times.">MkBvRotateLeft</a>(<span class="keywordtype">unsigned</span> i, TermPtr t1);
<a name="l01796"></a>01796     
<a name="l01802"></a>01802         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3df09da772a462d74c9f08546a44562b" title="Rotate bits of t1 to the right i times.">MkBvRotateRight</a>(<span class="keywordtype">unsigned</span> i, TermPtr t1);
<a name="l01803"></a>01803 
<a name="l01809"></a>01809         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#adecfc831ae6c9135828e3095b27a4956" title="Rotate bits of t1 to the left i times.">MkBvRotateLeft</a>(TermPtr t1, TermPtr t2);
<a name="l01810"></a>01810     
<a name="l01816"></a>01816         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3df09da772a462d74c9f08546a44562b" title="Rotate bits of t1 to the right i times.">MkBvRotateRight</a>(TermPtr t1, TermPtr t2);
<a name="l01817"></a>01817 
<a name="l01823"></a>01823         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a711b2b4ca79395d1d56820b7b3f9b3cc" title="Convert bit vector to integer.">MkBv2Int</a>(TermPtr t1, <span class="keywordtype">bool</span> is_signed);
<a name="l01824"></a>01824 
<a name="l01830"></a>01830         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a43be2bceee8a6d4a870733196a149612" title="Convert integer to bit vector.">MkInt2Bv</a>(<span class="keywordtype">unsigned</span> size, TermPtr t1);
<a name="l01831"></a>01831 
<a name="l01837"></a>01837         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a202fffba746c16499d216354e97ac74b" title="Check that addition does not overflow.">MkBvAddNoOverflow</a>(TermPtr t1, TermPtr t2, <span class="keywordtype">bool</span> is_signed);
<a name="l01838"></a>01838 
<a name="l01844"></a>01844         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a421fc4943889a1c10d2dddbdaac5d09d" title="Check that addition does not underflow.">MkBvAddNoUnderflow</a>(TermPtr t1, TermPtr t2);
<a name="l01845"></a>01845 
<a name="l01851"></a>01851         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a44065d4fa565d6efa0f351f266c61c58" title="Check that subtraction does not overflow.">MkBvSubNoOverflow</a>(TermPtr t1, TermPtr t2);
<a name="l01852"></a>01852 
<a name="l01858"></a>01858         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3386aa55309ead169a54aeeed1cef0d6" title="Check that subtraction does not underflow.">MkBvSubNoUnderflow</a>(TermPtr t1, TermPtr t2, <span class="keywordtype">bool</span> is_signed);
<a name="l01859"></a>01859 
<a name="l01865"></a>01865         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac537f6c8529718162b4a16a926f145f8" title="Check that division does not overflow.">MkBvSDivNoOverflow</a>(TermPtr t1, TermPtr t2);
<a name="l01866"></a>01866 
<a name="l01870"></a>01870         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a7dcdbe9ddac5ccf9744174f4a20aac19" title="Check that negation does not overflow.">MkBvNegNoOverflow</a>(TermPtr t1);
<a name="l01871"></a>01871 
<a name="l01877"></a>01877         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a688f2a2cb04cb30f68dca62c6477f14b" title="Check that multiplication does not overflow.">MkBvMulNoOverflow</a>(TermPtr t1, TermPtr t2, <span class="keywordtype">bool</span> is_signed);
<a name="l01878"></a>01878 
<a name="l01884"></a>01884         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a036fccd286efdc90134941defd6a1df8" title="Check that multiplication does not underflow.">MkBvMulNoUnderflow</a>(TermPtr t1, TermPtr t2);
<a name="l01885"></a>01885 
<a name="l01895"></a>01895         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#af0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a>(TermPtr a, TermPtr i);
<a name="l01896"></a>01896     
<a name="l01906"></a>01906         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aaed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a>(TermPtr a, TermPtr i, TermPtr v);
<a name="l01907"></a>01907 
<a name="l01919"></a>01919         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3fcbf7757a9ffdb56c4bdd145c145246" title="Array map.">MkArrayMap</a>(FuncDeclPtr d, array&lt;TermPtr&gt;^ args);
<a name="l01920"></a>01920 
<a name="l01932"></a>01932         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab5341894979c077ef1ad93ef67691c2a" title="Constant array.">MkArrayConst</a>(SortPtr domain, TermPtr v);
<a name="l01933"></a>01933 
<a name="l01948"></a>01948         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac645da9e615bc4e20515ef3cd8f74893" title="Access the array default.">MkArrayDefault</a>(TermPtr a);
<a name="l01949"></a>01949 
<a name="l01957"></a>01957 
<a name="l01961"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4fd038edb773b86952a3f4890d6bb0f5">01961</a>         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4fd038edb773b86952a3f4890d6bb0f5" title="Create Set type.">MkSetSort</a>(SortPtr ty) { <span class="keywordflow">return</span> SortPtr(<a class="code" href="group__capi.html#ga6865879523e7e882d7e50a2d8445ac8b" title="Create Set type.">Z3_mk_set_sort</a>(ctx(), get_sort(ty))); }
<a name="l01962"></a>01962 
<a name="l01966"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae3a1a555a0fce2e8c1dfdfb863b56216">01966</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae3a1a555a0fce2e8c1dfdfb863b56216" title="Create the empty set.">MkEmptySet</a>(SortPtr ty) { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga358b6b80509a567148f1c0ca9252118c" title="Create the empty set.">Z3_mk_empty_set</a>(ctx(), get_sort(ty))); }
<a name="l01967"></a>01967 
<a name="l01971"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a71d300776d9303680e79f784a2644e4c">01971</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a71d300776d9303680e79f784a2644e4c" title="Create the full set.">MkFullSet</a>(SortPtr ty) { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga5e92662c657374f7332aa32ce4503dd2" title="Create the full set.">Z3_mk_full_set</a>(ctx(), get_sort(ty))); }
<a name="l01972"></a>01972 
<a name="l01978"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a443543c80f0ace5c902df3589d3154c4">01978</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a443543c80f0ace5c902df3589d3154c4" title="Add an element to a set.">MkSetAdd</a>(TermPtr <span class="keyword">set</span>, TermPtr elem) {
<a name="l01979"></a>01979             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga856c3d0e28ce720f53912c2bbdd76175" title="Add an element to a set.">Z3_mk_set_add</a>(ctx(), get_ast(<span class="keyword">set</span>), get_ast(elem)));
<a name="l01980"></a>01980         }
<a name="l01981"></a>01981 
<a name="l01987"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a99a686c0e68a6862f47f066eac39f84e">01987</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a99a686c0e68a6862f47f066eac39f84e" title="Remove an element to a set.">MkSetDel</a>(TermPtr <span class="keyword">set</span>, TermPtr elem) {
<a name="l01988"></a>01988             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga80e883f39dd3b88f9d0745c8a5b91d1d" title="Remove an element to a set.">Z3_mk_set_del</a>(ctx(), get_ast(<span class="keyword">set</span>), get_ast(elem)));
<a name="l01989"></a>01989         }
<a name="l01990"></a>01990 
<a name="l01996"></a>01996         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a72da2154689afc36a91ba955e9ccf081" title="Take the union of a arrays of sets.">MkSetUnion</a>(array&lt;TermPtr&gt;^ sets);
<a name="l01997"></a>01997         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a72da2154689afc36a91ba955e9ccf081" title="Take the union of a arrays of sets.">MkSetUnion</a>(TermPtr set1, TermPtr set2);
<a name="l01998"></a>01998 
<a name="l02002"></a>02002         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a1bb3e567ae8090d8a659ad556c083e32" title="Take the intersection of a arrays of sets.">MkSetIntersect</a>(array&lt;TermPtr&gt;^ sets);
<a name="l02003"></a>02003         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a1bb3e567ae8090d8a659ad556c083e32" title="Take the intersection of a arrays of sets.">MkSetIntersect</a>(TermPtr set1, TermPtr set2);
<a name="l02004"></a>02004 
<a name="l02008"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad51d6429450362ce9dc9f476b86d22e1">02008</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad51d6429450362ce9dc9f476b86d22e1" title="Take the set difference between two sets.">MkSetDifference</a>(TermPtr arg1, TermPtr arg2) {
<a name="l02009"></a>02009             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gabb49c62f70b8198362e1a29ba6d8bde1" title="Take the set difference between two sets.">Z3_mk_set_difference</a>(ctx(), get_ast(arg1), get_ast(arg2)));
<a name="l02010"></a>02010         }
<a name="l02014"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae33216f5018efff4077640204c219dc2">02014</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae33216f5018efff4077640204c219dc2" title="Take the complement of a set.">MkSetComplement</a>(TermPtr arg) {
<a name="l02015"></a>02015             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga5c57143c9229cdf730c5103ff696590f" title="Take the complement of a set.">Z3_mk_set_complement</a>(ctx(), get_ast(arg)));
<a name="l02016"></a>02016         }
<a name="l02017"></a>02017 
<a name="l02023"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8449281ead0996eccbe5867d3b6ca96c">02023</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8449281ead0996eccbe5867d3b6ca96c" title="Check for set membership.">MkSetMember</a>(TermPtr elem, TermPtr <span class="keyword">set</span>) {
<a name="l02024"></a>02024             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gac6e516f3dce0bdd41095c6d6daf56063" title="Check for set membership.">Z3_mk_set_member</a>(ctx(), get_ast(elem), get_ast(<span class="keyword">set</span>)));
<a name="l02025"></a>02025         }
<a name="l02026"></a>02026 
<a name="l02030"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac05b3fbb60eecb46617782cd53e2b293">02030</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac05b3fbb60eecb46617782cd53e2b293" title="Check for subsetness of sets.">MkSetSubset</a>(TermPtr arg1, TermPtr arg2) {
<a name="l02031"></a>02031             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga139c5803af0e86464adc7cedc53e7f3a" title="Check for subsetness of sets.">Z3_mk_set_subset</a>(ctx(), get_ast(arg1), get_ast(arg2)));
<a name="l02032"></a>02032         }
<a name="l02040"></a>02040 
<a name="l02045"></a>02045         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a1c4f013234b21f0c4599f3c44fb778fb" title="Create injective function.">MkInjectiveFunction</a>(String^ name, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l02046"></a>02046 
<a name="l02047"></a>02047         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a1c4f013234b21f0c4599f3c44fb778fb" title="Create injective function.">MkInjectiveFunction</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ name, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l02048"></a>02048 
<a name="l02057"></a>02057         
<a name="l02066"></a>02066         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(String^ numeral, SortPtr ty);
<a name="l02067"></a>02067         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(<span class="keywordtype">int</span> n, SortPtr ty);
<a name="l02068"></a>02068         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(<span class="keywordtype">unsigned</span> n, SortPtr ty);
<a name="l02069"></a>02069         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(__int64 n, SortPtr ty);
<a name="l02070"></a>02070         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(<span class="keywordtype">unsigned</span> __int64 n, SortPtr ty);
<a name="l02071"></a>02071 
<a name="l02075"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3">02075</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3" title="Create a numeral of type Int.">MkIntNumeral</a>(String^ n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>()); }
<a name="l02076"></a>02076         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3" title="Create a numeral of type Int.">MkIntNumeral</a>(<span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>()); }
<a name="l02077"></a>02077         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3" title="Create a numeral of type Int.">MkIntNumeral</a>(<span class="keywordtype">unsigned</span> n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>()); }
<a name="l02078"></a>02078         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3" title="Create a numeral of type Int.">MkIntNumeral</a>(__int64 n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>()); }
<a name="l02079"></a>02079         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a48ef6618f933a3cf309e8462e48cf4e3" title="Create a numeral of type Int.">MkIntNumeral</a>(<span class="keywordtype">unsigned</span> __int64 n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a04bf543bb7b59788f7b7d40d4738648b" title="Create an integer type.">MkIntSort</a>()); }
<a name="l02080"></a>02080 
<a name="l02081"></a>02081 
<a name="l02085"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40">02085</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40" title="Create a numeral of type Real.">MkRealNumeral</a>(String^ n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>()); }
<a name="l02086"></a>02086         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40" title="Create a numeral of type Real.">MkRealNumeral</a>(<span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>()); }
<a name="l02087"></a>02087         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40" title="Create a numeral of type Real.">MkRealNumeral</a>(<span class="keywordtype">unsigned</span> n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>()); }
<a name="l02088"></a>02088         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40" title="Create a numeral of type Real.">MkRealNumeral</a>(__int64 n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>()); }
<a name="l02089"></a>02089         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac6bbb2be135e462bf68e86d53e07eb40" title="Create a numeral of type Real.">MkRealNumeral</a>(<span class="keywordtype">unsigned</span> __int64 n) { <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad04ee26dbb08422102bdc1189e293196" title="Create a numeral of a given type.">MkNumeral</a>(n, <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9fc32a94ce1e1064c04f7fe4e1678e81" title="Create a real type.">MkRealSort</a>()); }
<a name="l02090"></a>02090 
<a name="l02097"></a>02097         
<a name="l02156"></a>02156         PatternPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a>(array&lt;TermPtr&gt;^ terms);
<a name="l02157"></a>02157 
<a name="l02184"></a>02184         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a2e1ef04d234928c64248ce7eaf73502a" title="Create a bound variable.">MkBound</a>(<span class="keywordtype">unsigned</span> index, SortPtr ty);
<a name="l02185"></a>02185     
<a name="l02200"></a>02200         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a>(
<a name="l02201"></a>02201             <span class="keywordtype">unsigned</span> weight,
<a name="l02202"></a>02202             array&lt;PatternPtr&gt;^ patterns,
<a name="l02203"></a>02203             array&lt;SortPtr&gt;^ types,
<a name="l02204"></a>02204             array&lt;Symbol^&gt;^ names,
<a name="l02205"></a>02205             TermPtr body
<a name="l02206"></a>02206             );
<a name="l02207"></a>02207 
<a name="l02222"></a>02222         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a>(
<a name="l02223"></a>02223             <span class="keywordtype">unsigned</span> weight,
<a name="l02224"></a>02224             array&lt;PatternPtr&gt;^ patterns,
<a name="l02225"></a>02225             array&lt;SortPtr&gt;^ types,
<a name="l02226"></a>02226             array&lt;String^&gt;^ names,
<a name="l02227"></a>02227             TermPtr body
<a name="l02228"></a>02228             );
<a name="l02229"></a>02229 
<a name="l02249"></a>02249         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a>(
<a name="l02250"></a>02250             <span class="keywordtype">unsigned</span>           weight,
<a name="l02251"></a>02251             array&lt;AppPtr&gt;^   bound,
<a name="l02252"></a>02252             array&lt;PatternPtr&gt;^ patterns,
<a name="l02253"></a>02253             TermPtr body
<a name="l02254"></a>02254             );
<a name="l02255"></a>02255 
<a name="l02263"></a>02263         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a>(
<a name="l02264"></a>02264             <span class="keywordtype">unsigned</span> weight,
<a name="l02265"></a>02265             array&lt;PatternPtr&gt;^ patterns,
<a name="l02266"></a>02266             array&lt;SortPtr&gt;^ types,
<a name="l02267"></a>02267             array&lt;Symbol^&gt;^ names,
<a name="l02268"></a>02268             TermPtr body
<a name="l02269"></a>02269             );
<a name="l02270"></a>02270 
<a name="l02271"></a>02271         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a>(
<a name="l02272"></a>02272             <span class="keywordtype">unsigned</span> weight,
<a name="l02273"></a>02273             array&lt;PatternPtr&gt;^ patterns,
<a name="l02274"></a>02274             array&lt;SortPtr&gt;^ types,
<a name="l02275"></a>02275             array&lt;String^&gt;^ names,
<a name="l02276"></a>02276             TermPtr body
<a name="l02277"></a>02277             );
<a name="l02278"></a>02278 
<a name="l02279"></a>02279         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a>(
<a name="l02280"></a>02280             <span class="keywordtype">unsigned</span>           weight,
<a name="l02281"></a>02281             array&lt;AppPtr&gt;^   bound,
<a name="l02282"></a>02282             array&lt;PatternPtr&gt;^ patterns,
<a name="l02283"></a>02283             TermPtr            body
<a name="l02284"></a>02284             );
<a name="l02285"></a>02285 
<a name="l02297"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c">02297</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c" title="Create a quantifier with no-pattern directives and symbols.">MkQuantifier</a>(
<a name="l02298"></a>02298             <span class="keywordtype">bool</span>                  is_forall,
<a name="l02299"></a>02299             <span class="keywordtype">unsigned</span>              weight,
<a name="l02300"></a>02300             array&lt;PatternPtr&gt;^    patterns,
<a name="l02301"></a>02301             array&lt;TermPtr&gt;^       no_patterns,
<a name="l02302"></a>02302             array&lt;SortPtr&gt;^       types,
<a name="l02303"></a>02303             array&lt;Symbol^&gt;^       names,
<a name="l02304"></a>02304             TermPtr               body
<a name="l02305"></a>02305             )
<a name="l02306"></a>02306         {
<a name="l02307"></a>02307             <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c" title="Create a quantifier with no-pattern directives and symbols.">MkQuantifier</a>(is_forall, weight, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, patterns, no_patterns, types, names, body);
<a name="l02308"></a>02308         }
<a name="l02309"></a>02309 
<a name="l02310"></a>02310 
<a name="l02311"></a>02311         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c" title="Create a quantifier with no-pattern directives and symbols.">MkQuantifier</a>(
<a name="l02312"></a>02312             <span class="keywordtype">bool</span>                  is_forall,
<a name="l02313"></a>02313             <span class="keywordtype">unsigned</span>              weight,
<a name="l02314"></a>02314             <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^               quantifier_id,
<a name="l02315"></a>02315             <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^               skolem_id,
<a name="l02316"></a>02316             array&lt;PatternPtr&gt;^    patterns,
<a name="l02317"></a>02317             array&lt;TermPtr&gt;^       no_patterns,
<a name="l02318"></a>02318             array&lt;SortPtr&gt;^       types,
<a name="l02319"></a>02319             array&lt;Symbol^&gt;^       names,
<a name="l02320"></a>02320             TermPtr                body
<a name="l02321"></a>02321             );
<a name="l02322"></a>02322 
<a name="l02323"></a>02323 
<a name="l02324"></a>02324 
<a name="l02336"></a>02336         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3f6fe0d5e63e2aec779538fef2669a3c" title="Create a quantifier with no-pattern directives and symbols.">MkQuantifier</a>(
<a name="l02337"></a>02337             <span class="keywordtype">bool</span>                  is_forall,
<a name="l02338"></a>02338             <span class="keywordtype">unsigned</span>              weight,
<a name="l02339"></a>02339             <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^               quantifier_id,
<a name="l02340"></a>02340             <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^               skolem_id,
<a name="l02341"></a>02341             array&lt;PatternPtr&gt;^    patterns,
<a name="l02342"></a>02342             array&lt;TermPtr&gt;^       no_patterns,
<a name="l02343"></a>02343             array&lt;TermPtr&gt;^       bound,
<a name="l02344"></a>02344             TermPtr               body
<a name="l02345"></a>02345             );
<a name="l02346"></a>02346 
<a name="l02347"></a>02347 
<a name="l02355"></a>02355 
<a name="l02360"></a>02360         <span class="keywordtype">unsigned</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae810fc8c305ae442e0a516c1cb9f78a8" title="Return a unique identifier for t.">GetTermId</a>(TermPtr t);
<a name="l02361"></a>02361 
<a name="l02365"></a>02365         <span class="keywordtype">unsigned</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a30fc9cb5ea8660841b6912251b5c7574" title="Return a unique identifier for f.">GetFuncDeclId</a>(FuncDeclPtr f);
<a name="l02366"></a>02366 
<a name="l02370"></a>02370         <span class="keywordtype">unsigned</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#acb7747c8b17c86b75c4102f6a5adfafd" title="Return a unique identifier for s.">GetSortId</a>(SortPtr s);
<a name="l02371"></a>02371         
<a name="l02372"></a>02372         
<a name="l02378"></a>02378         <a class="code" href="group__mapi.html#ga05812818de02fb4b202d7513ce50745d" title="In Z3, a symbol can be represented using integers and strings (See GetSymbolKind)...">SymbolKind</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0e5e137439c1194fe6ceadd130c32844" title="Return SymbolKind.Int if the symbol was constructed using MkIntSymbol, and SymbolKind...">GetSymbolKind</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s);
<a name="l02379"></a>02379 
<a name="l02387"></a>02387         <span class="keywordtype">int</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#afabdd4c7aa7001151713568aaf4e27b9" title="Return the symbol int value.">GetSymbolInt</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s);
<a name="l02388"></a>02388     
<a name="l02396"></a>02396         String^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a63af55d0bc85edc1a08938fe94d059c3" title="Return the symbol name.">GetSymbolString</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s);
<a name="l02397"></a>02397 
<a name="l02401"></a>02401         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a95167a48c7a40a4acf32631a527758da" title="Return true if the two given AST nodes are equal.">IsEq</a>(TermPtr t1, TermPtr t2);
<a name="l02402"></a>02402 
<a name="l02406"></a>02406         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6e20e01d6d3f85406b9ba5091f2e60f7" title="Return true if t is well sorted.">IsWellSorted</a>(TermPtr t);
<a name="l02407"></a>02407 
<a name="l02411"></a>02411         <a class="code" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc" title="The different kinds of Z3 Terms.">TermKind</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa92cc97ea26a5d7ca06f7337a750c964" title="Return the kind of the given AST.">GetTermKind</a>(TermPtr a);
<a name="l02412"></a>02412 
<a name="l02418"></a>02418         <a class="code" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425" title="Different kinds of Z3 built-in declarations (See GetDeclKind).">DeclKind</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab5bd163cb2dff9a325fd961d413a8c22" title="Return the kind of the built-in operator.">GetDeclKind</a>(FuncDeclPtr d);
<a name="l02419"></a>02419 
<a name="l02425"></a>02425         array&lt;IRawParameter^&gt;^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#accdc25299d9fe8c5a7fa0889c46cbdf5" title="Return auxiliary parameters associated with the built-in operator. For example, the...">GetDeclParameters</a>(FuncDeclPtr d);
<a name="l02426"></a>02426     
<a name="l02432"></a>02432         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6aebc549137b2458e195ebe6d9d4c4ba" title="Return the declaration of a constant or function application.">GetAppDecl</a>(AppPtr a);
<a name="l02433"></a>02433         
<a name="l02438"></a>02438         array&lt;TermPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab021d6b4e58c052472ec3cd6d2dd0fac" title="Return the arguments of an application. If t is an constant, then array is empty...">GetAppArgs</a>(AppPtr a);
<a name="l02439"></a>02439 
<a name="l02445"></a>02445         String^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>(TermPtr a);
<a name="l02446"></a>02446 
<a name="l02455"></a>02455         <span class="keywordtype">int</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa00bb4f5b7abc37cf6c24e1c8ce08f4a" title="Similar to GetNumeralString, but only succeeds if the value can fit in a machine...">GetNumeralInt</a>(TermPtr v);
<a name="l02456"></a>02456 
<a name="l02457"></a>02457         <span class="keywordtype">bool</span> TryGetNumeralInt(TermPtr v, [Out] <span class="keywordtype">int</span>% i);
<a name="l02458"></a>02458 
<a name="l02467"></a>02467         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ae40d08d8f9fc05ea8bb0b035f0da9f09" title="Similar to GetNumeralString, but only succeeds if the value can fit in a machine...">GetNumeralUInt</a>(TermPtr v);
<a name="l02468"></a>02468 
<a name="l02469"></a>02469         <span class="keywordtype">bool</span> TryGetNumeralUInt(TermPtr v, [Out] <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>% u);
<a name="l02470"></a>02470 
<a name="l02471"></a>02471 
<a name="l02480"></a>02480         <span class="keywordtype">unsigned</span> __int64 <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa78f20144c40600d63c87ebc8bd5d85e" title="Similar to GetNumeralString, but only succeeds if the value can fit in a machine...">GetNumeralUInt64</a>(TermPtr v);
<a name="l02481"></a>02481 
<a name="l02482"></a>02482         <span class="keywordtype">bool</span> TryGetNumeralUInt64(TermPtr v, [Out] <span class="keywordtype">unsigned</span> __int64% u);
<a name="l02483"></a>02483 
<a name="l02484"></a>02484 
<a name="l02492"></a>02492         __int64 <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a016d026fcaf6c2299687ae4407533390" title="Similar to GetNumeralString, but only succeeds if the value can fit in a machine...">GetNumeralInt64</a>(TermPtr v);
<a name="l02493"></a>02493 
<a name="l02494"></a>02494         <span class="keywordtype">bool</span> TryGetNumeralInt64(TermPtr v, [Out] __int64% i);
<a name="l02495"></a>02495 
<a name="l02505"></a>02505         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#af74f7a7602abaa3b7d6451f33439af63" title="Similar to GetNumeralString, but only succeeds if the value can fit in a machine...">TryGetNumeral</a>(TermPtr v, [Out] __int64% num, [Out] __int64% den);
<a name="l02506"></a>02506 
<a name="l02507"></a>02507         <span class="keywordtype">void</span> GetNumeral(TermPtr v, [Out] System::Numerics::BigInteger% num, [Out] System::Numerics::BigInteger% den);        
<a name="l02508"></a>02508 
<a name="l02514"></a>02514         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a74ec06b79df90539553d1c53c2a02bdd" title="Return the Boolean value of a truth constant. Return LBool::Undef if a is not a boolean...">GetBoolValue</a>(TermPtr a);
<a name="l02515"></a>02515 
<a name="l02516"></a>02516 
<a name="l02522"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a17499379d443ca6ee0bf3770d18135af">02522</a>         <span class="keywordtype">unsigned</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a17499379d443ca6ee0bf3770d18135af" title="Return the index of a de-Brujin bound variable.">GetVarIndex</a>(TermPtr a) {
<a name="l02523"></a>02523             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gaba865ef17f1692ab14dbd304987db411" title="Return index of de-Brujin bound variable.">Z3_get_index_value</a>(ctx(), get_ast(a));
<a name="l02524"></a>02524         }
<a name="l02525"></a>02525 
<a name="l02531"></a>02531         RawQuantifier^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4dc623c04dfdeaef8d17f88034aab270" title="Return components of a quantifier.">GetQuantifier</a>(TermPtr a);
<a name="l02532"></a>02532 
<a name="l02533"></a>02533 
<a name="l02539"></a>02539         array&lt;TermPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a029d7befda8b1da2f597b3c9d3b5b998" title="Return array of terms in the pattern.">GetPatternTerms</a>(PatternPtr p);
<a name="l02540"></a>02540 
<a name="l02544"></a>02544         <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a7c62d9f2161dec8b726996082f05875c" title="Return the constant declaration name as a symbol.">GetDeclName</a>(FuncDeclPtr d);
<a name="l02545"></a>02545 
<a name="l02549"></a>02549         <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a16e84dca2b1d23ce89a98276e943eb59" title="Return the type name as a symbol.">GetSortName</a>(SortPtr ty);
<a name="l02550"></a>02550 
<a name="l02556"></a>02556         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad563e3268d5034c9147c98190c4327d6" title="Return the type of an AST node.">GetSort</a>(TermPtr a);
<a name="l02557"></a>02557 
<a name="l02562"></a>02562         array&lt;SortPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a612c60dae8dbc7cc04ebf8a299d7f78d" title="Return the domain of a function declaration.">GetDomain</a>(FuncDeclPtr d);
<a name="l02563"></a>02563 
<a name="l02564"></a>02564 
<a name="l02571"></a>02571         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a84d2dfcc3f579dcce0820cad12686f42" title="Return the range of the given declaration.">GetRange</a>(FuncDeclPtr d);
<a name="l02572"></a>02572 
<a name="l02578"></a>02578         <a class="code" href="group__mapi.html#ga7664c6569cf130a5d166ec8c8dc27101" title="The different kinds of Z3 sorts (See GetSortKind).">SortKind</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a>(SortPtr t);
<a name="l02579"></a>02579 
<a name="l02588"></a>02588         <span class="keywordtype">unsigned</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a423fc3c6dda476f6799a85a2168c78b1" title="Return the size of the given bit-vector type.">GetBvSortSize</a>(SortPtr t);
<a name="l02589"></a>02589 
<a name="l02598"></a>02598         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad230ba9177f3ca00d509b1ee4f1ab8a5" title="Return the domain of the given array type.">GetArraySortDomain</a>(SortPtr t);
<a name="l02599"></a>02599 
<a name="l02608"></a>02608         SortPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3de655e8182580662528e278b9bef566" title="Return the range of the given array type.">GetArraySortRange</a>(SortPtr t);
<a name="l02609"></a>02609 
<a name="l02619"></a>02619         FuncDeclPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8faadbc0b5b7aa7e1f5fb988eddb0467" title="Return the constructor declaration of the given tuple type.">GetTupleConstructor</a>(SortPtr t);
<a name="l02620"></a>02620     
<a name="l02630"></a>02630         array&lt;FuncDeclPtr&gt;^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a91e7e6ddb2615bb55ee58ea57c34f308" title="Return the field declarations of a given tuple type.">GetTupleFields</a>(SortPtr t);
<a name="l02631"></a>02631 
<a name="l02638"></a>02638 
<a name="l02644"></a>02644         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a12f2bc414c2c1520880db1444edd72d1" title="Update the arguments of a term or quantifier.">UpdateTerm</a>(TermPtr t, array&lt;TermPtr&gt;^ new_args);
<a name="l02645"></a>02645 
<a name="l02653"></a>02653         
<a name="l02664"></a>02664         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Create a backtracking point.">Push</a>();
<a name="l02665"></a>02665     
<a name="l02680"></a>02680         <span class="keywordtype">void</span> Pop(<span class="keywordtype">unsigned</span> num_scopes);
<a name="l02681"></a>02681 
<a name="l02682"></a>02682         <span class="keywordtype">void</span> Pop() { Pop(1); }
<a name="l02683"></a>02683 
<a name="l02684"></a>02684         <span class="keywordtype">unsigned</span> GetNumScopes();
<a name="l02685"></a>02685 
<a name="l02686"></a>02686 
<a name="l02713"></a>02713         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a268029705dabf988d7655c85df1b548e" title="Persist a term during num_scopes of pops.">PersistTerm</a>(TermPtr t, <span class="keywordtype">unsigned</span> num_scopes);
<a name="l02714"></a>02714 
<a name="l02715"></a>02715 
<a name="l02728"></a>02728         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a48d8c58bf4484b54bf612a3b81526648" title="Assert a constraing into the logical context.">AssertCnstr</a>(TermPtr a);
<a name="l02729"></a>02729     
<a name="l02743"></a>02743         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed51407e62b77b7bcc14d25ca8e320af" title="Check whether the given logical context is consistent or not.">CheckAndGetModel</a>([Out] RawModel^% m);
<a name="l02744"></a>02744     
<a name="l02751"></a>02751         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a>();
<a name="l02752"></a>02752 
<a name="l02775"></a>02775         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6623753616cdabbfeb889ed4a31dfbc7" title="Check whether the given logical context is consistent or not with respect to auxiliary...">CheckAssumptions</a>([Out] RawModel^% m, 
<a name="l02776"></a>02776                                [In]  array&lt;TermPtr&gt;^ assumptions, 
<a name="l02777"></a>02777                                [Out] TermPtr% proof, 
<a name="l02778"></a>02778                                [Out] array&lt;TermPtr&gt;^% core);
<a name="l02779"></a>02779 
<a name="l02787"></a>02787         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4717aab1cfc427ec9c049c9ba743a006" title="Cancel the current search initiated using Check, CheckAndGetModel, or CheckAssumptions...">SoftCheckCancel</a>();
<a name="l02788"></a>02788         
<a name="l02789"></a>02789 
<a name="l02790"></a>02790 
<a name="l02810"></a>02810         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a680762fecac781975b588f102dd8ae3e" title="Retrieve congruence class representatives for terms.">GetImpliedEqualities</a>(
<a name="l02811"></a>02811             [In]  array&lt;TermPtr&gt;^ terms,
<a name="l02812"></a>02812             [Out] array&lt;unsigned&gt;^% class_ids
<a name="l02813"></a>02813             );
<a name="l02814"></a>02814 
<a name="l02815"></a>02815 
<a name="l02821"></a>02821         <a class="code" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e" title="Different failure kinds.">SearchFailureExplanation</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3c2e03935c06e79eb6c4b249b910307d" title="Obtain explanation for search failure.">GetSearchFailureExplanation</a>();
<a name="l02822"></a>02822 
<a name="l02823"></a>02823 
<a name="l02827"></a>02827         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4db4d536f2203faa741073c01f61fb0e" title="Return conjunction of literals and formulas assigned to true in the current state...">GetAssignments</a>();
<a name="l02828"></a>02828 
<a name="l02832"></a>02832         LabeledLiterals^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac91878a6a5fd8cb8173aed946528f42f" title="Retrieve set of labels set in current satisfying assignment.">GetRelevantLabels</a>();
<a name="l02833"></a>02833 
<a name="l02837"></a>02837         LabeledLiterals^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed54018936a4d19c92a05d8c770d3c33" title="Retrieve set of literals satisfying the current assignment.">GetRelevantLiterals</a>();
<a name="l02838"></a>02838 
<a name="l02842"></a>02842         LabeledLiterals^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9522ebeb37a88abbb1a4a1c4cf75ac9f" title="Retrieve set of guessed literals satisfying the current assignment.">GetGuessedLiterals</a>();
<a name="l02843"></a>02843 
<a name="l02850"></a>02850         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a712b529cbbcd86eb099bcb97289f9a77" title="Block the combination of remaining non-disabled labels.">BlockLiterals</a>(LabeledLiterals^ labels);
<a name="l02851"></a>02851 
<a name="l02855"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a21c01788a1c75b8e9ee86634aec4ca8c">02855</a>         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a21c01788a1c75b8e9ee86634aec4ca8c" title="Obtain literal corresponding to index in list of literals.">GetLiteral</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_labeled_literals.html" title="Container for labeled literals.">LabeledLiterals</a>^ labels, <span class="keywordtype">unsigned</span> idx) {
<a name="l02856"></a>02856             <span class="keywordflow">return</span> labels-&gt;GetLiteral(idx);
<a name="l02857"></a>02857         }
<a name="l02858"></a>02858 
<a name="l02866"></a>02866         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aea36484f844217cc37a206be0fe565f6" title="Interface to simplifier.">Simplify</a>(TermPtr a);
<a name="l02867"></a>02867         
<a name="l02868"></a>02868     
<a name="l02875"></a>02875 
<a name="l02876"></a>02876 
<a name="l02887"></a>02887         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a17471e6be035651820a92e6c4e31d673" title="Select mode for the format used for pretty-printing AST nodes.">SetPrintMode</a>(<a class="code" href="group__mapi.html#ga8fcc700aeeee633213b4e5f433e5e12e" title="Z3 pretty printing modes used when pretty printing terms.">PrintMode</a> mode);
<a name="l02888"></a>02888 
<a name="l02892"></a>02892         String^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a08d99b52685eab1e9d5ac4d9223cb2be" title="Convert the given logical context into a string.">ToString</a>(AstPtr a);
<a name="l02893"></a>02893         
<a name="l02894"></a>02894         <span class="keywordtype">void</span> Display(System::IO::TextWriter^ w, AstPtr a);
<a name="l02895"></a>02895     
<a name="l02902"></a>02902         <span class="keyword">virtual</span> String^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a08d99b52685eab1e9d5ac4d9223cb2be" title="Convert the given logical context into a string.">ToString</a>() <span class="keyword">override</span>;
<a name="l02903"></a>02903 
<a name="l02904"></a>02904         <span class="keywordtype">void</span> Display(System::IO::TextWriter^ w);
<a name="l02905"></a>02905 
<a name="l02912"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0c7570d3474aec2457249e00de34c51a">02912</a>         String^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0c7570d3474aec2457249e00de34c51a" title="Convert the given logical context into a string.">StatisticsToString</a>() {
<a name="l02913"></a>02913             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> String(<a class="code" href="group__capi.html#ga660933fbbc1cd0dce85680d532fb56e0" title="Return runtime statistics as a string.">Z3_statistics_to_string</a>(ctx()));
<a name="l02914"></a>02914         }
<a name="l02915"></a>02915 
<a name="l02916"></a>02916         <span class="keywordtype">void</span> DisplayStatistics(System::IO::TextWriter^ w) {
<a name="l02917"></a>02917             w-&gt;Write(<a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0c7570d3474aec2457249e00de34c51a" title="Convert the given logical context into a string.">StatisticsToString</a>());
<a name="l02918"></a>02918         }
<a name="l02919"></a>02919 
<a name="l02923"></a>02923         String^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0805c579c20f25fec2c0f293259d9473" title="Convert the given benchmark into SMT-LIB formatted string.">BenchmarkToSmtlib</a>(String^ name,
<a name="l02924"></a>02924                                   String^ logic,
<a name="l02925"></a>02925                                   String^ status,
<a name="l02926"></a>02926                                   String^ attributes,
<a name="l02927"></a>02927                                   array&lt;TermPtr&gt;^ assumptions,
<a name="l02928"></a>02928                                   TermPtr formula);
<a name="l02929"></a>02929 
<a name="l02955"></a>02955         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a3d9995b5f0cd4395f93c9ad17a63d7cc" title="Parse the given string using the SMT-LIB parser.">ParseSmtlibString</a>(
<a name="l02956"></a>02956             String^ <span class="keywordtype">string</span>,
<a name="l02957"></a>02957             [In]  array&lt;SortPtr&gt;^     sorts,
<a name="l02958"></a>02958             [In]  array&lt;FuncDeclPtr&gt;^ decls,
<a name="l02959"></a>02959             [Out] array&lt;TermPtr&gt;^%    assumptions,            
<a name="l02960"></a>02960             [Out] array&lt;TermPtr&gt;^%    formulas,
<a name="l02961"></a>02961             [Out] array&lt;FuncDeclPtr&gt;^% new_decls,
<a name="l02962"></a>02962             [Out] array&lt;SortPtr&gt;^%    new_sorts,
<a name="l02963"></a>02963             [Out] String^% parser_out
<a name="l02964"></a>02964             );
<a name="l02965"></a>02965     
<a name="l02969"></a>02969         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a189844e560a2e30995b6d68823304932" title="Similar to ParseSmtlibString, but reads the benchmark from a file.">ParseSmtlibFile</a>(
<a name="l02970"></a>02970             String^             file,
<a name="l02971"></a>02971             [In]  array&lt;SortPtr&gt;^     sorts,
<a name="l02972"></a>02972             [In]  array&lt;FuncDeclPtr&gt;^ decls,
<a name="l02973"></a>02973             [Out] array&lt;TermPtr&gt;^%    assumptions,            
<a name="l02974"></a>02974             [Out] array&lt;TermPtr&gt;^%    formulas,
<a name="l02975"></a>02975             [Out] array&lt;FuncDeclPtr&gt;^% new_decls,
<a name="l02976"></a>02976             [Out] array&lt;SortPtr&gt;^%    new_sorts,
<a name="l02977"></a>02977             [Out] String^% parser_out
<a name="l02978"></a>02978             );
<a name="l02979"></a>02979 
<a name="l02980"></a>02980 
<a name="l02986"></a>02986         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ade46bed01c907e799528075996072637" title="Parse a string in the native Z3 format.">ParseZ3String</a>(String^ s);
<a name="l02987"></a>02987 
<a name="l02993"></a>02993         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#abb1e2e3a1d96aa625758845ed3b8d534" title="Parse a file containing formulas in Z3&amp;#39;s native format.">ParseZ3File</a>(String^ filename);
<a name="l02994"></a>02994 
<a name="l03000"></a>03000         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#afd791c9297c9a547017ba2cf0b94ee81" title="Parse a string in the SMT-LIB2 format.">ParseSmtlib2String</a>(String^ s, array&lt;SortPtr&gt;^ sorts, array&lt;FuncDeclPtr&gt;^ decls);
<a name="l03001"></a>03001 
<a name="l03007"></a>03007         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aedcfe737b097182e955e06099747630f" title="Parse a file containing formulas in SMT-LIB2 format.">ParseSmtlib2File</a>(String^ filename, array&lt;SortPtr&gt;^ sorts, array&lt;FuncDeclPtr&gt;^ decls);
<a name="l03008"></a>03008 
<a name="l03014"></a>03014         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a9d6d0233ca62b250f4ab0d7ffd34a021" title="Execute commands from a string in the SMT-LIB2 format.">ExecSmtlib2String</a>(String^ s, array&lt;SortPtr&gt;^ sorts, array&lt;FuncDeclPtr&gt;^ decls);
<a name="l03015"></a>03015 
<a name="l03021"></a>03021         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a41d7b23fa1f48ebaab07718ca78d7d1e" title="Execute commands from a file containing formulas in SMT-LIB2 format.">ExecSmtlib2File</a>(String^ filename, array&lt;SortPtr&gt;^ sorts, array&lt;FuncDeclPtr&gt;^ decls);
<a name="l03027"></a>03027         <span class="comment">/*{@*/</span>
<a name="l03028"></a>03028 
<a name="l03036"></a>03036         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a22af33e79aad8e443bfe2c249c6255ef" title="Register a Z3 error handler.">SetErrorHandler</a>(IErrorHandler^ h);
<a name="l03037"></a>03037 
<a name="l03041"></a>03041         <span class="keyword">static</span> String^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8478b135914c2e8c78127a50361331c4" title="Return a string describing the given error code.">GetErrorMessage</a>(<a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> err);
<a name="l03042"></a>03042 
<a name="l03046"></a>03046         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6bcc908b9ba41cd95dae64006321b34b" title="Free all resources allocated for Z3.">ResetMemory</a>();
<a name="l03047"></a>03047         
<a name="l03055"></a>03055     
<a name="l03059"></a>03059         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a7068a418e65d2a184e2275e72300afc1" title="Return Z3 version number information.">GetVersion</a>(
<a name="l03060"></a>03060             [Out] <span class="keywordtype">unsigned</span> % major, 
<a name="l03061"></a>03061             [Out] <span class="keywordtype">unsigned</span> % minor, 
<a name="l03062"></a>03062             [Out] <span class="keywordtype">unsigned</span> % build_number, 
<a name="l03063"></a>03063             [Out] <span class="keywordtype">unsigned</span> % revision_number);
<a name="l03072"></a>03072         RawTheory^ <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#aa414182801e38192dfb8beed739bfe23" title="Create user theory.">MkTheory</a>(String^ name);
<a name="l03073"></a>03073 
<a name="l03074"></a>03074 
<a name="l03079"></a>03079     <span class="keyword">internal</span>:
<a name="l03080"></a><a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ad9010a8c0b8110f5e670fa5fc280f064">03080</a>         IntPtr m_simplifier_gch;
<a name="l03081"></a>03081         <span class="keyword">static</span> Dictionary&lt;GCHandle, RawContext^&gt;^ contexts;
<a name="l03082"></a>03082         <span class="keyword">static</span> <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> user_simplifier_callback(<span class="keywordtype">void</span>* user_data, Z3_ast a, Z3_ast* r, Z3_ast* p);
<a name="l03083"></a>03083     <span class="keyword">private</span>:
<a name="l03084"></a>03084         Func&lt;TermPtr, TermProofPtr^&gt;^ user_simplifier;
<a name="l03085"></a>03085         <span class="keywordtype">void</span> set_user_simplifier(Func&lt;TermPtr, TermProofPtr^&gt;^ value);
<a name="l03086"></a>03086     <span class="keyword">public</span>:
<a name="l03087"></a>03087         <span class="keyword">property</span> Func&lt;TermPtr, TermProofPtr^&gt;^ UserSimplifier {
<a name="l03088"></a>03088             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func&lt;TermPtr, TermProofPtr^&gt;^ value) { set_user_simplifier(value); }
<a name="l03089"></a>03089         }
<a name="l03090"></a>03090 
<a name="l03095"></a>03095         <span class="keywordtype">void</span> RegisterRelation(FuncDeclPtr relation);
<a name="l03096"></a>03096 
<a name="l03097"></a>03097         <span class="keywordtype">void</span> AddRule(TermPtr rule, Symbol^ name);
<a name="l03098"></a>03098 
<a name="l03105"></a>03105         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a606e29bd48b267e20d8d04388cec4e4a" title="post a query. The return value is LBool.True if the query is satisfiabl,e it is LBool...">Query</a>(TermPtr query);
<a name="l03106"></a>03106 
<a name="l03110"></a>03110         <a class="code" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e" title="Different failure kinds.">SearchFailureExplanation</a> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a0c54f0a096c506bf93bce1532ddf977a" title="retrieve details on the search satus.">GetQueryStatus</a>();
<a name="l03111"></a>03111 
<a name="l03116"></a>03116         TermPtr <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#ab2ed8df926ca0b94a1f186a7b7e529de" title="retrieve formula that satisfies the previous query, assuming the return value was...">GetQueryAnswer</a>();
<a name="l03117"></a>03117 
<a name="l03118"></a>03118         String^ FixpointBenchmarkToString(array&lt;TermPtr&gt;^ fo_axioms, array&lt;TermPtr&gt;^ rules, array&lt;TermPtr&gt;^ queries);
<a name="l03119"></a>03119 
<a name="l03120"></a>03120         array&lt;TermPtr&gt;^ SimplifyFixpointRules(array&lt;TermPtr&gt;^ rules, array&lt;FuncDeclPtr&gt;^ output_predicates);
<a name="l03121"></a>03121 
<a name="l03122"></a>03122         <span class="comment">// functions for creating custom Datalog relations.</span>
<a name="l03123"></a>03123     <span class="keyword">internal</span>:
<a name="l03124"></a>03124         <span class="keyword">static</span> <span class="keywordtype">void</span> datalog_assign_callback(Z3_context, Z3_func_decl, <span class="keywordtype">unsigned</span>, Z3_ast <span class="keyword">const</span>[], <span class="keywordtype">unsigned</span>, Z3_ast <span class="keyword">const</span>[]);
<a name="l03125"></a>03125         <span class="keyword">static</span> <span class="keywordtype">void</span> datalog_apply_callback(Z3_context, Z3_func_decl, <span class="keywordtype">unsigned</span>, Z3_ast <span class="keyword">const</span>[], Z3_ast*);
<a name="l03126"></a>03126         IntPtr m_datalog_gch;
<a name="l03127"></a>03127     <span class="keyword">private</span>:
<a name="l03128"></a>03128         Action3&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, array&lt;TermPtr&gt;^&gt;^ m_datalog_assign;
<a name="l03129"></a>03129         Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^           m_datalog_apply;
<a name="l03130"></a>03130         <span class="keywordtype">void</span> init_datalog_callbacks();
<a name="l03131"></a>03131     <span class="keyword">public</span>:
<a name="l03132"></a>03132         <span class="keyword">property</span> Action3&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, array&lt;TermPtr&gt;^&gt;^ DatalogAssign {
<a name="l03133"></a>03133             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action3&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, array&lt;TermPtr&gt;^&gt;^ value) {
<a name="l03134"></a>03134                 m_datalog_assign = value;
<a name="l03135"></a>03135                 init_datalog_callbacks();
<a name="l03136"></a>03136             }
<a name="l03137"></a>03137         }
<a name="l03138"></a>03138         <span class="keyword">property</span> Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ DatalogApply {
<a name="l03139"></a>03139             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ value) {
<a name="l03140"></a>03140                 m_datalog_apply = value;
<a name="l03141"></a>03141                 init_datalog_callbacks();
<a name="l03142"></a>03142             }
<a name="l03143"></a>03143         }
<a name="l03144"></a>03144         
<a name="l03145"></a>03145     };
<a name="l03146"></a>03146 
<a name="l03147"></a>03147     <span class="keyword">public ref class</span> RawTheory {
<a name="l03148"></a>03148         <span class="keyword">typedef</span> GCHandle GCHandle;
<a name="l03149"></a>03149         <span class="keyword">typedef</span> GCHandleType GCHandleType;
<a name="l03150"></a>03150     <span class="keyword">private</span>: 
<a name="l03151"></a>03151         Z3_theory    m_theory;
<a name="l03152"></a>03152         ref_context&amp; m_context;
<a name="l03153"></a>03153         String^      m_name;
<a name="l03154"></a>03154         <span class="keyword">static</span> Dictionary&lt;GCHandle,RawTheory^&gt;^ theories;
<a name="l03155"></a>03155     <span class="keyword">protected</span>:
<a name="l03156"></a>03156         !RawTheory() {}
<a name="l03157"></a>03157     <span class="keyword">public</span>:        
<a name="l03158"></a>03158         <span class="keyword">property</span> String^ Name { String^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_name; } }
<a name="l03159"></a>03159     <span class="keyword">internal</span>:
<a name="l03160"></a>03160         RawTheory(ref_context&amp; ctx, String^ name);
<a name="l03161"></a>03161         ~RawTheory();
<a name="l03162"></a>03162         
<a name="l03163"></a>03163         <span class="keyword">static</span> RawTheory^ GetTheory(Z3_theory th) {
<a name="l03164"></a>03164             Z3_theory_data td = <a class="code" href="group__capi.html#ga9f8a5c32a1cc523d23a561780824e3af" title="Return a pointer to the external data-structure supplied to the function Z3_mk_theory...">Z3_theory_get_ext_data</a>(th);
<a name="l03165"></a>03165             <span class="keywordflow">return</span> theories[GCHandle::FromIntPtr(IntPtr(td))];
<a name="l03166"></a>03166         }
<a name="l03167"></a>03167 
<a name="l03168"></a>03168 
<a name="l03169"></a>03169         <span class="comment">// Delete Handler</span>
<a name="l03170"></a>03170     <span class="keyword">private</span>:
<a name="l03171"></a>03171         Action0^ delete_handler;
<a name="l03172"></a>03172     <span class="keyword">internal</span>:
<a name="l03173"></a>03173         <span class="keyword">static</span> <span class="keywordtype">void</span> static_delete_callback(Z3_theory th);
<a name="l03174"></a>03174 
<a name="l03175"></a>03175     <span class="keyword">public</span>:
<a name="l03176"></a>03176         <span class="keyword">property</span> Action0^ DeleteHandler
<a name="l03177"></a>03177         {
<a name="l03178"></a>03178             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l03179"></a>03179             {
<a name="l03180"></a>03180                 delete_handler = value;
<a name="l03181"></a>03181             }
<a name="l03182"></a>03182         }
<a name="l03183"></a>03183 
<a name="l03184"></a>03184         <span class="comment">// ReduceEq</span>
<a name="l03185"></a>03185     <span class="keyword">internal</span>:
<a name="l03186"></a>03186         <span class="keyword">static</span> <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> reduce_eq_callback(Z3_theory th, Z3_ast a, Z3_ast b, Z3_ast* r);
<a name="l03187"></a>03187     <span class="keyword">private</span>:
<a name="l03188"></a>03188         Func2&lt;TermPtr, TermPtr, TermPtr&gt;^ reduce_eq;
<a name="l03189"></a>03189         <span class="keywordtype">void</span> set_reduce_eq(Func2&lt;TermPtr, TermPtr, TermPtr&gt;^ value);
<a name="l03190"></a>03190     <span class="keyword">public</span>:
<a name="l03191"></a>03191         <span class="keyword">property</span> Func2&lt;TermPtr, TermPtr, TermPtr&gt;^ ReduceEq {
<a name="l03192"></a>03192             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;TermPtr, TermPtr, TermPtr&gt;^ value) {
<a name="l03193"></a>03193                 set_reduce_eq(value);
<a name="l03194"></a>03194             }
<a name="l03195"></a>03195         }
<a name="l03196"></a>03196 
<a name="l03197"></a>03197 
<a name="l03198"></a>03198         <span class="comment">// ReduceApp</span>
<a name="l03199"></a>03199     <span class="keyword">private</span>:
<a name="l03200"></a>03200         Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ reduce_app;
<a name="l03201"></a>03201         <span class="keywordtype">void</span> set_reduce_app(Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ value);
<a name="l03202"></a>03202     <span class="keyword">public</span>:
<a name="l03203"></a>03203         <span class="keyword">property</span> Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ ReduceApp {
<a name="l03204"></a>03204             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;^ value) {
<a name="l03205"></a>03205                 set_reduce_app(value);
<a name="l03206"></a>03206             }
<a name="l03207"></a>03207         }
<a name="l03208"></a>03208     <span class="keyword">internal</span>:
<a name="l03209"></a>03209         <span class="keyword">static</span> <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> reduce_app_callback(Z3_theory th, Z3_func_decl f, <span class="keywordtype">unsigned</span> num_args, Z3_ast <span class="keyword">const</span> args[], Z3_ast* r);
<a name="l03210"></a>03210 
<a name="l03211"></a>03211     <span class="comment">// Reduce distinct</span>
<a name="l03212"></a>03212     <span class="keyword">private</span>:
<a name="l03213"></a>03213         Func1&lt;array&lt;TermPtr&gt;^, TermPtr&gt;^ reduce_distinct;
<a name="l03214"></a>03214         <span class="keywordtype">void</span> set_reduce_distinct(Func1&lt;array&lt;TermPtr&gt;^, TermPtr&gt;^ value);
<a name="l03215"></a>03215     <span class="keyword">internal</span>:
<a name="l03216"></a>03216         <span class="keyword">static</span> <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> reduce_distinct_callback(Z3_theory th, <span class="keywordtype">unsigned</span> n, Z3_ast <span class="keyword">const</span> args[], Z3_ast* r);
<a name="l03217"></a>03217     <span class="keyword">public</span>:
<a name="l03218"></a>03218         <span class="keyword">property</span> Func1&lt;array&lt;TermPtr&gt;^, TermPtr&gt;^ ReduceDistinct {
<a name="l03219"></a>03219             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func1&lt;array&lt;TermPtr&gt;^, TermPtr&gt;^ value) {
<a name="l03220"></a>03220                 set_reduce_distinct(value);
<a name="l03221"></a>03221             }
<a name="l03222"></a>03222         }
<a name="l03223"></a>03223 
<a name="l03224"></a>03224         <span class="comment">// NewRelevant</span>
<a name="l03225"></a>03225     <span class="keyword">internal</span>: 
<a name="l03226"></a>03226         Action&lt;TermPtr&gt;^ new_relevant;
<a name="l03227"></a>03227     <span class="keyword">private</span>: 
<a name="l03228"></a>03228         <span class="keywordtype">void</span> set_new_relevant(Action&lt;TermPtr&gt;^ value);
<a name="l03229"></a>03229     <span class="keyword">public</span>: 
<a name="l03230"></a>03230         <span class="keyword">property</span> Action&lt;TermPtr&gt;^ NewRelevant {
<a name="l03231"></a>03231             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;TermPtr&gt;^ value) {
<a name="l03232"></a>03232                 set_new_relevant(value);
<a name="l03233"></a>03233             }
<a name="l03234"></a>03234         }
<a name="l03235"></a>03235 
<a name="l03236"></a>03236         <span class="comment">// NewApp</span>
<a name="l03237"></a>03237     <span class="keyword">private</span>: 
<a name="l03238"></a>03238         <span class="keywordtype">void</span> set_new_app(Action&lt;TermPtr&gt;^ value);
<a name="l03239"></a>03239     <span class="keyword">internal</span>: 
<a name="l03240"></a>03240         Action&lt;TermPtr&gt;^ new_app;
<a name="l03241"></a>03241     <span class="keyword">public</span>: 
<a name="l03242"></a>03242         <span class="keyword">property</span> Action&lt;TermPtr&gt;^ NewApp {
<a name="l03243"></a>03243             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;TermPtr&gt;^ value) {
<a name="l03244"></a>03244                 set_new_app(value);
<a name="l03245"></a>03245             }
<a name="l03246"></a>03246         }
<a name="l03247"></a>03247 
<a name="l03248"></a>03248         <span class="comment">// NewElem</span>
<a name="l03249"></a>03249     <span class="keyword">private</span>: 
<a name="l03250"></a>03250         <span class="keywordtype">void</span> set_new_elem(Action&lt;TermPtr&gt;^ value);
<a name="l03251"></a>03251     <span class="keyword">internal</span>: 
<a name="l03252"></a>03252         Action&lt;TermPtr&gt;^ new_elem;
<a name="l03253"></a>03253     <span class="keyword">public</span>: 
<a name="l03254"></a>03254         <span class="keyword">property</span> Action&lt;TermPtr&gt;^ NewElem {
<a name="l03255"></a>03255             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;TermPtr&gt;^ value) {
<a name="l03256"></a>03256                 set_new_elem(value);
<a name="l03257"></a>03257             }
<a name="l03258"></a>03258         }
<a name="l03259"></a>03259         
<a name="l03260"></a>03260         <span class="comment">// InitSearch</span>
<a name="l03261"></a>03261     <span class="keyword">private</span>:
<a name="l03262"></a>03262         <span class="keywordtype">void</span> set_init_search(Action0^ value);
<a name="l03263"></a>03263     <span class="keyword">internal</span>:
<a name="l03264"></a>03264         Action0^ init_search;
<a name="l03265"></a>03265     <span class="keyword">public</span>: 
<a name="l03266"></a>03266         <span class="keyword">property</span> Action0^ InitSearch {
<a name="l03267"></a>03267             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) { set_init_search(value); }
<a name="l03268"></a>03268         }
<a name="l03269"></a>03269 
<a name="l03270"></a>03270         <span class="comment">// Push</span>
<a name="l03271"></a>03271     <span class="keyword">private</span>:
<a name="l03272"></a>03272         <span class="keywordtype">void</span> set_push(Action0^ value);
<a name="l03273"></a>03273     <span class="keyword">internal</span>:
<a name="l03274"></a>03274         Action0^ push;
<a name="l03275"></a>03275     <span class="keyword">public</span>: 
<a name="l03276"></a>03276         <span class="keyword">property</span> Action0^ Push {
<a name="l03277"></a>03277             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) { set_push(value); }
<a name="l03278"></a>03278         }
<a name="l03279"></a>03279 
<a name="l03280"></a>03280         <span class="comment">// Pop</span>
<a name="l03281"></a>03281     <span class="keyword">private</span>:
<a name="l03282"></a>03282         <span class="keywordtype">void</span> set_pop(Action0^ value);
<a name="l03283"></a>03283     <span class="keyword">internal</span>:
<a name="l03284"></a>03284         Action0^ pop;
<a name="l03285"></a>03285     <span class="keyword">public</span>: 
<a name="l03286"></a>03286         <span class="keyword">property</span> Action0^ Pop {
<a name="l03287"></a>03287             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) { set_pop(value); }
<a name="l03288"></a>03288         }
<a name="l03289"></a>03289 
<a name="l03290"></a>03290         <span class="comment">// Restart</span>
<a name="l03291"></a>03291     <span class="keyword">private</span>:
<a name="l03292"></a>03292         <span class="keywordtype">void</span> set_restart(Action0^ value);
<a name="l03293"></a>03293     <span class="keyword">internal</span>:
<a name="l03294"></a>03294         Action0^ restart;
<a name="l03295"></a>03295     <span class="keyword">public</span>: 
<a name="l03296"></a>03296         <span class="keyword">property</span> Action0^ Restart {
<a name="l03297"></a>03297             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) { set_restart(value); }
<a name="l03298"></a>03298         }
<a name="l03299"></a>03299 
<a name="l03300"></a>03300         <span class="comment">// Reset</span>
<a name="l03301"></a>03301     <span class="keyword">private</span>:
<a name="l03302"></a>03302         <span class="keywordtype">void</span> set_reset(Action0^ value);
<a name="l03303"></a>03303     <span class="keyword">internal</span>:
<a name="l03304"></a>03304         Action0^ reset;
<a name="l03305"></a>03305     <span class="keyword">public</span>: 
<a name="l03306"></a>03306         <span class="keyword">property</span> Action0^ Reset {
<a name="l03307"></a>03307             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) { set_reset(value); }
<a name="l03308"></a>03308         }
<a name="l03309"></a>03309 
<a name="l03310"></a>03310 
<a name="l03311"></a>03311         <span class="comment">// FinalCheck</span>
<a name="l03312"></a>03312     <span class="keyword">private</span>:
<a name="l03313"></a>03313         <span class="keywordtype">void</span> set_final_check(Func0&lt;bool&gt;^ value);
<a name="l03314"></a>03314     <span class="keyword">internal</span>:
<a name="l03315"></a>03315         Func0&lt;bool&gt;^ final_check;
<a name="l03316"></a>03316     <span class="keyword">public</span>: 
<a name="l03317"></a>03317         <span class="keyword">property</span> Func0&lt;bool&gt;^ FinalCheck {
<a name="l03318"></a>03318             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func0&lt;bool&gt;^ value) { set_final_check(value); }
<a name="l03319"></a>03319         }
<a name="l03320"></a>03320 
<a name="l03321"></a>03321 
<a name="l03322"></a>03322         <span class="comment">// NewEq</span>
<a name="l03323"></a>03323     <span class="keyword">private</span>:
<a name="l03324"></a>03324         <span class="keywordtype">void</span> set_new_eq(Action2&lt;TermPtr, TermPtr&gt;^ value);
<a name="l03325"></a>03325     <span class="keyword">internal</span>:
<a name="l03326"></a>03326         Action2&lt;TermPtr, TermPtr&gt;^ new_eq;
<a name="l03327"></a>03327     <span class="keyword">public</span>:
<a name="l03328"></a>03328         <span class="keyword">property</span> Action2&lt;TermPtr, TermPtr&gt;^ NewEq
<a name="l03329"></a>03329         {
<a name="l03330"></a>03330             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;TermPtr, TermPtr&gt;^ value) { set_new_eq(value); }
<a name="l03331"></a>03331         }
<a name="l03332"></a>03332 
<a name="l03333"></a>03333 
<a name="l03334"></a>03334         <span class="comment">// NewDiseq</span>
<a name="l03335"></a>03335     <span class="keyword">private</span>:
<a name="l03336"></a>03336         <span class="keywordtype">void</span> set_new_diseq(Action2&lt;TermPtr, TermPtr&gt;^ value);
<a name="l03337"></a>03337     <span class="keyword">internal</span>:
<a name="l03338"></a>03338         Action2&lt;TermPtr, TermPtr&gt;^ new_diseq;
<a name="l03339"></a>03339     <span class="keyword">public</span>:
<a name="l03340"></a>03340         <span class="keyword">property</span> Action2&lt;TermPtr, TermPtr&gt;^ NewDiseq
<a name="l03341"></a>03341         {
<a name="l03342"></a>03342             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;TermPtr, TermPtr&gt;^ value) { set_new_diseq(value); }
<a name="l03343"></a>03343         }
<a name="l03344"></a>03344 
<a name="l03345"></a>03345         <span class="comment">// NewAssignment</span>
<a name="l03346"></a>03346     <span class="keyword">internal</span>:
<a name="l03347"></a>03347         Action2&lt;TermPtr, bool&gt;^ new_assignment;
<a name="l03348"></a>03348     <span class="keyword">private</span>:
<a name="l03349"></a>03349         <span class="keywordtype">void</span> set_new_assignment(Action2&lt;TermPtr, bool&gt;^ value);
<a name="l03350"></a>03350     <span class="keyword">public</span>:
<a name="l03351"></a>03351         <span class="keyword">property</span> Action2&lt;TermPtr, bool&gt;^ NewAssignment {
<a name="l03352"></a>03352             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;TermPtr, bool&gt;^ value) {
<a name="l03353"></a>03353                 set_new_assignment(value);
<a name="l03354"></a>03354             }
<a name="l03355"></a>03355         }
<a name="l03356"></a>03356 
<a name="l03357"></a>03357         <span class="keywordtype">void</span> AssertTheoryAxiom(TermPtr ax)
<a name="l03358"></a>03358         {
<a name="l03359"></a>03359             <a class="code" href="group__capi.html#ga6ab97a5867aef0556c64bb29c72f9ced" title="Assert a theory axiom/lemmas during the search.">Z3_theory_assert_axiom</a>(m_theory, get_ast(ax));
<a name="l03360"></a>03360         }
<a name="l03361"></a>03361 
<a name="l03362"></a>03362         <span class="keywordtype">void</span> AssumeEq(TermPtr lhs, TermPtr rhs)
<a name="l03363"></a>03363         {
<a name="l03364"></a>03364             <a class="code" href="group__capi.html#ga277e6cd16cddc0c7315306151b9816ef" title="Inform to the logical context that lhs and rhs have the same interpretation in the...">Z3_theory_assume_eq</a>(m_theory, get_ast(lhs), get_ast(rhs));
<a name="l03365"></a>03365         }
<a name="l03366"></a>03366 
<a name="l03367"></a>03367         <span class="keywordtype">void</span> EnableTheoryAxiomSimplification(<span class="keywordtype">bool</span> flag)
<a name="l03368"></a>03368         {
<a name="l03369"></a>03369             <a class="code" href="group__capi.html#ga2cdc617cf02b74c0e59ad34afc7f433a" title="Enable/disable the simplification of theory axioms asserted using Z3_theory_assert_axiom...">Z3_theory_enable_axiom_simplification</a>(m_theory, flag);
<a name="l03370"></a>03370         }
<a name="l03371"></a>03371 
<a name="l03372"></a>03372         TermPtr GetEqcRoot(TermPtr n)
<a name="l03373"></a>03373         {
<a name="l03374"></a>03374             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gaf8b5b897959cbf30b20f7449cb02ebe3" title="Return the root of the equivalence class containing n.">Z3_theory_get_eqc_root</a>(m_theory, get_ast(n)));
<a name="l03375"></a>03375         }
<a name="l03376"></a>03376 
<a name="l03377"></a>03377         TermPtr GetEqcNext(TermPtr n)
<a name="l03378"></a>03378         {
<a name="l03379"></a>03379             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gab91ac2b25b88f92d51359c0185cf1357" title="Return the next element in the equivalence class containing n.">Z3_theory_get_eqc_next</a>(m_theory, get_ast(n)));
<a name="l03380"></a>03380         }
<a name="l03381"></a>03381 
<a name="l03382"></a>03382         
<a name="l03383"></a>03383         array&lt;TermPtr&gt;^ GetParents(TermPtr n) {
<a name="l03384"></a>03384             <span class="keywordtype">unsigned</span> np = <a class="code" href="group__capi.html#ga00cf5d469ac5f267cb92d221fd8bcfd4" title="Return the number of parents of n that are operators of the given theory.">Z3_theory_get_num_parents</a>(m_theory, get_ast(n));
<a name="l03385"></a>03385             array&lt;TermPtr&gt;^ result = <span class="keyword">gcnew</span> array&lt;TermPtr&gt;(np);
<a name="l03386"></a>03386             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; np; ++i)
<a name="l03387"></a>03387                 {
<a name="l03388"></a>03388                 result[i] = TermPtr(<a class="code" href="group__capi.html#ga9b3099dcf4f295cc05e6f94693e7be35" title="Return the i-th parent of n. See Z3_theory_get_num_parents.">Z3_theory_get_parent</a>(m_theory, get_ast(n), i));
<a name="l03389"></a>03389             }
<a name="l03390"></a>03390             <span class="keywordflow">return</span> result;
<a name="l03391"></a>03391         }
<a name="l03392"></a>03392 
<a name="l03393"></a>03393         <span class="keywordtype">bool</span> IsTheoryValue(TermPtr a)
<a name="l03394"></a>03394         {
<a name="l03395"></a>03395             <span class="keywordflow">return</span> 0 != <a class="code" href="group__capi.html#gaca57d0410f9303b524f2050ecf5c0061" title="Return Z3_TRUE if n is an interpreted theory value.">Z3_theory_is_value</a>(m_theory, get_ast(a));
<a name="l03396"></a>03396         }
<a name="l03397"></a>03397 
<a name="l03398"></a>03398         <span class="keywordtype">bool</span> IsTheoryDecl(FuncDeclPtr d)
<a name="l03399"></a>03399         {
<a name="l03400"></a>03400             <span class="keywordflow">return</span> 0 != <a class="code" href="group__capi.html#ga4836063495a93a0a64f7ee55bc57a020" title="Return Z3_TRUE if d is an interpreted theory declaration.">Z3_theory_is_decl</a>(m_theory, get_func_decl(d));
<a name="l03401"></a>03401         }
<a name="l03402"></a>03402 
<a name="l03403"></a>03403         array&lt;TermPtr&gt;^ GetElems()
<a name="l03404"></a>03404         {
<a name="l03405"></a>03405             <span class="keywordtype">unsigned</span> n = <a class="code" href="group__capi.html#ga3f2d2e577849a075129142d8007cf0da" title="Return the number of expressions of the given theory in the logical context. These...">Z3_theory_get_num_elems</a>(m_theory);
<a name="l03406"></a>03406             array&lt;TermPtr&gt;^ result = <span class="keyword">gcnew</span> array&lt;TermPtr&gt;(n);
<a name="l03407"></a>03407             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)
<a name="l03408"></a>03408             {
<a name="l03409"></a>03409                 result[i] = TermPtr(<a class="code" href="group__capi.html#ga666931824dd7e4f1c9abd9fdab1f5f81" title="Return the i-th elem of the given theory in the logical context.">Z3_theory_get_elem</a>(m_theory, i));
<a name="l03410"></a>03410             }
<a name="l03411"></a>03411             <span class="keywordflow">return</span> result;
<a name="l03412"></a>03412         }
<a name="l03413"></a>03413 
<a name="l03414"></a>03414         array&lt;TermPtr&gt;^ GetApps()
<a name="l03415"></a>03415         {
<a name="l03416"></a>03416             <span class="keywordtype">unsigned</span> n = <a class="code" href="group__capi.html#ga117c55aa5044b5706df0a1926b630857" title="Return the number of theory applications in the logical context. These are the expressions...">Z3_theory_get_num_apps</a>(m_theory);
<a name="l03417"></a>03417             array&lt;TermPtr&gt;^ result = <span class="keyword">gcnew</span> array&lt;TermPtr&gt;(n);
<a name="l03418"></a>03418             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i)
<a name="l03419"></a>03419             {
<a name="l03420"></a>03420                 result[i] = TermPtr(<a class="code" href="group__capi.html#gac2ad9c9d6f677433ca27b4cf7466c56c" title="Return the i-th application of the given theory in the logical context.">Z3_theory_get_app</a>(m_theory, i));
<a name="l03421"></a>03421             }
<a name="l03422"></a>03422             <span class="keywordflow">return</span> result;
<a name="l03423"></a>03423         }
<a name="l03424"></a>03424 
<a name="l03425"></a>03425         SortPtr MkSort(Symbol^ s) 
<a name="l03426"></a>03426         {
<a name="l03427"></a>03427             <span class="keywordflow">return</span> SortPtr(<a class="code" href="group__capi.html#gaca80d3711728d0d492cd53ea6dda73a0" title="Create an interpreted theory sort.">Z3_theory_mk_sort</a>(m_context(), m_theory, s-&gt;get()));
<a name="l03428"></a>03428         }
<a name="l03429"></a>03429         
<a name="l03430"></a>03430         TermPtr MkValue(Symbol^ s, SortPtr srt) 
<a name="l03431"></a>03431         {
<a name="l03432"></a>03432             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ga239d03127793eeff0bdffbe335eed83a" title="Create an interpreted theory constant value. Values are assumed to be different from...">Z3_theory_mk_value</a>(m_context(), m_theory, s-&gt;get(), get_sort(srt)));
<a name="l03433"></a>03433         }
<a name="l03434"></a>03434         
<a name="l03435"></a>03435         TermPtr MkConstant(Symbol^ s, SortPtr srt)
<a name="l03436"></a>03436         {
<a name="l03437"></a>03437             <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#gab91110cd869988342168cef30f311671" title="Create an interpreted constant for the given theory.">Z3_theory_mk_constant</a>(m_context(), m_theory, s-&gt;get(), get_sort(srt)));
<a name="l03438"></a>03438         }
<a name="l03439"></a>03439         
<a name="l03440"></a>03440         FuncDeclPtr MkFuncDecl(Symbol^ n, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l03441"></a>03441 
<a name="l03442"></a>03442         SortPtr MkSort(String^ s);
<a name="l03443"></a>03443         
<a name="l03444"></a>03444         TermPtr MkValue(String^ s, SortPtr srt); 
<a name="l03445"></a>03445         
<a name="l03446"></a>03446         TermPtr MkConstant(String^ s, SortPtr srt);
<a name="l03447"></a>03447         
<a name="l03448"></a>03448         FuncDeclPtr MkFuncDecl(String^ n, array&lt;SortPtr&gt;^ domain, SortPtr range);
<a name="l03449"></a>03449                 
<a name="l03450"></a>03450     };
<a name="l03451"></a>03451 
<a name="l03452"></a>03452 
<a name="l03453"></a>03453     <span class="keyword">ref class</span> Context;
<a name="l03454"></a>03454     <span class="keyword">ref class</span> Model;
<a name="l03455"></a>03455     <span class="keyword">ref class</span> Theory;
<a name="l03456"></a>03456 
<a name="l03457"></a>03457     <span class="keyword">public ref class</span> Ast : <span class="keyword">public</span> System::IComparable {
<a name="l03458"></a>03458     <span class="keyword">protected</span>:
<a name="l03459"></a>03459         AstPtr      m_ast;
<a name="l03460"></a>03460         RawContext^ m_ctx;
<a name="l03461"></a>03461         !Ast();
<a name="l03462"></a>03462     <span class="keyword">internal</span>:
<a name="l03463"></a>03463         Ast(RawContext^ c, AstPtr a);
<a name="l03464"></a>03464         AstPtr GetPtr() { <span class="keywordflow">return</span> m_ast; }
<a name="l03465"></a>03465         AstPtr operator()() { <span class="keywordflow">return</span> m_ast; }
<a name="l03466"></a>03466     <span class="keyword">public</span>:
<a name="l03467"></a>03467         ~Ast();
<a name="l03468"></a>03468 
<a name="l03472"></a>03472         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> Equals(Object^ obj) <span class="keyword">override</span>;
<a name="l03473"></a>03473 
<a name="l03477"></a>03477         <span class="keyword">virtual</span> <span class="keywordtype">int</span> GetHashCode() <span class="keyword">override</span>;
<a name="l03478"></a>03478 
<a name="l03482"></a>03482         <span class="keyword">virtual</span> String^ ToString() <span class="keyword">override</span>;
<a name="l03483"></a>03483 
<a name="l03487"></a>03487         <span class="keyword">virtual</span> <span class="keywordtype">int</span> CompareTo(Object^ other);
<a name="l03488"></a>03488 
<a name="l03492"></a>03492         <span class="comment">// virtual bool operator==(Object^ other);</span>
<a name="l03493"></a>03493 
<a name="l03494"></a>03494         <span class="comment">// virtual bool operator!=(Object^ other);</span>
<a name="l03495"></a>03495 
<a name="l03496"></a>03496         <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> GetId() { <span class="keywordflow">return</span> m_ctx-&gt;GetTermId(m_ast); }
<a name="l03497"></a>03497     };
<a name="l03498"></a>03498 
<a name="l03499"></a>03499     <span class="keyword">public ref class</span> Sort : <span class="keyword">public</span> Ast{
<a name="l03500"></a>03500     <span class="keyword">internal</span>:
<a name="l03501"></a>03501         Sort(RawContext^ c, SortPtr a) : Ast(c,a) {}
<a name="l03502"></a>03502     <span class="keyword">public</span>:
<a name="l03503"></a>03503         String^ GetName();
<a name="l03504"></a>03504         <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> GetId()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_ctx-&gt;GetSortId(m_ast); }
<a name="l03505"></a>03505     };
<a name="l03506"></a>03506 
<a name="l03507"></a>03507     <span class="keyword">public ref class</span> FuncDecl : <span class="keyword">public</span> Ast {
<a name="l03508"></a>03508     <span class="keyword">internal</span>:
<a name="l03509"></a>03509         FuncDecl(RawContext^ c, FuncDeclPtr a) : Ast(c,a) {}
<a name="l03510"></a>03510     <span class="keyword">public</span>:
<a name="l03511"></a>03511         String^ GetDeclName();
<a name="l03512"></a>03512         <a class="code" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425" title="Different kinds of Z3 built-in declarations (See GetDeclKind).">DeclKind</a> GetKind();
<a name="l03513"></a>03513         <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> GetId()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_ctx-&gt;GetFuncDeclId(m_ast); }
<a name="l03514"></a>03514     };
<a name="l03515"></a>03515 
<a name="l03516"></a>03516     <span class="keyword">public ref class</span> Term : <span class="keyword">public</span> Ast {
<a name="l03517"></a>03517     <span class="keyword">internal</span>:
<a name="l03518"></a>03518         Term(RawContext^ c, TermPtr a) : Ast(c,a) {}
<a name="l03519"></a>03519     <span class="keyword">public</span>:
<a name="l03525"></a>03525         <span class="keyword">static</span> Term^ operator!(Term^ t1);
<a name="l03526"></a>03526         <span class="keyword">static</span> Term^ operator&amp;(Term^ t1, Term^ t2);
<a name="l03527"></a>03527         <span class="keyword">static</span> Term^ operator|(Term^ t1, Term^ t2);
<a name="l03528"></a>03528         <span class="keyword">static</span> Term^ operator^(Term^ t1, Term^ t2);
<a name="l03534"></a>03534         <span class="keyword">static</span> Term^ operator+(Term^ t1, Term^ t2);
<a name="l03535"></a>03535         <span class="keyword">static</span> Term^ operator*(Term^ t1, Term^ t2);
<a name="l03536"></a>03536         <span class="keyword">static</span> Term^ operator/(Term^ t1, Term^ t2);
<a name="l03537"></a>03537         <span class="keyword">static</span> Term^ operator-(Term^ t1, Term^ t2);
<a name="l03538"></a>03538         <span class="keyword">static</span> Term^ operator&gt;(Term^ t1, Term^ t2);
<a name="l03539"></a>03539         <span class="keyword">static</span> Term^ operator&lt;(Term^ t1, Term^ t2);
<a name="l03540"></a>03540         <span class="keyword">static</span> Term^ operator&gt;=(Term^ t1, Term^ t2);
<a name="l03541"></a>03541         <span class="keyword">static</span> Term^ operator&lt;=(Term^ t1, Term^ t2);
<a name="l03542"></a>03542 
<a name="l03548"></a>03548         Term^ operator[](Term^ index);
<a name="l03549"></a>03549 
<a name="l03550"></a>03550         <a class="code" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc" title="The different kinds of Z3 Terms.">TermKind</a> GetKind();
<a name="l03551"></a>03551         FuncDecl^ GetAppDecl();
<a name="l03552"></a>03552         array&lt;Term^&gt;^ GetAppArgs();
<a name="l03553"></a>03553         Sort^ GetSort();
<a name="l03554"></a>03554         String^ GetNumeralString();
<a name="l03555"></a>03555         <span class="keywordtype">unsigned</span> GetVarIndex();
<a name="l03556"></a>03556         <span class="keyword">ref class</span> Quantifier^ GetQuantifier();
<a name="l03557"></a>03557     };
<a name="l03558"></a>03558     
<a name="l03559"></a>03559     <span class="keyword">public ref class</span> Pattern : <span class="keyword">public</span> Ast {
<a name="l03560"></a>03560     <span class="keyword">internal</span>:
<a name="l03561"></a>03561         Pattern(RawContext^ c, PatternPtr a) : Ast(c,a) {}
<a name="l03562"></a>03562     };
<a name="l03563"></a>03563 
<a name="l03564"></a>03564     <span class="keyword">public ref class</span> Quantifier {
<a name="l03565"></a>03565     <span class="keyword">public</span>:
<a name="l03566"></a>03566         <span class="keywordtype">bool</span>                  IsForall;
<a name="l03567"></a>03567         <span class="keywordtype">unsigned</span>              Weight;
<a name="l03568"></a>03568         array&lt;Pattern^&gt;^      Patterns;
<a name="l03569"></a>03569         array&lt;Term^&gt;^         NoPatterns;
<a name="l03570"></a>03570         array&lt;Sort^&gt;^         Sorts;
<a name="l03571"></a>03571         array&lt;Symbol^&gt;^       Names;
<a name="l03572"></a>03572         Term^                 Body;
<a name="l03573"></a>03573     };
<a name="l03574"></a>03574 
<a name="l03575"></a>03575     <span class="keyword">public ref class</span> ArrayValue {
<a name="l03576"></a>03576     <span class="keyword">public</span>:
<a name="l03577"></a>03577         array&lt;Term^&gt;^   Domain; 
<a name="l03578"></a>03578         array&lt;Term^&gt;^   Range;
<a name="l03579"></a>03579         Term^           ElseCase;
<a name="l03580"></a>03580     };
<a name="l03581"></a>03581 
<a name="l03582"></a>03582     <span class="keyword">public ref class</span> TermParameter : <span class="keyword">public</span> IParameter  { 
<a name="l03583"></a>03583         Term^ m_value;
<a name="l03584"></a>03584     <span class="keyword">internal</span>:
<a name="l03585"></a>03585         TermParameter(Term^ t) : m_value(t) {}
<a name="l03586"></a>03586     <span class="keyword">public</span>:
<a name="l03587"></a>03587         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value-&gt;ToString(); }
<a name="l03588"></a>03588         <span class="keyword">property</span>  Term^ GetTerm {  Term^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l03589"></a>03589     };
<a name="l03590"></a>03590 
<a name="l03591"></a>03591     <span class="keyword">public ref class</span> SortParameter : <span class="keyword">public</span> IParameter  { 
<a name="l03592"></a>03592         Sort^ m_value;
<a name="l03593"></a>03593     <span class="keyword">internal</span>:
<a name="l03594"></a>03594         SortParameter(Sort^ s): m_value(s) {}
<a name="l03595"></a>03595     <span class="keyword">public</span>:
<a name="l03596"></a>03596         <span class="keyword">property</span>  Sort^ GetSort {  Sort^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l03597"></a>03597         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value-&gt;ToString(); }
<a name="l03598"></a>03598     };
<a name="l03599"></a>03599 
<a name="l03600"></a>03600     <span class="keyword">public ref class</span> FuncDeclParameter : <span class="keyword">public</span> IParameter  { 
<a name="l03601"></a>03601         FuncDecl^ m_value;
<a name="l03602"></a>03602     <span class="keyword">internal</span>:
<a name="l03603"></a>03603         FuncDeclParameter(FuncDecl^ d): m_value(d) {}
<a name="l03604"></a>03604     <span class="keyword">public</span>:
<a name="l03605"></a>03605         <span class="keyword">property</span>  FuncDecl^ GetFuncDecl { FuncDecl^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_value; } }
<a name="l03606"></a>03606         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_value-&gt;ToString(); } 
<a name="l03607"></a>03607     };
<a name="l03608"></a>03608 
<a name="l03612"></a><a class="code" href="class_microsoft_1_1_z3_1_1_term_proof.html">03612</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_term_proof.html" title="Term and optional proof object returned by user-simplifier.">TermProof</a> {
<a name="l03613"></a>03613         Term^ m_term;
<a name="l03614"></a>03614         Term^ m_proof; <span class="comment">// proof is optional, use null for absence of proofs.</span>
<a name="l03615"></a>03615     <span class="keyword">public</span>:
<a name="l03616"></a>03616         <a class="code" href="class_microsoft_1_1_z3_1_1_term_proof.html" title="Term and optional proof object returned by user-simplifier.">TermProof</a>(Term^ term, Term^ proof): m_term(term), m_proof(proof) {}
<a name="l03617"></a>03617         <span class="keyword">property</span> Term^ GetTerm { Term^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_term; } }
<a name="l03618"></a>03618         <span class="keyword">property</span> Term^ Proof { Term^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_proof; } }
<a name="l03619"></a>03619     };
<a name="l03620"></a>03620 
<a name="l03624"></a><a class="code" href="class_microsoft_1_1_z3_1_1_context.html">03624</a>     <span class="keyword">public ref class</span> <a class="code" href="class_microsoft_1_1_z3_1_1_context.html" title="Type safe contexts.">Context</a>  {
<a name="l03625"></a>03625         
<a name="l03627"></a>03627         <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ m_ctx;
<a name="l03628"></a>03628 
<a name="l03629"></a>03629 
<a name="l03630"></a>03630     <span class="keyword">public</span>:
<a name="l03631"></a>03631         <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tptr, <span class="keyword">class</span> T&gt;
<a name="l03632"></a>03632         array&lt;Tptr&gt;^ CopyArray(array&lt;T^&gt;^ a) {
<a name="l03633"></a>03633             <span class="keywordflow">if</span> (!a) {
<a name="l03634"></a>03634                 <span class="keywordflow">return</span> <span class="keyword">gcnew</span> array&lt;Tptr&gt;(0);
<a name="l03635"></a>03635             }
<a name="l03636"></a>03636             <span class="keywordtype">int</span> len = a-&gt;Length;
<a name="l03637"></a>03637             array&lt;Tptr&gt;^ result = <span class="keyword">gcnew</span> array&lt;Tptr&gt;(len);
<a name="l03638"></a>03638             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i) {
<a name="l03639"></a>03639                 <span class="keywordflow">if</span> (a[i]) {
<a name="l03640"></a>03640                     result[i] = a[i]();
<a name="l03641"></a>03641                 }
<a name="l03642"></a>03642                 <span class="keywordflow">else</span> {
<a name="l03643"></a>03643                     result[i] = IntPtr(0);
<a name="l03644"></a>03644                 }
<a name="l03645"></a>03645             }
<a name="l03646"></a>03646             <span class="keywordflow">return</span> result;
<a name="l03647"></a>03647         }
<a name="l03648"></a>03648 
<a name="l03649"></a>03649         array&lt;SortPtr&gt;^ CopyArray(array&lt;Sort^&gt;^ a) {
<a name="l03650"></a>03650             <span class="keywordflow">return</span> CopyArray&lt;SortPtr, Sort&gt;(a);
<a name="l03651"></a>03651         }
<a name="l03652"></a>03652 
<a name="l03653"></a>03653         array&lt;FuncDeclPtr&gt;^ CopyArray(array&lt;FuncDecl^&gt;^ a) {
<a name="l03654"></a>03654             <span class="keywordflow">return</span> CopyArray&lt;FuncDeclPtr, FuncDecl&gt;(a);
<a name="l03655"></a>03655         }
<a name="l03656"></a>03656 
<a name="l03657"></a>03657         array&lt;TermPtr&gt;^ CopyArray(array&lt;Term^&gt;^ a) {
<a name="l03658"></a>03658             <span class="keywordflow">return</span> CopyArray&lt;TermPtr,Term&gt;(a);
<a name="l03659"></a>03659         }
<a name="l03660"></a>03660 
<a name="l03661"></a>03661         array&lt;PatternPtr&gt;^ CopyArray(array&lt;Pattern^&gt;^ a) {
<a name="l03662"></a>03662             <span class="keywordflow">return</span> CopyArray&lt;PatternPtr,Pattern&gt;(a);
<a name="l03663"></a>03663         }
<a name="l03664"></a>03664     <span class="keyword">internal</span>:
<a name="l03665"></a>03665 
<a name="l03666"></a>03666         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> TPtr&gt;
<a name="l03667"></a>03667         <span class="keyword">static</span> array&lt;T^&gt;^ CopyAstArray(<a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ ctx, array&lt;TPtr&gt;^ a) {
<a name="l03668"></a>03668             <span class="keywordflow">if</span> (!a) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l03669"></a>03669             <span class="keywordtype">int</span> len = a-&gt;Length;
<a name="l03670"></a>03670             array&lt;T^&gt;^ result = <span class="keyword">gcnew</span> array&lt;T^&gt;(len);
<a name="l03671"></a>03671 
<a name="l03672"></a>03672             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; ++i) {
<a name="l03673"></a>03673                 <span class="keywordflow">if</span> (a[i] != IntPtr(0)) {
<a name="l03674"></a>03674                     result[i] = <span class="keyword">gcnew</span> T(ctx,a[i]);
<a name="l03675"></a>03675                 }
<a name="l03676"></a>03676                 <span class="keywordflow">else</span> {
<a name="l03677"></a>03677                     result[i] = <span class="keyword">nullptr</span>;
<a name="l03678"></a>03678                 }
<a name="l03679"></a>03679             }
<a name="l03680"></a>03680             <span class="keywordflow">return</span> result;
<a name="l03681"></a>03681         }
<a name="l03682"></a>03682 
<a name="l03683"></a>03683     <span class="keyword">public</span>:
<a name="l03684"></a>03684         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> TPtr&gt;
<a name="l03685"></a>03685         array&lt;T^&gt;^ CopyAstArray(array&lt;TPtr&gt;^ a) {
<a name="l03686"></a>03686             <span class="keywordflow">return</span> CopyAstArray&lt;T,TPtr&gt;(m_ctx, a);
<a name="l03687"></a>03687         }
<a name="l03688"></a>03688 
<a name="l03689"></a>03689 
<a name="l03690"></a>03690         array&lt;Sort^&gt;^ CopySortArray(array&lt;SortPtr&gt;^ a) {
<a name="l03691"></a>03691             <span class="keywordflow">return</span> CopyAstArray&lt;Sort, SortPtr&gt;(a);
<a name="l03692"></a>03692         }
<a name="l03693"></a>03693 
<a name="l03694"></a>03694         array&lt;Term^&gt;^ CopyTermArray(array&lt;TermPtr&gt;^ a) {
<a name="l03695"></a>03695             <span class="keywordflow">return</span> CopyAstArray&lt;Term, TermPtr&gt;(a);
<a name="l03696"></a>03696         }
<a name="l03697"></a>03697 
<a name="l03698"></a>03698         array&lt;FuncDecl^&gt;^ CopyFuncDeclArray(array&lt;FuncDeclPtr&gt;^ a) {
<a name="l03699"></a>03699             <span class="keywordflow">return</span> CopyAstArray&lt;FuncDecl, FuncDeclPtr&gt;(a);
<a name="l03700"></a>03700         }
<a name="l03701"></a>03701     <span class="keyword">internal</span>:
<a name="l03702"></a>03702         <span class="keyword">static</span> array&lt;Term^&gt;^ CopyTermArray(<a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ ctx, array&lt;TermPtr&gt;^ a) {
<a name="l03703"></a>03703             <span class="keywordflow">return</span> CopyAstArray&lt;Term, TermPtr&gt;(ctx, a);
<a name="l03704"></a>03704         }
<a name="l03705"></a>03705 
<a name="l03706"></a>03706         <span class="keyword">static</span> array&lt;Sort^&gt;^ CopySortArray(<a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ ctx, array&lt;SortPtr&gt;^ a) {
<a name="l03707"></a>03707             <span class="keywordflow">return</span> CopyAstArray&lt;Sort, SortPtr&gt;(ctx, a);
<a name="l03708"></a>03708         }
<a name="l03709"></a>03709         <span class="keyword">static</span> Quantifier^ GetQuantifier(<a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ ctx, Term^ term);
<a name="l03710"></a>03710 
<a name="l03711"></a>03711     <span class="keyword">internal</span>:
<a name="l03712"></a>03712         <span class="keyword">property</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ GetContext { <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_ctx; } }
<a name="l03713"></a>03713 
<a name="l03715"></a>03715 
<a name="l03716"></a>03716 
<a name="l03717"></a>03717     <span class="keyword">public</span>:
<a name="l03730"></a><a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a7540648fc201ffee17e0cdea0888a6f7">03730</a>         <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a7540648fc201ffee17e0cdea0888a6f7" title="Create a type safe version of a context.">Context</a>() { m_ctx = <span class="keyword">gcnew</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>(); }
<a name="l03731"></a>03731 
<a name="l03732"></a>03732         <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a7540648fc201ffee17e0cdea0888a6f7" title="Create a type safe version of a context.">Context</a>(<a class="code" href="class_microsoft_1_1_z3_1_1_config.html" title="Configuration.">Config</a>^ config) : m_ctx(gcnew <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html" title="Z3 API object.">RawContext</a>(config)) {}
<a name="l03733"></a>03733 
<a name="l03734"></a>03734         <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a7540648fc201ffee17e0cdea0888a6f7" title="Create a type safe version of a context.">Context</a>(Config^ config, ReferenceCounted^ rc) : m_ctx(gcnew RawContext(config, rc)) {}
<a name="l03735"></a>03735 
<a name="l03739"></a><a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a744ae2a046b90c3685f19b9edb14ad08">03739</a>         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a744ae2a046b90c3685f19b9edb14ad08" title="Set the context from an externally created context.">SetContext</a>(Z3_context ctx){ m_ctx-&gt;SetContext(ctx); }
<a name="l03740"></a>03740 
<a name="l03744"></a><a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ad2cdbdf8ca6efd618beb4f0c416e02f9">03744</a>         <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ad2cdbdf8ca6efd618beb4f0c416e02f9" title="Dispose method for type safe contexts.">~Context</a>() { m_ctx-&gt;Reset(); }
<a name="l03745"></a>03745 
<a name="l03752"></a><a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ae767eef7c521b644401e58a4adfb11a6">03752</a>         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ae767eef7c521b644401e58a4adfb11a6" title="Enable low-level debug tracing.">EnableDebugTrace</a>(String^ tag) { m_ctx-&gt;EnableDebugTrace(tag); }
<a name="l03753"></a>03753 
<a name="l03761"></a><a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a74d274e8e6fc3ccc4ac39a375c0cc536">03761</a>         <span class="keywordtype">void</span> <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a74d274e8e6fc3ccc4ac39a375c0cc536" title="Enable or disable warning messages sent to the console out/error.">ToggleWarningMessages</a>(<span class="keywordtype">bool</span> enabled) { m_ctx-&gt;ToggleWarningMessages(enabled); }
<a name="l03762"></a>03762 
<a name="l03763"></a>03763         <span class="keywordtype">void</span> UpdateParamValue(String^ param_id, String^ value) { m_ctx-&gt;UpdateParamValue(param_id, value); }
<a name="l03764"></a>03764 
<a name="l03765"></a>03765         String^ GetParamValue(String^ param_id) {
<a name="l03766"></a>03766             <span class="keywordflow">return</span> m_ctx-&gt;GetParamValue(param_id);
<a name="l03767"></a>03767         }
<a name="l03768"></a>03768 
<a name="l03773"></a><a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a925fd320cf1476d3b08d70f169c6790d">03773</a>         <span class="keywordtype">bool</span> <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a925fd320cf1476d3b08d70f169c6790d" title="Configure the SMTLIB logic to be used in the given logical context.">SetLogic</a>(String^ logic) { <span class="keywordflow">return</span> m_ctx-&gt;SetLogic(logic); }
<a name="l03774"></a>03774 
<a name="l03779"></a>03779         <a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ MkSymbol(<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> m_ctx-&gt;MkSymbol(i); }
<a name="l03780"></a>03780 
<a name="l03781"></a>03781         Symbol^ MkSymbol(String^ s) { <span class="keywordflow">return</span> m_ctx-&gt;MkSymbol(s); }
<a name="l03788"></a>03788 
<a name="l03794"></a><a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a5a3ac3b1e5482150708ba24cddaf1f4d">03794</a>         Term^ <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a5a3ac3b1e5482150708ba24cddaf1f4d" title="Update the arguments of a term or quantifier.">UpdateTerm</a>(Term^ t, array&lt;Term^&gt;^ new_args) {
<a name="l03795"></a>03795             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;UpdateTerm(t(), CopyArray(new_args)));
<a name="l03796"></a>03796         }
<a name="l03797"></a>03797         
<a name="l03804"></a>03804         <span class="keywordtype">void</span> Push() { m_ctx-&gt;Push(); }
<a name="l03805"></a>03805         <span class="keywordtype">void</span> Pop(<span class="keywordtype">unsigned</span> num_scopes) { m_ctx-&gt;Pop(num_scopes); }
<a name="l03806"></a>03806         <span class="keywordtype">void</span> Pop() { Pop(1); }
<a name="l03807"></a>03807         <span class="keywordtype">unsigned</span> GetNumScopes() { <span class="keywordflow">return</span> m_ctx-&gt;GetNumScopes(); }
<a name="l03808"></a>03808         <span class="keywordtype">void</span> PersistTerm(Term^ t, <span class="keywordtype">unsigned</span> num_scopes) { 
<a name="l03809"></a>03809             m_ctx-&gt;PersistTerm(t(), num_scopes); 
<a name="l03810"></a>03810         }
<a name="l03811"></a>03811         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> Check() { <span class="keywordflow">return</span> m_ctx-&gt;Check(); }
<a name="l03812"></a>03812         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> CheckAndGetModel([Out] Model^% m);
<a name="l03813"></a>03813         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> CheckAssumptions([Out] Model^% m, 
<a name="l03814"></a>03814                                [In]  array&lt;Term^&gt;^ assumptions, 
<a name="l03815"></a>03815                                [Out] Term^% proof, 
<a name="l03816"></a>03816                                [Out] array&lt;Term^&gt;^% core);
<a name="l03817"></a>03817         <span class="keywordtype">void</span> SoftCheckCancel();
<a name="l03818"></a>03818 
<a name="l03819"></a>03819         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> GetImpliedEqualities(
<a name="l03820"></a>03820             [In]  array&lt;Term^&gt;^ terms,
<a name="l03821"></a>03821             [Out] array&lt;unsigned&gt;^% class_ids);
<a name="l03822"></a>03822 
<a name="l03823"></a>03823         <a class="code" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e" title="Different failure kinds.">SearchFailureExplanation</a> GetSearchFailureExplanation() { <span class="keywordflow">return</span> m_ctx-&gt;GetSearchFailureExplanation(); }
<a name="l03824"></a>03824         LabeledLiterals^ GetRelevantLabels() { <span class="keywordflow">return</span> m_ctx-&gt;GetRelevantLabels(); }
<a name="l03825"></a>03825         LabeledLiterals^ GetRelevantLiterals() { <span class="keywordflow">return</span> m_ctx-&gt;GetRelevantLiterals(); }
<a name="l03826"></a>03826         LabeledLiterals^ GetGuessedLiterals() { <span class="keywordflow">return</span> m_ctx-&gt;GetGuessedLiterals(); }
<a name="l03827"></a>03827         <span class="keywordtype">void</span> BlockLiterals(LabeledLiterals^ lbls) { m_ctx-&gt;BlockLiterals(lbls); }
<a name="l03828"></a>03828         Term^ GetLiteral(LabeledLiterals^ lbls, <span class="keywordtype">unsigned</span> idx) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;GetLiteral(lbls, idx)); }
<a name="l03829"></a>03829         Term^ Simplify(Term^ a) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;Simplify(a())); }
<a name="l03830"></a>03830         <span class="keywordtype">void</span> AssertCnstr(Term^ a) { m_ctx-&gt;AssertCnstr(a()); }
<a name="l03833"></a>03833         <span class="keyword">virtual</span> String^ ToString()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> m_ctx-&gt;ToString(); }
<a name="l03834"></a>03834 
<a name="l03835"></a>03835         <span class="keywordtype">void</span> Display(System::IO::TextWriter^ w) { m_ctx-&gt;Display(w); }
<a name="l03836"></a>03836         Term^ GetAssignments() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;GetAssignments()); }
<a name="l03837"></a>03837         String^ StatisticsToString() { <span class="keywordflow">return</span> m_ctx-&gt;StatisticsToString(); }
<a name="l03838"></a>03838         <span class="keywordtype">void</span> DisplayStatistics(System::IO::TextWriter^ w) { m_ctx-&gt;DisplayStatistics(w); }
<a name="l03839"></a>03839 
<a name="l03843"></a>03843         String^ <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a5d16d7cb12df6994c0dda71a36922fbf" title="Convert the given benchmark into SMT-LIB formatted string.">BenchmarkToSmtlib</a>(String^ name,
<a name="l03844"></a>03844                                   String^ logic,
<a name="l03845"></a>03845                                   String^ status,
<a name="l03846"></a>03846                                   String^ attributes,
<a name="l03847"></a>03847                                   array&lt;Term^&gt;^ assumptions,
<a name="l03848"></a>03848                                   Term^ formula);
<a name="l03849"></a>03849 
<a name="l03850"></a>03850         <span class="keywordtype">void</span> ParseSmtlibString(
<a name="l03851"></a>03851             String^            <span class="keywordtype">string</span>,
<a name="l03852"></a>03852             [In]  array&lt;Sort^&gt;^     sorts,
<a name="l03853"></a>03853             [In]  array&lt;FuncDecl^&gt;^ decls,
<a name="l03854"></a>03854             [Out] array&lt;Term^&gt;^%    assumptions,            
<a name="l03855"></a>03855             [Out] array&lt;Term^&gt;^%    formulas,
<a name="l03856"></a>03856             [Out] array&lt;FuncDecl^&gt;^% new_decls,
<a name="l03857"></a>03857             [Out] array&lt;Sort^&gt;^%    new_sorts,
<a name="l03858"></a>03858             [Out] String^% parser_out
<a name="l03859"></a>03859             );
<a name="l03860"></a>03860                                          
<a name="l03861"></a>03861 
<a name="l03862"></a>03862         <span class="keywordtype">void</span> ParseSmtlibFile(
<a name="l03863"></a>03863             String^ file,
<a name="l03864"></a>03864             [In]  array&lt;Sort^&gt;^     sorts,
<a name="l03865"></a>03865             [In]  array&lt;FuncDecl^&gt;^ decls,
<a name="l03866"></a>03866             [Out] array&lt;Term^&gt;^%    assumptions,            
<a name="l03867"></a>03867             [Out] array&lt;Term^&gt;^%    formulas,
<a name="l03868"></a>03868             [Out] array&lt;FuncDecl^&gt;^% new_decls,
<a name="l03869"></a>03869             [Out] array&lt;Sort^&gt;^%    new_sorts,
<a name="l03870"></a>03870             [Out] String^% parser_out
<a name="l03871"></a>03871             );
<a name="l03872"></a>03872 
<a name="l03873"></a>03873 
<a name="l03874"></a>03874         Term^ ParseZ3String(String^ s) {
<a name="l03875"></a>03875             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ParseZ3String(s));
<a name="l03876"></a>03876         }
<a name="l03877"></a>03877 
<a name="l03878"></a>03878         Term^ ParseZ3File(String^ s) {
<a name="l03879"></a>03879             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ParseZ3File(s));
<a name="l03880"></a>03880         }
<a name="l03881"></a>03881 
<a name="l03882"></a>03882         Term^ ParseSmtlib2String(String^ s, array&lt;Sort^&gt;^ sorts, array&lt;FuncDecl^&gt;^ decls) {
<a name="l03883"></a>03883             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ParseSmtlib2String(s, CopyArray(sorts), CopyArray(decls)));
<a name="l03884"></a>03884         }
<a name="l03885"></a>03885 
<a name="l03886"></a>03886         Term^ ParseSmtlib2File(String^ s, array&lt;Sort^&gt;^ sorts, array&lt;FuncDecl^&gt;^ decls) {
<a name="l03887"></a>03887             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ParseSmtlib2File(s, CopyArray(sorts), CopyArray(decls)));
<a name="l03888"></a>03888         }
<a name="l03889"></a>03889 
<a name="l03890"></a>03890         Term^ ExecSmtlib2String(String^ s, array&lt;Sort^&gt;^ sorts, array&lt;FuncDecl^&gt;^ decls) {
<a name="l03891"></a>03891             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ExecSmtlib2String(s, CopyArray(sorts), CopyArray(decls)));
<a name="l03892"></a>03892         }
<a name="l03893"></a>03893 
<a name="l03894"></a>03894         Term^ ExecSmtlib2File(String^ s, array&lt;Sort^&gt;^ sorts, array&lt;FuncDecl^&gt;^ decls) {
<a name="l03895"></a>03895             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;ExecSmtlib2File(s, CopyArray(sorts), CopyArray(decls)));
<a name="l03896"></a>03896         }
<a name="l03897"></a>03897 
<a name="l03898"></a>03898         <span class="keyword">static</span> <span class="keywordtype">void</span> SetErrorHandler(IErrorHandler^ h) {
<a name="l03899"></a>03899             <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a22af33e79aad8e443bfe2c249c6255ef" title="Register a Z3 error handler.">RawContext::SetErrorHandler</a>(h);
<a name="l03900"></a>03900         }
<a name="l03901"></a>03901 
<a name="l03902"></a>03902         <span class="keyword">static</span> String^ GetErrorMessage(<a class="code" href="group__mapi.html#ga59e56af19e754a6aa26a612ebf91d05f" title="Z3 error codes.">ErrorCode</a> err) {
<a name="l03903"></a>03903             <span class="keywordflow">return</span> <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8478b135914c2e8c78127a50361331c4" title="Return a string describing the given error code.">RawContext::GetErrorMessage</a>(err);
<a name="l03904"></a>03904         }
<a name="l03905"></a>03905 
<a name="l03906"></a>03906         <span class="keyword">static</span> <span class="keywordtype">void</span> ResetMemory() {
<a name="l03907"></a>03907             <a class="code" href="class_microsoft_1_1_z3_1_1_raw_context.html#a6bcc908b9ba41cd95dae64006321b34b" title="Free all resources allocated for Z3.">RawContext::ResetMemory</a>();
<a name="l03908"></a>03908         }
<a name="l03909"></a>03909 
<a name="l03910"></a>03910         
<a name="l03911"></a>03911         <span class="keywordtype">void</span> SetPrintMode(<a class="code" href="group__mapi.html#ga8fcc700aeeee633213b4e5f433e5e12e" title="Z3 pretty printing modes used when pretty printing terms.">PrintMode</a> mode) { m_ctx-&gt;SetPrintMode(mode); }
<a name="l03912"></a>03912 
<a name="l03913"></a>03913         String^ ToString(Ast^ a) { <span class="keywordflow">return</span> m_ctx-&gt;ToString(a()); }
<a name="l03914"></a>03914         
<a name="l03915"></a>03915         <span class="keywordtype">void</span> Display(System::IO::TextWriter^ w, Ast^ a) { m_ctx-&gt;Display(w, a()); }
<a name="l03916"></a>03916 
<a name="l03917"></a>03917 
<a name="l03918"></a>03918         Sort^ MkIntSort() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkIntSort()); }
<a name="l03919"></a>03919         Sort^ MkBoolSort() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkBoolSort()); }
<a name="l03920"></a>03920         Sort^ MkSort(Symbol^ s) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkSort(s)); }
<a name="l03921"></a>03921         Sort^ MkSort(String^ s) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkSort(s)); }
<a name="l03922"></a>03922         Sort^ MkSort(<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkSort(i)); }   
<a name="l03923"></a>03923         Sort^ MkFiniteDomainSort(String^ s, <span class="keywordtype">unsigned</span> __int64 domain_size) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx, m_ctx-&gt;MkFiniteDomainSort(s, domain_size)); }
<a name="l03924"></a>03924         Sort^ MkRealSort() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkRealSort()); } 
<a name="l03925"></a>03925         Sort^ MkBvSort(<span class="keywordtype">unsigned</span> sz) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkBvSort(sz)); }
<a name="l03926"></a>03926         Sort^ MkArraySort(Sort^ domain, Sort^ range) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkArraySort(domain(), range())); }
<a name="l03927"></a>03927 
<a name="l03928"></a>03928         Sort^ MkTupleSort(
<a name="l03929"></a>03929             Symbol^               mk_tuple_name, 
<a name="l03930"></a>03930             array&lt;Symbol^&gt;^       field_names,
<a name="l03931"></a>03931             array&lt;Sort^&gt;^       field_types,
<a name="l03932"></a>03932             [Out] FuncDecl^%         mk_tuple_decl,
<a name="l03933"></a>03933             [In, Out] array&lt;FuncDecl^&gt;^  proj_decl
<a name="l03934"></a>03934             );
<a name="l03935"></a>03935 
<a name="l03936"></a>03936         Sort^ MkTupleSort(
<a name="l03937"></a>03937             String^               mk_tuple_name, 
<a name="l03938"></a>03938             array&lt;String^&gt;^       field_names,
<a name="l03939"></a>03939             array&lt;Sort^&gt;^       field_types,
<a name="l03940"></a>03940             [Out] FuncDecl^%         mk_tuple_decl,
<a name="l03941"></a>03941             [In, Out] array&lt;FuncDecl^&gt;^  proj_decl
<a name="l03942"></a>03942             );
<a name="l03943"></a>03943         
<a name="l03944"></a>03944         Sort^ MkEnumerationSort(
<a name="l03945"></a>03945             String^             name,
<a name="l03946"></a>03946             array&lt;String^&gt;^     enum_names,
<a name="l03947"></a>03947             array&lt;FuncDecl^&gt;^ enum_consts,
<a name="l03948"></a>03948             array&lt;FuncDecl^&gt;^ enum_testers);
<a name="l03949"></a>03949 
<a name="l03950"></a>03950         Sort^ MkListSort(
<a name="l03951"></a>03951             String^ name,
<a name="l03952"></a>03952             Sort^ elem_sort,
<a name="l03953"></a>03953             [Out] FuncDecl^% nil_decl,
<a name="l03954"></a>03954             [Out] FuncDecl^% is_nil_decl,
<a name="l03955"></a>03955             [Out] FuncDecl^% cons_decl,
<a name="l03956"></a>03956             [Out] FuncDecl^% is_cons_decl,
<a name="l03957"></a>03957             [Out] FuncDecl^% head_decl,
<a name="l03958"></a>03958             [Out] FuncDecl^% tail_decl
<a name="l03959"></a>03959             );
<a name="l03960"></a>03960         
<a name="l03961"></a>03961         Constructor^ MkConstructor(
<a name="l03962"></a>03962             String^ name,
<a name="l03963"></a>03963             String^ tester,
<a name="l03964"></a>03964             array&lt;String^&gt;^ field_names,
<a name="l03965"></a>03965             array&lt;Sort^&gt;^ field_sorts,
<a name="l03966"></a>03966             array&lt;unsigned&gt;^ field_refs
<a name="l03967"></a>03967             );
<a name="l03968"></a>03968 
<a name="l03969"></a>03969         
<a name="l03970"></a>03970         FuncDecl^ GetConstructor(Constructor^ c);
<a name="l03971"></a>03971 
<a name="l03972"></a>03972         FuncDecl^ GetTester(Constructor^ c);
<a name="l03973"></a>03973 
<a name="l03974"></a>03974         array&lt;FuncDecl^&gt;^ GetAccessors(Constructor^ c);
<a name="l03975"></a>03975 
<a name="l03980"></a><a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ace7e5666615a724df78e10093a19e70f">03980</a>         Sort^ <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ace7e5666615a724df78e10093a19e70f" title="create datatype sort.">MkDataType</a>(
<a name="l03981"></a>03981             String^ name,
<a name="l03982"></a>03982             array&lt;Constructor^&gt;^ constructors
<a name="l03983"></a>03983             ) {
<a name="l03984"></a>03984             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx, m_ctx-&gt;MkDataType(name, constructors));
<a name="l03985"></a>03985         }
<a name="l03986"></a>03986 
<a name="l03991"></a><a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a9888fb987071bd35392f5d6b33353f31">03991</a>         array&lt;Sort^&gt;^ <a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a9888fb987071bd35392f5d6b33353f31" title="create datatype sort.">MkDataTypes</a>(
<a name="l03992"></a>03992             array&lt;String^&gt;^ names,
<a name="l03993"></a>03993             array&lt;array&lt;Constructor^&gt;^&gt;^ constructors
<a name="l03994"></a>03994             ) {
<a name="l03995"></a>03995             <span class="keywordflow">return</span> CopySortArray(m_ctx-&gt;MkDataTypes(names, constructors));
<a name="l03996"></a>03996         }
<a name="l03997"></a>03997 
<a name="l03998"></a>03998 
<a name="l03999"></a>03999         FuncDecl^ MkFuncDecl(<a class="code" href="class_microsoft_1_1_z3_1_1_symbol.html" title="Symbol.">Symbol</a>^ s, array&lt;Sort^&gt;^ domain, Sort^ range) {
<a name="l04000"></a>04000             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, CopyArray(domain), range()));
<a name="l04001"></a>04001         }
<a name="l04002"></a>04002 
<a name="l04003"></a>04003         FuncDecl^ MkFuncDecl(String^ s, array&lt;Sort^&gt;^ domain, Sort^ range) {
<a name="l04004"></a>04004             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, CopyArray(domain), range()));
<a name="l04005"></a>04005         }
<a name="l04006"></a>04006 
<a name="l04007"></a>04007         FuncDecl^ MkConstDecl(Symbol^ s, Sort^ ty) {
<a name="l04008"></a>04008             <span class="keywordflow">return</span> MkFuncDecl(s, <span class="keyword">gcnew</span> array&lt;Sort^&gt;(0), ty);
<a name="l04009"></a>04009         }
<a name="l04010"></a>04010         FuncDecl^ MkFuncDecl(Symbol^ s, Sort^ domain, Sort^ range) {
<a name="l04011"></a>04011             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, domain(), range()));
<a name="l04012"></a>04012         }
<a name="l04013"></a>04013         FuncDecl^ MkFuncDecl(Symbol^ s, Sort^ d1, Sort^ d2, Sort^ range) {
<a name="l04014"></a>04014             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, d1(), d2(), range()));            
<a name="l04015"></a>04015         }
<a name="l04016"></a>04016         FuncDecl^ MkConstDecl(String^ s, Sort^ ty) {
<a name="l04017"></a>04017             <span class="keywordflow">return</span> MkFuncDecl(s, <span class="keyword">gcnew</span> array&lt;Sort^&gt;(0), ty);
<a name="l04018"></a>04018         }
<a name="l04019"></a>04019         FuncDecl^ MkFuncDecl(String^ s, Sort^ domain, Sort^ range) {
<a name="l04020"></a>04020             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, domain(), range()));
<a name="l04021"></a>04021         }
<a name="l04022"></a>04022         FuncDecl^ MkFuncDecl(String^ s, Sort^ d1, Sort^ d2, Sort^ range) {
<a name="l04023"></a>04023             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFuncDecl(s, d1(), d2(), range()));            
<a name="l04024"></a>04024         }
<a name="l04025"></a>04025         Term^ MkApp(FuncDecl^ d, array&lt;Term^&gt;^ args) {
<a name="l04026"></a>04026             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkApp(d(), CopyArray(args)));
<a name="l04027"></a>04027         }
<a name="l04028"></a>04028         Term^ MkApp(FuncDecl^ d, Term^ arg) {
<a name="l04029"></a>04029             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkApp(d(), arg()));
<a name="l04030"></a>04030         }
<a name="l04031"></a>04031         Term^ MkApp(FuncDecl^ d, Term^ arg1, Term^ arg2) {
<a name="l04032"></a>04032             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkApp(d(), arg1(), arg2()));
<a name="l04033"></a>04033         }
<a name="l04034"></a>04034         Term^ MkApp(FuncDecl^ d, Term^ arg1, Term^ arg2, Term^ arg3) {
<a name="l04035"></a>04035             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkApp(d(), arg1(), arg2(), arg3()));
<a name="l04036"></a>04036         }
<a name="l04037"></a>04037         Term^ MkConst(FuncDecl^ d) {
<a name="l04038"></a>04038             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkConst(d()));
<a name="l04039"></a>04039         }
<a name="l04040"></a>04040         Term^ MkConst(String^ s, Sort^ ty) {
<a name="l04041"></a>04041             <span class="keywordflow">return</span> <span class="keyword">gcnew</span>  Term(m_ctx,m_ctx-&gt;MkConst(s,ty()));
<a name="l04042"></a>04042         }
<a name="l04043"></a>04043         Term^ MkConst(Symbol^ s, Sort^ ty) {
<a name="l04044"></a>04044             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkConst(s, ty()));
<a name="l04045"></a>04045         }
<a name="l04046"></a>04046         FuncDecl^ MkFreshFuncDecl(String^ prefix, array&lt;Sort^&gt;^ domain, Sort^ range) {
<a name="l04047"></a>04047             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkFreshFuncDecl(prefix, CopyArray(domain), range()));
<a name="l04048"></a>04048         }
<a name="l04049"></a>04049         Term^ MkFreshConst(String^ prefix, Sort^ ty) {
<a name="l04050"></a>04050             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkFreshConst(prefix, ty()));
<a name="l04051"></a>04051         }
<a name="l04052"></a>04052         Term^ MkTrue() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkTrue()); }
<a name="l04053"></a>04053         Term^ MkFalse() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkFalse()); }
<a name="l04054"></a>04054         Term^ MkLabel(Symbol^ name, <span class="keywordtype">bool</span> pos, Term^ fml) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkLabel(name, pos, fml())); }
<a name="l04055"></a>04055 
<a name="l04056"></a>04056         Term^ MkEq(Term^ l, Term^ r) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkEq(l(), r())); }
<a name="l04057"></a>04057         Term^ MkDistinct(array&lt;Term^&gt;^ args) {
<a name="l04058"></a>04058             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkDistinct(CopyArray(args))); 
<a name="l04059"></a>04059         }
<a name="l04060"></a>04060         Term^ MkNot(Term^ arg) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNot(arg())); }
<a name="l04061"></a>04061         Term^ MkIte(Term^ t1, Term^ t2, Term^ t3) {
<a name="l04062"></a>04062             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkIte(t1(), t2(), t3()));
<a name="l04063"></a>04063         }
<a name="l04064"></a>04064         Term^ MkIff(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkIff(t1(), t2()));  }
<a name="l04065"></a>04065         Term^ MkImplies(Term^ t1, Term^ t2) {<span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkImplies(t1(), t2()));}
<a name="l04066"></a>04066         Term^ MkXor(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkXor(t1(), t2())); }
<a name="l04067"></a>04067         Term^ MkAnd(array&lt;Term^&gt;^ args) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkAnd(CopyArray(args))); }
<a name="l04068"></a>04068         Term^ MkAnd(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkAnd(t1(), t2())); }
<a name="l04069"></a>04069         Term^ MkOr(array&lt;Term^&gt;^ args) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkOr(CopyArray(args))); }
<a name="l04070"></a>04070         Term^ MkOr(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkOr(t1(), t2())); }
<a name="l04071"></a>04071         Term^ MkAdd(array&lt;Term^&gt;^ args) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkAdd(CopyArray(args))); }
<a name="l04072"></a>04072         Term^ MkAdd(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkAdd(t1(), t2())); }
<a name="l04073"></a>04073         Term^ MkMul(array&lt;Term^&gt;^ args) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkMul(CopyArray(args))); }
<a name="l04074"></a>04074         Term^ MkMul(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkMul(t1(), t2())); }
<a name="l04075"></a>04075         Term^ MkSub(array&lt;Term^&gt;^ args) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSub(CopyArray(args))); }
<a name="l04076"></a>04076         Term^ MkSub(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSub(t1(), t2())); }
<a name="l04077"></a>04077         Term^ MkUnaryMinus(Term^ arg) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkUnaryMinus(arg())); }
<a name="l04078"></a>04078         Term^ MkDiv(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkDiv(t1(), t2())); }
<a name="l04079"></a>04079         Term^ MkMod(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkMod(t1(), t2())); }
<a name="l04080"></a>04080         Term^ MkRem(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkRem(t1(), t2())); }
<a name="l04081"></a>04081         Term^ MkToReal(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkToReal(t1())); }
<a name="l04082"></a>04082         Term^ MkToInt(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkToInt(t1())); }
<a name="l04083"></a>04083         Term^ MkIsInt(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkIsInt(t1())); }
<a name="l04084"></a>04084         Term^ MkLt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkLt(t1(), t2())); }
<a name="l04085"></a>04085         Term^ MkLe(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkLe(t1(), t2())); }
<a name="l04086"></a>04086         Term^ MkGt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkGt(t1(), t2())); }
<a name="l04087"></a>04087         Term^ MkGe(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkGe(t1(), t2())); }
<a name="l04088"></a>04088         Term^ MkBvNot(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvNot(t1())); }
<a name="l04089"></a>04089         Term^ MkBvReduceAnd(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvReduceAnd(t1())); }
<a name="l04090"></a>04090         Term^ MkBvRedcueOr(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvReduceOr(t1())); }
<a name="l04091"></a>04091         Term^ MkBvAnd(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvAnd(t1(), t2())); }
<a name="l04092"></a>04092         Term^ MkBvOr(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvOr(t1(), t2())); }
<a name="l04093"></a>04093         Term^ MkBvXor(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvXor(t1(), t2())); }
<a name="l04094"></a>04094         Term^ MkBvNand(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvNand(t1(), t2())); }
<a name="l04095"></a>04095         Term^ MkBvNor(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvNor(t1(), t2())); }
<a name="l04096"></a>04096         Term^ MkBvXnor(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvXnor(t1(), t2())); }
<a name="l04097"></a>04097         Term^ MkBvNeg(Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvNeg(t1())); }
<a name="l04098"></a>04098         Term^ MkBvAdd(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvAdd(t1(), t2())); }
<a name="l04099"></a>04099         Term^ MkBvSub(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSub(t1(), t2())); }
<a name="l04100"></a>04100         Term^ MkBvMul(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvMul(t1(), t2())); }
<a name="l04101"></a>04101         Term^ MkBvUdiv(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUdiv(t1(), t2())); }
<a name="l04102"></a>04102         Term^ MkBvSdiv(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSdiv(t1(), t2())); }
<a name="l04103"></a>04103         Term^ MkBvUrem(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUrem(t1(), t2())); }
<a name="l04104"></a>04104         Term^ MkBvSrem(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSrem(t1(), t2())); }
<a name="l04105"></a>04105         Term^ MkBvSmod(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSmod(t1(), t2())); }
<a name="l04106"></a>04106         Term^ MkBvUlt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUlt(t1(), t2())); }
<a name="l04107"></a>04107         Term^ MkBvSlt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSlt(t1(), t2())); }
<a name="l04108"></a>04108         Term^ MkBvUle(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUle(t1(), t2())); }
<a name="l04109"></a>04109         Term^ MkBvSle(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSle(t1(), t2())); }
<a name="l04110"></a>04110         Term^ MkBvUge(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUge(t1(), t2())); }
<a name="l04111"></a>04111         Term^ MkBvSge(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSge(t1(), t2())); }
<a name="l04112"></a>04112         Term^ MkBvUgt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvUgt(t1(), t2())); }
<a name="l04113"></a>04113         Term^ MkBvSgt(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSgt(t1(), t2())); }
<a name="l04114"></a>04114         Term^ MkBvConcat(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvConcat(t1(), t2())); }
<a name="l04115"></a>04115         Term^ MkBvExtract(<span class="keywordtype">unsigned</span> high, <span class="keywordtype">unsigned</span> low, Term^ t) {
<a name="l04116"></a>04116             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvExtract(high, low, t()));
<a name="l04117"></a>04117         }
<a name="l04118"></a>04118         Term^ MkBvSignExt(<span class="keywordtype">unsigned</span> i, Term^ t) {
<a name="l04119"></a>04119             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSignExt(i, t()));
<a name="l04120"></a>04120         }
<a name="l04121"></a>04121         Term^ MkBvZeroExt(<span class="keywordtype">unsigned</span> i, Term^ t) {
<a name="l04122"></a>04122             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvZeroExt(i, t()));
<a name="l04123"></a>04123         }
<a name="l04124"></a>04124         Term^ MkBvRepeat(<span class="keywordtype">unsigned</span> i, Term^ t) {
<a name="l04125"></a>04125             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvRepeat(i, t()));
<a name="l04126"></a>04126         }
<a name="l04127"></a>04127         Term^ MkBvShl(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvShl(t1(), t2())); }
<a name="l04128"></a>04128         Term^ MkBvLshr(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvLshr(t1(), t2())); }
<a name="l04129"></a>04129         Term^ MkBvAshr(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvAshr(t1(), t2())); }
<a name="l04130"></a>04130         Term^ MkBvRotateLeft(<span class="keywordtype">unsigned</span> i, Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvRotateLeft(i,t1())); }
<a name="l04131"></a>04131         Term^ MkBvRotateRight(<span class="keywordtype">unsigned</span> i, Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvRotateRight(i,t1()));  }
<a name="l04132"></a>04132         Term^ MkBvRotateLeft(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvRotateLeft(t1(), t2())); }
<a name="l04133"></a>04133         Term^ MkBvRotateRight(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvRotateRight(t1(), t2()));  }
<a name="l04134"></a>04134         Term^ MkBv2Int(Term^ t1, <span class="keywordtype">bool</span> is_signed) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;MkBv2Int(t1(), is_signed)); }
<a name="l04135"></a>04135         Term^ MkInt2Bv(<span class="keywordtype">unsigned</span> n, Term^ t1) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;MkInt2Bv(n, t1())); }
<a name="l04136"></a>04136         Term^ MkBvAddNoOverflow(Term^ t1, Term^ t2, <span class="keywordtype">bool</span> is_signed) { 
<a name="l04137"></a>04137             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvAddNoOverflow(t1(), t2(), is_signed)); 
<a name="l04138"></a>04138         }
<a name="l04139"></a>04139         Term^ MkBvAddNoUnderflow(Term^ t1, Term^ t2) { 
<a name="l04140"></a>04140             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvAddNoUnderflow(t1(), t2())); 
<a name="l04141"></a>04141         }
<a name="l04142"></a>04142         Term^ MkBvSubNoOverflow(Term^ t1, Term^ t2) { 
<a name="l04143"></a>04143             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSubNoOverflow(t1(), t2())); 
<a name="l04144"></a>04144         }
<a name="l04145"></a>04145         Term^ MkBvSubNoUnderflow(Term^ t1, Term^ t2, <span class="keywordtype">bool</span> is_signed) { 
<a name="l04146"></a>04146             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSubNoUnderflow(t1(), t2(), is_signed)); 
<a name="l04147"></a>04147         }
<a name="l04148"></a>04148         Term^ MkBvSDivNoOverflow(Term^ t1, Term^ t2) { 
<a name="l04149"></a>04149             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvSDivNoOverflow(t1(), t2())); 
<a name="l04150"></a>04150         }
<a name="l04151"></a>04151         Term^ MkBvNegNoOverflow(Term^ t1) { 
<a name="l04152"></a>04152             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvNegNoOverflow(t1())); 
<a name="l04153"></a>04153         }
<a name="l04154"></a>04154         Term^ MkBvMulNoOverflow(Term^ t1, Term^ t2, <span class="keywordtype">bool</span> is_signed) { 
<a name="l04155"></a>04155             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvMulNoOverflow(t1(), t2(), is_signed)); 
<a name="l04156"></a>04156         }
<a name="l04157"></a>04157         Term^ MkBvMulNoUnderflow(Term^ t1, Term^ t2) { 
<a name="l04158"></a>04158             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBvMulNoUnderflow(t1(), t2())); 
<a name="l04159"></a>04159         }
<a name="l04160"></a>04160         Term^ MkArraySelect(Term^ a, Term^ i) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkArraySelect(a(), i()));  }
<a name="l04161"></a>04161         Term^ MkArrayStore(Term^ a, Term^ i, Term^ v) {
<a name="l04162"></a>04162             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkArrayStore(a(), i(), v()));
<a name="l04163"></a>04163         }
<a name="l04164"></a>04164         Term^ MkArrayMap(FuncDecl^ f, array&lt;Term^&gt;^ args) {
<a name="l04165"></a>04165             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;MkArrayMap(f(), CopyArray(args)));
<a name="l04166"></a>04166         }
<a name="l04167"></a>04167         Term^ MkArrayConst(Sort^ domain, Term^ v) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkArrayConst(domain(), v())); }
<a name="l04168"></a>04168         Term^ MkArrayDefault(Term^ a) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkArrayDefault(a())); }
<a name="l04169"></a>04169         Sort^ MkSetSort(Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;MkSetSort(ty())); }
<a name="l04170"></a>04170         Term^ MkEmptySet(Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkEmptySet(ty())); }
<a name="l04171"></a>04171         Term^ MkFullSet(Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkFullSet(ty())); }
<a name="l04172"></a>04172         Term^ MkSetAdd(Term^ <span class="keyword">set</span>, Term^ elem) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetAdd(<span class="keyword">set</span>(), elem())); }
<a name="l04173"></a>04173         Term^ MkSetDel(Term^ <span class="keyword">set</span>, Term^ elem) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetDel(<span class="keyword">set</span>(), elem())); }
<a name="l04174"></a>04174         Term^ MkSetUnion(array&lt;Term^&gt;^ sets) {
<a name="l04175"></a>04175             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetUnion(CopyArray(sets)));
<a name="l04176"></a>04176         }
<a name="l04177"></a>04177         Term^ MkSetUnion(Term^ set1, Term^ set2) {
<a name="l04178"></a>04178             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetUnion(set1(), set2()));
<a name="l04179"></a>04179         }
<a name="l04180"></a>04180         Term^ MkSetIntersect(array&lt;Term^&gt;^ sets) {
<a name="l04181"></a>04181             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetIntersect(CopyArray(sets)));
<a name="l04182"></a>04182         }
<a name="l04183"></a>04183         Term^ MkSetIntersect(Term^ set1, Term^ set2) {
<a name="l04184"></a>04184             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetIntersect(set1(), set2()));
<a name="l04185"></a>04185         }
<a name="l04186"></a>04186         Term^ MkSetDifference(Term^ t1, Term^ t2) {
<a name="l04187"></a>04187             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetDifference(t1(), t2()));
<a name="l04188"></a>04188         }
<a name="l04189"></a>04189         Term^ MkSetComplement(Term^ arg) {
<a name="l04190"></a>04190             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetComplement(arg()));
<a name="l04191"></a>04191         }
<a name="l04192"></a>04192         Term^ MkSetMember(Term^ elem, Term^ <span class="keyword">set</span>) {
<a name="l04193"></a>04193             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetMember(elem(), <span class="keyword">set</span>()));
<a name="l04194"></a>04194         }
<a name="l04195"></a>04195         Term^ MkSetSubset(Term^ t1, Term^ t2) {
<a name="l04196"></a>04196             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkSetSubset(t1(), t2()));
<a name="l04197"></a>04197         }
<a name="l04198"></a>04198         
<a name="l04199"></a>04199         FuncDecl^ MkInjectiveFunction(String^ name, array&lt;Sort^&gt;^ domain, Sort^ range) {
<a name="l04200"></a>04200             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkInjectiveFunction(name, CopyArray(domain), range()));
<a name="l04201"></a>04201         }
<a name="l04202"></a>04202         FuncDecl^ MkInjectiveFunction(Symbol^ name, array&lt;Sort^&gt;^ domain, Sort^ range) {
<a name="l04203"></a>04203             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;MkInjectiveFunction(name, CopyArray(domain), range()));
<a name="l04204"></a>04204         }
<a name="l04205"></a>04205 
<a name="l04206"></a>04206         Term^ MkNumeral(String^ numeral, Sort^ ty) {
<a name="l04207"></a>04207             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNumeral(numeral, ty()));
<a name="l04208"></a>04208         }
<a name="l04209"></a>04209         Term^ MkNumeral(<span class="keywordtype">int</span> n, Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNumeral(n, ty()));  }
<a name="l04210"></a>04210         Term^ MkNumeral(<span class="keywordtype">unsigned</span> n, Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNumeral(n, ty())); }
<a name="l04211"></a>04211         Term^ MkNumeral(__int64 n, Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNumeral(n, ty())); }
<a name="l04212"></a>04212         Term^ MkNumeral(<span class="keywordtype">unsigned</span> __int64 n, Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkNumeral(n, ty())); }
<a name="l04213"></a>04213 
<a name="l04214"></a>04214         Term^ MkIntNumeral(String^ n) { <span class="keywordflow">return</span> MkNumeral(n, MkIntSort()); }
<a name="l04215"></a>04215         Term^ MkIntNumeral(<span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> MkNumeral(n, MkIntSort()); }
<a name="l04216"></a>04216         Term^ MkIntNumeral(<span class="keywordtype">unsigned</span> n) { <span class="keywordflow">return</span> MkNumeral(n, MkIntSort()); }
<a name="l04217"></a>04217         Term^ MkIntNumeral(__int64 n) { <span class="keywordflow">return</span> MkNumeral(n, MkIntSort()); }
<a name="l04218"></a>04218         Term^ MkIntNumeral(<span class="keywordtype">unsigned</span> __int64 n) { <span class="keywordflow">return</span> MkNumeral(n, MkIntSort()); }
<a name="l04219"></a>04219         
<a name="l04220"></a>04220         Term^ MkRealNumeral(String^ n) { <span class="keywordflow">return</span> MkNumeral(n, MkRealSort()); }
<a name="l04221"></a>04221         Term^ MkRealNumeral(<span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> MkNumeral(n, MkRealSort()); }
<a name="l04222"></a>04222         Term^ MkRealNumeral(<span class="keywordtype">unsigned</span> n) { <span class="keywordflow">return</span> MkNumeral(n, MkRealSort()); }
<a name="l04223"></a>04223         Term^ MkRealNumeral(__int64 n) { <span class="keywordflow">return</span> MkNumeral(n, MkRealSort()); }
<a name="l04224"></a>04224         Term^ MkRealNumeral(<span class="keywordtype">unsigned</span> __int64 n) { <span class="keywordflow">return</span> MkNumeral(n, MkRealSort()); }
<a name="l04225"></a>04225 
<a name="l04226"></a>04226         Pattern^ MkPattern(array&lt;Term^&gt;^ terms) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Pattern(m_ctx,m_ctx-&gt;MkPattern(CopyArray(terms))); }
<a name="l04227"></a>04227         Term^ MkBound(<span class="keywordtype">unsigned</span> index, Sort^ ty) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkBound(index, ty())); }
<a name="l04228"></a>04228 
<a name="l04229"></a>04229         Term^ MkForall(
<a name="l04230"></a>04230             <span class="keywordtype">unsigned</span> weight,
<a name="l04231"></a>04231             array&lt;Pattern^&gt;^ patterns,
<a name="l04232"></a>04232             array&lt;Sort^&gt;^ types,
<a name="l04233"></a>04233             array&lt;Symbol^&gt;^ names,
<a name="l04234"></a>04234             Term^ body
<a name="l04235"></a>04235             ) {
<a name="l04236"></a>04236             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkForall(weight, CopyArray(patterns), CopyArray(types), names, body()));
<a name="l04237"></a>04237         }
<a name="l04238"></a>04238 
<a name="l04239"></a>04239         Term^ MkForall(
<a name="l04240"></a>04240             <span class="keywordtype">unsigned</span> weight,
<a name="l04241"></a>04241             array&lt;Pattern^&gt;^ patterns,
<a name="l04242"></a>04242             array&lt;Sort^&gt;^ types,
<a name="l04243"></a>04243             array&lt;String^&gt;^ names,
<a name="l04244"></a>04244             Term^ body
<a name="l04245"></a>04245             ) {
<a name="l04246"></a>04246             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkForall(weight, CopyArray(patterns), CopyArray(types), names, body()));
<a name="l04247"></a>04247         }
<a name="l04248"></a>04248 
<a name="l04249"></a>04249         Term^ MkForall(
<a name="l04250"></a>04250             <span class="keywordtype">unsigned</span>           weight,
<a name="l04251"></a>04251             array&lt;Term^&gt;^   bound,
<a name="l04252"></a>04252             array&lt;Pattern^&gt;^ patterns,
<a name="l04253"></a>04253             Term^ body
<a name="l04254"></a>04254             ) {
<a name="l04255"></a>04255             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkForall(weight, CopyArray(bound), CopyArray(patterns), body()));
<a name="l04256"></a>04256         }
<a name="l04257"></a>04257 
<a name="l04258"></a>04258 
<a name="l04259"></a>04259         Term^ MkExists(
<a name="l04260"></a>04260             <span class="keywordtype">unsigned</span> weight,
<a name="l04261"></a>04261             array&lt;Pattern^&gt;^ patterns,
<a name="l04262"></a>04262             array&lt;Sort^&gt;^ types,
<a name="l04263"></a>04263             array&lt;Symbol^&gt;^ names,
<a name="l04264"></a>04264             Term^ body
<a name="l04265"></a>04265             ) {
<a name="l04266"></a>04266             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkExists(weight, CopyArray(patterns), CopyArray(types), names, body()));
<a name="l04267"></a>04267         }
<a name="l04268"></a>04268 
<a name="l04269"></a>04269         Term^ MkExists(
<a name="l04270"></a>04270             <span class="keywordtype">unsigned</span> weight,
<a name="l04271"></a>04271             array&lt;Pattern^&gt;^ patterns,
<a name="l04272"></a>04272             array&lt;Sort^&gt;^ types,
<a name="l04273"></a>04273             array&lt;String^&gt;^ names,
<a name="l04274"></a>04274             Term^ body
<a name="l04275"></a>04275             ) {
<a name="l04276"></a>04276             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkExists(weight, CopyArray(patterns), CopyArray(types), names, body()));
<a name="l04277"></a>04277         }
<a name="l04278"></a>04278 
<a name="l04279"></a>04279         Term^ MkExists(
<a name="l04280"></a>04280             <span class="keywordtype">unsigned</span>           weight,
<a name="l04281"></a>04281             array&lt;Term^&gt;^   bound,
<a name="l04282"></a>04282             array&lt;Pattern^&gt;^ patterns,
<a name="l04283"></a>04283             Term^            body
<a name="l04284"></a>04284             ) {
<a name="l04285"></a>04285             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkExists(weight, CopyArray(bound), CopyArray(patterns), body()));
<a name="l04286"></a>04286         }
<a name="l04287"></a>04287 
<a name="l04288"></a>04288 
<a name="l04289"></a>04289 
<a name="l04290"></a>04290         Term^ MkQuantifier(
<a name="l04291"></a>04291             <span class="keywordtype">bool</span>             is_forall,
<a name="l04292"></a>04292             <span class="keywordtype">unsigned</span>         weight,
<a name="l04293"></a>04293             array&lt;Pattern^&gt;^ patterns,
<a name="l04294"></a>04294             array&lt;Term^&gt;^    no_patterns,
<a name="l04295"></a>04295             array&lt;Sort^&gt;^    types,
<a name="l04296"></a>04296             array&lt;Symbol^&gt;^  names,
<a name="l04297"></a>04297             Term^            body
<a name="l04298"></a>04298             ) {
<a name="l04299"></a>04299             <span class="keywordflow">return</span> MkQuantifier(is_forall, weight, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, patterns, no_patterns, types, names, body);
<a name="l04300"></a>04300         }
<a name="l04301"></a>04301 
<a name="l04302"></a>04302         Term^ MkQuantifier(
<a name="l04303"></a>04303             <span class="keywordtype">bool</span>             is_forall,
<a name="l04304"></a>04304             <span class="keywordtype">unsigned</span>         weight,
<a name="l04305"></a>04305             Symbol^          quantifier_id,
<a name="l04306"></a>04306             Symbol^          skolem_id,
<a name="l04307"></a>04307             array&lt;Pattern^&gt;^ patterns,
<a name="l04308"></a>04308             array&lt;Term^&gt;^    no_patterns,
<a name="l04309"></a>04309             array&lt;Sort^&gt;^    types,
<a name="l04310"></a>04310             array&lt;Symbol^&gt;^  names,
<a name="l04311"></a>04311             Term^            body
<a name="l04312"></a>04312             ) {
<a name="l04313"></a>04313             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkQuantifier(
<a name="l04314"></a>04314                                      is_forall, weight, 
<a name="l04315"></a>04315                                      quantifier_id, skolem_id,
<a name="l04316"></a>04316                                      CopyArray(patterns),
<a name="l04317"></a>04317                                      CopyArray(no_patterns),
<a name="l04318"></a>04318                                      CopyArray(types),
<a name="l04319"></a>04319                                      names,
<a name="l04320"></a>04320                                      body()));
<a name="l04321"></a>04321         }
<a name="l04322"></a>04322 
<a name="l04323"></a>04323         Term^ MkQuantifier(
<a name="l04324"></a>04324             <span class="keywordtype">bool</span>             is_forall,
<a name="l04325"></a>04325             <span class="keywordtype">unsigned</span>         weight,
<a name="l04326"></a>04326             Symbol^          quantifier_id,
<a name="l04327"></a>04327             Symbol^          skolem_id,
<a name="l04328"></a>04328             array&lt;Pattern^&gt;^ patterns,
<a name="l04329"></a>04329             array&lt;Term^&gt;^    no_patterns,
<a name="l04330"></a>04330             array&lt;Term^&gt;^    bound,
<a name="l04331"></a>04331             Term^            body
<a name="l04332"></a>04332             ) {
<a name="l04333"></a>04333             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx,m_ctx-&gt;MkQuantifier(
<a name="l04334"></a>04334                                      is_forall, weight, 
<a name="l04335"></a>04335                                      quantifier_id, skolem_id,
<a name="l04336"></a>04336                                      CopyArray(patterns),
<a name="l04337"></a>04337                                      CopyArray(no_patterns),
<a name="l04338"></a>04338                                      CopyArray(bound),
<a name="l04339"></a>04339                                      body()));
<a name="l04340"></a>04340         }
<a name="l04341"></a>04341 
<a name="l04342"></a>04342         <a class="code" href="group__mapi.html#ga05812818de02fb4b202d7513ce50745d" title="In Z3, a symbol can be represented using integers and strings (See GetSymbolKind)...">SymbolKind</a> GetSymbolKind(Symbol^ s) { <span class="keywordflow">return</span> m_ctx-&gt;GetSymbolKind(s); }
<a name="l04343"></a>04343         <span class="keywordtype">int</span> GetSymbolInt(Symbol^ s) { <span class="keywordflow">return</span> m_ctx-&gt;GetSymbolInt(s); }
<a name="l04344"></a>04344         String^ GetSymbolString(Symbol^ s) { <span class="keywordflow">return</span> m_ctx-&gt;GetSymbolString(s); }
<a name="l04345"></a>04345         <span class="keywordtype">bool</span> IsEq(Term^ t1, Term^ t2) { <span class="keywordflow">return</span> m_ctx-&gt;IsEq(t1(), t2()); }
<a name="l04346"></a>04346         <span class="keywordtype">bool</span> IsWellSorted(Term^ t) { <span class="keywordflow">return</span> m_ctx-&gt;IsWellSorted(t()); }
<a name="l04347"></a>04347         <a class="code" href="group__mapi.html#ga4b115a647ef9efa7c5fdfd8f376050dc" title="The different kinds of Z3 Terms.">TermKind</a> GetTermKind(Term^ a) { <span class="keywordflow">return</span> m_ctx-&gt;GetTermKind(a()); }
<a name="l04348"></a>04348         <a class="code" href="group__mapi.html#gac25bfa6294c0cc5dcf0e42e4bfa2b425" title="Different kinds of Z3 built-in declarations (See GetDeclKind).">DeclKind</a> GetDeclKind(FuncDecl^ d) { <span class="keywordflow">return</span> m_ctx-&gt;GetDeclKind(d()); }
<a name="l04349"></a>04349         array&lt;IParameter^&gt;^ GetDeclParameters(FuncDecl^ d);
<a name="l04350"></a>04350         FuncDecl^ GetAppDecl(Term^ a) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;GetAppDecl(a())); }
<a name="l04351"></a>04351         array&lt;Term^&gt;^ GetAppArgs(Term^ a) { <span class="keywordflow">return</span> CopyTermArray(m_ctx-&gt;GetAppArgs(a())); }
<a name="l04352"></a>04352         String^ GetNumeralString(Term^ a) { <span class="keywordflow">return</span> m_ctx-&gt;GetNumeralString(a()); }
<a name="l04353"></a>04353         <span class="keywordtype">int</span> GetNumeralInt(Term^ v) { <span class="keywordflow">return</span> m_ctx-&gt;GetNumeralInt(v()); }
<a name="l04354"></a>04354         <span class="keywordtype">bool</span> TryGetNumeralInt(Term^ v, [Out] <span class="keywordtype">int</span>% i) { <span class="keywordflow">return</span> m_ctx-&gt;TryGetNumeralInt(v(), i); }
<a name="l04355"></a>04355         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GetNumeralUInt(Term^ v) { <span class="keywordflow">return</span> m_ctx-&gt;GetNumeralUInt(v()); }
<a name="l04356"></a>04356         <span class="keywordtype">bool</span> TryGetNumeralUInt(Term^ v, [Out] <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>% u) { <span class="keywordflow">return</span> m_ctx-&gt;TryGetNumeralUInt(v(), u); }
<a name="l04357"></a>04357         __int64 GetNumeralInt64(Term^ v) { <span class="keywordflow">return</span> m_ctx-&gt;GetNumeralInt64(v()); }
<a name="l04358"></a>04358         <span class="keywordtype">bool</span> TryGetNumeralInt64(Term^ v, [Out] __int64% i) { <span class="keywordflow">return</span> m_ctx-&gt;TryGetNumeralInt64(v(), i); }
<a name="l04359"></a>04359         <span class="keywordtype">unsigned</span> __int64 GetNumeralUInt64(Term^ v) { <span class="keywordflow">return</span> m_ctx-&gt;GetNumeralUInt64(v()); }
<a name="l04360"></a>04360         <span class="keywordtype">bool</span> TryGetNumeralUInt64(Term^ v, [Out] <span class="keywordtype">unsigned</span> __int64% u) { <span class="keywordflow">return</span> m_ctx-&gt;TryGetNumeralUInt64(v(), u); }
<a name="l04361"></a>04361         <span class="keywordtype">bool</span> TryGetNumeral(Term^ v, [Out] __int64% num, [Out] __int64% den) { <span class="keywordflow">return</span> m_ctx-&gt;TryGetNumeral(v(), num, den); }
<a name="l04362"></a>04362         <span class="keywordtype">void</span> GetNumeral(Term^ v, [Out] System::Numerics::BigInteger% num, [Out] System::Numerics::BigInteger% den) {
<a name="l04363"></a>04363             m_ctx-&gt;GetNumeral(v(), num, den);
<a name="l04364"></a>04364         }
<a name="l04365"></a>04365 
<a name="l04366"></a>04366         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> GetBoolValue(Term^ v) { <span class="keywordflow">return</span> m_ctx-&gt;GetBoolValue(v()); }
<a name="l04367"></a>04367 
<a name="l04368"></a>04368         <span class="keywordtype">unsigned</span> GetVarIndex(Term^ a) { <span class="keywordflow">return</span> m_ctx-&gt;GetVarIndex(a()); }
<a name="l04369"></a>04369         Quantifier^ GetQuantifier(Term^ a) { <span class="keywordflow">return</span> GetQuantifier(m_ctx, a); }
<a name="l04370"></a>04370 
<a name="l04371"></a>04371         array&lt;Term^&gt;^ GetPatternTerms(Pattern^ p) { <span class="keywordflow">return</span> CopyTermArray(m_ctx-&gt;GetPatternTerms(p())); }
<a name="l04372"></a>04372         Symbol^ GetDeclName(FuncDecl^ d) { <span class="keywordflow">return</span> m_ctx-&gt;GetDeclName(d()); }
<a name="l04373"></a>04373         Symbol^ GetSortName(Sort^ ty) { <span class="keywordflow">return</span> m_ctx-&gt;GetSortName(ty()); }
<a name="l04374"></a>04374         Sort^ GetSort(Term^ a) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;GetSort(a())); }
<a name="l04375"></a>04375         array&lt;Sort^&gt;^ GetDomain(FuncDecl^ d) { <span class="keywordflow">return</span> CopySortArray(m_ctx-&gt;GetDomain(d())); }
<a name="l04376"></a>04376         Sort^ GetRange(FuncDecl^ d) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;GetRange(d())); }
<a name="l04377"></a>04377         <a class="code" href="group__mapi.html#ga7664c6569cf130a5d166ec8c8dc27101" title="The different kinds of Z3 sorts (See GetSortKind).">SortKind</a> GetSortKind(Sort^ t) { <span class="keywordflow">return</span> m_ctx-&gt;GetSortKind(t()); }
<a name="l04378"></a>04378         <span class="keywordtype">unsigned</span> GetBvSortSize(Sort^ t) { <span class="keywordflow">return</span> m_ctx-&gt;GetBvSortSize(t()); }
<a name="l04379"></a>04379         Sort^ GetArraySortDomain(Sort^ t) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;GetArraySortDomain(t())); }
<a name="l04380"></a>04380         Sort^ GetArraySortRange(Sort^ t) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_ctx,m_ctx-&gt;GetArraySortRange(t())); }
<a name="l04381"></a>04381         FuncDecl^ GetTupleConstructor(Sort^ t) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_ctx,m_ctx-&gt;GetTupleConstructor(t())); }
<a name="l04382"></a>04382         array&lt;FuncDecl^&gt;^ GetTupleFields(Sort^ t) { <span class="keywordflow">return</span> CopyFuncDeclArray(m_ctx-&gt;GetTupleFields(t())); }
<a name="l04383"></a>04383 
<a name="l04384"></a>04384     <span class="keyword">private</span>:
<a name="l04385"></a>04385         Func&lt;Term^, TermProof^&gt;^ m_user_simplifier;
<a name="l04386"></a>04386         TermProofPtr^ UserSimplifierAux(TermPtr arg);
<a name="l04387"></a>04387     <span class="keyword">public</span>:
<a name="l04388"></a>04388         <span class="keyword">property</span> Func&lt;Term^, TermProof^&gt;^ UserSimplifier {
<a name="l04389"></a>04389             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func&lt;Term^, TermProof^&gt;^ value) { 
<a name="l04390"></a>04390                 m_user_simplifier = value;
<a name="l04391"></a>04391                 m_ctx-&gt;UserSimplifier = <span class="keyword">gcnew</span> Func&lt;TermPtr,TermProofPtr^&gt;(<span class="keyword">this</span>, &amp;Context::UserSimplifierAux);
<a name="l04392"></a>04392             }
<a name="l04393"></a>04393         }
<a name="l04394"></a>04394 
<a name="l04395"></a>04395         Theory^ MkTheory(String^ name);
<a name="l04396"></a>04396 
<a name="l04397"></a>04397         <span class="keywordtype">void</span> RegisterRelation(FuncDecl^ r) { m_ctx-&gt;RegisterRelation(r()); }
<a name="l04398"></a>04398 
<a name="l04399"></a>04399         <span class="keywordtype">void</span> AddRule(Term^ rule, Symbol^ name) { m_ctx-&gt;AddRule(rule(), name); }
<a name="l04400"></a>04400 
<a name="l04401"></a>04401         <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> Query(Term^ query) { <span class="keywordflow">return</span> m_ctx-&gt;Query(query()); }
<a name="l04402"></a>04402 
<a name="l04403"></a>04403         <a class="code" href="group__mapi.html#gad1c87dc0c2486f35f7ebe425f2041a3e" title="Different failure kinds.">SearchFailureExplanation</a> GetQueryStatus() { <span class="keywordflow">return</span> m_ctx-&gt;GetQueryStatus(); }
<a name="l04404"></a>04404 
<a name="l04405"></a>04405         Term^ GetQueryAnswer() { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx, m_ctx-&gt;GetQueryAnswer()); }
<a name="l04406"></a>04406 
<a name="l04407"></a>04407         String^ FixpointBenchmarkToString(array&lt;Term^&gt;^ axioms, array&lt;Term^&gt;^ rules, array&lt;Term^&gt;^ queries) {
<a name="l04408"></a>04408             <span class="keywordflow">return</span> m_ctx-&gt;FixpointBenchmarkToString(CopyArray(axioms), CopyArray(rules), CopyArray(queries)); 
<a name="l04409"></a>04409         }
<a name="l04410"></a>04410         array&lt;Term^&gt;^ SimplifyFixpointRules(array&lt;Term^&gt;^ rules, array&lt;FuncDecl^&gt;^ output_predicates) {
<a name="l04411"></a>04411             <span class="keywordflow">return</span> CopyTermArray(m_ctx-&gt;SimplifyFixpointRules(CopyArray(rules), CopyArray(output_predicates)));
<a name="l04412"></a>04412         }
<a name="l04413"></a>04413         <span class="comment">// functions for creating custom Datalog relations.</span>
<a name="l04414"></a>04414 
<a name="l04415"></a>04415     <span class="keyword">private</span>:
<a name="l04416"></a>04416         Action3&lt;FuncDecl^, array&lt;Term^&gt;^, array&lt;Term^&gt;^&gt;^ m_assign_callback;
<a name="l04417"></a>04417         <span class="keywordtype">void</span> AssignCallbackAux(FuncDeclPtr f, array&lt;TermPtr&gt;^ args, array&lt;TermPtr&gt;^ outs) {
<a name="l04418"></a>04418             m_assign_callback(<span class="keyword">gcnew</span> FuncDecl(m_ctx, f), CopyAstArray&lt;Term, TermPtr&gt;(args), CopyAstArray&lt;Term, TermPtr&gt;(outs));
<a name="l04419"></a>04419         }
<a name="l04420"></a>04420         Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ m_apply_callback;
<a name="l04421"></a>04421         TermPtr ApplyCallbackAux(FuncDeclPtr f, array&lt;TermPtr&gt;^ args) {
<a name="l04422"></a>04422             <span class="keywordflow">return</span> m_apply_callback(<span class="keyword">gcnew</span> FuncDecl(m_ctx, f), CopyAstArray&lt;Term, TermPtr&gt;(args))();
<a name="l04423"></a>04423         }
<a name="l04424"></a>04424     <span class="keyword">public</span>:
<a name="l04425"></a>04425         <span class="keyword">property</span> Action3&lt;FuncDecl^, array&lt;Term^&gt;^, array&lt;Term^&gt;^&gt;^ DatalogAssign {
<a name="l04426"></a>04426             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action3&lt;FuncDecl^, array&lt;Term^&gt;^, array&lt;Term^&gt;^&gt;^ value) {
<a name="l04427"></a>04427                 m_assign_callback = value;
<a name="l04428"></a>04428                 m_ctx-&gt;DatalogAssign = <span class="keyword">gcnew</span> Action3&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, array&lt;TermPtr&gt;^&gt;(<span class="keyword">this</span>,&amp;Context::AssignCallbackAux);
<a name="l04429"></a>04429             }
<a name="l04430"></a>04430         }
<a name="l04431"></a>04431         <span class="keyword">property</span> Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ DatalogApply {
<a name="l04432"></a>04432             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ value) {
<a name="l04433"></a>04433                 m_apply_callback = value;
<a name="l04434"></a>04434                 m_ctx-&gt;DatalogApply = <span class="keyword">gcnew</span> Func2&lt;FuncDeclPtr, array&lt;TermPtr&gt;^, TermPtr&gt;(<span class="keyword">this</span>,&amp;Context::ApplyCallbackAux);
<a name="l04435"></a>04435             }
<a name="l04436"></a>04436         }
<a name="l04437"></a>04437     };
<a name="l04438"></a>04438 
<a name="l04439"></a>04439     <span class="keyword">public ref class</span> FunctionEntry {
<a name="l04440"></a>04440     <span class="keyword">public</span>:
<a name="l04441"></a>04441         array&lt;Term^&gt;^ Arguments;
<a name="l04442"></a>04442         Term^         Result;
<a name="l04443"></a>04443     };
<a name="l04444"></a>04444 
<a name="l04445"></a>04445     <span class="keyword">public ref class</span> FunctionGraph {
<a name="l04446"></a>04446     <span class="keyword">public</span>:
<a name="l04447"></a>04447         FuncDecl^        Declaration;
<a name="l04448"></a>04448         array&lt;FunctionEntry^&gt;^ Entries;
<a name="l04449"></a>04449         Term^               Else;
<a name="l04450"></a>04450     };
<a name="l04451"></a>04451 
<a name="l04452"></a>04452 
<a name="l04453"></a>04453     <span class="keyword">public ref class</span> Model {
<a name="l04454"></a>04454         RawModel^ m_model;
<a name="l04455"></a>04455         Context^ m_ctx;
<a name="l04456"></a>04456 
<a name="l04457"></a>04457         ArrayValue^ Mk(RawArrayValue^ av);
<a name="l04458"></a>04458         FunctionEntry^ Mk(RawFunctionEntry^ fe);
<a name="l04459"></a>04459         FunctionGraph^ Mk(RawFunctionGraph^ fg);
<a name="l04460"></a>04460         Dictionary&lt;FuncDecl^, FunctionGraph^&gt;^ Mk(Dictionary&lt;FuncDeclPtr, RawFunctionGraph^&gt;^ fgs);
<a name="l04461"></a>04461 
<a name="l04462"></a>04462     <span class="keyword">internal</span>:
<a name="l04463"></a>04463         <span class="keyword">property</span> Context^ GetContext { Context^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_ctx; }}
<a name="l04464"></a>04464         <span class="keyword">property</span> RawModel^ GetModel { RawModel^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_model; }}
<a name="l04465"></a>04465 
<a name="l04466"></a>04466         Model(RawModel^ m, Context^ c) : m_model(m), m_ctx(c) {}
<a name="l04467"></a>04467 
<a name="l04468"></a>04468     <span class="keyword">public</span>:
<a name="l04469"></a>04469         ~Model() { m_model-&gt;Reset(); }
<a name="l04470"></a>04470 
<a name="l04471"></a>04471         array&lt;FuncDecl^&gt;^ GetModelConstants() {
<a name="l04472"></a>04472             <span class="keywordflow">return</span> m_ctx-&gt;CopyFuncDeclArray(m_model-&gt;GetModelConstants());
<a name="l04473"></a>04473         }
<a name="l04474"></a>04474 
<a name="l04475"></a>04475         <span class="keywordtype">bool</span> TryGetArrayValue(Term^ a, [Out] ArrayValue^% av);
<a name="l04476"></a>04476 
<a name="l04477"></a>04477         Dictionary&lt;FuncDecl^, FunctionGraph^&gt;^ GetFunctionGraphs() { <span class="keywordflow">return</span> Mk(m_model-&gt;GetFunctionGraphs()); }
<a name="l04478"></a>04478 
<a name="l04479"></a>04479         Term^ Eval(Term^ t) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx-&gt;GetContext, m_model-&gt;Eval(t())); }
<a name="l04480"></a>04480 
<a name="l04481"></a>04481         Term^ Eval(FuncDecl^ d, array&lt;Term^&gt;^ args) {
<a name="l04482"></a>04482             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_ctx-&gt;GetContext, m_model-&gt;Eval(d(), m_ctx-&gt;CopyArray(args)));
<a name="l04483"></a>04483         }
<a name="l04484"></a>04484 
<a name="l04485"></a>04485         <span class="keywordtype">void</span> Display(System::IO::TextWriter^ w) { m_model-&gt;Display(w); }
<a name="l04486"></a>04486 
<a name="l04487"></a>04487     };
<a name="l04488"></a>04488 
<a name="l04489"></a>04489     <span class="keyword">public ref class</span> Theory
<a name="l04490"></a>04490     {
<a name="l04491"></a>04491         Context^ m_context;
<a name="l04492"></a>04492         RawTheory^ m_theory;
<a name="l04493"></a>04493 
<a name="l04494"></a>04494     <span class="keyword">public</span>:
<a name="l04495"></a>04495         <span class="keyword">property</span> String^ Name { String^ <span class="keyword">get</span>() { <span class="keywordflow">return</span> m_theory-&gt;Name; } }
<a name="l04496"></a>04496 
<a name="l04497"></a>04497     <span class="keyword">internal</span>: 
<a name="l04498"></a>04498         Theory(Context^ ctx, String^ name)
<a name="l04499"></a>04499         {
<a name="l04500"></a>04500             m_context = ctx;
<a name="l04501"></a>04501             m_theory = <span class="keyword">gcnew</span> RawTheory(ctx-&gt;GetContext-&gt;ref_context(), name);
<a name="l04502"></a>04502         }
<a name="l04503"></a>04503 
<a name="l04504"></a>04504     <span class="keyword">private</span>:
<a name="l04505"></a>04505         array&lt;Term^&gt;^ MkTerms(array&lt;TermPtr&gt;^ ts)
<a name="l04506"></a>04506         {
<a name="l04507"></a>04507             <span class="keywordflow">return</span> m_context-&gt;CopyAstArray&lt;Term, TermPtr&gt;(ts);
<a name="l04508"></a>04508         }
<a name="l04509"></a>04509         Term^ MkTerm(TermPtr t) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Term(m_context-&gt;GetContext, t); }
<a name="l04510"></a>04510         FuncDecl^ MkFuncDecl(FuncDeclPtr f) { <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_context-&gt;GetContext, f); }
<a name="l04511"></a>04511 
<a name="l04512"></a>04512         TermPtr GetTermPtr(Term^ t)
<a name="l04513"></a>04513         {
<a name="l04514"></a>04514             <span class="keywordflow">if</span> (t) <span class="keywordflow">return</span> t();
<a name="l04515"></a>04515             <span class="keywordflow">return</span> IntPtr::Zero;
<a name="l04516"></a>04516         }
<a name="l04517"></a>04517 
<a name="l04518"></a>04518     <span class="keyword">public</span>:
<a name="l04519"></a>04519         <span class="keyword">property</span> Action0^ DeleteHandler
<a name="l04520"></a>04520         {
<a name="l04521"></a>04521             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value) 
<a name="l04522"></a>04522             {
<a name="l04523"></a>04523                 m_theory-&gt;DeleteHandler = value;
<a name="l04524"></a>04524             }
<a name="l04525"></a>04525         }
<a name="l04526"></a>04526     <span class="keyword">private</span>:
<a name="l04527"></a>04527         Func2&lt;Term^, Term^, Term^&gt;^ reduce_eq;
<a name="l04528"></a>04528         TermPtr ReduceEqAux(TermPtr a, TermPtr b) {
<a name="l04529"></a>04529             <span class="keywordflow">return</span> GetTermPtr(reduce_eq(MkTerm(a), MkTerm(b)));
<a name="l04530"></a>04530         }
<a name="l04531"></a>04531     <span class="keyword">public</span>:
<a name="l04532"></a>04532         <span class="keyword">property</span> Func2&lt;Term^, Term^, Term^&gt;^ ReduceEq
<a name="l04533"></a>04533             {
<a name="l04534"></a>04534                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;Term^, Term^, Term^&gt;^ value)
<a name="l04535"></a>04535                 {
<a name="l04536"></a>04536                     reduce_eq = value;
<a name="l04537"></a>04537                     m_theory-&gt;ReduceEq = <span class="keyword">gcnew</span> Func2&lt;TermPtr,TermPtr,TermPtr&gt;(<span class="keyword">this</span>,&amp;Theory::ReduceEqAux);
<a name="l04538"></a>04538                 }
<a name="l04539"></a>04539             }
<a name="l04540"></a>04540     <span class="keyword">private</span>:
<a name="l04541"></a>04541         Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ reduce_app;
<a name="l04542"></a>04542         TermPtr ReduceAppAux(FuncDeclPtr a, array&lt;TermPtr&gt;^ b) {
<a name="l04543"></a>04543             <span class="keywordflow">return</span> GetTermPtr(reduce_app(MkFuncDecl(a), MkTerms(b)));
<a name="l04544"></a>04544         }
<a name="l04545"></a>04545     <span class="keyword">public</span>:
<a name="l04546"></a>04546         <span class="keyword">property</span> Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ ReduceApp
<a name="l04547"></a>04547             {
<a name="l04548"></a>04548                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Func2&lt;FuncDecl^, array&lt;Term^&gt;^, Term^&gt;^ value)
<a name="l04549"></a>04549                 {
<a name="l04550"></a>04550                     reduce_app = value;
<a name="l04551"></a>04551                     m_theory-&gt;ReduceApp = <span class="keyword">gcnew</span> Func2&lt;FuncDeclPtr,array&lt;TermPtr&gt;^,TermPtr&gt;(<span class="keyword">this</span>,&amp;Theory::ReduceAppAux);
<a name="l04552"></a>04552                 }
<a name="l04553"></a>04553             }
<a name="l04554"></a>04554     <span class="keyword">private</span>:
<a name="l04555"></a>04555         Func1&lt;array&lt;Term^&gt;^, Term^&gt;^ reduce_distinct;
<a name="l04556"></a>04556         TermPtr ReduceDistinctAux(array&lt;TermPtr&gt;^ args) {
<a name="l04557"></a>04557             <span class="keywordflow">return</span> GetTermPtr(reduce_distinct(MkTerms(args)));
<a name="l04558"></a>04558         }
<a name="l04559"></a>04559         
<a name="l04560"></a>04560     <span class="keyword">public</span>:
<a name="l04561"></a>04561         <span class="keyword">property</span> Func1&lt;array&lt;Term^&gt;^, Term^&gt;^ ReduceDistinct
<a name="l04562"></a>04562             {
<a name="l04563"></a>04563                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Func1&lt;array&lt;Term^&gt;^, Term^&gt;^ value)
<a name="l04564"></a>04564                 {
<a name="l04565"></a>04565                     reduce_distinct = value;
<a name="l04566"></a>04566                     m_theory-&gt;ReduceDistinct = <span class="keyword">gcnew</span> Func1&lt;array&lt;TermPtr&gt;^,TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::ReduceDistinctAux);
<a name="l04567"></a>04567                 }
<a name="l04568"></a>04568             }
<a name="l04569"></a>04569     <span class="keyword">private</span>:
<a name="l04570"></a>04570         Action&lt;Term^&gt;^ new_app;
<a name="l04571"></a>04571         <span class="keywordtype">void</span> NewAppAux(TermPtr a) { <span class="keywordflow">return</span> new_app(MkTerm(a)); }
<a name="l04572"></a>04572     <span class="keyword">public</span>:
<a name="l04573"></a>04573         <span class="keyword">property</span> Action&lt;Term^&gt;^ NewApp
<a name="l04574"></a>04574         {
<a name="l04575"></a>04575             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;Term^&gt;^ value)
<a name="l04576"></a>04576             {
<a name="l04577"></a>04577                 new_app = value;
<a name="l04578"></a>04578                 m_theory-&gt;NewApp = <span class="keyword">gcnew</span> Action&lt;TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::NewAppAux);
<a name="l04579"></a>04579             }
<a name="l04580"></a>04580         }
<a name="l04581"></a>04581     <span class="keyword">private</span>:
<a name="l04582"></a>04582         Action&lt;Term^&gt;^ new_elem;
<a name="l04583"></a>04583         <span class="keywordtype">void</span> NewElemAux(TermPtr a) { <span class="keywordflow">return</span> new_elem(MkTerm(a)); }
<a name="l04584"></a>04584     <span class="keyword">public</span>:
<a name="l04585"></a>04585         <span class="keyword">property</span> Action&lt;Term^&gt;^ NewElem
<a name="l04586"></a>04586         {
<a name="l04587"></a>04587             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;Term^&gt;^ value)
<a name="l04588"></a>04588             {
<a name="l04589"></a>04589                 new_elem = value;
<a name="l04590"></a>04590                 m_theory-&gt;NewElem = <span class="keyword">gcnew</span> Action&lt;TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::NewElemAux);
<a name="l04591"></a>04591             }
<a name="l04592"></a>04592         }
<a name="l04593"></a>04593         <span class="keyword">property</span> Action0^ InitSearch
<a name="l04594"></a>04594         {
<a name="l04595"></a>04595             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l04596"></a>04596             {
<a name="l04597"></a>04597                 m_theory-&gt;InitSearch = value;
<a name="l04598"></a>04598             }
<a name="l04599"></a>04599         }
<a name="l04600"></a>04600         <span class="keyword">property</span> Action0^ Push
<a name="l04601"></a>04601         {
<a name="l04602"></a>04602             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l04603"></a>04603             {
<a name="l04604"></a>04604                 m_theory-&gt;Push = value;
<a name="l04605"></a>04605             }
<a name="l04606"></a>04606         }
<a name="l04607"></a>04607         <span class="keyword">property</span> Action0^ Pop
<a name="l04608"></a>04608         {
<a name="l04609"></a>04609             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l04610"></a>04610             {
<a name="l04611"></a>04611                 m_theory-&gt;Pop = value;
<a name="l04612"></a>04612             }
<a name="l04613"></a>04613         }
<a name="l04614"></a>04614         <span class="keyword">property</span> Action0^ Reset
<a name="l04615"></a>04615         {
<a name="l04616"></a>04616             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l04617"></a>04617             {
<a name="l04618"></a>04618                 m_theory-&gt;Reset = value;
<a name="l04619"></a>04619             }
<a name="l04620"></a>04620         }
<a name="l04621"></a>04621         <span class="keyword">property</span> Action0^ Restart
<a name="l04622"></a>04622         {
<a name="l04623"></a>04623             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action0^ value)
<a name="l04624"></a>04624             {
<a name="l04625"></a>04625                 m_theory-&gt;Restart = value;
<a name="l04626"></a>04626             }
<a name="l04627"></a>04627         }
<a name="l04628"></a>04628 
<a name="l04629"></a>04629         <span class="keyword">property</span> Func0&lt;bool&gt;^ FinalCheck
<a name="l04630"></a>04630         {
<a name="l04631"></a>04631             <span class="keywordtype">void</span> <span class="keyword">set</span>(Func0&lt;bool&gt;^ value)
<a name="l04632"></a>04632             {
<a name="l04633"></a>04633                 m_theory-&gt;FinalCheck = value;
<a name="l04634"></a>04634             }
<a name="l04635"></a>04635         }
<a name="l04636"></a>04636     <span class="keyword">private</span>:
<a name="l04637"></a>04637         Action2&lt;Term^,Term^&gt;^ new_eq;
<a name="l04638"></a>04638         <span class="keywordtype">void</span> NewEqAux(TermPtr a, TermPtr b) {
<a name="l04639"></a>04639             new_eq(MkTerm(a), MkTerm(b));
<a name="l04640"></a>04640         }
<a name="l04641"></a>04641     <span class="keyword">public</span>:
<a name="l04642"></a>04642         <span class="keyword">property</span> Action2&lt;Term^, Term^&gt;^ NewEq
<a name="l04643"></a>04643             {
<a name="l04644"></a>04644                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;Term^, Term^&gt;^  value) 
<a name="l04645"></a>04645                 {
<a name="l04646"></a>04646                     new_eq = value;
<a name="l04647"></a>04647                     m_theory-&gt;NewEq = <span class="keyword">gcnew</span> Action2&lt;TermPtr,TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::NewEqAux);
<a name="l04648"></a>04648                 }
<a name="l04649"></a>04649             }
<a name="l04650"></a>04650     <span class="keyword">private</span>:
<a name="l04651"></a>04651         Action2&lt;Term^,Term^&gt;^ new_diseq;
<a name="l04652"></a>04652         <span class="keywordtype">void</span> NewDiseqAux(TermPtr a, TermPtr b) {
<a name="l04653"></a>04653             new_diseq(MkTerm(a), MkTerm(b));
<a name="l04654"></a>04654         }
<a name="l04655"></a>04655     <span class="keyword">public</span>:
<a name="l04656"></a>04656         <span class="keyword">property</span> Action2&lt;Term^, Term^&gt;^ NewDiseq
<a name="l04657"></a>04657             {
<a name="l04658"></a>04658                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;Term^, Term^&gt;^  value) 
<a name="l04659"></a>04659                 {
<a name="l04660"></a>04660                     new_diseq = value;
<a name="l04661"></a>04661                     m_theory-&gt;NewDiseq = <span class="keyword">gcnew</span> Action2&lt;TermPtr,TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::NewDiseqAux);
<a name="l04662"></a>04662                 }
<a name="l04663"></a>04663             }
<a name="l04664"></a>04664     <span class="keyword">private</span>:
<a name="l04665"></a>04665         Action2&lt;Term^,bool&gt;^ new_assignment;
<a name="l04666"></a>04666         <span class="keywordtype">void</span> NewAssignmentAux(TermPtr a, <span class="keywordtype">bool</span> b) {
<a name="l04667"></a>04667             new_assignment(MkTerm(a), b);
<a name="l04668"></a>04668         }
<a name="l04669"></a>04669     <span class="keyword">public</span>:
<a name="l04670"></a>04670         <span class="keyword">property</span> Action2&lt;Term^, bool&gt;^ NewAssignment
<a name="l04671"></a>04671             {
<a name="l04672"></a>04672                 <span class="keywordtype">void</span> <span class="keyword">set</span>(Action2&lt;Term^, bool&gt;^  value) 
<a name="l04673"></a>04673                 {
<a name="l04674"></a>04674                     new_assignment = value;
<a name="l04675"></a>04675                     m_theory-&gt;NewAssignment = <span class="keyword">gcnew</span> Action2&lt;TermPtr,bool&gt;(<span class="keyword">this</span>, &amp;Theory::NewAssignmentAux);
<a name="l04676"></a>04676                 }
<a name="l04677"></a>04677             }
<a name="l04678"></a>04678     <span class="keyword">private</span>:
<a name="l04679"></a>04679         Action&lt;Term^&gt;^ new_relevant;
<a name="l04680"></a>04680         <span class="keywordtype">void</span> NewRelevantAux(TermPtr a) { new_relevant(MkTerm(a)); }
<a name="l04681"></a>04681     <span class="keyword">public</span>:
<a name="l04682"></a>04682         <span class="keyword">property</span> Action&lt;Term^&gt;^ NewRelevant
<a name="l04683"></a>04683         {
<a name="l04684"></a>04684             <span class="keywordtype">void</span> <span class="keyword">set</span>(Action&lt;Term^&gt;^ value) {
<a name="l04685"></a>04685                 new_relevant = value;
<a name="l04686"></a>04686                 m_theory-&gt;NewRelevant = <span class="keyword">gcnew</span> Action&lt;TermPtr&gt;(<span class="keyword">this</span>, &amp;Theory::NewRelevantAux);
<a name="l04687"></a>04687             }
<a name="l04688"></a>04688         }
<a name="l04689"></a>04689         
<a name="l04690"></a>04690         <span class="keywordtype">void</span> AssertTheoryAxiom(Term^ ax)
<a name="l04691"></a>04691         {
<a name="l04692"></a>04692             m_theory-&gt;AssertTheoryAxiom(ax());
<a name="l04693"></a>04693         }
<a name="l04694"></a>04694 
<a name="l04695"></a>04695         <span class="keywordtype">void</span> AssumeEq(Term^ lhs, Term^ rhs)
<a name="l04696"></a>04696         {
<a name="l04697"></a>04697             m_theory-&gt;AssumeEq(lhs(), rhs());
<a name="l04698"></a>04698         }
<a name="l04699"></a>04699 
<a name="l04700"></a>04700 
<a name="l04701"></a>04701         <span class="keywordtype">void</span> EnableTheoryAxiomSimplification(<span class="keywordtype">bool</span> flag)
<a name="l04702"></a>04702         {
<a name="l04703"></a>04703             m_theory-&gt;EnableTheoryAxiomSimplification(flag);
<a name="l04704"></a>04704         }
<a name="l04705"></a>04705 
<a name="l04706"></a>04706         Term^ GetEqcRoot(Term^ n)
<a name="l04707"></a>04707         {
<a name="l04708"></a>04708             <span class="keywordflow">return</span> MkTerm(m_theory-&gt;GetEqcRoot(n()));
<a name="l04709"></a>04709         }
<a name="l04710"></a>04710 
<a name="l04711"></a>04711         Term^ GetEqcNext(Term^ n)
<a name="l04712"></a>04712         {
<a name="l04713"></a>04713             <span class="keywordflow">return</span> MkTerm(m_theory-&gt;GetEqcNext(n()));
<a name="l04714"></a>04714         }
<a name="l04715"></a>04715 
<a name="l04716"></a>04716         array&lt;Term^&gt;^ GetParents(Term^ n)
<a name="l04717"></a>04717         {
<a name="l04718"></a>04718             <span class="keywordflow">return</span> MkTerms(m_theory-&gt;GetParents(n()));
<a name="l04719"></a>04719         }
<a name="l04720"></a>04720 
<a name="l04721"></a>04721         <span class="keywordtype">bool</span> IsTheoryValue(Term^ a)
<a name="l04722"></a>04722         {
<a name="l04723"></a>04723             <span class="keywordflow">return</span> m_theory-&gt;IsTheoryValue(a());
<a name="l04724"></a>04724         }
<a name="l04725"></a>04725 
<a name="l04726"></a>04726         <span class="keywordtype">bool</span> IsTheoryDecl(FuncDecl^ d)
<a name="l04727"></a>04727         {
<a name="l04728"></a>04728             <span class="keywordflow">return</span> m_theory-&gt;IsTheoryDecl(d());
<a name="l04729"></a>04729         }
<a name="l04730"></a>04730 
<a name="l04731"></a>04731         array&lt;Term^&gt;^ GetElems()
<a name="l04732"></a>04732         {
<a name="l04733"></a>04733             <span class="keywordflow">return</span> MkTerms(m_theory-&gt;GetElems());
<a name="l04734"></a>04734         }
<a name="l04735"></a>04735 
<a name="l04736"></a>04736         array&lt;Term^&gt;^ GetApps()
<a name="l04737"></a>04737         {
<a name="l04738"></a>04738             <span class="keywordflow">return</span> MkTerms(m_theory-&gt;GetApps());
<a name="l04739"></a>04739         }
<a name="l04740"></a>04740 
<a name="l04741"></a>04741 
<a name="l04742"></a>04742         Sort^ MkSort(Symbol^ s) 
<a name="l04743"></a>04743             {
<a name="l04744"></a>04744                 <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_context-&gt;GetContext,m_theory-&gt;MkSort(s));
<a name="l04745"></a>04745             }
<a name="l04746"></a>04746         
<a name="l04747"></a>04747         Term^ MkValue(Symbol^ s, Sort^ srt) 
<a name="l04748"></a>04748             {
<a name="l04749"></a>04749                 <span class="keywordflow">return</span> MkTerm(m_theory-&gt;MkValue(s, srt()));
<a name="l04750"></a>04750             }
<a name="l04751"></a>04751         
<a name="l04752"></a>04752         Term^ MkConstant(Symbol^ s, Sort^ srt)
<a name="l04753"></a>04753             {
<a name="l04754"></a>04754                 <span class="keywordflow">return</span> MkTerm(m_theory-&gt;MkConstant(s, srt()));
<a name="l04755"></a>04755             }
<a name="l04756"></a>04756         
<a name="l04757"></a>04757         FuncDecl^ MkFuncDecl(Symbol^ n, array&lt;Sort^&gt;^ domain, Sort^ range)
<a name="l04758"></a>04758             {
<a name="l04759"></a>04759                 array&lt;SortPtr&gt;^ dom = <span class="keyword">gcnew</span> array&lt;SortPtr&gt;(domain-&gt;Length);
<a name="l04760"></a>04760                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; domain-&gt;Length; ++i) dom[i] = domain[i]();
<a name="l04761"></a>04761                 <span class="keywordflow">return</span> <span class="keyword">gcnew</span> FuncDecl(m_context-&gt;GetContext, m_theory-&gt;MkFuncDecl(n, dom, range()));
<a name="l04762"></a>04762             }
<a name="l04763"></a>04763 
<a name="l04764"></a>04764         Sort^ MkSort(String^ s) 
<a name="l04765"></a>04765             {
<a name="l04766"></a>04766                 <span class="keywordflow">return</span> <span class="keyword">gcnew</span> Sort(m_context-&gt;GetContext,m_theory-&gt;MkSort(s));
<a name="l04767"></a>04767             }
<a name="l04768"></a>04768         
<a name="l04769"></a>04769         Term^ MkValue(String^ s, Sort^ srt) 
<a name="l04770"></a>04770             {
<a name="l04771"></a>04771                 <span class="keywordflow">return</span> MkTerm(m_theory-&gt;MkValue(s, srt()));
<a name="l04772"></a>04772             }
<a name="l04773"></a>04773         
<a name="l04774"></a>04774         Term^ MkConstant(String^ s, Sort^ srt)
<a name="l04775"></a>04775             {
<a name="l04776"></a>04776                 <span class="keywordflow">return</span> MkTerm(m_theory-&gt;MkConstant(s, srt()));
<a name="l04777"></a>04777             }
<a name="l04778"></a>04778         
<a name="l04779"></a>04779         FuncDecl^ MkFuncDecl(String^ n, array&lt;Sort^&gt;^ domain, Sort^ range)
<a name="l04780"></a>04780             {
<a name="l04781"></a>04781                 <span class="keywordflow">return</span> this-&gt;MkFuncDecl(m_context-&gt;MkSymbol(n), domain, range);
<a name="l04782"></a>04782             }
<a name="l04783"></a>04783         
<a name="l04784"></a>04784 
<a name="l04785"></a>04785     };
<a name="l04786"></a>04786 
<a name="l04787"></a>04787 
<a name="l04790"></a>04790 };
<a name="l04791"></a>04791 };
<a name="l04792"></a>04792 
<a name="l04793"></a>04793 <span class="preprocessor">#endif</span>
</pre></div></div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Mon Mar 19 16:36:31 2012
</BODY>
</HTML>
