 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">

<table>
<tr>
<th style="width:120px"><a style="border=0px" class="el" href="index.html"><img border="0" src="z3.png" alt="Z3" /></a></th>
<th style="width:100%">
<div id="nav">
<ul>
<li><a href="download.html">Download</a></li>
<li>/</li>
<li><a href="documentation.html#tutorial">Tutorials</a></li>
<li>/</li>
<li><a href="documentation.html">Documentation</a></li>
<li>/</li>
<li><a href="mail.html">Contact</a></li>
<li>/</li>
<li><a href="faq.html">FAQ</a></li>
<li>/</li>
<li><a href="awards.html">Awards</a></li>
<li>/</li>
<li><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx">RiSE</a></li>
</ul>
</div>
</th>
<th style="width:120px">
<a style="border=0px" class="el" href="http://research.microsoft.com"><img border="0" src="logo_msr.gif" alt="Microsoft Research" />
</th>
</tr>
</table>

<!-- <p> -->
<!-- <img align="middle" src="z3.png" alt="Z3" /> -->
<!-- <table class="centered-small"> -->
<!--   <tr> -->
<!--     <th><a href="index.html"><span>Home</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="documentation.html"><span>Docs</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="download.html"><span>Download</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="mail.html"><span>Mail</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="faq.html"><span>FAQ</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="awards.html"><span>Awards</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com"><span>MSR</span></a></th> -->
<!--   </tr> -->
<!-- </table> -->
<!-- </p> -->

<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>Z3 low level input format</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>This format is mainly used for generating logs. These logs capture the expressions created using the Z3 API, and the main commands available there. It is very low-level and follows some of the conventions found in the DIMACS format for SAT problems and by the <a href="http://www.cs.ubc.ca/~babic/index_spear.htm" class="el">Spear</a> input format.</p>
<p>The format is extensible, as the grammar allows for selecting solvers and adding <em>semantic attachments</em> with constructors. The <a href="http://www.smtlib.org" class="el">SMT-LIB</a> and Simplify text formats are easier to write and read for a human consumer.</p>
<p>Every line consists of a command that gets interpreted as a declaration of a node in anbstract syntax tree, or as a control instruction to Z3, such as to augment the current context with constraints or check for satisfiability.</p>
<div class="fragment"><pre class="fragment">
    <em>command</em> := 
      | <em>ast</em>
      | <em>control </em>
      | <em> ; commented line </em>      
  </pre></div><p>White spaces are implicit in the production rules. The legal white-spaces have the ASCII representations</p>
<div class="fragment"><pre class="fragment">
     ' ' | \ t | \ r
  </pre></div><p>Comment lines start with <code></code>;. All characters up to the newline \ n are ignored.</p>
<p>We use <em>id</em> for identifiers in general. Identifiers associated with certain semantic categories, such as <em>ast</em> nodes, or <em>type</em>s are prefixed by the category and suffixed by <em>id</em>. For example, we have:</p>
<div class="fragment"><pre class="fragment">
   ast-id        - identifier for ast nodes</pre></div><div class="fragment"><pre class="fragment">   type-id       - identifier for type nodes</pre></div><div class="fragment"><pre class="fragment">   parameter-id  - identifier for ast</pre></div><div class="fragment"><pre class="fragment">   name-id       - identifier for a function/type name</pre></div><div class="fragment"><pre class="fragment">   decl-id       - identifier for declaration node</pre></div><div class="fragment"><pre class="fragment">   context-id    - identifier for Boolean context
  </pre></div><p>Identifiers can be any sequence of non-whitespace and non-newline characters whose first character is not one of the decimal digits. Identifiers enclosed in quotes ''...'' are treated specially: the quotes are stripped. Thus, the identifier consisting of zero characters is written ''''. The identifier ''null'' is allowed for <em>skolem-id</em> and <em>quant-id</em>.</p>
<h2><a class="anchor" id="nativecontrol">
Control commands</a></h2>
<p>To load a theory solver for integer linear arithmetic, include a line of the form <b>Solver LIA</b>. To load the mixed integer/real solver include instead a line of the form <b>Solver LRA</b></p>
<p>Use <b>Push</b> and <b>Pop</b> to push/pop contexts (constraints that are asserted under a <b>Push</b> are removed after a <b>Pop</b>). To reset the state entirely, use <b>Reset</b>.</p>
<p>To assert a constraint use <b>Assert</b> <em>ast-id</em>, where the <em>ast-id</em> is an identifier declared for a boolean typed term.</p>
<p>To check for satisfiability of all asserted constraints use <b>Check</b>.</p>
<div class="fragment"><pre class="fragment">
  <em>control</em> :=
     | Solver <em>solver</em>        - load specified theory solver 
     | Assert <em>ast-id</em>        - assert constraint 
     | Check                - check for satisfiability of asserts
     | Push                 - push a context
     | Pop                  - pop a context
     | Version <em>major minor build-number revision</em> - specify Z3 version</pre></div><div class="fragment"><pre class="fragment">  <em>solver</em> :=
     | LRA                  - mixed integer/real arithmetic 
     | LIA                  - integer arithmetic</pre></div><h2><a class="anchor" id="z3nativeast">
Abstract syntax trees</a></h2>
<p>Every node in the abstract syntax trees understood by Z3 is declared by using a syntax category identifier, followed by a (unique) identifier that names the node. The node identifier is followed by a description of the node.</p>
<p>In overview abstract syntax tree nodes are declared using the commands:</p>
<div class="fragment"><pre class="fragment">
  <em>ast</em> :=
     | Type <em>id</em> <em>type</em> 
     | Dec <em>id</em> <em>declaration</em>
     | Const <em>id</em> <em>constant</em>             
     | Fun <em>id</em> <em>function</em>               
     | App <em>id</em> <em>built-in</em>               
     | Num <em>id</em> <em>numeral</em>                
     | Qua <em>id</em> <em>quantifier</em>                     
     | Var <em>id</em> <em>bound-variable</em>             
     | Ctx <em>id</em> <em>local-context</em>          
     | Lab <em>id</em> <em>label-term</em>         
     | Pat <em>id</em> <em>pattern</em> 
 </pre></div><h3><a class="anchor" id="z3nativetypes">
Types</a></h3>
<p>Types are created from a name and optional parameters. A number of names are reserved for built-in theories. These names are: </p>
<div class="fragment"><pre class="fragment">
    Int  Real  Bool  bv  array
 </pre></div><p> When the name of a type is one of these, the type is automatically associated with the respective theory. The <b>bv</b> type takes one numeric parameter (the bit-width of the bit-vector), and <b>array</b> takes <em>n+1</em> parameters (the <em>n</em> types for the domain of the array and the last parameter for the range of the array.</p>
<div class="fragment"><pre class="fragment">
 <em>type</em> := <em>name</em> '[' <em>parameter</em>* ']'</pre></div><div class="fragment"><pre class="fragment"> <em>parameter</em> := <em>number</em> | <em>ast-id</em> | <em>symbol</em>
 </pre></div><p> A parameter can either be an integer, an identifier used for another defined term or type, or a symbol. Symbols are given as strings. The parser first attempts to identify a parameter as a previously defined term or type, and if there is no such previously defined term/type, then it treats the string as a symbol.</p>
<h3><a class="anchor" id="nativez3Fuctions">
Function and constant declarations</a></h3>
<p>In Z3, functions are constants that take more than zero arguments, thus, everything is treated as a constant.</p>
<p>Constant declarations comprise of a name, followed by a non-empty list of types, all but the first types are the domain of the function (there are no domain types for 0-ary constants), the last type is the range. A constant declaration is followed by optional theory specific information.</p>
<p>The codes used in the theory specific information is described under <a class="el" href="group__theories.html">Z3 theories</a></p>
<p>The theory specific information indicates whether the constant is associative/commutative/injective; a list of parameters may also be used to indicate auxiliary information for the constant declarations.</p>
<div class="fragment"><pre class="fragment">
 <em>declaration</em> := <em>name-id</em> <em>type-id</em>* [<em>const-info</em>]</pre></div><div class="fragment"><pre class="fragment"> <em>const-info</em> := BUILTIN <em>theory</em> <em>kind-num</em> (:assoc | :comm | :inj | <em>parameter</em>)*</pre></div><div class="fragment"><pre class="fragment"> <em>theory</em> := 
    | basic -  built-in types and operations 
    | arith -  arithmetical 
    | bv    -  bit-vectors 
    | array -  arrays 
    | datatype - datatypes
 </pre></div><h3><a class="anchor" id="z3nativeterms">
Terms</a></h3>
<p>Terms are built from constants, function applications, labeling, context formation, quantification and bound variables.</p>
<p>A constant consists of a declarations, functions consist of a declaration followed by a non-empty list of term identifiers. All constants and function applications can be constructed using the <b>Fun</b> construct. However, two shortcuts are available.</p>
<ul>
<li>
<b>Const</b>: Constants may be defined directly by supplying the name and the type of the constant.  </li>
<li>
<b>App</b>: Built-in arithmetic, array, bit-vector, and Boolean operations may be applied directly to their arguments without first providing function declarations.  </li>
</ul>
<div class="fragment"><pre class="fragment">
  <em>constant</em>  := <em>name-id</em> <em>type-id</em></pre></div><div class="fragment"><pre class="fragment">  <em>function</em>  := <em>decl-id</em> <em>ast-id</em>*</pre></div><div class="fragment"><pre class="fragment">  <em>built-in</em>  := <em>name-id</em> [<em> [</em> <em>parameter</em>* ] ] <em>ast-id</em>*
  </pre></div><p>Labeled terms consist of a polarity (<b>LBLPOS</b> for positive context, <b>LBLNEG</b> for negative contexts), a name, and a term identifier.</p>
<div class="fragment"><pre class="fragment">
  <em>label-term</em>  :=  (LBLPOS | LBLNEG) <em>label-name</em> <em>ast-id</em> 
  </pre></div><p>Local contexts consist of an identifier for the underlying term, followed by a predicate summarizing the context in which the term is interpreted.</p>
<div class="fragment"><pre class="fragment">
  <em>local-context</em> :=  <em>ast-id</em> <em>context-id</em>
  </pre></div><p>A quantifier consists of </p>
<ul>
<li>
A number indiciating the weight of the quantifier (for matching precedence), </li>
<li>
A skolem identifier, used for Boogie quantifier instantiation, </li>
<li>
A quantifier identifier, used for profiling instantiations, </li>
<li>
A number indicating how many variables are bound by the quantifier, followed by the bound variables, which are <ul>
<li>
A name for the bound variable. </li>
<li>
An identifier for the type of the bound variable. </li>
</ul>
</li>
<li>
A number indicating how many patterns are associated with the quantifier, followed by the patterns, which are <ul>
<li>
An identifier for the pattern. </li>
</ul>
</li>
<li>
An identifier for the body of the quantifier. </li>
</ul>
<div class="fragment"><pre class="fragment">
  <em>quantifier</em>  :=  
      (FORALL | EXISTS) 
      <em>weight-num</em>  
      <em>skolem-id</em>
      <em>quant-id</em> 
      <em>decls-num</em>
      (<em>name-id</em> <em>type-id</em>)*
      <em>pattern-num</em>
      <em>pattern-id</em>*
      <em>ast-id</em>
  </pre></div><p>A bound variable consists of a de-Brujin index for the bound variable together with the type of the bound variable. While the type can be computed by matching the index of the de-Brujin index with the associated quantifier,</p>
<p>Patterns comprise of a list of terms.</p>
<div class="fragment"><pre class="fragment">
  <em>bound-variable</em>  :=  <em>index-num</em> <em>type-id</em></pre></div><div class="fragment"><pre class="fragment">  <em>numeral</em>   :=  <em>rational</em> <em>type-id</em></pre></div><div class="fragment"><pre class="fragment">  <em>rational</em>  :=  <em>number</em> [/<em>number</em>]</pre></div><div class="fragment"><pre class="fragment">  <em>number</em>    :=  [0-9]+</pre></div><div class="fragment"><pre class="fragment">  <em>pattern</em>   :=  <em>id</em> <em>ast-id</em>*
  </pre></div><h2><a class="anchor" id="z3nativeexamples">
Examples</a></h2>
<h3><a class="anchor" id="z3nativearithmetic">
Integer Arithmetic</a></h3>
<p>Suppose we wish to check whether </p>
<div class="fragment"><pre class="fragment">
       z0 &gt;= 0 &amp;&amp; z1 &gt;= 0 &amp;&amp; z2 &gt;= 1 &amp;&amp; z1 &gt;= z2 &amp;&amp; z2 &gt;= z0
</pre></div><p> is satisfiable for </p>
<pre>z0, z1, z2</pre><p> integers. With the low-level input format, we may specify this by:</p>
<div class="fragment"><pre class="fragment">
   Type INT  Int
   Type BOOL Bool
   Const z0  z0 INT
   Const z1  z1 INT
   Const z2  z2 INT
   Num   0   0 INT
   Num   1   1 INT
   App c0 &gt;= z0 0
   Assert c0
   App c1 &gt;= z1 0
   Assert c1
   App c2 &gt;= z2 1
   Assert c2
   App c3 &gt;= z1 z2
   Assert c3
   App c4 &gt;= z2 z0
   Assert c4
   Check
</pre></div><p>Notice that the identifiers may be arbitrary strings, including numerals. So for instance, we used 1 to represent integer 1.</p>
<h3><a class="anchor" id="z3nativebv">
Bit-vectors</a></h3>
<p>We can check whether 32-bit addition is commutative. Z3 reports <b>unsat</b> in for the first check. The second satisfiable check illustrates the use of parameters (<b>extract</b> takes two integer parameters for the range of bits extracted from the bit-vectors).</p>
<div class="fragment"><pre class="fragment">
   Type bool Bool 
   Type bv32 bv [ 32 ]
   Type bv64 bv [ 64 ]
   Num 0 0 bv32
   Num 1 1 bv32
   Const x0 x0 bv32
   Const x1 x1 bv32
   Const x2 x2 bv64
   App a bvadd x0 x1
   App b bvadd x1 x0
   App eq = a b
   App constraint1 not eq
   Push
   Assert constraint1
   Check
   Pop
   App c extract [ 31 0 ] x2
   App eq2 = a c
   App constraint2 not eq2
   Push
   Assert constraint2
   Check
   Pop
</pre></div><p>We added the declarations of bit-vector constants 0 and 1. Like integers, these are also numerals, but with bit-vector type.</p>
<h3><a class="anchor" id="z3nativeexarray">
Arrays</a></h3>
<p>The low-level version of: { store(f1,i1,v1) = store(f2,i2,v2) &amp;&amp; i1 != i3 &amp;&amp; i2 != i3 &amp;&amp; select(f1,i3) != select(f2,i3) } is:</p>
<div class="fragment"><pre class="fragment">
  Type Index Index
  Type Elem Elem
  Type Array array [ Index Elem ]
  Type bool Bool
  Const i1 i1 Index
  Const i2 i2 Index
  Const i3 i3 Index
  Const v1 v1 Elem
  Const v2 v2 Elem
  Const f1 f1 Array
  Const f2 f2 Array
  App n1 store f1 i1 v1
  App n2 store f2 i2 v2
  App n3 = n1 n2
  App n4 = i1 i3
  App n5 not n4
  App n6 = i2 i3
  App n7 not n6 
  App n8 select f1 i3
  App n9 select f2 i3
  App n10 = n8 n9
  App n11 not n10
  Assert n3
  Assert n5
  Assert n7
  Assert n11
  Check
</pre></div><h3><a class="anchor" id="z3nativeexdatatype">
Data-types</a></h3>
<p>To check projection over tuples </p>
<div class="fragment"><pre class="fragment">
  (= x (first (mk_tuple x y)))
</pre></div><p>we write: </p>
<div class="fragment"><pre class="fragment">
  Type int Int
  Type pair tuple [ mk_tuple first int second int ]
  Const x x int
  Const y y int
  Const p p pair
  App n1 mk_tuple x y
  App n2 first n1
  App n3 = n2 x
  App n4 not n3
  Assert n4
  Check
</pre></div> </div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Aug 9 16:34:45 2012
</BODY>
</HTML>
