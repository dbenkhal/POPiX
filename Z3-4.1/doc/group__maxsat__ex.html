 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">

<table>
<tr>
<th style="width:120px"><a style="border=0px" class="el" href="index.html"><img border="0" src="z3.png" alt="Z3" /></a></th>
<th style="width:100%">
<div id="nav">
<ul>
<li><a href="download.html">Download</a></li>
<li>/</li>
<li><a href="documentation.html#tutorial">Tutorials</a></li>
<li>/</li>
<li><a href="documentation.html">Documentation</a></li>
<li>/</li>
<li><a href="mail.html">Contact</a></li>
<li>/</li>
<li><a href="faq.html">FAQ</a></li>
<li>/</li>
<li><a href="awards.html">Awards</a></li>
<li>/</li>
<li><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx">RiSE</a></li>
</ul>
</div>
</th>
<th style="width:120px">
<a style="border=0px" class="el" href="http://research.microsoft.com"><img border="0" src="logo_msr.gif" alt="Microsoft Research" />
</th>
</tr>
</table>

<!-- <p> -->
<!-- <img align="middle" src="z3.png" alt="Z3" /> -->
<!-- <table class="centered-small"> -->
<!--   <tr> -->
<!--     <th><a href="index.html"><span>Home</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="documentation.html"><span>Docs</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="download.html"><span>Download</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="mail.html"><span>Mail</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="faq.html"><span>FAQ</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="awards.html"><span>Awards</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com"><span>MSR</span></a></th> -->
<!--   </tr> -->
<!-- </table> -->
<!-- </p> -->

<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">
<h1>MaxSAT/MaxSMT examples</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#gaad9796c174f7ef5d226cd169f2520fd5">error</a> (char *msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit gracefully in case of error.  <a href="#gaad9796c174f7ef5d226cd169f2520fd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_context&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga102b86f8b4829828c5c2d06c5d8b8489">mk_context</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a logical context. Enable model construction only.  <a href="#ga102b86f8b4829828c5c2d06c5d8b8489"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_ast&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#gad55575aaf95896158c9e2f12e93769c8">mk_var</a> (Z3_context ctx, const char *name, Z3_sort ty)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a variable using the given name and type.  <a href="#gad55575aaf95896158c9e2f12e93769c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_ast&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga397d6e03e2538ff0df36aad6e02030ae">mk_bool_var</a> (Z3_context ctx, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a boolean variable using the given name.  <a href="#ga397d6e03e2538ff0df36aad6e02030ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_ast&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga2d600be3c99aa6bd76b39d1e715420c6">mk_fresh_bool_var</a> (Z3_context ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a fresh boolean variable.  <a href="#ga2d600be3c99aa6bd76b39d1e715420c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_ast *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga6c7f9f06eab298ed6f6ad19e1266549b">mk_fresh_bool_var_array</a> (Z3_context ctx, unsigned num_vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an array with <code>num_vars</code> fresh boolean variables.  <a href="#ga6c7f9f06eab298ed6f6ad19e1266549b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga3cb6544cf32dc16f43c739071bd346c7">del_bool_var_array</a> (Z3_ast *arr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete array of boolean variables.  <a href="#ga3cb6544cf32dc16f43c739071bd346c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_ast&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#gaab12e81ed001b3e1bff357ef8263c8c1">mk_binary_or</a> (Z3_context ctx, Z3_ast in_1, Z3_ast in_2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a binary OR.  <a href="#gaab12e81ed001b3e1bff357ef8263c8c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_ast&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga6f720e11eb8cc3b085cfa9766269a663">mk_ternary_or</a> (Z3_context ctx, Z3_ast in_1, Z3_ast in_2, Z3_ast in_3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a ternary OR.  <a href="#ga6f720e11eb8cc3b085cfa9766269a663"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_ast&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga75be768cdd0806203beb01c9186d8805">mk_binary_and</a> (Z3_context ctx, Z3_ast in_1, Z3_ast in_2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a binary AND.  <a href="#ga75be768cdd0806203beb01c9186d8805"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_ast *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga37df58ec6af77230db093d908dd88333">get_hard_constraints</a> (Z3_context ctx, unsigned *num_cnstrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get hard constraints from a SMT-LIB file. We assume hard constraints are formulas preceeded with the keyword :formula. Return an array containing all formulas read by the last Z3_parse_smtlib_file invocation. It will store the number of formulas in num_cnstrs.  <a href="#ga37df58ec6af77230db093d908dd88333"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_ast *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga3489c094c45ae2468b18776e15066cda">get_soft_constraints</a> (Z3_context ctx, unsigned *num_cnstrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get soft constraints from a SMT-LIB file. We assume soft constraints are formulas preceeded with the keyword :assumption. Return an array containing all assumptions read by the last Z3_parse_smtlib_file invocation. It will store the number of formulas in num_cnstrs.  <a href="#ga3489c094c45ae2468b18776e15066cda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga9addf8d434da3c6daa1cc87cfa52ee69">free_cnstr_array</a> (Z3_ast *cnstrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the given array of cnstrs that was allocated using get_hard_constraints or get_soft_constraints.  <a href="#ga9addf8d434da3c6daa1cc87cfa52ee69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#gac0ff93d06034b18b5017068b01412342">assert_hard_constraints</a> (Z3_context ctx, unsigned num_cnstrs, Z3_ast *cnstrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assert hard constraints stored in the given array.  <a href="#gac0ff93d06034b18b5017068b01412342"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_ast *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga09cab25d24e179709402bd4a2ca8548d">assert_soft_constraints</a> (Z3_context ctx, unsigned num_cnstrs, Z3_ast *cnstrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assert soft constraints stored in the given array. This funtion will assert each soft-constraint C_i as (C_i or k_i) where k_i is a fresh boolean variable. It will also return an array containing these fresh variables.  <a href="#ga09cab25d24e179709402bd4a2ca8548d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga7be6e5527171df812c1d574083626357">mk_full_adder</a> (Z3_context ctx, Z3_ast in_1, Z3_ast in_2, Z3_ast cin, Z3_ast *out, Z3_ast *cout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a full adder with inputs <code>in_1</code>, <code>in_2</code> and <code>cin</code>. The output of the full adder is stored in <code>out</code>, and the carry in <code>c_out</code>.  <a href="#ga7be6e5527171df812c1d574083626357"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#gafa3546986987389015292f26f6ca838f">mk_adder</a> (Z3_context ctx, unsigned num_bits, Z3_ast *in_1, Z3_ast *in_2, Z3_ast *result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an adder for inputs of size <code>num_bits</code>. The arguments <code>in1</code> and <code>in2</code> are arrays of bits of size <code>num_bits</code>.  <a href="#gafa3546986987389015292f26f6ca838f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#gac4a5af441cfab87f25b02444898b6ee3">mk_adder_pairs</a> (Z3_context ctx, unsigned num_bits, unsigned num_ins, Z3_ast *in, unsigned *out_num_ins, Z3_ast *out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given <code>num_ins</code> "numbers" of size <code>num_bits</code> stored in <code>in</code>. Create floor(num_ins/2) adder circuits. Each circuit is adding two consecutive "numbers". The numbers are stored one after the next in the array <code>in</code>. That is, the array <code>in</code> has size num_bits * num_ins. Return an array of bits containing <code>ceil</code>(num_ins/2) numbers of size <code></code>(num_bits + 1). If num_ins/2 is not an integer, then the last "number" in the output, is the last "number" in <code>in</code> with an appended "zero".  <a href="#gac4a5af441cfab87f25b02444898b6ee3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Z3_ast *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga110028ed331e1303de2b8eb66592d6e6">mk_counter_circuit</a> (Z3_context ctx, unsigned n, Z3_ast *lits, unsigned *out_sz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a counter circuit to count the number of "ones" in lits. The function returns an array of bits (i.e. boolean expressions) containing the output of the circuit. The size of the array is stored in out_sz.  <a href="#ga110028ed331e1303de2b8eb66592d6e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga34e61f425c4c47fe3238465536f2b157">get_bit</a> (unsigned val, unsigned idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <code>idx</code> bit of <code>val</code>.  <a href="#ga34e61f425c4c47fe3238465536f2b157"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga37f2b6f8f117d52f72d4e10148c1e548">assert_le_k</a> (Z3_context ctx, unsigned n, Z3_ast *val, unsigned k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an integer val encoded in n bits (boolean variables), assert the constraint that val &lt;= k.  <a href="#ga37f2b6f8f117d52f72d4e10148c1e548"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#gaccbeb5c2ebcbb71bfa309f4ffcc3440e">assert_at_most_k</a> (Z3_context ctx, unsigned n, Z3_ast *lits, unsigned k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assert that at most <code>k</code> literals in <code>lits</code> can be true, where <code>n</code> is the number of literals in lits.  <a href="#gaccbeb5c2ebcbb71bfa309f4ffcc3440e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga0cd161e82d1bcc3a172222f86b89c6c7">assert_at_most_one</a> (Z3_context ctx, unsigned n, Z3_ast *lits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assert that at most one literal in <code>lits</code> can be true, where <code>n</code> is the number of literals in lits.  <a href="#ga0cd161e82d1bcc3a172222f86b89c6c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga38972953eace8df5ce0c34a41fa0b3e1">tst_at_most_one</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Small test for the at-most-one constraint.  <a href="#ga38972953eace8df5ce0c34a41fa0b3e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#gaad360c0088050f32e64f24a27d26cc4a">get_num_disabled_soft_constraints</a> (Z3_context ctx, Z3_model m, unsigned num_soft_cnstrs, Z3_ast *aux_vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of soft-constraints that were disable by the given model. A soft-constraint was disabled if the associated auxiliary variable was assigned to true.  <a href="#gaad360c0088050f32e64f24a27d26cc4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#ga4c670fc1e4cbcdba5dc237b439c6a08d">naive_maxsat</a> (Z3_context ctx, unsigned num_hard_cnstrs, Z3_ast *hard_cnstrs, unsigned num_soft_cnstrs, Z3_ast *soft_cnstrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Naive maxsat procedure based on linear search and at-most-k constraint. Return the number of soft-constraints that can be satisfied. Return -1 if the hard-constraints cannot be satisfied. That is, the formula cannot be satisfied even if all soft-constraints are ignored.  <a href="#ga4c670fc1e4cbcdba5dc237b439c6a08d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#gad06532e231b6fd3eb01ed05fab779432">fu_malik_maxsat_step</a> (Z3_context ctx, unsigned num_soft_cnstrs, Z3_ast *soft_cnstrs, Z3_ast *aux_vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implement one step of the Fu&amp;Malik algorithm. See fu_malik_maxsat function for more details.  <a href="#gad06532e231b6fd3eb01ed05fab779432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#gacac27baf151175043165a9b07d1347f0">fu_malik_maxsat</a> (Z3_context ctx, unsigned num_hard_cnstrs, Z3_ast *hard_cnstrs, unsigned num_soft_cnstrs, Z3_ast *soft_cnstrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fu &amp; Malik procedure for MaxSAT. This procedure is based on unsat core extraction and the at-most-one constraint.  <a href="#gacac27baf151175043165a9b07d1347f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maxsat__ex.html#gaf584c13710008c3a66d2afb7b09e79d6">smtlib_maxsat</a> (char *file_name, int approach)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the maximal number of assumptions that can be satisfied. An assumption is any formula preceeded with the :assumption keyword. "Hard" constraints can be supported by using the :formula keyword.  <a href="#gaf584c13710008c3a66d2afb7b09e79d6"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaccbeb5c2ebcbb71bfa309f4ffcc3440e"></a><!-- doxytag: member="maxsat.c::assert_at_most_k" ref="gaccbeb5c2ebcbb71bfa309f4ffcc3440e" args="(Z3_context ctx, unsigned n, Z3_ast *lits, unsigned k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assert_at_most_k </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>lits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assert that at most <code>k</code> literals in <code>lits</code> can be true, where <code>n</code> is the number of literals in lits. </p>
<p>We use a simple encoding using an adder (counter). An interesting exercise consists in implementing more sophisticated encodings. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00328">328</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00343">assert_at_most_one()</a>, and <a class="el" href="maxsat_8c_source.html#l00425">naive_maxsat()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00329"></a>00329 {
<a name="l00330"></a>00330     Z3_ast * counter_bits;
<a name="l00331"></a>00331     <span class="keywordtype">unsigned</span> counter_bits_sz;
<a name="l00332"></a>00332     <span class="keywordflow">if</span> (k &gt;= n || n &lt;= 1)
<a name="l00333"></a>00333         <span class="keywordflow">return</span>; <span class="comment">/* nothing to be done */</span>
<a name="l00334"></a>00334     counter_bits = <a class="code" href="group__maxsat__ex.html#ga110028ed331e1303de2b8eb66592d6e6" title="Create a counter circuit to count the number of &amp;quot;ones&amp;quot; in lits. The function...">mk_counter_circuit</a>(ctx, n, lits, &amp;counter_bits_sz);
<a name="l00335"></a>00335     <a class="code" href="group__maxsat__ex.html#ga37f2b6f8f117d52f72d4e10148c1e548" title="Given an integer val encoded in n bits (boolean variables), assert the constraint...">assert_le_k</a>(ctx, counter_bits_sz, counter_bits, k);
<a name="l00336"></a>00336     <a class="code" href="group__maxsat__ex.html#ga3cb6544cf32dc16f43c739071bd346c7" title="Delete array of boolean variables.">del_bool_var_array</a>(counter_bits);
<a name="l00337"></a>00337 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga0cd161e82d1bcc3a172222f86b89c6c7"></a><!-- doxytag: member="maxsat.c::assert_at_most_one" ref="ga0cd161e82d1bcc3a172222f86b89c6c7" args="(Z3_context ctx, unsigned n, Z3_ast *lits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assert_at_most_one </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>lits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assert that at most one literal in <code>lits</code> can be true, where <code>n</code> is the number of literals in lits. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00343">343</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00486">fu_malik_maxsat_step()</a>, and <a class="el" href="maxsat_8c_source.html#l00351">tst_at_most_one()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00344"></a>00344 {
<a name="l00345"></a>00345     <a class="code" href="group__maxsat__ex.html#gaccbeb5c2ebcbb71bfa309f4ffcc3440e" title="Assert that at most k literals in lits can be true, where n is the number of literals...">assert_at_most_k</a>(ctx, n, lits, 1);
<a name="l00346"></a>00346 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac0ff93d06034b18b5017068b01412342"></a><!-- doxytag: member="maxsat.c::assert_hard_constraints" ref="gac0ff93d06034b18b5017068b01412342" args="(Z3_context ctx, unsigned num_cnstrs, Z3_ast *cnstrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assert_hard_constraints </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_cnstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>cnstrs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assert hard constraints stored in the given array. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00160">160</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00550">fu_malik_maxsat()</a>, and <a class="el" href="maxsat_8c_source.html#l00425">naive_maxsat()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00161"></a>00161 {
<a name="l00162"></a>00162     <span class="keywordtype">unsigned</span> i;
<a name="l00163"></a>00163     <span class="keywordflow">for</span> (i = 0; i &lt; num_cnstrs; i++) {
<a name="l00164"></a>00164         <a class="code" href="group__capi.html#ga1a05ff73a564ae7256a2257048a4680a" title="Assert a constraint into the logical context.">Z3_assert_cnstr</a>(ctx, cnstrs[i]);
<a name="l00165"></a>00165     }
<a name="l00166"></a>00166 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga37f2b6f8f117d52f72d4e10148c1e548"></a><!-- doxytag: member="maxsat.c::assert_le_k" ref="ga37f2b6f8f117d52f72d4e10148c1e548" args="(Z3_context ctx, unsigned n, Z3_ast *val, unsigned k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assert_le_k </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an integer val encoded in n bits (boolean variables), assert the constraint that val &lt;= k. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00296">296</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00328">assert_at_most_k()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00297"></a>00297 {
<a name="l00298"></a>00298     Z3_ast i1, i2, not_val, out;
<a name="l00299"></a>00299     <span class="keywordtype">unsigned</span> idx;
<a name="l00300"></a>00300     not_val = <a class="code" href="group__capi.html#ga3329538091996eb7b3dc677760a61072" title="Create an AST node representing not(a).">Z3_mk_not</a>(ctx, val[0]);
<a name="l00301"></a>00301     <span class="keywordflow">if</span> (<a class="code" href="group__maxsat__ex.html#ga34e61f425c4c47fe3238465536f2b157" title="Return the idx bit of val.">get_bit</a>(k, 0))
<a name="l00302"></a>00302         out = <a class="code" href="group__capi.html#gae898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(ctx);
<a name="l00303"></a>00303     <span class="keywordflow">else</span>
<a name="l00304"></a>00304         out = not_val;
<a name="l00305"></a>00305     <span class="keywordflow">for</span> (idx = 1; idx &lt; n; idx++) {
<a name="l00306"></a>00306         not_val = <a class="code" href="group__capi.html#ga3329538091996eb7b3dc677760a61072" title="Create an AST node representing not(a).">Z3_mk_not</a>(ctx, val[idx]);
<a name="l00307"></a>00307         <span class="keywordflow">if</span> (<a class="code" href="group__maxsat__ex.html#ga34e61f425c4c47fe3238465536f2b157" title="Return the idx bit of val.">get_bit</a>(k, idx)) {
<a name="l00308"></a>00308             i1 = not_val;
<a name="l00309"></a>00309             i2 = out;
<a name="l00310"></a>00310         }
<a name="l00311"></a>00311         <span class="keywordflow">else</span> {
<a name="l00312"></a>00312             i1 = <a class="code" href="group__capi.html#ga5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(ctx);
<a name="l00313"></a>00313             i2 = <a class="code" href="group__capi.html#ga5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(ctx);
<a name="l00314"></a>00314         }
<a name="l00315"></a>00315         out = <a class="code" href="group__maxsat__ex.html#ga6f720e11eb8cc3b085cfa9766269a663" title="Create a ternary OR.">mk_ternary_or</a>(ctx, i1, i2, <a class="code" href="group__maxsat__ex.html#ga75be768cdd0806203beb01c9186d8805" title="Create a binary AND.">mk_binary_and</a>(ctx, not_val, out));
<a name="l00316"></a>00316     }
<a name="l00317"></a>00317     <span class="comment">// printf(&quot;at-most-k:\n%s\n&quot;, Z3_ast_to_string(ctx, out));</span>
<a name="l00318"></a>00318     <a class="code" href="group__capi.html#ga1a05ff73a564ae7256a2257048a4680a" title="Assert a constraint into the logical context.">Z3_assert_cnstr</a>(ctx, out);
<a name="l00319"></a>00319 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga09cab25d24e179709402bd4a2ca8548d"></a><!-- doxytag: member="maxsat.c::assert_soft_constraints" ref="ga09cab25d24e179709402bd4a2ca8548d" args="(Z3_context ctx, unsigned num_cnstrs, Z3_ast *cnstrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_ast* assert_soft_constraints </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_cnstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>cnstrs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assert soft constraints stored in the given array. This funtion will assert each soft-constraint C_i as (C_i or k_i) where k_i is a fresh boolean variable. It will also return an array containing these fresh variables. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00173">173</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00550">fu_malik_maxsat()</a>, and <a class="el" href="maxsat_8c_source.html#l00425">naive_maxsat()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00174"></a>00174 {
<a name="l00175"></a>00175     <span class="keywordtype">unsigned</span> i;
<a name="l00176"></a>00176     Z3_ast * aux_vars;
<a name="l00177"></a>00177     aux_vars = <a class="code" href="group__maxsat__ex.html#ga6c7f9f06eab298ed6f6ad19e1266549b" title="Create an array with num_vars fresh boolean variables.">mk_fresh_bool_var_array</a>(ctx, num_cnstrs);
<a name="l00178"></a>00178     <span class="keywordflow">for</span> (i = 0; i &lt; num_cnstrs; i++) {
<a name="l00179"></a>00179         Z3_ast assumption = cnstrs[i];
<a name="l00180"></a>00180         <a class="code" href="group__capi.html#ga1a05ff73a564ae7256a2257048a4680a" title="Assert a constraint into the logical context.">Z3_assert_cnstr</a>(ctx, <a class="code" href="group__maxsat__ex.html#gaab12e81ed001b3e1bff357ef8263c8c1" title="Create a binary OR.">mk_binary_or</a>(ctx, assumption, aux_vars[i]));
<a name="l00181"></a>00181     }
<a name="l00182"></a>00182     <span class="keywordflow">return</span> aux_vars;
<a name="l00183"></a>00183 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga3cb6544cf32dc16f43c739071bd346c7"></a><!-- doxytag: member="maxsat.c::del_bool_var_array" ref="ga3cb6544cf32dc16f43c739071bd346c7" args="(Z3_ast *arr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void del_bool_var_array </td>
          <td>(</td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>arr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete array of boolean variables. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00080">80</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00328">assert_at_most_k()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00081"></a>00081 {
<a name="l00082"></a>00082     free(arr);
<a name="l00083"></a>00083 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaad9796c174f7ef5d226cd169f2520fd5"></a><!-- doxytag: member="maxsat.c::error" ref="gaad9796c174f7ef5d226cd169f2520fd5" args="(char *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void error </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exit gracefully in case of error. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00017">17</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00425">naive_maxsat()</a>, <a class="el" href="maxsat_8c_source.html#l00590">smtlib_maxsat()</a>, and <a class="el" href="maxsat_8c_source.html#l00351">tst_at_most_one()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00018"></a>00018 {
<a name="l00019"></a>00019     fprintf(stderr, <span class="stringliteral">&quot;%s\n&quot;</span>, msg);
<a name="l00020"></a>00020     exit(1);
<a name="l00021"></a>00021 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9addf8d434da3c6daa1cc87cfa52ee69"></a><!-- doxytag: member="maxsat.c::free_cnstr_array" ref="ga9addf8d434da3c6daa1cc87cfa52ee69" args="(Z3_ast *cnstrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_cnstr_array </td>
          <td>(</td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>cnstrs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the given array of cnstrs that was allocated using get_hard_constraints or get_soft_constraints. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00152">152</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00590">smtlib_maxsat()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00153"></a>00153 {
<a name="l00154"></a>00154     free(cnstrs);
<a name="l00155"></a>00155 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gacac27baf151175043165a9b07d1347f0"></a><!-- doxytag: member="maxsat.c::fu_malik_maxsat" ref="gacac27baf151175043165a9b07d1347f0" args="(Z3_context ctx, unsigned num_hard_cnstrs, Z3_ast *hard_cnstrs, unsigned num_soft_cnstrs, Z3_ast *soft_cnstrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fu_malik_maxsat </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_hard_cnstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>hard_cnstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_soft_cnstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>soft_cnstrs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fu &amp; Malik procedure for MaxSAT. This procedure is based on unsat core extraction and the at-most-one constraint. </p>
<p>Return the number of soft-constraints that can be satisfied. Return -1 if the hard-constraints cannot be satisfied. That is, the formula cannot be satisfied even if all soft-constraints are ignored.</p>
<p>For more information on the Fu &amp; Malik procedure:</p>
<p>Z. Fu and S. Malik, On solving the partial MAX-SAT problem, in International Conference on Theory and Applications of Satisfiability Testing, 2006. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00550">550</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00590">smtlib_maxsat()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00551"></a>00551 {
<a name="l00552"></a>00552     Z3_ast * aux_vars;
<a name="l00553"></a>00553     <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> is_sat;
<a name="l00554"></a>00554     <span class="keywordtype">unsigned</span> k;
<a name="l00555"></a>00555     <a class="code" href="group__maxsat__ex.html#gac0ff93d06034b18b5017068b01412342" title="Assert hard constraints stored in the given array.">assert_hard_constraints</a>(ctx, num_hard_cnstrs, hard_cnstrs);
<a name="l00556"></a>00556     printf(<span class="stringliteral">&quot;checking whether hard constraints are satisfiable...\n&quot;</span>);
<a name="l00557"></a>00557     is_sat = <a class="code" href="group__capi.html#ga72055cfbae81bd174abed32a83e50b03" title="Check whether the given logical context is consistent or not.">Z3_check</a>(ctx);
<a name="l00558"></a>00558     <span class="keywordflow">if</span> (is_sat == Z3_L_FALSE) {
<a name="l00559"></a>00559         <span class="comment">// It is not possible to make the formula satisfiable even when ignoring all soft constraints.</span>
<a name="l00560"></a>00560         <span class="keywordflow">return</span> -1; 
<a name="l00561"></a>00561     }
<a name="l00562"></a>00562     <span class="keywordflow">if</span> (num_soft_cnstrs == 0)
<a name="l00563"></a>00563         <span class="keywordflow">return</span> 0; <span class="comment">// nothing to be done...</span>
<a name="l00564"></a>00564     <span class="comment">/*</span>
<a name="l00565"></a>00565 <span class="comment">      Fu&amp;Malik algorithm is based on UNSAT-core extraction.</span>
<a name="l00566"></a>00566 <span class="comment">      We accomplish that using auxiliary variables (aka answer literals).</span>
<a name="l00567"></a>00567 <span class="comment">    */</span>
<a name="l00568"></a>00568     aux_vars = <a class="code" href="group__maxsat__ex.html#ga09cab25d24e179709402bd4a2ca8548d" title="Assert soft constraints stored in the given array. This funtion will assert each...">assert_soft_constraints</a>(ctx, num_soft_cnstrs, soft_cnstrs);
<a name="l00569"></a>00569     k = 0;
<a name="l00570"></a>00570     <span class="keywordflow">for</span> (;;) {
<a name="l00571"></a>00571         printf(<span class="stringliteral">&quot;iteration %d\n&quot;</span>, k);
<a name="l00572"></a>00572         <span class="keywordflow">if</span> (<a class="code" href="group__maxsat__ex.html#gad06532e231b6fd3eb01ed05fab779432" title="Implement one step of the Fu&amp;amp;Malik algorithm. See fu_malik_maxsat function for...">fu_malik_maxsat_step</a>(ctx, num_soft_cnstrs, soft_cnstrs, aux_vars)) {
<a name="l00573"></a>00573             <span class="keywordflow">return</span> num_soft_cnstrs - k;
<a name="l00574"></a>00574         }
<a name="l00575"></a>00575         k++;
<a name="l00576"></a>00576     }
<a name="l00577"></a>00577 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad06532e231b6fd3eb01ed05fab779432"></a><!-- doxytag: member="maxsat.c::fu_malik_maxsat_step" ref="gad06532e231b6fd3eb01ed05fab779432" args="(Z3_context ctx, unsigned num_soft_cnstrs, Z3_ast *soft_cnstrs, Z3_ast *aux_vars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fu_malik_maxsat_step </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_soft_cnstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>soft_cnstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>aux_vars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implement one step of the Fu&amp;Malik algorithm. See fu_malik_maxsat function for more details. </p>
<p>Input: soft constraints + aux-vars (aka answer literals) Output: done/not-done when not done return updated set of soft-constraints and aux-vars.</p>
<ul>
<li>if SAT --&gt; terminates</li>
<li>if UNSAT compute unsat core add blocking variable to soft-constraints in the core<ul>
<li>replace soft-constraint with the one with the blocking variable</li>
<li>we should also add an aux-var</li>
<li>replace aux-var with a new one add at-most-one constraint with blocking </li>
</ul>
</li>
</ul>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00486">486</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00550">fu_malik_maxsat()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00487"></a>00487 {
<a name="l00488"></a>00488     <span class="comment">// create assumptions</span>
<a name="l00489"></a>00489     Z3_ast * assumptions = (Z3_ast*) malloc(<span class="keyword">sizeof</span>(Z3_ast) * num_soft_cnstrs);
<a name="l00490"></a>00490     Z3_ast * core        = (Z3_ast*) malloc(<span class="keyword">sizeof</span>(Z3_ast) * num_soft_cnstrs);
<a name="l00491"></a>00491     <span class="keywordtype">unsigned</span> core_size;
<a name="l00492"></a>00492     Z3_ast dummy_proof; <span class="comment">// we don&#39;t care about proofs in this example</span>
<a name="l00493"></a>00493     Z3_model m;
<a name="l00494"></a>00494     <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> is_sat;
<a name="l00495"></a>00495     <span class="keywordtype">unsigned</span> i = 0;
<a name="l00496"></a>00496     <span class="keywordflow">for</span> (i = 0; i &lt; num_soft_cnstrs; i++) {
<a name="l00497"></a>00497         <span class="comment">// Recall that we asserted (soft_cnstrs[i] \/ aux_vars[i])</span>
<a name="l00498"></a>00498         <span class="comment">// So using (NOT aux_vars[i]) as an assumption we are actually forcing the soft_cnstrs[i] to be considered.</span>
<a name="l00499"></a>00499         assumptions[i] = <a class="code" href="group__capi.html#ga3329538091996eb7b3dc677760a61072" title="Create an AST node representing not(a).">Z3_mk_not</a>(ctx, aux_vars[i]);
<a name="l00500"></a>00500         core[i]        = 0;
<a name="l00501"></a>00501     }
<a name="l00502"></a>00502     
<a name="l00503"></a>00503     is_sat = <a class="code" href="group__capi.html#ga289e6cfc3207ee0beb4f9dc8dd4e378b" title="Check whether the given logical context and optional assumptions is consistent or...">Z3_check_assumptions</a>(ctx, num_soft_cnstrs, assumptions, &amp;m, &amp;dummy_proof, &amp;core_size, core);
<a name="l00504"></a>00504     <span class="keywordflow">if</span> (is_sat != Z3_L_FALSE) {
<a name="l00505"></a>00505         <span class="keywordflow">return</span> 1; <span class="comment">// done</span>
<a name="l00506"></a>00506     }
<a name="l00507"></a>00507     <span class="keywordflow">else</span> {
<a name="l00508"></a>00508         Z3_ast * block_vars = (Z3_ast*) malloc(<span class="keyword">sizeof</span>(Z3_ast) * core_size);
<a name="l00509"></a>00509         <span class="keywordtype">unsigned</span> k = 0;
<a name="l00510"></a>00510         <span class="comment">// update soft-constraints and aux_vars</span>
<a name="l00511"></a>00511         <span class="keywordflow">for</span> (i = 0; i &lt; num_soft_cnstrs; i++) {
<a name="l00512"></a>00512             <span class="keywordtype">unsigned</span> j;
<a name="l00513"></a>00513             <span class="comment">// check whether assumption[i] is in the core or not</span>
<a name="l00514"></a>00514             <span class="keywordflow">for</span> (j = 0; j &lt; core_size; j++) {
<a name="l00515"></a>00515                 <span class="keywordflow">if</span> (assumptions[i] == core[j])
<a name="l00516"></a>00516                     <span class="keywordflow">break</span>;
<a name="l00517"></a>00517             }
<a name="l00518"></a>00518             <span class="keywordflow">if</span> (j &lt; core_size) {
<a name="l00519"></a>00519                 <span class="comment">// assumption[i] is in the unsat core... so soft_cnstrs[i] is in the unsat core</span>
<a name="l00520"></a>00520                 Z3_ast block_var   = <a class="code" href="group__maxsat__ex.html#ga2d600be3c99aa6bd76b39d1e715420c6" title="Create a fresh boolean variable.">mk_fresh_bool_var</a>(ctx);
<a name="l00521"></a>00521                 Z3_ast new_aux_var = <a class="code" href="group__maxsat__ex.html#ga2d600be3c99aa6bd76b39d1e715420c6" title="Create a fresh boolean variable.">mk_fresh_bool_var</a>(ctx);
<a name="l00522"></a>00522                 soft_cnstrs[i]     = <a class="code" href="group__maxsat__ex.html#gaab12e81ed001b3e1bff357ef8263c8c1" title="Create a binary OR.">mk_binary_or</a>(ctx, soft_cnstrs[i], block_var);
<a name="l00523"></a>00523                 aux_vars[i]        = new_aux_var;
<a name="l00524"></a>00524                 block_vars[k]      = block_var;
<a name="l00525"></a>00525                 k++;
<a name="l00526"></a>00526                 <span class="comment">// Add new constraint containing the block variable.</span>
<a name="l00527"></a>00527                 <span class="comment">// Note that we are using the new auxiliary variable to be able to use it as an assumption.</span>
<a name="l00528"></a>00528                 <a class="code" href="group__capi.html#ga1a05ff73a564ae7256a2257048a4680a" title="Assert a constraint into the logical context.">Z3_assert_cnstr</a>(ctx, <a class="code" href="group__maxsat__ex.html#gaab12e81ed001b3e1bff357ef8263c8c1" title="Create a binary OR.">mk_binary_or</a>(ctx, soft_cnstrs[i], new_aux_var));
<a name="l00529"></a>00529             }
<a name="l00530"></a>00530         }
<a name="l00531"></a>00531         <a class="code" href="group__maxsat__ex.html#ga0cd161e82d1bcc3a172222f86b89c6c7" title="Assert that at most one literal in lits can be true, where n is the number of literals...">assert_at_most_one</a>(ctx, k, block_vars);
<a name="l00532"></a>00532         <span class="keywordflow">return</span> 0; <span class="comment">// not done.</span>
<a name="l00533"></a>00533     }
<a name="l00534"></a>00534 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga34e61f425c4c47fe3238465536f2b157"></a><!-- doxytag: member="maxsat.c::get_bit" ref="ga34e61f425c4c47fe3238465536f2b157" args="(unsigned val, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_bit </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the <code>idx</code> bit of <code>val</code>. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00287">287</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00296">assert_le_k()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00288"></a>00288 {
<a name="l00289"></a>00289     <span class="keywordtype">unsigned</span> mask = 1 &lt;&lt; (idx &amp; 31);
<a name="l00290"></a>00290     <span class="keywordflow">return</span> (val &amp; mask) != 0;
<a name="l00291"></a>00291 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga37df58ec6af77230db093d908dd88333"></a><!-- doxytag: member="maxsat.c::get_hard_constraints" ref="ga37df58ec6af77230db093d908dd88333" args="(Z3_context ctx, unsigned *num_cnstrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_ast* get_hard_constraints </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>num_cnstrs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get hard constraints from a SMT-LIB file. We assume hard constraints are formulas preceeded with the keyword :formula. Return an array containing all formulas read by the last Z3_parse_smtlib_file invocation. It will store the number of formulas in num_cnstrs. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00119">119</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00590">smtlib_maxsat()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00120"></a>00120 {
<a name="l00121"></a>00121     Z3_ast * result;
<a name="l00122"></a>00122     <span class="keywordtype">unsigned</span> i;
<a name="l00123"></a>00123     *num_cnstrs = <a class="code" href="group__capi.html#ga5dd0dfb9ec1fcc7edba1e86a6ff98a77" title="Return the number of SMTLIB formulas parsed by the last call to Z3_parse_smtlib_string...">Z3_get_smtlib_num_formulas</a>(ctx); 
<a name="l00124"></a>00124     result = (Z3_ast *) malloc(<span class="keyword">sizeof</span>(Z3_ast) * (*num_cnstrs));
<a name="l00125"></a>00125     <span class="keywordflow">for</span> (i = 0; i &lt; *num_cnstrs; i++) {
<a name="l00126"></a>00126         result[i] = <a class="code" href="group__capi.html#ga0ac42d0fa1874e4e773c89a56066f242" title="Return the i-th formula parsed by the last call to Z3_parse_smtlib_string or Z3_parse_smtlib_file...">Z3_get_smtlib_formula</a>(ctx, i);
<a name="l00127"></a>00127     }
<a name="l00128"></a>00128     <span class="keywordflow">return</span> result;
<a name="l00129"></a>00129 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaad360c0088050f32e64f24a27d26cc4a"></a><!-- doxytag: member="maxsat.c::get_num_disabled_soft_constraints" ref="gaad360c0088050f32e64f24a27d26cc4a" args="(Z3_context ctx, Z3_model m, unsigned num_soft_cnstrs, Z3_ast *aux_vars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned get_num_disabled_soft_constraints </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_model&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_soft_cnstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>aux_vars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of soft-constraints that were disable by the given model. A soft-constraint was disabled if the associated auxiliary variable was assigned to true. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00397">397</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00425">naive_maxsat()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00398"></a>00398 {
<a name="l00399"></a>00399     <span class="keywordtype">unsigned</span> i;
<a name="l00400"></a>00400     <span class="keywordtype">unsigned</span> num_disabled = 0;
<a name="l00401"></a>00401     Z3_ast t = <a class="code" href="group__capi.html#gae898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(ctx);
<a name="l00402"></a>00402     <span class="keywordflow">for</span> (i = 0; i &lt; num_soft_cnstrs; i++) {
<a name="l00403"></a>00403         Z3_ast val;
<a name="l00404"></a>00404         <span class="keywordflow">if</span> (<a class="code" href="group__capi.html#ga47d3655283564918c85bda0b423b7f67" title="Evaluate the AST node t in the given model. Return Z3_TRUE if succeeded, and store...">Z3_eval</a>(ctx, m, aux_vars[i], &amp;val) == <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>) {
<a name="l00405"></a>00405             <span class="comment">// printf(&quot;%s&quot;, Z3_ast_to_string(ctx, aux_vars[i]));</span>
<a name="l00406"></a>00406             <span class="comment">// printf(&quot; -&gt; %s\n&quot;, Z3_ast_to_string(ctx, val));</span>
<a name="l00407"></a>00407             <span class="keywordflow">if</span> (<a class="code" href="group__capi.html#ga10b4c8088013ecd876054c6817e61640" title="compare terms.">Z3_is_eq_ast</a>(ctx, val, t)) {
<a name="l00408"></a>00408                 num_disabled++;
<a name="l00409"></a>00409             }
<a name="l00410"></a>00410         }
<a name="l00411"></a>00411     }
<a name="l00412"></a>00412     <span class="keywordflow">return</span> num_disabled;
<a name="l00413"></a>00413 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga3489c094c45ae2468b18776e15066cda"></a><!-- doxytag: member="maxsat.c::get_soft_constraints" ref="ga3489c094c45ae2468b18776e15066cda" args="(Z3_context ctx, unsigned *num_cnstrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_ast* get_soft_constraints </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>num_cnstrs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get soft constraints from a SMT-LIB file. We assume soft constraints are formulas preceeded with the keyword :assumption. Return an array containing all assumptions read by the last Z3_parse_smtlib_file invocation. It will store the number of formulas in num_cnstrs. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00137">137</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00590">smtlib_maxsat()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00138"></a>00138 {
<a name="l00139"></a>00139     Z3_ast * result;
<a name="l00140"></a>00140     <span class="keywordtype">unsigned</span> i;
<a name="l00141"></a>00141     *num_cnstrs = <a class="code" href="group__capi.html#gaa6682931827a2af6413c2ad6e57a01b4" title="Return the number of SMTLIB assumptions parsed by Z3_parse_smtlib_string or Z3_parse_smtlib_file...">Z3_get_smtlib_num_assumptions</a>(ctx); 
<a name="l00142"></a>00142     result = (Z3_ast *) malloc(<span class="keyword">sizeof</span>(Z3_ast) * (*num_cnstrs));
<a name="l00143"></a>00143     <span class="keywordflow">for</span> (i = 0; i &lt; *num_cnstrs; i++) {
<a name="l00144"></a>00144         result[i] = <a class="code" href="group__capi.html#ga00764430965b47fbcba657305e1dd820" title="Return the i-th assumption parsed by the last call to Z3_parse_smtlib_string or Z3_parse_smtlib_file...">Z3_get_smtlib_assumption</a>(ctx, i);
<a name="l00145"></a>00145     }
<a name="l00146"></a>00146     <span class="keywordflow">return</span> result;
<a name="l00147"></a>00147 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gafa3546986987389015292f26f6ca838f"></a><!-- doxytag: member="maxsat.c::mk_adder" ref="gafa3546986987389015292f26f6ca838f" args="(Z3_context ctx, unsigned num_bits, Z3_ast *in_1, Z3_ast *in_2, Z3_ast *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mk_adder </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>in_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>in_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an adder for inputs of size <code>num_bits</code>. The arguments <code>in1</code> and <code>in2</code> are arrays of bits of size <code>num_bits</code>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><code>result</code> must be an array of size <code>num_bits</code> + 1. </dd></dl>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00201">201</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00222">mk_adder_pairs()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00202"></a>00202 {
<a name="l00203"></a>00203     Z3_ast cin, cout, out;
<a name="l00204"></a>00204     <span class="keywordtype">unsigned</span> i;
<a name="l00205"></a>00205     cin = <a class="code" href="group__capi.html#ga5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(ctx);
<a name="l00206"></a>00206     <span class="keywordflow">for</span> (i = 0; i &lt; num_bits; i++) {
<a name="l00207"></a>00207         <a class="code" href="group__maxsat__ex.html#ga7be6e5527171df812c1d574083626357" title="Create a full adder with inputs in_1, in_2 and cin. The output of the full adder...">mk_full_adder</a>(ctx, in_1[i], in_2[i], cin, &amp;out, &amp;cout);
<a name="l00208"></a>00208         result[i] = out;
<a name="l00209"></a>00209         cin = cout;
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211     result[num_bits] = cout;
<a name="l00212"></a>00212 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac4a5af441cfab87f25b02444898b6ee3"></a><!-- doxytag: member="maxsat.c::mk_adder_pairs" ref="gac4a5af441cfab87f25b02444898b6ee3" args="(Z3_context ctx, unsigned num_bits, unsigned num_ins, Z3_ast *in, unsigned *out_num_ins, Z3_ast *out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mk_adder_pairs </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>out_num_ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given <code>num_ins</code> "numbers" of size <code>num_bits</code> stored in <code>in</code>. Create floor(num_ins/2) adder circuits. Each circuit is adding two consecutive "numbers". The numbers are stored one after the next in the array <code>in</code>. That is, the array <code>in</code> has size num_bits * num_ins. Return an array of bits containing <code>ceil</code>(num_ins/2) numbers of size <code></code>(num_bits + 1). If num_ins/2 is not an integer, then the last "number" in the output, is the last "number" in <code>in</code> with an appended "zero". </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00222">222</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00248">mk_counter_circuit()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00223"></a>00223 {
<a name="l00224"></a>00224     <span class="keywordtype">unsigned</span> out_num_bits = num_bits + 1;
<a name="l00225"></a>00225     <span class="keywordtype">unsigned</span> i            = 0;
<a name="l00226"></a>00226     Z3_ast * _in          = in;
<a name="l00227"></a>00227     Z3_ast * _out         = out;
<a name="l00228"></a>00228     *out_num_ins  = (num_ins % 2 == 0) ? (num_ins / 2) : (num_ins / 2) + 1;
<a name="l00229"></a>00229     <span class="keywordflow">for</span> (i = 0; i &lt; num_ins / 2; i++) {
<a name="l00230"></a>00230         <a class="code" href="group__maxsat__ex.html#gafa3546986987389015292f26f6ca838f" title="Create an adder for inputs of size num_bits. The arguments in1 and in2 are arrays...">mk_adder</a>(ctx, num_bits, _in, _in + num_bits, _out);
<a name="l00231"></a>00231         _in  += num_bits;
<a name="l00232"></a>00232         _in  += num_bits;
<a name="l00233"></a>00233         _out += out_num_bits;
<a name="l00234"></a>00234     }
<a name="l00235"></a>00235     <span class="keywordflow">if</span> (num_ins % 2 != 0) {
<a name="l00236"></a>00236         <span class="keywordflow">for</span> (i = 0; i &lt; num_bits; i++) {
<a name="l00237"></a>00237             _out[i] = _in[i];
<a name="l00238"></a>00238         }
<a name="l00239"></a>00239         _out[num_bits] = <a class="code" href="group__capi.html#ga5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(ctx);
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga75be768cdd0806203beb01c9186d8805"></a><!-- doxytag: member="maxsat.c::mk_binary_and" ref="ga75be768cdd0806203beb01c9186d8805" args="(Z3_context ctx, Z3_ast in_1, Z3_ast in_2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_ast mk_binary_and </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast&nbsp;</td>
          <td class="paramname"> <em>in_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast&nbsp;</td>
          <td class="paramname"> <em>in_2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a binary AND. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00106">106</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00296">assert_le_k()</a>, and <a class="el" href="maxsat_8c_source.html#l00189">mk_full_adder()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00107"></a>00107 {
<a name="l00108"></a>00108     Z3_ast args[2] = { in_1, in_2 };
<a name="l00109"></a>00109     <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gacde98ce4a8ed1dde50b9669db4838c61" title="Create an AST node representing args[0] and ... and args[num_args-1].">Z3_mk_and</a>(ctx, 2, args);
<a name="l00110"></a>00110 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaab12e81ed001b3e1bff357ef8263c8c1"></a><!-- doxytag: member="maxsat.c::mk_binary_or" ref="gaab12e81ed001b3e1bff357ef8263c8c1" args="(Z3_context ctx, Z3_ast in_1, Z3_ast in_2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_ast mk_binary_or </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast&nbsp;</td>
          <td class="paramname"> <em>in_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast&nbsp;</td>
          <td class="paramname"> <em>in_2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a binary OR. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00088">88</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00173">assert_soft_constraints()</a>, <a class="el" href="maxsat_8c_source.html#l00486">fu_malik_maxsat_step()</a>, and <a class="el" href="maxsat_8c_source.html#l00351">tst_at_most_one()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00089"></a>00089 {
<a name="l00090"></a>00090     Z3_ast args[2] = { in_1, in_2 };
<a name="l00091"></a>00091     <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga00866d16331d505620a6c515302021f9" title="Create an AST node representing args[0] or ... or args[num_args-1].">Z3_mk_or</a>(ctx, 2, args);
<a name="l00092"></a>00092 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga397d6e03e2538ff0df36aad6e02030ae"></a><!-- doxytag: member="maxsat.c::mk_bool_var" ref="ga397d6e03e2538ff0df36aad6e02030ae" args="(Z3_context ctx, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_ast mk_bool_var </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a boolean variable using the given name. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00050">50</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="test__capi_8c_source.html#l01484">error_code_example1()</a>, <a class="el" href="test__capi_8c_source.html#l01528">error_code_example2()</a>, <a class="el" href="test__capi_8c_source.html#l00738">find_model_example1()</a>, <a class="el" href="maxsat_8c_source.html#l00351">tst_at_most_one()</a>, and <a class="el" href="test__capi_8c_source.html#l02184">unsat_core_and_proof_example()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00051"></a>00051 {
<a name="l00052"></a>00052     Z3_sort ty = <a class="code" href="group__capi.html#gacdc73510b69a010b71793d429015f342" title="Create the Boolean type.">Z3_mk_bool_sort</a>(ctx);
<a name="l00053"></a>00053     <span class="keywordflow">return</span> <a class="code" href="group__maxsat__ex.html#gad55575aaf95896158c9e2f12e93769c8" title="Create a variable using the given name and type.">mk_var</a>(ctx, name, ty);
<a name="l00054"></a>00054 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga102b86f8b4829828c5c2d06c5d8b8489"></a><!-- doxytag: member="maxsat.c::mk_context" ref="ga102b86f8b4829828c5c2d06c5d8b8489" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_context mk_context </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a logical context. Enable model construction only. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00027">27</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="test__capi_8c_source.html#l01099">array_example1()</a>, <a class="el" href="test__capi_8c_source.html#l01156">array_example2()</a>, <a class="el" href="test__capi_8c_source.html#l01195">array_example3()</a>, <a class="el" href="test__capi_8c_source.html#l02102">binary_tree_example()</a>, <a class="el" href="test__capi_8c_source.html#l01347">bitvector_example1()</a>, <a class="el" href="test__capi_8c_source.html#l01377">bitvector_example2()</a>, <a class="el" href="test__capi_8c_source.html#l01795">enum_example()</a>, <a class="el" href="test__capi_8c_source.html#l01407">eval_example1()</a>, <a class="el" href="test__capi_8c_source.html#l00738">find_model_example1()</a>, <a class="el" href="test__capi_8c_source.html#l00764">find_model_example2()</a>, <a class="el" href="test__capi_8c_source.html#l01994">forest_example()</a>, <a class="el" href="test__capi_8c_source.html#l01771">ite_example()</a>, <a class="el" href="test__capi_8c_source.html#l01852">list_example()</a>, <a class="el" href="test__capi_8c_source.html#l02323">mk_ext_context()</a>, <a class="el" href="test__user__theory_8c_source.html#l00889">model_display_example()</a>, <a class="el" href="test__capi_8c_source.html#l01745">numeral_example()</a>, <a class="el" href="test__user__theory_8c_source.html#l00814">pa_theory_example1()</a>, <a class="el" href="test__user__theory_8c_source.html#l00842">pa_theory_example2()</a>, <a class="el" href="test__capi_8c_source.html#l01564">parser_example1()</a>, <a class="el" href="test__capi_8c_source.html#l01593">parser_example2()</a>, <a class="el" href="test__capi_8c_source.html#l01676">parser_example4()</a>, <a class="el" href="test__capi_8c_source.html#l00812">prove_example1()</a>, <a class="el" href="test__capi_8c_source.html#l00871">prove_example2()</a>, <a class="el" href="test__capi_8c_source.html#l00946">push_pop_example1()</a>, <a class="el" href="test__capi_8c_source.html#l00663">simple_example()</a>, <a class="el" href="test__user__theory_8c_source.html#l00488">simple_example1()</a>, <a class="el" href="test__user__theory_8c_source.html#l00515">simple_example2()</a>, <a class="el" href="test__capi_8c_source.html#l02546">smt2parser_example()</a>, <a class="el" href="maxsat_8c_source.html#l00590">smtlib_maxsat()</a>, <a class="el" href="test__capi_8c_source.html#l02561">substitute_example()</a>, <a class="el" href="test__capi_8c_source.html#l02606">substitute_vars_example()</a>, <a class="el" href="test__capi_8c_source.html#l01916">tree_example()</a>, <a class="el" href="maxsat_8c_source.html#l00351">tst_at_most_one()</a>, <a class="el" href="test__capi_8c_source.html#l01233">tuple_example1()</a>, and <a class="el" href="test__capi_8c_source.html#l01458">two_contexts_example1()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00028"></a>00028 {
<a name="l00029"></a>00029     Z3_config  cfg;
<a name="l00030"></a>00030     Z3_context ctx;
<a name="l00031"></a>00031     cfg = <a class="code" href="group__capi.html#ga7d6c40d9b79fe8a8851cc8540970787f" title="Create a configuration.">Z3_mk_config</a>();
<a name="l00032"></a>00032     <a class="code" href="group__capi.html#gab6f8f5d3d059be1ae2982902202b3a25" title="Set a configuration parameter.">Z3_set_param_value</a>(cfg, <span class="stringliteral">&quot;MODEL&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>);
<a name="l00033"></a>00033     ctx = <a class="code" href="group__capi.html#ga0bd93cfab4d749dd3e2f2a4416820a46" title="Create a context using the given configuration.">Z3_mk_context</a>(cfg);
<a name="l00034"></a>00034     <a class="code" href="group__capi.html#ga5e620acf5d55d0271097c9bb97219774" title="Delete the given configuration object.">Z3_del_config</a>(cfg);
<a name="l00035"></a>00035     <span class="keywordflow">return</span> ctx;
<a name="l00036"></a>00036 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga110028ed331e1303de2b8eb66592d6e6"></a><!-- doxytag: member="maxsat.c::mk_counter_circuit" ref="ga110028ed331e1303de2b8eb66592d6e6" args="(Z3_context ctx, unsigned n, Z3_ast *lits, unsigned *out_sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_ast* mk_counter_circuit </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>lits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&nbsp;</td>
          <td class="paramname"> <em>out_sz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a counter circuit to count the number of "ones" in lits. The function returns an array of bits (i.e. boolean expressions) containing the output of the circuit. The size of the array is stored in out_sz. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00248">248</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00328">assert_at_most_k()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00249"></a>00249 {
<a name="l00250"></a>00250     <span class="keywordtype">unsigned</span> num_ins  = n;
<a name="l00251"></a>00251     <span class="keywordtype">unsigned</span> num_bits = 1;
<a name="l00252"></a>00252     Z3_ast * aux_1;
<a name="l00253"></a>00253     Z3_ast * aux_2;
<a name="l00254"></a>00254     <span class="keywordflow">if</span> (n == 0)
<a name="l00255"></a>00255         <span class="keywordflow">return</span> 0;
<a name="l00256"></a>00256     aux_1    = (Z3_ast *) malloc(<span class="keyword">sizeof</span>(Z3_ast) * (n + 1)); 
<a name="l00257"></a>00257     aux_2    = (Z3_ast *) malloc(<span class="keyword">sizeof</span>(Z3_ast) * (n + 1)); 
<a name="l00258"></a>00258     memcpy(aux_1, lits, <span class="keyword">sizeof</span>(Z3_ast) * n);
<a name="l00259"></a>00259     <span class="keywordflow">while</span> (num_ins &gt; 1) {
<a name="l00260"></a>00260         <span class="keywordtype">unsigned</span> new_num_ins;
<a name="l00261"></a>00261         Z3_ast * tmp;
<a name="l00262"></a>00262         <a class="code" href="group__maxsat__ex.html#gac4a5af441cfab87f25b02444898b6ee3" title="Given num_ins &amp;quot;numbers&amp;quot; of size num_bits stored in in. Create floor(num_ins/2)...">mk_adder_pairs</a>(ctx, num_bits, num_ins, aux_1, &amp;new_num_ins, aux_2);
<a name="l00263"></a>00263         num_ins = new_num_ins;
<a name="l00264"></a>00264         num_bits++;
<a name="l00265"></a>00265 <span class="preprocessor">#ifdef MAXSAT_DEBUG</span>
<a name="l00266"></a>00266 <span class="preprocessor"></span>        {
<a name="l00267"></a>00267             <span class="keywordtype">unsigned</span> i;
<a name="l00268"></a>00268             printf(<span class="stringliteral">&quot;num_bits: %d, num_ins: %d \n&quot;</span>, num_bits, num_ins);
<a name="l00269"></a>00269             <span class="keywordflow">for</span> (i = 0; i &lt; num_ins * num_bits; i++) {
<a name="l00270"></a>00270                 printf(<span class="stringliteral">&quot;bit %d:\n%s\n&quot;</span>, i, <a class="code" href="group__capi.html#gab1aa4b78298fe00b3167bf7bfd88aea3" title="Convert the given AST node into a string.">Z3_ast_to_string</a>(ctx, aux_2[i]));
<a name="l00271"></a>00271             }
<a name="l00272"></a>00272             printf(<span class="stringliteral">&quot;-----------\n&quot;</span>);
<a name="l00273"></a>00273         }
<a name="l00274"></a>00274 <span class="preprocessor">#endif</span>
<a name="l00275"></a>00275 <span class="preprocessor"></span>        tmp   = aux_1;
<a name="l00276"></a>00276         aux_1 = aux_2;
<a name="l00277"></a>00277         aux_2 = tmp;
<a name="l00278"></a>00278     }
<a name="l00279"></a>00279     *out_sz = num_bits;
<a name="l00280"></a>00280     free(aux_2);
<a name="l00281"></a>00281     <span class="keywordflow">return</span> aux_1;
<a name="l00282"></a>00282 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2d600be3c99aa6bd76b39d1e715420c6"></a><!-- doxytag: member="maxsat.c::mk_fresh_bool_var" ref="ga2d600be3c99aa6bd76b39d1e715420c6" args="(Z3_context ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_ast mk_fresh_bool_var </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a fresh boolean variable. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00059">59</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00486">fu_malik_maxsat_step()</a>, and <a class="el" href="maxsat_8c_source.html#l00067">mk_fresh_bool_var_array()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00060"></a>00060 {
<a name="l00061"></a>00061     <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga99cbd3e87cdd759a3d0ea43b4884ed32" title="Declare and create a fresh constant.">Z3_mk_fresh_const</a>(ctx, <span class="stringliteral">&quot;k&quot;</span>, <a class="code" href="group__capi.html#gacdc73510b69a010b71793d429015f342" title="Create the Boolean type.">Z3_mk_bool_sort</a>(ctx));
<a name="l00062"></a>00062 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6c7f9f06eab298ed6f6ad19e1266549b"></a><!-- doxytag: member="maxsat.c::mk_fresh_bool_var_array" ref="ga6c7f9f06eab298ed6f6ad19e1266549b" args="(Z3_context ctx, unsigned num_vars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_ast* mk_fresh_bool_var_array </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_vars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an array with <code>num_vars</code> fresh boolean variables. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00067">67</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00173">assert_soft_constraints()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00068"></a>00068 {
<a name="l00069"></a>00069     Z3_ast * result = (Z3_ast *) malloc(<span class="keyword">sizeof</span>(Z3_ast) * num_vars);
<a name="l00070"></a>00070     <span class="keywordtype">unsigned</span> i;
<a name="l00071"></a>00071     <span class="keywordflow">for</span> (i = 0; i &lt; num_vars; i++) {
<a name="l00072"></a>00072         result[i] = <a class="code" href="group__maxsat__ex.html#ga2d600be3c99aa6bd76b39d1e715420c6" title="Create a fresh boolean variable.">mk_fresh_bool_var</a>(ctx);
<a name="l00073"></a>00073     }
<a name="l00074"></a>00074     <span class="keywordflow">return</span> result;
<a name="l00075"></a>00075 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga7be6e5527171df812c1d574083626357"></a><!-- doxytag: member="maxsat.c::mk_full_adder" ref="ga7be6e5527171df812c1d574083626357" args="(Z3_context ctx, Z3_ast in_1, Z3_ast in_2, Z3_ast cin, Z3_ast *out, Z3_ast *cout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mk_full_adder </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast&nbsp;</td>
          <td class="paramname"> <em>in_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast&nbsp;</td>
          <td class="paramname"> <em>in_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast&nbsp;</td>
          <td class="paramname"> <em>cin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>cout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a full adder with inputs <code>in_1</code>, <code>in_2</code> and <code>cin</code>. The output of the full adder is stored in <code>out</code>, and the carry in <code>c_out</code>. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00189">189</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00201">mk_adder()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00190"></a>00190 {
<a name="l00191"></a>00191     *cout = <a class="code" href="group__maxsat__ex.html#ga6f720e11eb8cc3b085cfa9766269a663" title="Create a ternary OR.">mk_ternary_or</a>(ctx, <a class="code" href="group__maxsat__ex.html#ga75be768cdd0806203beb01c9186d8805" title="Create a binary AND.">mk_binary_and</a>(ctx, in_1, in_2), <a class="code" href="group__maxsat__ex.html#ga75be768cdd0806203beb01c9186d8805" title="Create a binary AND.">mk_binary_and</a>(ctx, in_1, cin), <a class="code" href="group__maxsat__ex.html#ga75be768cdd0806203beb01c9186d8805" title="Create a binary AND.">mk_binary_and</a>(ctx, in_2, cin));
<a name="l00192"></a>00192     *out  = <a class="code" href="group__capi.html#gacc6d1b848032dec0c4617b594d4229ec" title="Create an AST node representing t1 xor t2.">Z3_mk_xor</a>(ctx, <a class="code" href="group__capi.html#gacc6d1b848032dec0c4617b594d4229ec" title="Create an AST node representing t1 xor t2.">Z3_mk_xor</a>(ctx, in_1, in_2), cin);
<a name="l00193"></a>00193 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6f720e11eb8cc3b085cfa9766269a663"></a><!-- doxytag: member="maxsat.c::mk_ternary_or" ref="ga6f720e11eb8cc3b085cfa9766269a663" args="(Z3_context ctx, Z3_ast in_1, Z3_ast in_2, Z3_ast in_3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_ast mk_ternary_or </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast&nbsp;</td>
          <td class="paramname"> <em>in_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast&nbsp;</td>
          <td class="paramname"> <em>in_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast&nbsp;</td>
          <td class="paramname"> <em>in_3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a ternary OR. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00097">97</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00296">assert_le_k()</a>, and <a class="el" href="maxsat_8c_source.html#l00189">mk_full_adder()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00098"></a>00098 {
<a name="l00099"></a>00099     Z3_ast args[3] = { in_1, in_2, in_3 };
<a name="l00100"></a>00100     <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga00866d16331d505620a6c515302021f9" title="Create an AST node representing args[0] or ... or args[num_args-1].">Z3_mk_or</a>(ctx, 3, args);
<a name="l00101"></a>00101 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad55575aaf95896158c9e2f12e93769c8"></a><!-- doxytag: member="maxsat.c::mk_var" ref="gad55575aaf95896158c9e2f12e93769c8" args="(Z3_context ctx, const char *name, Z3_sort ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Z3_ast mk_var </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_sort&nbsp;</td>
          <td class="paramname"> <em>ty</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a variable using the given name and type. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00041">41</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="test__capi_8c_source.html#l01099">array_example1()</a>, <a class="el" href="test__capi_8c_source.html#l01347">bitvector_example1()</a>, <a class="el" href="test__capi_8c_source.html#l01377">bitvector_example2()</a>, <a class="el" href="test__capi_8c_source.html#l01795">enum_example()</a>, <a class="el" href="test__capi_8c_source.html#l01994">forest_example()</a>, <a class="el" href="test__capi_8c_source.html#l01852">list_example()</a>, <a class="el" href="maxsat_8c_source.html#l00050">mk_bool_var()</a>, <a class="el" href="test__capi_8c_source.html#l00135">mk_int_var()</a>, <a class="el" href="test__capi_8c_source.html#l00153">mk_real_var()</a>, <a class="el" href="test__user__theory_8c_source.html#l00889">model_display_example()</a>, <a class="el" href="test__user__theory_8c_source.html#l00814">pa_theory_example1()</a>, <a class="el" href="test__user__theory_8c_source.html#l00842">pa_theory_example2()</a>, <a class="el" href="test__user__theory_8c_source.html#l00488">simple_example1()</a>, <a class="el" href="test__user__theory_8c_source.html#l00515">simple_example2()</a>, <a class="el" href="test__capi_8c_source.html#l01916">tree_example()</a>, and <a class="el" href="test__capi_8c_source.html#l01233">tuple_example1()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00042"></a>00042 {
<a name="l00043"></a>00043     Z3_symbol   s  = <a class="code" href="group__capi.html#ga6b9ed981ba0180962928394fe828b0a7" title="Create a Z3 symbol using a C string.">Z3_mk_string_symbol</a>(ctx, name);
<a name="l00044"></a>00044     <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga093c9703393f33ae282ec5e8729354ef" title="Declare and create a constant.">Z3_mk_const</a>(ctx, s, ty);
<a name="l00045"></a>00045 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4c670fc1e4cbcdba5dc237b439c6a08d"></a><!-- doxytag: member="maxsat.c::naive_maxsat" ref="ga4c670fc1e4cbcdba5dc237b439c6a08d" args="(Z3_context ctx, unsigned num_hard_cnstrs, Z3_ast *hard_cnstrs, unsigned num_soft_cnstrs, Z3_ast *soft_cnstrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int naive_maxsat </td>
          <td>(</td>
          <td class="paramtype">Z3_context&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_hard_cnstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>hard_cnstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_soft_cnstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Z3_ast *&nbsp;</td>
          <td class="paramname"> <em>soft_cnstrs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Naive maxsat procedure based on linear search and at-most-k constraint. Return the number of soft-constraints that can be satisfied. Return -1 if the hard-constraints cannot be satisfied. That is, the formula cannot be satisfied even if all soft-constraints are ignored. </p>
<p>Exercise: use binary search to implement MaxSAT. Hint: you will need to use an answer literal to retract the at-most-k constraint. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00425">425</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p>Referenced by <a class="el" href="maxsat_8c_source.html#l00590">smtlib_maxsat()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00426"></a>00426 {
<a name="l00427"></a>00427     Z3_ast * aux_vars;
<a name="l00428"></a>00428     <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> is_sat;
<a name="l00429"></a>00429     <span class="keywordtype">unsigned</span> r, k;
<a name="l00430"></a>00430     <a class="code" href="group__maxsat__ex.html#gac0ff93d06034b18b5017068b01412342" title="Assert hard constraints stored in the given array.">assert_hard_constraints</a>(ctx, num_hard_cnstrs, hard_cnstrs);
<a name="l00431"></a>00431     printf(<span class="stringliteral">&quot;checking whether hard constraints are satisfiable...\n&quot;</span>);
<a name="l00432"></a>00432     is_sat = <a class="code" href="group__capi.html#ga72055cfbae81bd174abed32a83e50b03" title="Check whether the given logical context is consistent or not.">Z3_check</a>(ctx);
<a name="l00433"></a>00433     <span class="keywordflow">if</span> (is_sat == Z3_L_FALSE) {
<a name="l00434"></a>00434         <span class="comment">// It is not possible to make the formula satisfiable even when ignoring all soft constraints.</span>
<a name="l00435"></a>00435         <span class="keywordflow">return</span> -1; 
<a name="l00436"></a>00436     }
<a name="l00437"></a>00437     <span class="keywordflow">if</span> (num_soft_cnstrs == 0)
<a name="l00438"></a>00438         <span class="keywordflow">return</span> 0; <span class="comment">// nothing to be done...</span>
<a name="l00439"></a>00439     aux_vars = <a class="code" href="group__maxsat__ex.html#ga09cab25d24e179709402bd4a2ca8548d" title="Assert soft constraints stored in the given array. This funtion will assert each...">assert_soft_constraints</a>(ctx, num_soft_cnstrs, soft_cnstrs);
<a name="l00440"></a>00440     <span class="comment">// Perform linear search.</span>
<a name="l00441"></a>00441     r = 0;
<a name="l00442"></a>00442     k = num_soft_cnstrs - 1;
<a name="l00443"></a>00443     <span class="keywordflow">for</span> (;;) {
<a name="l00444"></a>00444         Z3_model m;
<a name="l00445"></a>00445         <span class="keywordtype">unsigned</span> num_disabled;
<a name="l00446"></a>00446         <span class="comment">// at most k soft-constraints can be ignored.</span>
<a name="l00447"></a>00447         printf(<span class="stringliteral">&quot;checking whether at-most %d soft-constraints can be ignored.\n&quot;</span>, k);
<a name="l00448"></a>00448         <a class="code" href="group__maxsat__ex.html#gaccbeb5c2ebcbb71bfa309f4ffcc3440e" title="Assert that at most k literals in lits can be true, where n is the number of literals...">assert_at_most_k</a>(ctx, num_soft_cnstrs, aux_vars, k);
<a name="l00449"></a>00449         is_sat = <a class="code" href="group__capi.html#gaff310fef80ac8a82d0a51417e073ec0a" title="Check whether the given logical context is consistent or not.">Z3_check_and_get_model</a>(ctx, &amp;m);
<a name="l00450"></a>00450         <span class="keywordflow">if</span> (is_sat == Z3_L_FALSE) {
<a name="l00451"></a>00451             printf(<span class="stringliteral">&quot;unsat\n&quot;</span>);
<a name="l00452"></a>00452             <span class="keywordflow">return</span> num_soft_cnstrs - k - 1;
<a name="l00453"></a>00453         }
<a name="l00454"></a>00454         num_disabled = <a class="code" href="group__maxsat__ex.html#gaad360c0088050f32e64f24a27d26cc4a" title="Return the number of soft-constraints that were disable by the given model. A soft-constraint...">get_num_disabled_soft_constraints</a>(ctx, m, num_soft_cnstrs, aux_vars);
<a name="l00455"></a>00455         <span class="keywordflow">if</span> (num_disabled &gt; k) {
<a name="l00456"></a>00456             <a class="code" href="group__maxsat__ex.html#gaad9796c174f7ef5d226cd169f2520fd5" title="Exit gracefully in case of error.">error</a>(<span class="stringliteral">&quot;BUG&quot;</span>);
<a name="l00457"></a>00457         }
<a name="l00458"></a>00458         <span class="keywordflow">if</span> (m) {
<a name="l00459"></a>00459             <a class="code" href="group__capi.html#ga0cc98d3ce68047f873e119bccaabdbee" title="Delete a model object.">Z3_del_model</a>(ctx, m);
<a name="l00460"></a>00460         }
<a name="l00461"></a>00461         printf(<span class="stringliteral">&quot;sat\n&quot;</span>);
<a name="l00462"></a>00462         k = num_disabled;
<a name="l00463"></a>00463         <span class="keywordflow">if</span> (k == 0) {
<a name="l00464"></a>00464             <span class="comment">// it was possible to satisfy all soft-constraints.</span>
<a name="l00465"></a>00465             <span class="keywordflow">return</span> num_soft_cnstrs; 
<a name="l00466"></a>00466         }
<a name="l00467"></a>00467         k--;
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf584c13710008c3a66d2afb7b09e79d6"></a><!-- doxytag: member="maxsat.c::smtlib_maxsat" ref="gaf584c13710008c3a66d2afb7b09e79d6" args="(char *file_name, int approach)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smtlib_maxsat </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>approach</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the maximal number of assumptions that can be satisfied. An assumption is any formula preceeded with the :assumption keyword. "Hard" constraints can be supported by using the :formula keyword. </p>
<p>Input: file in SMT-LIB format, and MaxSAT algorithm to be used: 0 - Naive, 1 - Fu&amp;Malik's algo. Output: the maximum number of assumptions that can be satisfied. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00590">590</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00591"></a>00591 {
<a name="l00592"></a>00592     Z3_context ctx;
<a name="l00593"></a>00593     <span class="keywordtype">unsigned</span> num_hard_cnstrs, num_soft_cnstrs;
<a name="l00594"></a>00594     Z3_ast * hard_cnstrs, * soft_cnstrs;
<a name="l00595"></a>00595     <span class="keywordtype">unsigned</span> result;
<a name="l00596"></a>00596     ctx = <a class="code" href="group__maxsat__ex.html#ga102b86f8b4829828c5c2d06c5d8b8489" title="Create a logical context. Enable model construction only.">mk_context</a>();
<a name="l00597"></a>00597     <a class="code" href="group__capi.html#gaa63fb1ecc49057f28aa6e0c328491eb3" title="Similar to Z3_parse_smtlib_string, but reads the benchmark from a file.">Z3_parse_smtlib_file</a>(ctx, file_name, 0, 0, 0, 0, 0, 0);
<a name="l00598"></a>00598     hard_cnstrs = <a class="code" href="group__maxsat__ex.html#ga37df58ec6af77230db093d908dd88333" title="Get hard constraints from a SMT-LIB file. We assume hard constraints are formulas...">get_hard_constraints</a>(ctx, &amp;num_hard_cnstrs);
<a name="l00599"></a>00599     soft_cnstrs = <a class="code" href="group__maxsat__ex.html#ga3489c094c45ae2468b18776e15066cda" title="Get soft constraints from a SMT-LIB file. We assume soft constraints are formulas...">get_soft_constraints</a>(ctx, &amp;num_soft_cnstrs);
<a name="l00600"></a>00600     <span class="keywordflow">switch</span> (approach) {
<a name="l00601"></a>00601     <span class="keywordflow">case</span> NAIVE_MAXSAT: 
<a name="l00602"></a>00602         result = <a class="code" href="group__maxsat__ex.html#ga4c670fc1e4cbcdba5dc237b439c6a08d" title="Naive maxsat procedure based on linear search and at-most-k constraint. Return the...">naive_maxsat</a>(ctx, num_hard_cnstrs, hard_cnstrs, num_soft_cnstrs, soft_cnstrs);
<a name="l00603"></a>00603         <span class="keywordflow">break</span>;
<a name="l00604"></a>00604     <span class="keywordflow">case</span> FU_MALIK_MAXSAT:
<a name="l00605"></a>00605         result = <a class="code" href="group__maxsat__ex.html#gacac27baf151175043165a9b07d1347f0" title="Fu &amp;amp; Malik procedure for MaxSAT. This procedure is based on unsat core extraction...">fu_malik_maxsat</a>(ctx, num_hard_cnstrs, hard_cnstrs, num_soft_cnstrs, soft_cnstrs);
<a name="l00606"></a>00606         <span class="keywordflow">break</span>;
<a name="l00607"></a>00607     <span class="keywordflow">default</span>:
<a name="l00608"></a>00608         <span class="comment">/* Exercise: implement your own MaxSAT algorithm.*/</span>
<a name="l00609"></a>00609         <a class="code" href="group__maxsat__ex.html#gaad9796c174f7ef5d226cd169f2520fd5" title="Exit gracefully in case of error.">error</a>(<span class="stringliteral">&quot;Not implemented yet.&quot;</span>);
<a name="l00610"></a>00610         <span class="keywordflow">break</span>;
<a name="l00611"></a>00611     }
<a name="l00612"></a>00612     <a class="code" href="group__maxsat__ex.html#ga9addf8d434da3c6daa1cc87cfa52ee69" title="Free the given array of cnstrs that was allocated using get_hard_constraints or get_soft_constraints...">free_cnstr_array</a>(hard_cnstrs);
<a name="l00613"></a>00613     <a class="code" href="group__maxsat__ex.html#ga9addf8d434da3c6daa1cc87cfa52ee69" title="Free the given array of cnstrs that was allocated using get_hard_constraints or get_soft_constraints...">free_cnstr_array</a>(soft_cnstrs);
<a name="l00614"></a>00614     <span class="keywordflow">return</span> result;
<a name="l00615"></a>00615 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga38972953eace8df5ce0c34a41fa0b3e1"></a><!-- doxytag: member="maxsat.c::tst_at_most_one" ref="ga38972953eace8df5ce0c34a41fa0b3e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tst_at_most_one </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Small test for the at-most-one constraint. </p>

<p>Definition at line <a class="el" href="maxsat_8c_source.html#l00351">351</a> of file <a class="el" href="maxsat_8c_source.html">maxsat.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00352"></a>00352 {
<a name="l00353"></a>00353     Z3_context ctx = <a class="code" href="group__maxsat__ex.html#ga102b86f8b4829828c5c2d06c5d8b8489" title="Create a logical context. Enable model construction only.">mk_context</a>();
<a name="l00354"></a>00354     Z3_ast k1      = <a class="code" href="group__maxsat__ex.html#ga397d6e03e2538ff0df36aad6e02030ae" title="Create a boolean variable using the given name.">mk_bool_var</a>(ctx, <span class="stringliteral">&quot;k1&quot;</span>);
<a name="l00355"></a>00355     Z3_ast k2      = <a class="code" href="group__maxsat__ex.html#ga397d6e03e2538ff0df36aad6e02030ae" title="Create a boolean variable using the given name.">mk_bool_var</a>(ctx, <span class="stringliteral">&quot;k2&quot;</span>);
<a name="l00356"></a>00356     Z3_ast k3      = <a class="code" href="group__maxsat__ex.html#ga397d6e03e2538ff0df36aad6e02030ae" title="Create a boolean variable using the given name.">mk_bool_var</a>(ctx, <span class="stringliteral">&quot;k3&quot;</span>);
<a name="l00357"></a>00357     Z3_ast k4      = <a class="code" href="group__maxsat__ex.html#ga397d6e03e2538ff0df36aad6e02030ae" title="Create a boolean variable using the given name.">mk_bool_var</a>(ctx, <span class="stringliteral">&quot;k4&quot;</span>);
<a name="l00358"></a>00358     Z3_ast k5      = <a class="code" href="group__maxsat__ex.html#ga397d6e03e2538ff0df36aad6e02030ae" title="Create a boolean variable using the given name.">mk_bool_var</a>(ctx, <span class="stringliteral">&quot;k5&quot;</span>);
<a name="l00359"></a>00359     Z3_ast k6      = <a class="code" href="group__maxsat__ex.html#ga397d6e03e2538ff0df36aad6e02030ae" title="Create a boolean variable using the given name.">mk_bool_var</a>(ctx, <span class="stringliteral">&quot;k6&quot;</span>);
<a name="l00360"></a>00360     Z3_ast args1[5] = { k1, k2, k3, k4, k5 };
<a name="l00361"></a>00361     Z3_ast args2[3] = { k4, k5, k6 };
<a name="l00362"></a>00362     Z3_model m      = 0;
<a name="l00363"></a>00363     <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> result;
<a name="l00364"></a>00364     printf(<span class="stringliteral">&quot;testing at-most-one constraint\n&quot;</span>);
<a name="l00365"></a>00365     <a class="code" href="group__maxsat__ex.html#ga0cd161e82d1bcc3a172222f86b89c6c7" title="Assert that at most one literal in lits can be true, where n is the number of literals...">assert_at_most_one</a>(ctx, 5, args1);
<a name="l00366"></a>00366     <a class="code" href="group__maxsat__ex.html#ga0cd161e82d1bcc3a172222f86b89c6c7" title="Assert that at most one literal in lits can be true, where n is the number of literals...">assert_at_most_one</a>(ctx, 3, args2);
<a name="l00367"></a>00367     printf(<span class="stringliteral">&quot;it must be sat...\n&quot;</span>);
<a name="l00368"></a>00368     result = <a class="code" href="group__capi.html#gaff310fef80ac8a82d0a51417e073ec0a" title="Check whether the given logical context is consistent or not.">Z3_check_and_get_model</a>(ctx, &amp;m);
<a name="l00369"></a>00369     <span class="keywordflow">if</span> (result != Z3_L_TRUE)
<a name="l00370"></a>00370         <a class="code" href="group__maxsat__ex.html#gaad9796c174f7ef5d226cd169f2520fd5" title="Exit gracefully in case of error.">error</a>(<span class="stringliteral">&quot;BUG&quot;</span>);
<a name="l00371"></a>00371     printf(<span class="stringliteral">&quot;model:\n%s\n&quot;</span>, <a class="code" href="group__capi.html#gaf36d49862a8c0d20dd5e6508eef5f8af" title="Convert the given model into a string.">Z3_model_to_string</a>(ctx, m));
<a name="l00372"></a>00372     <span class="keywordflow">if</span> (m) {
<a name="l00373"></a>00373         <a class="code" href="group__capi.html#ga0cc98d3ce68047f873e119bccaabdbee" title="Delete a model object.">Z3_del_model</a>(ctx, m);
<a name="l00374"></a>00374     }
<a name="l00375"></a>00375     <a class="code" href="group__capi.html#ga1a05ff73a564ae7256a2257048a4680a" title="Assert a constraint into the logical context.">Z3_assert_cnstr</a>(ctx, <a class="code" href="group__maxsat__ex.html#gaab12e81ed001b3e1bff357ef8263c8c1" title="Create a binary OR.">mk_binary_or</a>(ctx, k2, k3));
<a name="l00376"></a>00376     <a class="code" href="group__capi.html#ga1a05ff73a564ae7256a2257048a4680a" title="Assert a constraint into the logical context.">Z3_assert_cnstr</a>(ctx, <a class="code" href="group__maxsat__ex.html#gaab12e81ed001b3e1bff357ef8263c8c1" title="Create a binary OR.">mk_binary_or</a>(ctx, k1, k6));
<a name="l00377"></a>00377     printf(<span class="stringliteral">&quot;it must be sat...\n&quot;</span>);
<a name="l00378"></a>00378     result = <a class="code" href="group__capi.html#gaff310fef80ac8a82d0a51417e073ec0a" title="Check whether the given logical context is consistent or not.">Z3_check_and_get_model</a>(ctx, &amp;m);
<a name="l00379"></a>00379     <span class="keywordflow">if</span> (result != Z3_L_TRUE)
<a name="l00380"></a>00380         <a class="code" href="group__maxsat__ex.html#gaad9796c174f7ef5d226cd169f2520fd5" title="Exit gracefully in case of error.">error</a>(<span class="stringliteral">&quot;BUG&quot;</span>);
<a name="l00381"></a>00381     printf(<span class="stringliteral">&quot;model:\n%s\n&quot;</span>, <a class="code" href="group__capi.html#gaf36d49862a8c0d20dd5e6508eef5f8af" title="Convert the given model into a string.">Z3_model_to_string</a>(ctx, m));
<a name="l00382"></a>00382     <span class="keywordflow">if</span> (m) {
<a name="l00383"></a>00383         <a class="code" href="group__capi.html#ga0cc98d3ce68047f873e119bccaabdbee" title="Delete a model object.">Z3_del_model</a>(ctx, m);
<a name="l00384"></a>00384     }
<a name="l00385"></a>00385     <a class="code" href="group__capi.html#ga1a05ff73a564ae7256a2257048a4680a" title="Assert a constraint into the logical context.">Z3_assert_cnstr</a>(ctx, <a class="code" href="group__maxsat__ex.html#gaab12e81ed001b3e1bff357ef8263c8c1" title="Create a binary OR.">mk_binary_or</a>(ctx, k4, k5));
<a name="l00386"></a>00386     printf(<span class="stringliteral">&quot;it must be unsat...\n&quot;</span>);
<a name="l00387"></a>00387     result = <a class="code" href="group__capi.html#gaff310fef80ac8a82d0a51417e073ec0a" title="Check whether the given logical context is consistent or not.">Z3_check_and_get_model</a>(ctx, &amp;m);
<a name="l00388"></a>00388     <span class="keywordflow">if</span> (result != Z3_L_FALSE)
<a name="l00389"></a>00389         <a class="code" href="group__maxsat__ex.html#gaad9796c174f7ef5d226cd169f2520fd5" title="Exit gracefully in case of error.">error</a>(<span class="stringliteral">&quot;BUG&quot;</span>);
<a name="l00390"></a>00390     <a class="code" href="group__capi.html#ga556eae80ed43ab13e1e7dc3b38c35200" title="Delete the given logical context.">Z3_del_context</a>(ctx);
<a name="l00391"></a>00391 }
</pre></div></p>

</div>
</div>
</div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Aug 9 16:34:45 2012
</BODY>
</HTML>
