 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: SMT solver" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: SMT solver</TITLE>
      <LINK HREF="z3_ml.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">
<table class="centered-small">
  <tr>
    <th><a href="../index.html"><span>Home</span></a></th>
    <th> &bull; </th>
    <th><a href="../documentation.html"><span>Docs</span></a></th>
    <th> &bull; </th>
    <th><a href="../download.html"><span>Download</span></a></th>
    <th> &bull; </th>
    <th><a href="../mail.html"><span>Mail</span></a></th>
    <th> &bull; </th>
    <th><a href="../faq.html"><span>FAQ</span></a></th>
    <th> &bull; </th>
    <th><a href="../awards.html"><span>Awards</span></a></th>
    <th> &bull; </th>
    <th><a href="../status.html"><span>Status</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com"><span>MSR</span></a></th>
  </tr>
</table>
<p class="Z3Title"><img align="middle" src="z3.png" alt="Z3" />An Efficient SMT Solver</p>
<h1>OCaml API (<a href="index_values.html" class="el">Index</a>)</h1>
<h2>Module Z3: Sections</h2>
<ul>
<li><a href="#2_Types" class="el">Types</a></li>
<li><a href="#2_Createcontext" class="el">Create context</a></li>
<li><a href="#2_Parameters" class="el">Parameters</a></li>
<li><a href="#2_Symbols" class="el">Symbols</a></li>
<li><a href="#2_Sorts" class="el">Sorts</a></li>
<li><a href="#2_ConstantsandApplications" class="el">Constants and Applications</a></li>
<li><a href="#2_PropositionalLogicandEquality" class="el">Propositional Logic and Equality</a></li>
<li><a href="#2_ArithmeticIntegersandReals" class="el">Arithmetic: Integers and Reals</a></li>
<li><a href="#2_Bitvectors" class="el">Bit-vectors</a></li>
<li><a href="#2_Arrays" class="el">Arrays</a></li>
<li><a href="#2_Sets" class="el">Sets</a></li>
<li><a href="#2_Numerals" class="el">Numerals</a></li>
<li><a href="#2_Quantifiers" class="el">Quantifiers</a></li>
<li><a href="#2_Accessors" class="el">Accessors</a></li>
<li><a href="#2_Modifiers" class="el">Modifiers</a></li>
<li><a href="#2_Models" class="el">Models</a></li>
<li><a href="#2_Interactionlogging" class="el">Interaction logging</a></li>
<li><a href="#2_Stringconversion" class="el">String conversion</a></li>
<li><a href="#2_Parserinterface" class="el">Parser interface</a></li>
<li><a href="#2_ErrorHandling" class="el">Error Handling</a></li>
<li><a href="#2_Miscellaneous" class="el">Miscellaneous</a></li>
<li><a href="#2_Fixedpointfacilities" class="el">Fixedpoint facilities</a></li>
<li><a href="#2_ASTvectors" class="el">AST vectors</a></li>
<li><a href="#2_ASTmaps" class="el">AST maps</a></li>
<li><a href="#2_Goals" class="el">Goals</a></li>
<li><a href="#2_TacticsandProbes" class="el">Tactics and Probes</a></li>
<li><a href="#2_Solvers" class="el">Solvers</a></li>
<li><a href="#2_Statistics" class="el">Statistics</a></li>
<li><a href="#2_LegacyV3API" class="el">Legacy V3 API</a></li>
</ul>
<link title="Goals" rel="Section" href="#2_Goals">
<link title="Tactics and Probes" rel="Section" href="#2_TacticsandProbes">
<link title="Solvers" rel="Section" href="#2_Solvers">
<link title="Statistics" rel="Section" href="#2_Statistics">
<link title="Legacy V3 API" rel="Section" href="#2_LegacyV3API">
<link title="Symbols" rel="Subsection" href="#3_Symbols">
<link title="Sorts" rel="Subsection" href="#3_Sorts">
<link title="Function Declarations" rel="Subsection" href="#3_FunctionDeclarations">
<link title="Applications" rel="Subsection" href="#3_Applications">
<link title="Terms" rel="Subsection" href="#3_Terms">
<link title="Simplification" rel="Subsection" href="#3_Simplification">
<title>Z3</title>
</head>
<body>
<div class="navbar"><a href="Test_mlapi.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;</div>
<center><h1>Module <a href="type_Z3.html">Z3</a></h1></center>
<br>
<pre><span class="keyword">module</span> Z3: <code class="code">sig</code> <a href="Z3.html">..</a> <code class="code">end</code></pre><hr width="100%">
<pre><span id="TYPEcontext"><span class="keyword">type</span> <code class="type"></code>context</span> </pre>

<pre><span id="TYPEsymbol"><span class="keyword">type</span> <code class="type"></code>symbol</span> </pre>

<pre><span id="TYPEast"><span class="keyword">type</span> <code class="type"></code>ast</span> </pre>

<pre><span id="TYPEsort"><span class="keyword">type</span> <code class="type"></code>sort</span> = private <code class="type"><a href="Z3.html#TYPEast">ast</a></code> </pre>

<pre><span id="TYPEfunc_decl"><span class="keyword">type</span> <code class="type"></code>func_decl</span> = private <code class="type"><a href="Z3.html#TYPEast">ast</a></code> </pre>

<pre><span id="TYPEapp"><span class="keyword">type</span> <code class="type"></code>app</span> = private <code class="type"><a href="Z3.html#TYPEast">ast</a></code> </pre>

<pre><span id="TYPEpattern"><span class="keyword">type</span> <code class="type"></code>pattern</span> = private <code class="type"><a href="Z3.html#TYPEast">ast</a></code> </pre>

<pre><span id="TYPEparams"><span class="keyword">type</span> <code class="type"></code>params</span> </pre>

<pre><span id="TYPEmodel"><span class="keyword">type</span> <code class="type"></code>model</span> </pre>

<pre><span id="TYPEfunc_interp"><span class="keyword">type</span> <code class="type"></code>func_interp</span> </pre>

<pre><span id="TYPEfunc_entry"><span class="keyword">type</span> <code class="type"></code>func_entry</span> </pre>

<pre><span id="TYPEfixedpoint"><span class="keyword">type</span> <code class="type"></code>fixedpoint</span> </pre>

<pre><span id="TYPEast_vector"><span class="keyword">type</span> <code class="type"></code>ast_vector</span> </pre>

<pre><span id="TYPEast_map"><span class="keyword">type</span> <code class="type"></code>ast_map</span> </pre>

<pre><span id="TYPEgoal"><span class="keyword">type</span> <code class="type"></code>goal</span> </pre>

<pre><span id="TYPEtactic"><span class="keyword">type</span> <code class="type"></code>tactic</span> </pre>

<pre><span id="TYPEprobe"><span class="keyword">type</span> <code class="type"></code>probe</span> </pre>

<pre><span id="TYPEapply_result"><span class="keyword">type</span> <code class="type"></code>apply_result</span> </pre>

<pre><span id="TYPEsolver"><span class="keyword">type</span> <code class="type"></code>solver</span> </pre>

<pre><span id="TYPEstats"><span class="keyword">type</span> <code class="type"></code>stats</span> </pre>

<pre><span id="TYPEconstructor"><span class="keyword">type</span> <code class="type"></code>constructor</span> </pre>

<pre><span id="TYPEconstructor_list"><span class="keyword">type</span> <code class="type"></code>constructor_list</span> </pre>

<br><code><span id="TYPElbool"><span class="keyword">type</span> <code class="type"></code>lbool</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">L_FALSE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">L_UNDEF</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">L_TRUE</span></code></td>

</tr></table>


<br><code><span id="TYPEsymbol_kind"><span class="keyword">type</span> <code class="type"></code>symbol_kind</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">INT_SYMBOL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">STRING_SYMBOL</span></code></td>

</tr></table>


<br><code><span id="TYPEparameter_kind"><span class="keyword">type</span> <code class="type"></code>parameter_kind</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PARAMETER_INT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PARAMETER_DOUBLE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PARAMETER_RATIONAL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PARAMETER_SYMBOL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PARAMETER_SORT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PARAMETER_AST</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PARAMETER_FUNC_DECL</span></code></td>

</tr></table>


<br><code><span id="TYPEsort_kind"><span class="keyword">type</span> <code class="type"></code>sort_kind</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">UNINTERPRETED_SORT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">BOOL_SORT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">INT_SORT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">REAL_SORT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">BV_SORT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ARRAY_SORT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">DATATYPE_SORT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">RELATION_SORT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FINITE_DOMAIN_SORT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">UNKNOWN_SORT</span></code></td>

</tr></table>


<br><code><span id="TYPEast_kind"><span class="keyword">type</span> <code class="type"></code>ast_kind</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">NUMERAL_AST</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">APP_AST</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">VAR_AST</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">QUANTIFIER_AST</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SORT_AST</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FUNC_DECL_AST</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">UNKNOWN_AST</span></code></td>

</tr></table>


<br><code><span id="TYPEdecl_kind"><span class="keyword">type</span> <code class="type"></code>decl_kind</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_TRUE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_FALSE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_EQ</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_DISTINCT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_ITE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_AND</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_OR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_IFF</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_XOR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_NOT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_IMPLIES</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_OEQ</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_ANUM</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_AGNUM</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_LE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_GE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_LT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_GT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_ADD</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SUB</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_UMINUS</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_MUL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_DIV</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_IDIV</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_REM</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_MOD</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_TO_REAL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_TO_INT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_IS_INT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_POWER</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_STORE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SELECT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_CONST_ARRAY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_ARRAY_MAP</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_ARRAY_DEFAULT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SET_UNION</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SET_INTERSECT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SET_DIFFERENCE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SET_COMPLEMENT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SET_SUBSET</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_AS_ARRAY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BNUM</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BIT1</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BIT0</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BNEG</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BADD</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BSUB</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BMUL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BSDIV</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BUDIV</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BSREM</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BUREM</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BSMOD</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BSDIV0</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BUDIV0</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BSREM0</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BUREM0</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BSMOD0</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_ULEQ</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SLEQ</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_UGEQ</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SGEQ</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_ULT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SLT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_UGT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SGT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BAND</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BOR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BNOT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BXOR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BNAND</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BNOR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BXNOR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_CONCAT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_SIGN_EXT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_ZERO_EXT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_EXTRACT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_REPEAT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BREDOR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BREDAND</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BCOMP</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BSHL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BLSHR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BASHR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_ROTATE_LEFT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_ROTATE_RIGHT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_EXT_ROTATE_LEFT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_EXT_ROTATE_RIGHT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_INT2BV</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_BV2INT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_CARRY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_XOR3</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_UNDEF</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_TRUE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_ASSERTED</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_GOAL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_MODUS_PONENS</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_REFLEXIVITY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_SYMMETRY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_TRANSITIVITY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_TRANSITIVITY_STAR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_MONOTONICITY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_QUANT_INTRO</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_DISTRIBUTIVITY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_AND_ELIM</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_NOT_OR_ELIM</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_REWRITE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_REWRITE_STAR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_PULL_QUANT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_PULL_QUANT_STAR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_PUSH_QUANT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_ELIM_UNUSED_VARS</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_DER</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_QUANT_INST</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_HYPOTHESIS</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_LEMMA</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_UNIT_RESOLUTION</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_IFF_TRUE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_IFF_FALSE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_COMMUTATIVITY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_DEF_AXIOM</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_DEF_INTRO</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_APPLY_DEF</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_IFF_OEQ</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_NNF_POS</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_NNF_NEG</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_NNF_STAR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_CNF_STAR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_SKOLEMIZE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_MODUS_PONENS_OEQ</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_PR_TH_LEMMA</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_STORE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_EMPTY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_IS_EMPTY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_JOIN</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_UNION</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_WIDEN</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_PROJECT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_FILTER</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_NEGATION_FILTER</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_RENAME</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_COMPLEMENT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_SELECT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_RA_CLONE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_FD_LT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_LABEL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_LABEL_LIT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OP_UNINTERPRETED</span></code></td>

</tr></table>


<br><code><span id="TYPEsearch_failure"><span class="keyword">type</span> <code class="type"></code>search_failure</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">NO_FAILURE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">UNKNOWN</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TIMEOUT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">MEMOUT_WATERMARK</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">CANCELED</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">NUM_CONFLICTS</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">THEORY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">QUANTIFIERS</span></code></td>

</tr></table>


<br><code><span id="TYPEast_print_mode"><span class="keyword">type</span> <code class="type"></code>ast_print_mode</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PRINT_SMTLIB_FULL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PRINT_LOW_LEVEL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PRINT_SMTLIB_COMPLIANT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PRINT_SMTLIB2_COMPLIANT</span></code></td>

</tr></table>


<br><code><span id="TYPEerror_code"><span class="keyword">type</span> <code class="type"></code>error_code</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">OK</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SORT_ERROR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">IOB</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">INVALID_ARG</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PARSER_ERROR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">NO_PARSER</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">INVALID_PATTERN</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">MEMOUT_FAIL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FILE_ACCESS_ERROR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">INTERNAL_FATAL</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">INVALID_USAGE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">DEC_REF_ERROR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">EXCEPTION</span></code></td>

</tr></table>


<br><code><span id="TYPEgoal_prec"><span class="keyword">type</span> <code class="type"></code>goal_prec</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GOAL_PRECISE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GOAL_UNDER</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GOAL_OVER</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">GOAL_UNDER_OVER</span></code></td>

</tr></table>


<br>
<span id="2_Types"><h2><div align=left>Types</div></h2></span>
<p>

    Most of the types in the API are abstract. 
<p>
<ul>
<li><code class="code">context</code>: manager of all other Z3 objects, global configuration options, etc.</li>
<li><code class="code">symbol</code>: Lisp-like symbol used to name types, constants, and functions.  A symbol can be created using string or integers.</li>
<li><code class="code">ast</code>: abstract syntax tree node. That is, the data-structure used in Z3 to represent terms, formulas and types.</li>
<li><code class="code">sort</code>: kind of AST used to represent types.</li>
<li><code class="code">func_decl</code>: kind of AST used to represent function symbols.</li>
<li><code class="code">app</code>: kind of AST used to represent function applications.</li>
<li><code class="code">pattern</code>: kind of AST used to represent pattern and multi-patterns used to guide quantifier instantiation.</li>
</ul>
<ul>
<li><code class="code">params</code>: parameter set used to configure many components such as: simplifiers, tactics, solvers, etc.</li>
<li><code class="code">model</code>: model for the constraints asserted into the logical context.</li>
<li><code class="code">func_interp</code>: interpretation of a function in a model.</li>
<li><code class="code">func_entry</code>: representation of the value of a <code class="code">func_interp</code> at a particular point.</li>
<li><code class="code">fixedpoint</code>: context for the recursive predicate solver.</li>
<li><code class="code">ast_vector</code>: vector of <code class="code">ast</code> objects.</li>
<li><code class="code">ast_map</code>: mapping from <code class="code">ast</code> to <code class="code">ast</code> objects.</li>
<li><code class="code">goal</code>: set of formulas that can be solved and/or transformed using tactics and solvers.</li>
<li><code class="code">tactic</code>: basic building block for creating custom solvers for specific problem domains.</li>
<li><code class="code">probe</code>: function/predicate used to inspect a goal and collect information that may be used to decide which solver and/or preprocessing step will be used.</li>
<li><code class="code">apply_result</code>: collection of subgoals resulting from applying of a tactic to a goal.</li>
<li><code class="code">solver</code>: (incremental) solver, possibly specialized by a particular tactic or logic.</li>
<li><code class="code">stats</code>: statistical data for a solver.</li>
</ul>
<br>
<br>
<a href="Z3.html#TYPElbool"><code class="code">lbool</code></a>  
   Lifted Boolean type: <code class="code">false</code>, <code class="code">undefined</code>, <code class="code">true</code>.<br>
<br>
<a href="Z3.html#TYPEsymbol_kind"><code class="code">symbol_kind</code></a>  
   The different kinds of symbol.
   In Z3, a symbol can be represented using integers and strings (See <a href="Z3.html#VALget_symbol_kind"><code class="code">get_symbol_kind</code></a>).
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_int_symbol"><code class="code">mk_int_symbol</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_string_symbol"><code class="code">mk_string_symbol</code></a></li>
</ul>
<br>
<br>
<a href="Z3.html#TYPEparameter_kind"><code class="code">parameter_kind</code></a>  
   The different kinds of parameters that can be associated with function symbols.<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_decl_num_parameters"><code class="code">get_decl_num_parameters</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_decl_parameter_kind"><code class="code">get_decl_parameter_kind</code></a></li>
</ul>
<ul>
<li>PARAMETER_INT is used for integer parameters.</li>
<li>PARAMETER_DOUBLE is used for double parameters.</li>
<li>PARAMETER_RATIONAL is used for parameters that are rational numbers.</li>
<li>PARAMETER_SYMBOL is used for parameters that are symbols.</li>
<li>PARAMETER_SORT is used for sort parameters.</li>
<li>PARAMETER_AST is used for expression parameters.</li>
<li>PARAMETER_FUNC_DECL is used for function declaration parameters.</li>
</ul>
<br>
<br>
<a href="Z3.html#TYPEsort_kind"><code class="code">sort_kind</code></a>  
   The different kinds of Z3 types (See <a href="Z3.html#VALget_sort_kind"><code class="code">get_sort_kind</code></a>).<br>
<br>
<a href="Z3.html#TYPEast_kind"><code class="code">ast_kind</code></a>  
   The different kinds of Z3 AST (abstract syntax trees). That is, terms, formulas and types.
<p>
<ul>
<li>APP_AST:            constant and applications</li>
<li>NUMERAL_AST:        numeral constants</li>
<li>VAR_AST:            bound variables</li>
<li>QUANTIFIER_AST:     quantifiers</li>
<li>SORT_AST:           sort</li>
<li>FUNC_DECL_AST:      function declaration</li>
<li>UNKNOWN_AST:        internal</li>
</ul>
<br>
<br>
<a href="Z3.html#TYPEdecl_kind"><code class="code">decl_kind</code></a>  
   The different kinds of interpreted function kinds.
<p>
<ul>
<li>OP_TRUE The constant true.</li>
</ul>
<ul>
<li>OP_FALSE The constant false.</li>
</ul>
<ul>
<li>OP_EQ The equality predicate.</li>
</ul>
<ul>
<li>OP_DISTINCT The n-ary distinct predicate (every argument is mutually distinct).</li>
</ul>
<ul>
<li>OP_ITE The ternary if-then-else term.</li>
</ul>
<ul>
<li>OP_AND n-ary conjunction.</li>
</ul>
<ul>
<li>OP_OR n-ary disjunction.</li>
</ul>
<ul>
<li>OP_IFF equivalence (binary).</li>
</ul>
<ul>
<li>OP_XOR Exclusive or.</li>
</ul>
<ul>
<li>OP_NOT Negation.</li>
</ul>
<ul>
<li>OP_IMPLIES Implication.</li>
</ul>
<ul>
<li>OP_OEQ Binary equivalence modulo namings. This binary predicate is used in proof terms.
        It captures equisatisfiability and equivalence modulo renamings.</li>
</ul>
<ul>
<li>OP_ANUM Arithmetic numeral.</li>
</ul>
<ul>
<li>OP_AGNUM Arithmetic algebraic numeral. Algebraic numbers are used to represent irrational numbers in Z3.</li>
</ul>
<ul>
<li>OP_LE &lt;=.</li>
</ul>
<ul>
<li>OP_GE &gt;=.</li>
</ul>
<ul>
<li>OP_LT &lt;.</li>
</ul>
<ul>
<li>OP_GT &gt;.</li>
</ul>
<ul>
<li>OP_ADD Addition - Binary.</li>
</ul>
<ul>
<li>OP_SUB Binary subtraction.</li>
</ul>
<ul>
<li>OP_UMINUS Unary minus.</li>
</ul>
<ul>
<li>OP_MUL Multiplication - Binary.</li>
</ul>
<ul>
<li>OP_DIV Division - Binary.</li>
</ul>
<ul>
<li>OP_IDIV Integer division - Binary.</li>
</ul>
<ul>
<li>OP_REM Remainder - Binary.</li>
</ul>
<ul>
<li>OP_MOD Modulus - Binary.</li>
</ul>
<ul>
<li>OP_TO_REAL Coercion of integer to real - Unary.</li>
</ul>
<ul>
<li>OP_TO_INT Coercion of real to integer - Unary.</li>
</ul>
<ul>
<li>OP_IS_INT Check if real is also an integer - Unary.</li>
</ul>
<ul>
<li>OP_POWER Power operator x^y.</li>
</ul>
<ul>
<li>OP_STORE Array store. It satisfies select(store(a,i,v),j) = if i = j then v else select(a,j).
        Array store takes at least 3 arguments. </li>
</ul>
<ul>
<li>OP_SELECT Array select. </li>
</ul>
<ul>
<li>OP_CONST_ARRAY The constant array. For example, select(const(v),i) = v holds for every v and i. The function is unary.</li>
</ul>
<ul>
<li>OP_ARRAY_DEFAULT Default value of arrays. For example default(const(v)) = v. The function is unary.</li>
</ul>
<ul>
<li>OP_ARRAY_MAP Array map operator.
         It satisfies map<code class="code">f</code>(a1,..,a_n)<code class="code">i</code> = f(a1<code class="code">i</code>,...,a_n<code class="code">i</code>) for every i.</li>
</ul>
<ul>
<li>OP_SET_UNION Set union between two Booelan arrays (two arrays whose range type is Boolean). The function is binary.</li>
</ul>
<ul>
<li>OP_SET_INTERSECT Set intersection between two Boolean arrays. The function is binary.</li>
</ul>
<ul>
<li>OP_SET_DIFFERENCE Set difference between two Boolean arrays. The function is binary.</li>
</ul>
<ul>
<li>OP_SET_COMPLEMENT Set complement of a Boolean array. The function is unary.</li>
</ul>
<ul>
<li>OP_SET_SUBSET Subset predicate between two Boolean arrays. The relation is binary.</li>
</ul>
<ul>
<li>OP_AS_ARRAY An array value that behaves as the function graph of the
                    function passed as parameter.</li>
</ul>
<ul>
<li>OP_BNUM Bit-vector numeral.</li>
</ul>
<ul>
<li>OP_BIT1 One bit bit-vector.</li>
</ul>
<ul>
<li>OP_BIT0 Zero bit bit-vector.</li>
</ul>
<ul>
<li>OP_BNEG Unary minus.</li>
</ul>
<ul>
<li>OP_BADD Binary addition.</li>
</ul>
<ul>
<li>OP_BSUB Binary subtraction.</li>
</ul>
<ul>
<li>OP_BMUL Binary multiplication.</li>
</ul>
<ul>
<li>OP_BSDIV Binary signed division.</li>
</ul>
<ul>
<li>OP_BUDIV Binary unsigned int division.</li>
</ul>
<ul>
<li>OP_BSREM Binary signed remainder.</li>
</ul>
<ul>
<li>OP_BUREM Binary unsigned int remainder.</li>
</ul>
<ul>
<li>OP_BSMOD Binary signed modulus.</li>
</ul>
<ul>
<li>OP_BSDIV0 Unary function. bsdiv(x,0) is congruent to bsdiv0(x).</li>
</ul>
<ul>
<li>OP_BUDIV0 Unary function. budiv(x,0) is congruent to budiv0(x).</li>
</ul>
<ul>
<li>OP_BSREM0 Unary function. bsrem(x,0) is congruent to bsrem0(x).</li>
</ul>
<ul>
<li>OP_BUREM0 Unary function. burem(x,0) is congruent to burem0(x).</li>
</ul>
<ul>
<li>OP_BSMOD0 Unary function. bsmod(x,0) is congruent to bsmod0(x).</li>
</ul>
<ul>
<li>OP_ULEQ Unsigned bit-vector &lt;= - Binary relation.</li>
</ul>
<ul>
<li>OP_SLEQ Signed bit-vector  &lt;= - Binary relation.</li>
</ul>
<ul>
<li>OP_UGEQ Unsigned bit-vector  &gt;= - Binary relation.</li>
</ul>
<ul>
<li>OP_SGEQ Signed bit-vector  &gt;= - Binary relation.</li>
</ul>
<ul>
<li>OP_ULT Unsigned bit-vector  &lt; - Binary relation.</li>
</ul>
<ul>
<li>OP_SLT Signed bit-vector &lt; - Binary relation.</li>
</ul>
<ul>
<li>OP_UGT Unsigned bit-vector &gt; - Binary relation.</li>
</ul>
<ul>
<li>OP_SGT Signed bit-vector &gt; - Binary relation.</li>
</ul>
<ul>
<li>OP_BAND Bit-wise and - Binary.</li>
</ul>
<ul>
<li>OP_BOR Bit-wise or - Binary.</li>
</ul>
<ul>
<li>OP_BNOT Bit-wise not - Unary.</li>
</ul>
<ul>
<li>OP_BXOR Bit-wise xor - Binary.</li>
</ul>
<ul>
<li>OP_BNAND Bit-wise nand - Binary.</li>
</ul>
<ul>
<li>OP_BNOR Bit-wise nor - Binary.</li>
</ul>
<ul>
<li>OP_BXNOR Bit-wise xnor - Binary.</li>
</ul>
<ul>
<li>OP_CONCAT Bit-vector concatenation - Binary.</li>
</ul>
<ul>
<li>OP_SIGN_EXT Bit-vector sign extension.</li>
</ul>
<ul>
<li>OP_ZERO_EXT Bit-vector zero extension.</li>
</ul>
<ul>
<li>OP_EXTRACT Bit-vector extraction.</li>
</ul>
<ul>
<li>OP_REPEAT Repeat bit-vector n times.</li>
</ul>
<ul>
<li>OP_BREDOR Bit-vector reduce or - Unary.</li>
</ul>
<ul>
<li>OP_BREDAND Bit-vector reduce and - Unary.</li>
</ul>
<ul>
<li>OP_BCOMP .</li>
</ul>
<ul>
<li>OP_BSHL Shift left.</li>
</ul>
<ul>
<li>OP_BLSHR Logical shift right.</li>
</ul>
<ul>
<li>OP_BASHR Arithmetical shift right.</li>
</ul>
<ul>
<li>OP_ROTATE_LEFT Left rotation.</li>
</ul>
<ul>
<li>OP_ROTATE_RIGHT Right rotation.</li>
</ul>
<ul>
<li>OP_EXT_ROTATE_LEFT (extended) Left rotation. Similar to OP_ROTATE_LEFT, but it is a binary operator instead of a parametric one.</li>
</ul>
<ul>
<li>OP_EXT_ROTATE_RIGHT (extended) Right rotation. Similar to OP_ROTATE_RIGHT, but it is a binary operator instead of a parametric one.</li>
</ul>
<ul>
<li>OP_INT2BV Coerce integer to bit-vector. NB. This function
       is not supported by the decision procedures. Only the most
       rudimentary simplification rules are applied to this function.</li>
</ul>
<ul>
<li>OP_BV2INT Coerce bit-vector to integer. NB. This function
       is not supported by the decision procedures. Only the most
       rudimentary simplification rules are applied to this function.</li>
</ul>
<ul>
<li>OP_CARRY Compute the carry bit in a full-adder. 
       The meaning is given by the equivalence
       (carry l1 l2 l3) &lt;=&gt; (or (and l1 l2) (and l1 l3) (and l2 l3)))</li>
</ul>
<ul>
<li>OP_XOR3 Compute ternary XOR.
       The meaning is given by the equivalence
       (xor3 l1 l2 l3) &lt;=&gt; (xor (xor l1 l2) l3)</li>
</ul>
<ul>
<li>OP_PR_UNDEF: Undef/Null proof object.</li>
</ul>
<ul>
<li>OP_PR_TRUE: Proof for the expression 'true'.</li>
</ul>
<ul>
<li>OP_PR_ASSERTED: Proof for a fact asserted by the user.</li>
</ul>
<ul>
<li>OP_PR_GOAL: Proof for a fact (tagged as goal) asserted by the user.</li>
</ul>
<ul>
<li>OP_PR_MODUS_PONENS: Given a proof for p and a proof for (implies p q), produces a proof for q.
       <em>
          T1: p
          T2: (implies p q)
          <code class="code">mp T1 T2</code>: q
          </em>
          The second antecedents may also be a proof for (iff p q).</li>
</ul>
<ul>
<li>OP_PR_REFLEXIVITY: A proof for (R t t), where R is a reflexive relation. This proof object has no antecedents.
        The only reflexive relations that are used are 
        equivalence modulo namings, equality and equivalence.
        That is, R is either '~', '=' or 'iff'.</li>
</ul>
<ul>
<li>OP_PR_SYMMETRY: Given an symmetric relation R and a proof for (R t s), produces a proof for (R s t).
          <em>
          T1: (R t s)
          <code class="code">symmetry T1</code>: (R s t)
          </em>
          T1 is the antecedent of this proof object.</li>
</ul>
<ul>
<li>OP_PR_TRANSITIVITY: Given a transitive relation R, and proofs for (R t s) and (R s u), produces a proof
       for (R t u).
       <em>
       T1: (R t s)
       T2: (R s u)
       <code class="code">trans T1 T2</code>: (R t u)
       </em></li>
</ul>
<ul>
<li>OP_PR_TRANSITIVITY_STAR: Condensed transitivity proof. This proof object is only used if the parameter PROOF_MODE is 1.
     It combines several symmetry and transitivity proofs. </li>
</ul>

          Example:
          <em>
          T1: (R a b)
          T2: (R c b)
          T3: (R c d)
          <code class="code">trans* T1 T2 T3</code>: (R a d)
          </em>
          R must be a symmetric and transitive relation.
<p>

          Assuming that this proof object is a proof for (R s t), then
          a proof checker must check if it is possible to prove (R s t)
          using the antecedents, symmetry and transitivity.  That is, 
          if there is a path from s to t, if we view every
          antecedent (R a b) as an edge between a and b.
<p>
<ul>
<li>OP_PR_MONOTONICITY: Monotonicity proof object.
          <em>
          T1: (R t_1 s_1)
          ...
          Tn: (R t_n s_n)
          <code class="code">monotonicity T1 ... Tn</code>: (R (f t_1 ... t_n) (f s_1 ... s_n))
          </em>
          Remark: if t_i == s_i, then the antecedent Ti is suppressed.
          That is, reflexivity proofs are supressed to save space.</li>
</ul>
<ul>
<li>OP_PR_QUANT_INTRO: Given a proof for (~ p q), produces a proof for (~ (forall (x) p) (forall (x) q)).</li>
</ul>

       T1: (~ p q)
       <code class="code">quant-intro T1</code>: (~ (forall (x) p) (forall (x) q))
<p>
<ul>
<li>OP_PR_DISTRIBUTIVITY: Distributivity proof object. 
          Given that f (= or) distributes over g (= and), produces a proof for</li>
</ul>

          (= (f a (g c d))
             (g (f a c) (f a d)))
<p>

          If f and g are associative, this proof also justifies the following equality:
<p>

          (= (f (g a b) (g c d))
             (g (f a c) (f a d) (f b c) (f b d)))
<p>

          where each f and g can have arbitrary number of arguments.
<p>

          This proof object has no antecedents.
          Remark. This rule is used by the CNF conversion pass and 
          instantiated by f = or, and g = and.
<p>
<ul>
<li>OP_PR_AND_ELIM: Given a proof for (and l_1 ... l_n), produces a proof for l_i</li>
</ul>

       <em>
       T1: (and l_1 ... l_n)
       <code class="code">and-elim T1</code>: l_i
       </em><ul>
<li>OP_PR_NOT_OR_ELIM: Given a proof for (not (or l_1 ... l_n)), produces a proof for (not l_i).</li>
</ul>

       <em>
       T1: (not (or l_1 ... l_n))
       <code class="code">not-or-elim T1</code>: (not l_i)
       </em>
<p>
<ul>
<li>OP_PR_REWRITE: A proof for a local rewriting step (= t s).
          The head function symbol of t is interpreted.</li>
</ul>

          This proof object has no antecedents.
          The conclusion of a rewrite rule is either an equality (= t s), 
          an equivalence (iff t s), or equi-satisfiability (~ t s).
          Remark: if f is bool, then = is iff.
<p>

          Examples:
          <em>
          (= (+ x 0) x)
          (= (+ x 1 2) (+ 3 x))
          (iff (or x false) x)
          </em>
<p>
<ul>
<li>OP_PR_REWRITE_STAR: A proof for rewriting an expression t into an expression s.
       This proof object is used if the parameter PROOF_MODE is 1.
       This proof object can have n antecedents.
       The antecedents are proofs for equalities used as substitution rules.
       The object is also used in a few cases if the parameter PROOF_MODE is 2.
       The cases are:</li>
<li>When applying contextual simplification (CONTEXT_SIMPLIFIER=true)</li>
<li>When converting bit-vectors to Booleans (BIT2BOOL=true)</li>
<li>When pulling ite expression up (PULL_CHEAP_ITE_TREES=true)</li>
</ul>
<ul>
<li>OP_PR_PULL_QUANT: A proof for (iff (f (forall (x) q(x)) r) (forall (x) (f (q x) r))). This proof object has no antecedents.</li>
</ul>
<ul>
<li>OP_PR_PULL_QUANT_STAR: A proof for (iff P Q) where Q is in prenex normal form.
       This proof object is only used if the parameter PROOF_MODE is 1.       
       This proof object has no antecedents.</li>
</ul>
<ul>
<li>OP_PR_PUSH_QUANT: A proof for:</li>
</ul>

       <em>
          (iff (forall (x_1 ... x_m) (and p_1<code class="code">x_1 ... x_m</code> ... p_n<code class="code">x_1 ... x_m</code>))
               (and (forall (x_1 ... x_m) p_1<code class="code">x_1 ... x_m</code>)
                 ... 
               (forall (x_1 ... x_m) p_n<code class="code">x_1 ... x_m</code>)))
               </em>
         This proof object has no antecedents.
<p>
<ul>
<li>OP_PR_ELIM_UNUSED_VARS:  
          A proof for (iff (forall (x_1 ... x_n y_1 ... y_m) p<code class="code">x_1 ... x_n</code>)
                           (forall (x_1 ... x_n) p<code class="code">x_1 ... x_n</code>)) </li>
</ul>

          It is used to justify the elimination of unused variables.
          This proof object has no antecedents.
<p>
<ul>
<li>OP_PR_DER: A proof for destructive equality resolution:
          (iff (forall (x) (or (not (= x t)) P<code class="code">x</code>)) P<code class="code">t</code>)
          if x does not occur in t.</li>
</ul>

          This proof object has no antecedents.
<p>

          Several variables can be eliminated simultaneously.
<p>
<ul>
<li>OP_PR_QUANT_INST: A proof of (or (not (forall (x) (P x))) (P a))</li>
</ul>
<ul>
<li>OP_PR_HYPOTHESIS: Mark a hypothesis in a natural deduction style proof.</li>
</ul>
<ul>
<li>OP_PR_LEMMA: </li>
</ul>

       <em>
          T1: false
          <code class="code">lemma T1</code>: (or (not l_1) ... (not l_n))
          </em>
          This proof object has one antecedent: a hypothetical proof for false.
          It converts the proof in a proof for (or (not l_1) ... (not l_n)),
          when T1 contains the hypotheses: l_1, ..., l_n.
<p>
<ul>
<li>OP_PR_UNIT_RESOLUTION: 
       <em>
          T1:      (or l_1 ... l_n l_1' ... l_m')
          T2:      (not l_1)
          ...
          T(n+1):  (not l_n)
          <code class="code">unit-resolution T1 ... T(n+1)</code>: (or l_1' ... l_m')
          </em></li>
</ul>
<ul>
<li>OP_PR_IFF_TRUE: 
      <em>
       T1: p
       <code class="code">iff-true T1</code>: (iff p true)
       </em></li>
</ul>
<ul>
<li>OP_PR_IFF_FALSE:
      <em>
       T1: (not p)
       <code class="code">iff-false T1</code>: (iff p false)
       </em></li>
</ul>
<ul>
<li>OP_PR_COMMUTATIVITY:</li>
</ul>

          <code class="code">comm</code>: (= (f a b) (f b a))
<p>

          f is a commutative operator.
<p>

          This proof object has no antecedents.
          Remark: if f is bool, then = is iff.
<p>
<ul>
<li>OP_PR_DEF_AXIOM: Proof object used to justify Tseitin's like axioms:</li>
</ul>

          <em>
          (or (not (and p q)) p)
          (or (not (and p q)) q)
          (or (not (and p q r)) p)
          (or (not (and p q r)) q)
          (or (not (and p q r)) r)
          ...
          (or (and p q) (not p) (not q))
          (or (not (or p q)) p q)
          (or (or p q) (not p))
          (or (or p q) (not q))
          (or (not (iff p q)) (not p) q)
          (or (not (iff p q)) p (not q))
          (or (iff p q) (not p) (not q))
          (or (iff p q) p q)
          (or (not (ite a b c)) (not a) b)
          (or (not (ite a b c)) a c)
          (or (ite a b c) (not a) (not b))
          (or (ite a b c) a (not c))
          (or (not (not a)) (not a))
          (or (not a) a)
          </em>
          This proof object has no antecedents.
          Note: all axioms are propositional tautologies.
          Note also that 'and' and 'or' can take multiple arguments.
          You can recover the propositional tautologies by
          unfolding the Boolean connectives in the axioms a small
          bounded number of steps (=3).
<p>
<ul>
<li>OP_PR_DEF_INTRO: Introduces a name for a formula/term.
       Suppose e is an expression with free variables x, and def-intro
       introduces the name n(x). The possible cases are:</li>
</ul>

       When e is of Boolean type:
       <code class="code">def-intro</code>: (and (or n (not e)) (or (not n) e))
<p>

       or:
       <code class="code">def-intro</code>: (or (not n) e)
       when e only occurs positively.
<p>

       When e is of the form (ite cond th el):
       <code class="code">def-intro</code>: (and (or (not cond) (= n th)) (or cond (= n el)))
<p>

       Otherwise:
       <code class="code">def-intro</code>: (= n e)       
<p>
<ul>
<li>OP_PR_APPLY_DEF: 
       <code class="code">apply-def T1</code>: F ~ n
       F is 'equivalent' to n, given that T1 is a proof that
       n is a name for F.</li>
</ul>
<ul>
<li>OP_PR_IFF_OEQ:
       T1: (iff p q)
       <code class="code">iff~ T1</code>: (~ p q)</li>
</ul>
<ul>
<li>OP_PR_NNF_POS: Proof for a (positive) NNF step. Example:
       <em>
          T1: (not s_1) ~ r_1
          T2: (not s_2) ~ r_2
          T3: s_1 ~ r_1'
          T4: s_2 ~ r_2'
          <code class="code">nnf-pos T1 T2 T3 T4</code>: (~ (iff s_1 s_2)
                                    (and (or r_1 r_2') (or r_1' r_2)))
          </em>
       The negation normal form steps NNF_POS and NNF_NEG are used in the following cases:
       (a) When creating the NNF of a positive force quantifier.
        The quantifier is retained (unless the bound variables are eliminated).
        Example
        <em>
           T1: q ~ q_new 
           <code class="code">nnf-pos T1</code>: (~ (forall (x T) q) (forall (x T) q_new))
        </em>
       (b) When recursively creating NNF over Boolean formulas, where the top-level
       connective is changed during NNF conversion. The relevant Boolean connectives
       for NNF_POS are 'implies', 'iff', 'xor', 'ite'.
       NNF_NEG furthermore handles the case where negation is pushed
       over Boolean connectives 'and' and 'or'.</li>
</ul>
<ul>
<li>OP_PR_NFF_NEG: Proof for a (negative) NNF step. Examples:
          <em>
          T1: (not s_1) ~ r_1
          ...
          Tn: (not s_n) ~ r_n
         <code class="code">nnf-neg T1 ... Tn</code>: (not (and s_1 ... s_n)) ~ (or r_1 ... r_n)
      and
          T1: (not s_1) ~ r_1
          ...
          Tn: (not s_n) ~ r_n
         <code class="code">nnf-neg T1 ... Tn</code>: (not (or s_1 ... s_n)) ~ (and r_1 ... r_n)
      and
          T1: (not s_1) ~ r_1
          T2: (not s_2) ~ r_2
          T3: s_1 ~ r_1'
          T4: s_2 ~ r_2'
         <code class="code">nnf-neg T1 T2 T3 T4</code>: (~ (not (iff s_1 s_2))
                                   (and (or r_1 r_2) (or r_1' r_2')))
       </em></li>
<li>OP_PR_NNF_STAR: A proof for (~ P Q) where Q is in negation normal form.</li>
</ul>

       This proof object is only used if the parameter PROOF_MODE is 1.       
<p>

       This proof object may have n antecedents. Each antecedent is a PR_DEF_INTRO.
<p>
<ul>
<li>OP_PR_CNF_STAR: A proof for (~ P Q) where Q is in conjunctive normal form.
       This proof object is only used if the parameter PROOF_MODE is 1.       
       This proof object may have n antecedents. Each antecedent is a PR_DEF_INTRO.          </li>
</ul>
<ul>
<li>OP_PR_SKOLEMIZE: Proof for:  </li>
</ul>

          <em>
          <code class="code">sk</code>: (~ (not (forall x (p x y))) (not (p (sk y) y)))
          <code class="code">sk</code>: (~ (exists x (p x y)) (p (sk y) y))
          </em>
<p>

          This proof object has no antecedents.
<p>
<ul>
<li>OP_PR_MODUS_PONENS_OEQ: Modus ponens style rule for equi-satisfiability.
       <em>
          T1: p
          T2: (~ p q)
          <code class="code">mp~ T1 T2</code>: q
          </em></li>
</ul>
<ul>
<li>OP_PR_TH_LEMMA: Generic proof for theory lemmas.</li>
</ul>

         The theory lemma function comes with one or more parameters.
         The first parameter indicates the name of the theory.
         For the theory of arithmetic, additional parameters provide hints for
         checking the theory lemma. 
         The hints for arithmetic are:
<p>
<ul>
<li>farkas - followed by rational coefficients. Multiply the coefficients to the
           inequalities in the lemma, add the (negated) inequalities and obtain a contradiction.</li>
</ul>
<ul>
<li>triangle-eq - Indicates a lemma related to the equivalence:
         <em>
            (iff (= t1 t2) (and (&lt;= t1 t2) (&lt;= t2 t1)))
         </em></li>
</ul>
<ul>
<li>gcd-test - Indicates an integer linear arithmetic lemma that uses a gcd test.</li>
</ul>
<ul>
<li>OP_RA_STORE: Insert a record into a relation.
        The function takes <code class="code">n+1</code> arguments, where the first argument is the relation and the remaining <code class="code">n</code> elements 
        correspond to the <code class="code">n</code> columns of the relation.</li>
</ul>
<ul>
<li>OP_RA_EMPTY: Creates the empty relation. </li>
</ul>
<ul>
<li>OP_RA_IS_EMPTY: Tests if the relation is empty.</li>
</ul>
<ul>
<li>OP_RA_JOIN: Create the relational join.</li>
</ul>
<ul>
<li>OP_RA_UNION: Create the union or convex hull of two relations. 
        The function takes two arguments.</li>
</ul>
<ul>
<li>OP_RA_WIDEN: Widen two relations.
        The function takes two arguments.</li>
</ul>
<ul>
<li>OP_RA_PROJECT: Project the columns (provided as numbers in the parameters).
        The function takes one argument.</li>
</ul>
<ul>
<li>OP_RA_FILTER: Filter (restrict) a relation with respect to a predicate.
        The first argument is a relation. 
        The second argument is a predicate with free de-Brujin indices
        corresponding to the columns of the relation.
        So the first column in the relation has index 0.</li>
</ul>
<ul>
<li>OP_RA_NEGATION_FILTER: Intersect the first relation with respect to negation
        of the second relation (the function takes two arguments).
        Logically, the specification can be described by a function</li>
</ul>

           target = filter_by_negation(pos, neg, columns)
<p>

        where columns are pairs c1, d1, .., cN, dN of columns from pos and neg, such that
        target are elements in x in pos, such that there is no y in neg that agrees with
        x on the columns c1, d1, .., cN, dN.
<p>
<ul>
<li>OP_RA_RENAME: rename columns in the relation. 
        The function takes one argument.
        The parameters contain the renaming as a cycle.</li>
</ul>
<ul>
<li>OP_RA_COMPLEMENT: Complement the relation.</li>
</ul>
<ul>
<li>OP_RA_SELECT: Check if a record is an element of the relation.
        The function takes <code class="code">n+1</code> arguments, where the first argument is a relation,
        and the remaining <code class="code">n</code> arguments correspond to a record.</li>
</ul>
<ul>
<li>OP_RA_CLONE: Create a fresh copy (clone) of a relation. 
        The function is logically the identity, but
        in the context of a register machine allows
        for  <code class="code">OP_RA_UNION</code>  
        to perform destructive updates to the first argument.</li>
</ul>
<ul>
<li>OP_FD_LT: A less than predicate over the finite domain FINITE_DOMAIN_SORT.</li>
</ul>
<ul>
<li>OP_LABEL: A label (used by the Boogie Verification condition generator).
                     The label has two parameters, a string and a Boolean polarity.
                     It takes one argument, a formula.</li>
</ul>
<ul>
<li>OP_LABEL_LIT: A label literal (used by the Boogie Verification condition generator).
                     A label literal has a set of string parameters. It takes no arguments.</li>
</ul>
<ul>
<li>OP_UNINTERPRETED: kind used for uninterpreted symbols.</li>
</ul>
<br>
<br>
<a href="Z3.html#TYPEsearch_failure"><code class="code">search_failure</code></a>  
   The different kinds of search failure types.
<p>
<ul>
<li>NO_FAILURE:         The last search was successful</li>
<li>UNKNOWN:            Undocumented failure reason</li>
<li>TIMEOUT:            Timeout</li>
<li>MEMOUT_WATERMAK:    Search hit a memory high-watermak limit</li>
<li>CANCELED:           External cancel flag was set</li>
<li>NUM_CONFLICTS:      Maximum number of conflicts was reached</li>
<li>THEORY:             Theory is incomplete</li>
<li>QUANTIFIERS:        Logical context contains universal quantifiers</li>
</ul>
<br>
<br>
<a href="Z3.html#TYPEast_print_mode"><code class="code">ast_print_mode</code></a>  
   Z3 pretty printing modes (See <a href="Z3.html#VALset_ast_print_mode"><code class="code">set_ast_print_mode</code></a>).
<p>
<ul>
<li>PRINT_SMTLIB_FULL:   Print AST nodes in SMTLIB verbose format.</li>
<li>PRINT_LOW_LEVEL:     Print AST nodes using a low-level format.</li>
<li>PRINT_SMTLIB_COMPLIANT: Print AST nodes in SMTLIB 1.x compliant format.</li>
<li>PRINT_SMTLIB2_COMPLIANT: Print AST nodes in SMTLIB 2.x compliant format.</li>
</ul>
<br>
<br>
<a href="Z3.html#TYPEerror_code"><code class="code">error_code</code></a>  
   Z3 error codes 
<p>
<ul>
<li>OK:            No error.</li>
<li>SORT_ERROR:    User tried to build an invalid (type incorrect) AST.</li>
<li>IOB:           Index out of bounds.</li>
<li>INVALID_ARG:   Invalid argument was provided.</li>
<li>PARSER_ERROR:  An error occurred when parsing a string or file.</li>
<li>NO_PARSER:     Parser output is not available, that is, user didn't invoke <a href="Z3.html#VALparse_smtlib_string"><code class="code">parse_smtlib_string</code></a> or <a href="Z3.html#VALparse_smtlib_file"><code class="code">parse_smtlib_file</code></a>.</li>
<li>INVALID_PATTERN: Invalid pattern was used to build a quantifier.</li>
<li>MEMOUT_FAIL:   A memory allocation failure was encountered.</li>
<li>FILE_ACCESS_ERRROR: A file could not be accessed.</li>
<li>INVALID_USAGE:   API call is invalid in the current state.</li>
<li>INTERNAL_FATAL: An error internal to Z3 occurred.</li>
<li>DEC_REF_ERROR: Trying to decrement the reference counter of an AST that was deleted or the reference counter was not initialized.</li>
<li>EXCEPTION:     Internal Z3 exception. Additional details can be retrieved using  <a href="Z3.html#VALget_error_msg"><code class="code">get_error_msg</code></a>.</li>
</ul>
<br>
<pre><span id="EXCEPTIONError"><span class="keyword">exception</span> Error</span> <span class="keyword">of</span> <code class="type"><a href="Z3.html#TYPEcontext">context</a> * <a href="Z3.html#TYPEerror_code">error_code</a></code></pre>
<div class="info">
Exceptions raised by Z3. It is safe to continue interacting with Z3 after
    catching <code class="code">Error</code> exceptions.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_error_msg"><code class="code">get_error_msg</code></a></li>
</ul>
<br>
</div>
<br>
<a href="Z3.html#TYPEgoal_prec"><code class="code">goal_prec</code></a>  
   A Goal is essentially a set of formulas. Z3 provide APIs for building strategies/tactics for solving and transforming Goals. Some of these transformations apply under/over approximations.
<p>
<ul>
<li>GOAL_PRECISE:    Approximations/Relaxations were not applied on the goal (sat and unsat answers were preserved).</li>
<li>GOAL_UNDER:      Goal is the product of a under-approximation (sat answers are preserved).</li>
<li>GOAL_OVER:       Goal is the product of an over-approximation (unsat answers are preserved).</li>
<li>GOAL_UNDER_OVER: Goal is garbage (it is the product of over- and under-approximations, sat and unsat answers are not preserved).</li>
</ul>
<br>
<br>
<span id="2_Createcontext"><h2><div align=left>Create context</div></h2></span><br>
<pre><span id="VALmk_context"><span class="keyword">val</span> mk_context</span> : <code class="type">(string * string) list -> <a href="Z3.html#TYPEcontext">context</a></code></pre><div class="info">
Summary: Create a context using the given configuration. 
<p>

       After a context is created, the configuration cannot be changed,
       although some parameters can be changed using <a href="Z3.html#VALupdate_param_value"><code class="code">update_param_value</code></a>.
       All main interaction with Z3 happens in the context of a <code class="code">context</code>.<br>
</div>
<pre><span id="VALupdate_param_value"><span class="keyword">val</span> update_param_value</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> string -> unit</code></pre><div class="info">
Summary: Update a mutable configuration parameter.
<p>

       The list of all configuration parameters can be obtained using the Z3 executable:
<p>

       <pre>
       z3.exe -ini?
       </pre>
<p>

       Only a few configuration parameters are mutable once the context is created.
       The error handler is invoked when trying to modify an immutable parameter.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_context"><code class="code">mk_context</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_param_value"><span class="keyword">val</span> get_param_value</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> string option</code></pre><div class="info">
Summary: Get a configuration parameter.
<p>

       Returns  <code class="code">None</code>  
       if the parameter value does not exist.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_context"><code class="code">mk_context</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALinterrupt"><span class="keyword">val</span> interrupt</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> unit</code></pre><div class="info">
Summary: Interrupt the execution of a Z3 procedure.
       This procedure can be used to interrupt: solvers, simplifiers and tactics.<br>
</div>
<br>
<span id="2_Parameters"><h2><div align=left>Parameters</div></h2></span><br>
<pre><span id="VALmk_params"><span class="keyword">val</span> mk_params</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEparams">params</a></code></pre><div class="info">
Summary: Create a Z3 (empty) parameter set.
       Starting at Z3 4.0, parameter sets are used to configure many components such as:
       simplifiers, tactics, solvers, etc.<br>
</div>
<pre><span id="VALparams_set_bool"><span class="keyword">val</span> params_set_bool</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEparams">params</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> bool -> unit</code></pre><div class="info">
Summary: Add a Boolean parameter <code class="code">k</code> with value <code class="code">v</code> to the parameter set <code class="code">p</code>.<br>
</div>
<pre><span id="VALparams_set_uint"><span class="keyword">val</span> params_set_uint</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEparams">params</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> int -> unit</code></pre><div class="info">
Summary: Add a unsigned int parameter <code class="code">k</code> with value <code class="code">v</code> to the parameter set <code class="code">p</code>.<br>
</div>
<pre><span id="VALparams_set_double"><span class="keyword">val</span> params_set_double</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEparams">params</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> float -> unit</code></pre><div class="info">
Summary: Add a double parameter <code class="code">k</code> with value <code class="code">v</code> to the parameter set <code class="code">p</code>.<br>
</div>
<pre><span id="VALparams_set_symbol"><span class="keyword">val</span> params_set_symbol</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEparams">params</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> unit</code></pre><div class="info">
Summary: Add a symbol parameter <code class="code">k</code> with value <code class="code">v</code> to the parameter set <code class="code">p</code>.<br>
</div>
<pre><span id="VALparams_to_string"><span class="keyword">val</span> params_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEparams">params</a> -> string</code></pre><div class="info">
Summary: Convert a parameter set into a string. This function is mainly used for printing the
       contents of a parameter set.<br>
</div>
<br>
<span id="2_Symbols"><h2><div align=left>Symbols</div></h2></span><br>
<br><code><span id="TYPEsymbol_refined"><span class="keyword">type</span> <code class="type"></code>symbol_refined</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Symbol_int</span> <span class="keyword">of</span> <code class="type">int</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Symbol_string</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr></table>

<div class="info">
Refined view of a <a href="Z3.html#TYPEsymbol"><code class="code">symbol</code></a>.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_symbol"><code class="code">mk_symbol</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALsymbol_refine"><code class="code">symbol_refine</code></a></li>
</ul>
<br>
</div>

<pre><span id="VALmk_symbol"><span class="keyword">val</span> mk_symbol</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsymbol_refined">symbol_refined</a> -> <a href="Z3.html#TYPEsymbol">symbol</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_symbol c sr </code> ] constructs the symbol described by <code class="code">sr</code>.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALsymbol_refine"><code class="code">symbol_refine</code></a></li>
</ul>
<br>
</div>
<br>
<span id="4_RedundantlowlevelAPI"><h4><div align=left>Redundant low-level API</div></h4></span><br>
<pre><span id="VALmk_int_symbol"><span class="keyword">val</span> mk_int_symbol</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEsymbol">symbol</a></code></pre><div class="info">
Summary: Create a Z3 symbol using an integer.
<p>

       Symbols are used to name several term and type constructors.
<p>

       NB. Not all integers can be passed to this function.
       The legal range of unsigned int integers is 0 to 2^30-1.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_string_symbol"><code class="code">mk_string_symbol</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_string_symbol"><span class="keyword">val</span> mk_string_symbol</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> <a href="Z3.html#TYPEsymbol">symbol</a></code></pre><div class="info">
Summary: Create a Z3 symbol using a C string.
<p>

       Symbols are used to name several term and type constructors.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_int_symbol"><code class="code">mk_int_symbol</code></a></li>
</ul>
<br>
</div>
<br>
<span id="2_Sorts"><h2><div align=left>Sorts</div></h2></span><br>
<br><code><span id="TYPEdatatype_constructor_desc"><span class="keyword">type</span> <code class="type"></code>datatype_constructor_desc</span> = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>constructor_desc&nbsp;: <code class="type"><a href="Z3.html#TYPEsymbol">symbol</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >name of the constructor function</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>recognizer_desc&nbsp;: <code class="type"><a href="Z3.html#TYPEsymbol">symbol</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >name of the recognizer function</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>accessor_descs&nbsp;: <code class="type">(<a href="Z3.html#TYPEsymbol">symbol</a> * <a href="Z3.html#TYPEsort">sort</a>) array</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >names and sorts of the fields</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
A datatype constructor descriptor.<br>
</div>

<pre><span id="TYPEdatatype_desc"><span class="keyword">type</span> <code class="type"></code>datatype_desc</span> = <code class="type"><a href="Z3.html#TYPEsymbol">symbol</a> * <a href="Z3.html#TYPEdatatype_constructor_desc">datatype_constructor_desc</a> array</code> </pre>
<div class="info">
A datatype is described by a name and constructor descriptors.<br>
</div>

<br><code><span id="TYPEdatatype_constructor"><span class="keyword">type</span> <code class="type"></code>datatype_constructor</span> = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>constructor&nbsp;: <code class="type"><a href="Z3.html#TYPEfunc_decl">func_decl</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >constructor function</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>recognizer&nbsp;: <code class="type"><a href="Z3.html#TYPEfunc_decl">func_decl</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >recognizer function</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>accessors&nbsp;: <code class="type"><a href="Z3.html#TYPEfunc_decl">func_decl</a> array</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >field accessor functions</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
A datatype constructor representation.<br>
</div>

<pre><span id="TYPEdatatype"><span class="keyword">type</span> <code class="type"></code>datatype</span> = <code class="type"><a href="Z3.html#TYPEsort">sort</a> * <a href="Z3.html#TYPEdatatype_constructor">datatype_constructor</a> array</code> </pre>
<div class="info">
A datatype is represented by a sort and constructors.<br>
</div>

<br><code><span id="TYPEsort_refined"><span class="keyword">type</span> <code class="type"></code>sort_refined</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Sort_uninterpreted</span> <span class="keyword">of</span> <code class="type"><a href="Z3.html#TYPEsymbol">symbol</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Sort_bool</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Sort_int</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Sort_bv</span> <span class="keyword">of</span> <code class="type">int</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Sort_finite_domain</span> <span class="keyword">of</span> <code class="type"><a href="Z3.html#TYPEsymbol">symbol</a> * int64</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Sort_real</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Sort_array</span> <span class="keyword">of</span> <code class="type"><a href="Z3.html#TYPEsort">sort</a> * <a href="Z3.html#TYPEsort">sort</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Sort_datatype</span> <span class="keyword">of</span> <code class="type"><a href="Z3.html#TYPEdatatype_constructor">datatype_constructor</a> array</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Sort_relation</span> <span class="keyword">of</span> <code class="type"><a href="Z3.html#TYPEsort">sort</a> array</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Sort_unknown</span></code></td>

</tr></table>

<div class="info">
Refined view of a <a href="Z3.html#TYPEsort"><code class="code">sort</code></a>.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_sort"><code class="code">mk_sort</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALsort_refine"><code class="code">sort_refine</code></a></li>
</ul>
<br>
</div>

<pre><span id="VALmk_sort"><span class="keyword">val</span> mk_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort_refined">sort_refined</a> -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_sort c sr </code> ] constructs the sort described by <code class="code">sr</code>.
<p>
<ul>
<li><b>Precondition</b>: <code class="code">sr</code> is not of form <code class="code">Sort_relation</code> or <code class="code">Sort_unknown</code>, which cannot be directly constructed</li>
<li><b>See also</b>: <a href="Z3.html#VALmk_datatypes"><code class="code">mk_datatypes</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALsort_refine"><code class="code">sort_refine</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_datatypes"><span class="keyword">val</span> mk_datatypes</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       (<a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEdatatype_desc">datatype_desc</a> array option) -> <a href="Z3.html#TYPEdatatype">datatype</a> array</code></pre><div class="info">
[ <code class="code">mk_datatypes ctx sorts_to_descriptors</code> ] creates mutually recursive datatypes described by
   <code class="code">sorts_to_descriptors</code>, which is a function from the sorts of the datatypes to be created to
   descriptors of the datatypes' constructors.
<p>
<ul>
<li><b>See also</b>: <a href="Test_mlapi.html#VALforest_example"><code class="code">forest_example</code></a></li>
</ul>
<br>
</div>
<br>
<span id="4_RedundantlowlevelAPI"><h4><div align=left>Redundant low-level API</div></h4></span><br>
<pre><span id="VALmk_uninterpreted_sort"><span class="keyword">val</span> mk_uninterpreted_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Create a free (uninterpreted) type using the given name (symbol).
<p>

       Two free types are considered the same iff the have the same name.<br>
</div>
<pre><span id="VALmk_bool_sort"><span class="keyword">val</span> mk_bool_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Create the Boolean type. 
<p>

       This type is used to create propositional variables and predicates.<br>
</div>
<pre><span id="VALmk_int_sort"><span class="keyword">val</span> mk_int_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Create the integer type.
<p>

       This type is not the int type found in programming languages.
       A machine integer can be represented using bit-vectors. The function
       <a href="Z3.html#VALmk_bv_sort"><code class="code">mk_bv_sort</code></a> creates a bit-vector type.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_bv_sort"><code class="code">mk_bv_sort</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_real_sort"><span class="keyword">val</span> mk_real_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Create the real type. 
<p>

       This type is not a floating point number.
       Z3 does not have support for floating point numbers yet.<br>
</div>
<pre><span id="VALmk_bv_sort"><span class="keyword">val</span> mk_bv_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Create a bit-vector type of the given size.
<p>

       This type can also be seen as a machine integer.
<p>
<ul>
<li><b>Remarks</b>: The size of the bitvector type must be greater than zero.</li>
</ul>
<br>
</div>
<pre><span id="VALmk_finite_domain_sort"><span class="keyword">val</span> mk_finite_domain_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> int64 -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Create a named finite domain sort.
<p>

       To create constants that belong to the finite domain, 
       use the APIs for creating numerals and pass a numeric
       constant together with the sort returned by this call.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_finite_domain_sort_size"><code class="code">get_finite_domain_sort_size</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_array_sort"><span class="keyword">val</span> mk_array_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Create an array type. 
<p>

       We usually represent the array type as: <em><code class="code">domain -&gt; range</code> </em>.
       Arrays are usually used to model the heap/memory in software verification.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_select"><code class="code">mk_select</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_store"><code class="code">mk_store</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_tuple_sort"><span class="keyword">val</span> mk_tuple_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -><br>       <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsort">sort</a> * <a href="Z3.html#TYPEfunc_decl">func_decl</a> * <a href="Z3.html#TYPEfunc_decl">func_decl</a> array</code></pre><div class="info">
Summary: Create a tuple type.
<p>

        <code class="code">mk_tuple_sort c name field_names field_sorts</code> creates a tuple with a constructor named <code class="code">name</code>,
       a <code class="code">n</code> fields, where <code class="code">n</code> is the size of the arrays <code class="code">field_names</code> and <code class="code">field_sorts</code>.<br>
</div>
<pre><span id="VALmk_enumeration_sort"><span class="keyword">val</span> mk_enumeration_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -> <a href="Z3.html#TYPEsort">sort</a> * <a href="Z3.html#TYPEfunc_decl">func_decl</a> array * <a href="Z3.html#TYPEfunc_decl">func_decl</a> array</code></pre><div class="info">
Summary: Create a enumeration sort.
<p>

        <code class="code">mk_enumeration_sort c enums</code> creates an enumeration sort with enumeration names <code class="code">enums</code>, 
               it also returns <code class="code">n</code> predicates, where <code class="code">n</code> is the number of <code class="code">enums</code> corresponding
               to testing whether an element is one of the enumerants.<br>
</div>
<pre><span id="VALmk_list_sort"><span class="keyword">val</span> mk_list_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> -><br>       <a href="Z3.html#TYPEsort">sort</a> -><br>       <a href="Z3.html#TYPEsort">sort</a> * <a href="Z3.html#TYPEfunc_decl">func_decl</a> * <a href="Z3.html#TYPEfunc_decl">func_decl</a> * <a href="Z3.html#TYPEfunc_decl">func_decl</a> * <a href="Z3.html#TYPEfunc_decl">func_decl</a> *<br>       <a href="Z3.html#TYPEfunc_decl">func_decl</a> * <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: Create a list sort
<p>

        <code class="code">mk_list_sort c name elem_sort</code> creates a list sort of <code class="code">name</code>, over elements of sort <code class="code">elem_sort</code>.<br>
</div>
<br>
<span id="2_ConstantsandApplications"><h2><div align=left>Constants and Applications</div></h2></span><br>
<pre><span id="VALmk_func_decl"><span class="keyword">val</span> mk_func_decl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: Declare a constant or function.
<p>

        <code class="code">mk_func_decl c n d r</code> creates a function with name <code class="code">n</code>, domain <code class="code">d</code>, and range <code class="code">r</code>.
       The arity of the function is the size of the array <code class="code">d</code>.<br>
</div>
<pre><span id="VALmk_app"><span class="keyword">val</span> mk_app</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a constant or function application.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_func_decl"><code class="code">mk_func_decl</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_const"><span class="keyword">val</span> mk_const</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Declare and create a constant.
<p>

        <code class="code">mk_const c s t</code> is a shorthand for <code class="code">mk_app c (mk_func_decl c s [||] t) [||]</code> 
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_func_decl"><code class="code">mk_func_decl</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_app"><code class="code">mk_app</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_fresh_func_decl"><span class="keyword">val</span> mk_fresh_func_decl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: Declare a fresh constant or function.
<p>

       Z3 will generate an unique name for this function declaration.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_func_decl"><code class="code">mk_func_decl</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_fresh_const"><span class="keyword">val</span> mk_fresh_const</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Declare and create a fresh constant.
<p>

        <code class="code">mk_fresh_const c p t</code> is a shorthand for <code class="code">mk_app c (mk_fresh_func_decl c p [||] t) [||]</code>. 
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_func_decl"><code class="code">mk_func_decl</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_app"><code class="code">mk_app</code></a></li>
</ul>
<br>
</div>
<br>
<span id="2_PropositionalLogicandEquality"><h2><div align=left>Propositional Logic and Equality</div></h2></span><br>
<pre><span id="VALmk_true"><span class="keyword">val</span> mk_true</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create an AST node representing <code class="code">true</code>.<br>
</div>
<pre><span id="VALmk_false"><span class="keyword">val</span> mk_false</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create an AST node representing <code class="code">false</code>.<br>
</div>
<pre><span id="VALmk_eq"><span class="keyword">val</span> mk_eq</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_eq c l r </code> ]
        Create an AST node representing <em>l = r </em>.
<p>

        The nodes <code class="code">l</code> and <code class="code">r</code> must have the same type.<br>
</div>
<pre><span id="VALmk_distinct"><span class="keyword">val</span> mk_distinct</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code">mk_distinct c [| t_1; ...; t_n |]</code> ] Create an AST
       node represeting a distinct construct. It is used for declaring
       the arguments t_i pairwise distinct. 
<p>

       The <code class="code">distinct</code> construct is used for declaring the arguments pairwise distinct.
       That is, <em>Forall 0 &lt;= i &lt; j &lt; num_args. not args<code class="code">i</code> = args<code class="code">j</code> </em>.
<p>

       All arguments must have the same sort.
<p>
<ul>
<li><b>Remarks</b>: The number of arguments of a distinct construct must be greater than one.</li>
</ul>
<br>
</div>
<pre><span id="VALmk_not"><span class="keyword">val</span> mk_not</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_not c a </code> ] 
        Create an AST node representing <em>not(a) </em>.
<p>

        The node <code class="code">a</code> must have Boolean sort.<br>
</div>
<pre><span id="VALmk_ite"><span class="keyword">val</span> mk_ite</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_ite c t1 t2 t2 </code> ] 
       Create an AST node representing an if-then-else: <em>ite(t1, t2,
       t3) </em>.
<p>

       The node <code class="code">t1</code> must have Boolean sort, <code class="code">t2</code> and <code class="code">t3</code> must have the same sort.
       The sort of the new node is equal to the sort of <code class="code">t2</code> and <code class="code">t3</code>.<br>
</div>
<pre><span id="VALmk_iff"><span class="keyword">val</span> mk_iff</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_iff c t1 t2 </code> ]
       Create an AST node representing <em>t1 iff t2 </em>.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have Boolean sort.<br>
</div>
<pre><span id="VALmk_implies"><span class="keyword">val</span> mk_implies</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_implies c t1 t2 </code> ]
       Create an AST node representing <em>t1 implies t2 </em>.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have Boolean sort.<br>
</div>
<pre><span id="VALmk_xor"><span class="keyword">val</span> mk_xor</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_xor c t1 t2 </code> ]
       Create an AST node representing <em>t1 xor t2 </em>.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have Boolean sort.<br>
</div>
<pre><span id="VALmk_and"><span class="keyword">val</span> mk_and</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code">mk_and c [| t_1; ...; t_n |]</code> ] Create the conjunction: <em>t_1 and ... and t_n</em>. 
<p>

       All arguments must have Boolean sort.
<p>
<ul>
<li><b>Remarks</b>: The number of arguments must be greater than zero.</li>
</ul>
<br>
</div>
<pre><span id="VALmk_or"><span class="keyword">val</span> mk_or</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code">mk_or c [| t_1; ...; t_n |]</code> ] Create the disjunction: <em>t_1 or ... or t_n</em>. 
<p>

       All arguments must have Boolean sort.
<p>
<ul>
<li><b>Remarks</b>: The number of arguments must be greater than zero.</li>
</ul>
<br>
</div>
<br>
<span id="2_ArithmeticIntegersandReals"><h2><div align=left>Arithmetic: Integers and Reals</div></h2></span><br>
<pre><span id="VALmk_add"><span class="keyword">val</span> mk_add</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code">mk_add c [| t_1; ...; t_n |]</code> ] Create the term: <em>t_1 + ... + t_n</em>. 
<p>

       All arguments must have int or real sort.
<p>
<ul>
<li><b>Remarks</b>: The number of arguments must be greater than zero.</li>
</ul>
<br>
</div>
<pre><span id="VALmk_mul"><span class="keyword">val</span> mk_mul</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code">mk_mul c [| t_1; ...; t_n |]</code> ] Create the term: <em>t_1 * ... * t_n</em>. 
<p>

       All arguments must have int or real sort.
<p>
<ul>
<li><b>Remarks</b>: Z3 has limited support for non-linear arithmetic.</li>
<li><b>Remarks</b>: The number of arguments must be greater than zero.</li>
</ul>
<br>
</div>
<pre><span id="VALmk_sub"><span class="keyword">val</span> mk_sub</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code">mk_sub c [| t_1; ...; t_n |]</code> ] Create the term: <em>t_1 - ... - t_n</em>. 
<p>

       All arguments must have int or real sort.
<p>
<ul>
<li><b>Remarks</b>: The number of arguments must be greater than zero.</li>
</ul>
<br>
</div>
<pre><span id="VALmk_unary_minus"><span class="keyword">val</span> mk_unary_minus</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code">mk_unary_minus c arg</code> ] Create the term: <em>- arg</em>. 
<p>

       The arguments must have int or real type.<br>
</div>
<pre><span id="VALmk_div"><span class="keyword">val</span> mk_div</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code">mk_div c t_1 t_2</code> ] Create the term: <em>t_1 div t_2</em>. 
<p>

       The arguments must either both have int type or both have real type.
       If the arguments have int type, then the result type is an int type, otherwise the
       the result type is real.<br>
</div>
<pre><span id="VALmk_mod"><span class="keyword">val</span> mk_mod</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code">mk_mod c t_1 t_2</code> ] Create the term: <em>t_1 mod t_2</em>. 
<p>

       The arguments must have int type.<br>
</div>
<pre><span id="VALmk_rem"><span class="keyword">val</span> mk_rem</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code">mk_rem c t_1 t_2</code> ] Create the term: <em>t_1 rem t_2</em>. 
<p>

       The arguments must have int type.<br>
</div>
<pre><span id="VALmk_power"><span class="keyword">val</span> mk_power</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
The arguments must have int or real type.<br>
</div>
<pre><span id="VALmk_lt"><span class="keyword">val</span> mk_lt</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_lt c t1 t2 </code> ] 
        Create less than.
<p>

        The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same sort, and must be int or real.<br>
</div>
<pre><span id="VALmk_le"><span class="keyword">val</span> mk_le</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_le c t1 t2 </code> ]
        Create less than or equal to.
<p>

        The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same sort, and must be int or real.<br>
</div>
<pre><span id="VALmk_gt"><span class="keyword">val</span> mk_gt</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_gt c t1 t2 </code> ]
        Create greater than.
<p>

        The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same sort, and must be int or real.<br>
</div>
<pre><span id="VALmk_ge"><span class="keyword">val</span> mk_ge</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_ge c t1 t2 </code> ]
        Create greater than or equal to.
<p>

        The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same sort, and must be int or real.<br>
</div>
<pre><span id="VALmk_int2real"><span class="keyword">val</span> mk_int2real</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_int2real c t1 </code> ]
        Coerce an integer to a real.
<p>

        There is also a converse operation exposed.
        It follows the semantics prescribed by the SMT-LIB standard.
<p>

        You can take the floor of a real by 
        creating an auxiliary integer constant <code class="code">k</code> and
        and asserting <em> mk_int2real(k) &lt;= t1 &lt; mk_int2real(k)+1 </em>.
<p>

        The node <code class="code">t1</code> must have sort integer.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_real2int"><code class="code">mk_real2int</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_is_int"><code class="code">mk_is_int</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_real2int"><span class="keyword">val</span> mk_real2int</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_real2int c t1 </code> ]
        Coerce a real to an integer.
<p>

        The semantics of this function follows the SMT-LIB standard
        for the function to_int
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_int2real"><code class="code">mk_int2real</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_is_int"><code class="code">mk_is_int</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_is_int"><span class="keyword">val</span> mk_is_int</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_is_int c t1 </code> ]
        Check if a real number is an integer.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_int2real"><code class="code">mk_int2real</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_real2int"><code class="code">mk_real2int</code></a></li>
</ul>
<br>
</div>
<br>
<span id="2_Bitvectors"><h2><div align=left>Bit-vectors</div></h2></span><br>
<pre><span id="VALmk_bvnot"><span class="keyword">val</span> mk_bvnot</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvnot c t1 </code> ]
       Bitwise negation.
<p>

       The node <code class="code">t1</code> must have a bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvredand"><span class="keyword">val</span> mk_bvredand</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvredand c t1 </code> ]
       Take conjunction of bits in vector, return vector of length 1.
<p>

       The node <code class="code">t1</code> must have a bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvredor"><span class="keyword">val</span> mk_bvredor</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvredor c t1 </code> ]
       Take disjunction of bits in vector, return vector of length 1.
<p>

       The node <code class="code">t1</code> must have a bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvand"><span class="keyword">val</span> mk_bvand</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvand c t1 t2 </code> ]
       Bitwise and.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvor"><span class="keyword">val</span> mk_bvor</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvor c t1 t2 </code> ]
       Bitwise or.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvxor"><span class="keyword">val</span> mk_bvxor</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvxor c t1 t2 </code> ]
       Bitwise exclusive-or.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvnand"><span class="keyword">val</span> mk_bvnand</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvnand c t1 t2 </code> ]
       Bitwise nand. 
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvnor"><span class="keyword">val</span> mk_bvnor</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvnor c t1 t2 </code> ]
       Bitwise nor. 
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvxnor"><span class="keyword">val</span> mk_bvxnor</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvxnor c t1 t2 </code> ]
       Bitwise xnor. 
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvneg"><span class="keyword">val</span> mk_bvneg</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvneg c t1 </code> ]
       Standard two's complement unary minus. 
<p>

       The node <code class="code">t1</code> must have bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvadd"><span class="keyword">val</span> mk_bvadd</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvadd c t1 t2 </code> ]
        Standard two's complement addition.
<p>

        The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvsub"><span class="keyword">val</span> mk_bvsub</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvsub c t1 t2 </code> ]
        Standard two's complement subtraction.
<p>

        The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvmul"><span class="keyword">val</span> mk_bvmul</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvmul c t1 t2 </code> ]
        Standard two's complement multiplication.
<p>

        The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvudiv"><span class="keyword">val</span> mk_bvudiv</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvudiv c t1 t2 </code> ]
        Unsigned division. 
<p>

        It is defined as the <code class="code">floor</code> of <em>t1/t2 </em> if <code class="code">t2</code> is
        different from zero. If <em>t2 </em> is zero, then the result
        is undefined.
<p>

        The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvsdiv"><span class="keyword">val</span> mk_bvsdiv</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvsdiv c t1 t2 </code> ]
        Two's complement signed division. 
<p>

        It is defined in the following way:
<p>
<ul>
<li>The <code class="code">floor</code> of <em>t1/t2 </em> if <code class="code">t2</code> is different from zero, and <em>t1*t2 &gt;= 0 </em>.</li>
</ul>
<ul>
<li>The <code class="code">ceiling</code> of <em>t1/t2 </em> if <code class="code">t2</code> is different from zero, and <em>t1*t2 &lt; 0 </em>.</li>
</ul>

        If <em>t2 </em> is zero, then the result is undefined.
<p>

        The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvurem"><span class="keyword">val</span> mk_bvurem</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvurem c t1 t2 </code> ]
       Unsigned remainder.
<p>

       It is defined as <em>t1 - (t1 /u t2) * t2 </em>, where <em>/u </em> represents unsigned int division.
<p>

       If <em>t2 </em> is zero, then the result is undefined.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvsrem"><span class="keyword">val</span> mk_bvsrem</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvsrem c t1 t2 </code> ]
       Two's complement signed remainder (sign follows dividend).
<p>

       It is defined as <em>t1 - (t1 /s t2) * t2 </em>, where <em>/s </em> represents signed division.
       The most significant bit (sign) of the result is equal to the most significant bit of <code class="code">t1</code>.
<p>

       If <em>t2 </em> is zero, then the result is undefined.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_bvsmod"><code class="code">mk_bvsmod</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_bvsmod"><span class="keyword">val</span> mk_bvsmod</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvsmod c t1 t2 </code> ]
       Two's complement signed remainder (sign follows divisor).
<p>

       If <em>t2 </em> is zero, then the result is undefined.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_bvsrem"><code class="code">mk_bvsrem</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_bvult"><span class="keyword">val</span> mk_bvult</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvult c t1 t2 </code> ]
       Unsigned less than.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvslt"><span class="keyword">val</span> mk_bvslt</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvslt c t1 t2 </code> ]
       Two's complement signed less than.
<p>

       It abbreviates:
       <pre>
      (or (and (= (extract[|m-1|:|m-1|] t1) bit1)
               (= (extract[|m-1|:|m-1|] t2) bit0))
          (and (= (extract[|m-1|:|m-1|] t1) (extract[|m-1|:|m-1|] t2))
               (bvult t1 t2)))
       </pre>
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvule"><span class="keyword">val</span> mk_bvule</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvule c t1 t2 </code> ]
       Unsigned less than or equal to.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvsle"><span class="keyword">val</span> mk_bvsle</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvsle c t1 t2 </code> ]
       Two's complement signed less than or equal to.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvuge"><span class="keyword">val</span> mk_bvuge</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvuge c t1 t2 </code> ]
       Unsigned greater than or equal to.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvsge"><span class="keyword">val</span> mk_bvsge</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvsge c t1 t2 </code> ]
       Two's complement signed greater than or equal to.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvugt"><span class="keyword">val</span> mk_bvugt</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvugt c t1 t2 </code> ]
       Unsigned greater than.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvsgt"><span class="keyword">val</span> mk_bvsgt</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvsgt c t1 t2 </code> ]
       Two's complement signed greater than.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_concat"><span class="keyword">val</span> mk_concat</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_concat c t1 t2 </code> ]
       Concatenate the given bit-vectors.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have (possibly different) bit-vector sorts
<p>

       The result is a bit-vector of size <em>n1+n2 </em>, where <code class="code">n1</code> (<code class="code">n2)</code> is the size
       of <code class="code">t1</code> (<code class="code">t2)</code>.<br>
</div>
<pre><span id="VALmk_extract"><span class="keyword">val</span> mk_extract</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> int -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_extract c high low t1 </code> ]
       Extract the bits <code class="code">high</code> down to <code class="code">low</code> from a bitvector of
       size <code class="code">m</code> to yield a new bitvector of size <code class="code">n</code>, where <em>n =
       high - low + 1 </em>.
<p>

       The node <code class="code">t1</code> must have a bit-vector sort.<br>
</div>
<pre><span id="VALmk_sign_ext"><span class="keyword">val</span> mk_sign_ext</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_sign_ext c i t1 </code> ]
       Sign-extend of the given bit-vector to the (signed) equivalent bitvector of
       size <em>m+i </em>, where <code class="code">m</code> is the size of the given
       bit-vector.
<p>

       The node <code class="code">t1</code> must have a bit-vector sort.<br>
</div>
<pre><span id="VALmk_zero_ext"><span class="keyword">val</span> mk_zero_ext</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_zero_ext c i t1 </code> ]
       Extend the given bit-vector with zeros to the (unsigned int) equivalent
       bitvector of size <em>m+i </em>, where <code class="code">m</code> is the size of the
       given bit-vector.
<p>

       The node <code class="code">t1</code> must have a bit-vector sort.<br>
</div>
<pre><span id="VALmk_repeat"><span class="keyword">val</span> mk_repeat</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_repeat c i t1 </code> ]
       Repeat the given bit-vector up length <em>i </em>.
<p>

       The node <code class="code">t1</code> must have a bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvshl"><span class="keyword">val</span> mk_bvshl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvshl c t1 t2 </code> ]
       Shift left.
<p>

       It is equivalent to multiplication by <em>2^x </em> where <code class="code">x</code> is the value of the
       third argument.
<p>

       NB. The semantics of shift operations varies between environments. This 
       definition does not necessarily capture directly the semantics of the 
       programming language or assembly architecture you are modeling.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvlshr"><span class="keyword">val</span> mk_bvlshr</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvlshr c t1 t2 </code> ]
       Logical shift right.
<p>

       It is equivalent to unsigned int division by <em>2^x </em> where <code class="code">x</code> is the
       value of the third argument.
<p>

       NB. The semantics of shift operations varies between environments. This 
       definition does not necessarily capture directly the semantics of the 
       programming language or assembly architecture you are modeling.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvashr"><span class="keyword">val</span> mk_bvashr</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvashr c t1 t2 </code> ]
       Arithmetic shift right.
<p>

       It is like logical shift right except that the most significant
       bits of the result always copy the most significant bit of the
       second argument.
<p>

       NB. The semantics of shift operations varies between environments. This 
       definition does not necessarily capture directly the semantics of the 
       programming language or assembly architecture you are modeling.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_rotate_left"><span class="keyword">val</span> mk_rotate_left</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_rotate_left c i t1 </code> ]
       Rotate bits of <code class="code">t1</code> to the left <code class="code">i</code> times.
<p>

       The node <code class="code">t1</code> must have a bit-vector sort.<br>
</div>
<pre><span id="VALmk_rotate_right"><span class="keyword">val</span> mk_rotate_right</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_rotate_right c i t1 </code> ]
       Rotate bits of <code class="code">t1</code> to the right <code class="code">i</code> times.
<p>

       The node <code class="code">t1</code> must have a bit-vector sort.<br>
</div>
<pre><span id="VALmk_ext_rotate_left"><span class="keyword">val</span> mk_ext_rotate_left</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_ext_rotate_left c t1 t2 </code> ]
       Rotate bits of <code class="code">t1</code> to the left <code class="code">t2</code> times.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_ext_rotate_right"><span class="keyword">val</span> mk_ext_rotate_right</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_ext_rotate_right c t1 t2 </code> ]
       Rotate bits of <code class="code">t1</code> to the right <code class="code">t2</code> times.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_int2bv"><span class="keyword">val</span> mk_int2bv</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_int2bv c n t1 </code> ]
       Create an <code class="code">n</code> bit bit-vector from the integer argument <code class="code">t1</code>.
<p>

       NB. This function is essentially treated as uninterpreted. 
       So you cannot expect Z3 to precisely reflect the semantics of this function
       when solving constraints with this function.
<p>

       The node <code class="code">t1</code> must have integer sort.<br>
</div>
<pre><span id="VALmk_bv2int"><span class="keyword">val</span> mk_bv2int</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bv2int c t1 is_signed </code> ]
       Create an integer from the bit-vector argument <code class="code">t1</code>.
       If <code class="code">is_signed</code> is false, then the bit-vector <code class="code">t1</code> is treated as unsigned int. 
       So the result is non-negative
       and in the range <em><code class="code">0..2^N-1</code> </em>, where N are the number of bits in <code class="code">t1</code>.
       If <code class="code">is_signed</code> is true, <code class="code">t1</code> is treated as a signed bit-vector.
<p>

       NB. This function is essentially treated as uninterpreted. 
       So you cannot expect Z3 to precisely reflect the semantics of this function
       when solving constraints with this function.
<p>

       The node <code class="code">t1</code> must have a bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvadd_no_overflow"><span class="keyword">val</span> mk_bvadd_no_overflow</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvadd_no_overflow c t1 t2 is_signed </code> ]
       Create a predicate that checks that the bit-wise addition
       of <code class="code">t1</code> and <code class="code">t2</code> does not overflow.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvadd_no_underflow"><span class="keyword">val</span> mk_bvadd_no_underflow</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvadd_no_underflow c t1 t2 </code> ]
       Create a predicate that checks that the bit-wise signed addition
       of <code class="code">t1</code> and <code class="code">t2</code> does not underflow.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvsub_no_overflow"><span class="keyword">val</span> mk_bvsub_no_overflow</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvsub_no_overflow c t1 t2 </code> ]
       Create a predicate that checks that the bit-wise signed subtraction
       of <code class="code">t1</code> and <code class="code">t2</code> does not overflow.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvsub_no_underflow"><span class="keyword">val</span> mk_bvsub_no_underflow</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvsub_no_underflow c t1 t2 is_signed </code> ]
       Create a predicate that checks that the bit-wise subtraction
       of <code class="code">t1</code> and <code class="code">t2</code> does not underflow.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvsdiv_no_overflow"><span class="keyword">val</span> mk_bvsdiv_no_overflow</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvsdiv_no_overflow c t1 t2 </code> ]
       Create a predicate that checks that the bit-wise signed division 
       of <code class="code">t1</code> and <code class="code">t2</code> does not overflow.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvneg_no_overflow"><span class="keyword">val</span> mk_bvneg_no_overflow</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvneg_no_overflow c t1 </code> ]
       Check that bit-wise negation does not overflow when 
       <code class="code">t1</code> is interpreted as a signed bit-vector.
<p>

       The node <code class="code">t1</code> must have bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvmul_no_overflow"><span class="keyword">val</span> mk_bvmul_no_overflow</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvmul_no_overflow c t1 t2 is_signed </code> ]
       Create a predicate that checks that the bit-wise multiplication
       of <code class="code">t1</code> and <code class="code">t2</code> does not overflow.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<pre><span id="VALmk_bvmul_no_underflow"><span class="keyword">val</span> mk_bvmul_no_underflow</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_bvmul_no_underflow c t1 t2 </code> ]
       Create a predicate that checks that the bit-wise signed multiplication
       of <code class="code">t1</code> and <code class="code">t2</code> does not underflow.
<p>

       The nodes <code class="code">t1</code> and <code class="code">t2</code> must have the same bit-vector sort.<br>
</div>
<br>
<span id="2_Arrays"><h2><div align=left>Arrays</div></h2></span><br>
<pre><span id="VALmk_select"><span class="keyword">val</span> mk_select</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_select c a i </code> ]
       Array read.
       The argument <code class="code">a</code> is the array and <code class="code">i</code> is the index of the array that gets read.      
<p>

       The node <code class="code">a</code> must have an array sort <em><code class="code">domain -&gt; range</code> </em>, 
       and <code class="code">i</code> must have the sort <code class="code">domain</code>.
       The sort of the result is <code class="code">range</code>.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_array_sort"><code class="code">mk_array_sort</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_store"><code class="code">mk_store</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_store"><span class="keyword">val</span> mk_store</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_store c a i v </code> ]
       Array update.
<p>

       The node <code class="code">a</code> must have an array sort <em><code class="code">domain -&gt; range</code> </em>, <code class="code">i</code> must have sort <code class="code">domain</code>,
       <code class="code">v</code> must have sort range. The sort of the result is <em><code class="code">domain -&gt; range</code> </em>.
       The semantics of this function is given by the theory of arrays described in the SMT-LIB
       standard. See http:
       The result of this function is an array that is equal to <code class="code">a</code> (with respect to <code class="code">select)</code>
       on all indices except for <code class="code">i</code>, where it maps to <code class="code">v</code> (and the <code class="code">select</code> of <code class="code">a</code> with 
       respect to <code class="code">i</code> may be a different value).
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_array_sort"><code class="code">mk_array_sort</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_select"><code class="code">mk_select</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_const_array"><span class="keyword">val</span> mk_const_array</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create the constant array.
<p>

        The resulting term is an array, such that a <code class="code">select</code> on an arbitrary index 
        produces the value <code class="code">v</code>.<br>
</div>
<pre><span id="VALmk_map"><span class="keyword">val</span> mk_map</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> mk_map f n args </code> ]
       map f on the the argument arrays.
<p>

       The <code class="code">n</code> nodes <code class="code">args</code> must be of array sorts <em><code class="code">domain_i -&gt; range_i</code> </em>.
       The function declaration <code class="code">f</code> must have type <em> range_1 .. range_n -&gt; range </em>.
       <code class="code">v</code> must have sort range. The sort of the result is <em><code class="code">domain_i -&gt; range</code> </em>.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_array_sort"><code class="code">mk_array_sort</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_store"><code class="code">mk_store</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_select"><code class="code">mk_select</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_array_default"><span class="keyword">val</span> mk_array_default</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Access the array default value.
        Produces the default range value, for arrays that can be represented as 
        finite maps with a default range value.<br>
</div>
<br>
<span id="2_Sets"><h2><div align=left>Sets</div></h2></span><br>
<pre><span id="VALmk_set_sort"><span class="keyword">val</span> mk_set_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Create Set type.<br>
</div>
<pre><span id="VALmk_empty_set"><span class="keyword">val</span> mk_empty_set</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create the empty set.<br>
</div>
<pre><span id="VALmk_full_set"><span class="keyword">val</span> mk_full_set</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create the full set.<br>
</div>
<pre><span id="VALmk_set_add"><span class="keyword">val</span> mk_set_add</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Add an element to a set.
<p>

       The first argument must be a set, the second an element.<br>
</div>
<pre><span id="VALmk_set_del"><span class="keyword">val</span> mk_set_del</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Remove an element to a set.
<p>

       The first argument must be a set, the second an element.<br>
</div>
<pre><span id="VALmk_set_union"><span class="keyword">val</span> mk_set_union</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Take the union of a list of sets.<br>
</div>
<pre><span id="VALmk_set_intersect"><span class="keyword">val</span> mk_set_intersect</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Take the intersection of a list of sets.<br>
</div>
<pre><span id="VALmk_set_difference"><span class="keyword">val</span> mk_set_difference</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Take the set difference between two sets.<br>
</div>
<pre><span id="VALmk_set_complement"><span class="keyword">val</span> mk_set_complement</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Take the complement of a set.<br>
</div>
<pre><span id="VALmk_set_member"><span class="keyword">val</span> mk_set_member</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Check for set membership.
<p>

       The first argument should be an element type of the set.<br>
</div>
<pre><span id="VALmk_set_subset"><span class="keyword">val</span> mk_set_subset</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Check for subsetness of sets.<br>
</div>
<br>
<span id="2_Numerals"><h2><div align=left>Numerals</div></h2></span><br>
<br><code><span id="TYPEnumeral_refined"><span class="keyword">type</span> <code class="type"></code>numeral_refined</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Numeral_int</span> <span class="keyword">of</span> <code class="type">int * <a href="Z3.html#TYPEsort">sort</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Numeral_int64</span> <span class="keyword">of</span> <code class="type">int64 * <a href="Z3.html#TYPEsort">sort</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Numeral_large</span> <span class="keyword">of</span> <code class="type">string * <a href="Z3.html#TYPEsort">sort</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Numeral_rational</span> <span class="keyword">of</span> <code class="type"><a href="Z3.html#TYPEnumeral_refined">numeral_refined</a> * <a href="Z3.html#TYPEnumeral_refined">numeral_refined</a></code></code></td>

</tr></table>

<div class="info">
Summary: [ <code class="code"> numeral_refined </code> ] is the refined view of a numeral .<br>
</div>

<pre><span id="VALembed_numeral"><span class="keyword">val</span> embed_numeral</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEnumeral_refined">numeral_refined</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> embed_numeral c nr </code> ] constructs the numeral described by <code class="code">nr</code>.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALnumeral_refine"><code class="code">numeral_refine</code></a></li>
</ul>
<br>
</div>
<br>
<span id="4_RedundantlowlevelAPI"><h4><div align=left>Redundant low-level API</div></h4></span><br>
<pre><span id="VALmk_numeral"><span class="keyword">val</span> mk_numeral</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a numeral of a given sort.<br>
</div>
<pre><span id="VALmk_real"><span class="keyword">val</span> mk_real</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a real from a fraction.<br>
</div>
<pre><span id="VALmk_int"><span class="keyword">val</span> mk_int</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a numeral of an int, bit-vector, or finite-domain sort. 
<p>

       This function can be use to create numerals that fit in a machine integer.
       It is slightly faster than <a href="Z3.html#VALmk_numeral"><code class="code">mk_numeral</code></a> since it is not necessary to parse a string.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_numeral"><code class="code">mk_numeral</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_int64"><span class="keyword">val</span> mk_int64</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int64 -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a numeral of a int, bit-vector, or finite-domain sort. 
<p>

       This function can be use to create numerals that fit in a machine long long integer.
       It is slightly faster than <a href="Z3.html#VALmk_numeral"><code class="code">mk_numeral</code></a> since it is not necessary to parse a string.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_numeral"><code class="code">mk_numeral</code></a></li>
</ul>
<br>
</div>
<br>
<span id="2_Quantifiers"><h2><div align=left>Quantifiers</div></h2></span><br>
<pre><span id="VALmk_pattern"><span class="keyword">val</span> mk_pattern</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEpattern">pattern</a></code></pre><div class="info">
Summary: Create a pattern for quantifier instantiation.
<p>

       Z3 uses pattern matching to instantiate quantifiers. If a
       pattern is not provided for a quantifier, then Z3 will
       automatically compute a set of patterns for it. However, for
       optimal performance, the user should provide the patterns.
<p>

       Patterns comprise a list of terms. The list should be
       non-empty.  If the list comprises of more than one term, it is
       a called a multi-pattern.
<p>

       In general, one can pass in a list of (multi-)patterns in the
       quantifier constructor.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_forall"><code class="code">mk_forall</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_exists"><code class="code">mk_exists</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_bound"><span class="keyword">val</span> mk_bound</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a bound variable.
<p>

       Bound variables are indexed by de-Bruijn indices. It is perhaps easiest to explain
       the meaning of de-Bruijn indices by indicating the compilation process from
       non-de-Bruijn formulas to de-Bruijn format.
<p>

       <pre> 
       abs(forall (x1) phi) = forall (x1) abs1(phi, x1, 0)
       abs(forall (x1, x2) phi) = abs(forall (x1) abs(forall (x2) phi))
       abs1(x, x, n) = b_n
       abs1(y, x, n) = y
       abs1(f(t1,...,tn), x, n) = f(abs1(t1,x,n), ..., abs1(tn,x,n))
       abs1(forall (x1) phi, x, n) = forall (x1) (abs1(phi, x, n+1))
       </pre>
<p>

       The last line is significant: the index of a bound variable is different depending
       on the scope in which it appears. The deeper x appears, the higher is its
       index.<br>
</div>
<pre><span id="VALmk_forall"><span class="keyword">val</span> mk_forall</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       int -><br>       <a href="Z3.html#TYPEpattern">pattern</a> array -> <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsymbol">symbol</a> array -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a forall formula. It takes an expression <code class="code">body</code> that contains bound variables
       of the same sorts as the sorts listed in the array <code class="code">sorts</code>. The bound variables are de-Bruijn indices created
       using <a href="Z3.html#VALmk_bound"><code class="code">mk_bound</code></a>. The array <code class="code">decl_names</code> contains the names that the quantified formula uses for the 
       bound variables. Z3 applies the convention that the last element in the <code class="code">decl_names</code> and <code class="code">sorts</code> array
       refers to the variable with index 0, the second to last element of <code class="code">decl_names</code> and <code class="code">sorts</code> refers
       to the variable with index 1, etc.
<p>

        <code class="code">mk_forall c w p t n b</code> creates a forall formula, where
       <code class="code">w</code> is the weight, <code class="code">p</code> is an array of patterns, <code class="code">t</code> is an array
       with the sorts of the bound variables, <code class="code">n</code> is an array with the
       'names' of the bound variables, and <code class="code">b</code> is the body of the
       quantifier. Quantifiers are associated with weights indicating
       the importance of using the quantifier during
       instantiation.<br>
</div>
<pre><span id="VALmk_exists"><span class="keyword">val</span> mk_exists</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       int -><br>       <a href="Z3.html#TYPEpattern">pattern</a> array -> <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsymbol">symbol</a> array -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create an exists formula. Similar to <a href="Z3.html#VALmk_forall"><code class="code">mk_forall</code></a>.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_pattern"><code class="code">mk_pattern</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_bound"><code class="code">mk_bound</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_forall"><code class="code">mk_forall</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmk_quantifier"><code class="code">mk_quantifier</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmk_quantifier"><span class="keyword">val</span> mk_quantifier</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       bool -><br>       int -><br>       <a href="Z3.html#TYPEpattern">pattern</a> array -> <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsymbol">symbol</a> array -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a quantifier - universal or existential, with pattern hints. 
       See the documentation for <a href="Z3.html#VALmk_forall"><code class="code">mk_forall</code></a> for an explanation of the parameters.<br>
</div>
<pre><span id="VALmk_quantifier_ex"><span class="keyword">val</span> mk_quantifier_ex</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       bool -><br>       int -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> -><br>       <a href="Z3.html#TYPEpattern">pattern</a> array -><br>       <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsymbol">symbol</a> array -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a quantifier - universal or existential, with pattern hints, no patterns, and attributes<br>
</div>
<pre><span id="VALmk_forall_const"><span class="keyword">val</span> mk_forall_const</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEapp">app</a> array -> <a href="Z3.html#TYPEpattern">pattern</a> array -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a universal quantifier using a list of constants that
       will form the set of bound variables.<br>
</div>
<pre><span id="VALmk_exists_const"><span class="keyword">val</span> mk_exists_const</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEapp">app</a> array -> <a href="Z3.html#TYPEpattern">pattern</a> array -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Similar to <a href="Z3.html#VALmk_forall_const"><code class="code">mk_forall_const</code></a>.
<p>

       Summary: Create an existential quantifier using a list of constants that
       will form the set of bound variables.<br>
</div>
<pre><span id="VALmk_quantifier_const"><span class="keyword">val</span> mk_quantifier_const</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       bool -> int -> <a href="Z3.html#TYPEapp">app</a> array -> <a href="Z3.html#TYPEpattern">pattern</a> array -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a universal or existential 
       quantifier using a list of constants that
       will form the set of bound variables.<br>
</div>
<pre><span id="VALmk_quantifier_const_ex"><span class="keyword">val</span> mk_quantifier_const_ex</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       bool -><br>       int -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> -><br>       <a href="Z3.html#TYPEapp">app</a> array -> <a href="Z3.html#TYPEpattern">pattern</a> array -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Create a universal or existential 
       quantifier using a list of constants that
       will form the set of bound variables.<br>
</div>
<br>
<span id="2_Accessors"><h2><div align=left>Accessors</div></h2></span><br>
<br>
<span id="3_Symbols"><h3><div align=left>Symbols</div></h3></span><br>
<pre><span id="VALsymbol_refine"><span class="keyword">val</span> symbol_refine</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> <a href="Z3.html#TYPEsymbol_refined">symbol_refined</a></code></pre><div class="info">
Summary: [ <code class="code"> symbol_refine c s </code> ] is the refined view of <code class="code">s</code>.<br>
</div>
<br>
<span id="4_RedundantlowlevelAPI"><h4><div align=left>Redundant low-level API</div></h4></span><br>
<pre><span id="VALget_symbol_kind"><span class="keyword">val</span> get_symbol_kind</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> <a href="Z3.html#TYPEsymbol_kind">symbol_kind</a></code></pre><div class="info">
Summary: Return <code class="code">INT_SYMBOL</code> if the symbol was constructed
       using <a href="Z3.html#VALmk_int_symbol"><code class="code">mk_int_symbol</code></a>, and <code class="code">STRING_SYMBOL</code> if the symbol
       was constructed using <a href="Z3.html#VALmk_string_symbol"><code class="code">mk_string_symbol</code></a>.<br>
</div>
<pre><span id="VALget_symbol_int"><span class="keyword">val</span> get_symbol_int</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> int</code></pre><div class="info">
Summary: [ <code class="code"> get_symbol_int c s </code> ]
       Return the symbol int value. 
<p>
<ul>
<li><b>Precondition</b>: get_symbol_kind s == INT_SYMBOL</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_int_symbol"><code class="code">mk_int_symbol</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_symbol_string"><span class="keyword">val</span> get_symbol_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> string</code></pre><div class="info">
Summary: [ <code class="code"> get_symbol_string c s </code> ]
       Return the symbol name. 
<p>
<ul>
<li><b>Precondition</b>: get_symbol_string s == STRING_SYMBOL</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_string_symbol"><code class="code">mk_string_symbol</code></a></li>
</ul>
<br>
</div>
<br>
<span id="3_Sorts"><h3><div align=left>Sorts</div></h3></span><br>
<pre><span id="VALsort_refine"><span class="keyword">val</span> sort_refine</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEsort_refined">sort_refined</a></code></pre><div class="info">
Summary: [ <code class="code"> sort_refine c s </code> ] is the refined view of <code class="code">s</code>.<br>
</div>
<pre><span id="VALget_sort_name"><span class="keyword">val</span> get_sort_name</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEsymbol">symbol</a></code></pre><div class="info">
Summary: Return the sort name as a symbol.<br>
</div>
<pre><span id="VALget_sort_id"><span class="keyword">val</span> get_sort_id</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> int</code></pre><div class="info">
Summary: Return a unique identifier for <code class="code">s</code>.<ul>
<li><b>Remarks</b>: Implicitly used by <code class="code">Pervasives.( = )</code> and <code class="code">Pervasives.compare</code>.</li>
</ul>
<br>
</div>
<br>
<span id="4_RedundantlowlevelAPI"><h4><div align=left>Redundant low-level API</div></h4></span><br>
<pre><span id="VALsort_to_ast"><span class="keyword">val</span> sort_to_ast</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Convert a <code class="code">sort</code> into <code class="code">ast</code>. <ul>
<li><b>Remarks</b>: <code class="code">sort_to_ast c s</code> can be replaced by <code class="code">(s :&gt; ast)</code>.</li>
</ul>
<br>
</div>
<pre><span id="VALis_eq_sort"><span class="keyword">val</span> is_eq_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEsort">sort</a> -> bool</code></pre><div class="info">
Summary: compare sorts.<ul>
<li><b>Remarks</b>: <code class="code">Pervasives.( = )</code> or <code class="code">Pervasives.compare</code> can also be used.</li>
</ul>
<br>
</div>
<pre><span id="VALget_sort_kind"><span class="keyword">val</span> get_sort_kind</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEsort_kind">sort_kind</a></code></pre><div class="info">
Summary: Return the sort kind (e.g., array, tuple, int, bool, etc).
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#TYPEsort_kind"><code class="code">sort_kind</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_bv_sort_size"><span class="keyword">val</span> get_bv_sort_size</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> int</code></pre><div class="info">
Summary: [ <code class="code"> get_bv_sort_size c t </code> ]
       Return the size of the given bit-vector sort. 
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind c t == BV_SORT</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_bv_sort"><code class="code">mk_bv_sort</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_sort_kind"><code class="code">get_sort_kind</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_finite_domain_sort_size"><span class="keyword">val</span> get_finite_domain_sort_size</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> int64 option</code></pre><div class="info">
Summary: Return the size of the sort in <code class="code">r</code>.  Return <code class="code">None</code> if the call failed. 
        That is, get_sort_kind(s) == FINITE_DOMAIN_SORT<br>
</div>
<pre><span id="VALget_array_sort_domain"><span class="keyword">val</span> get_array_sort_domain</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: [ <code class="code"> get_array_sort_domain c t </code> ]
       Return the domain of the given array sort.
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind c t == ARRAY_SORT</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_array_sort"><code class="code">mk_array_sort</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_sort_kind"><code class="code">get_sort_kind</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_array_sort_range"><span class="keyword">val</span> get_array_sort_range</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: [ <code class="code"> get_array_sort_range c t </code> ] 
       Return the range of the given array sort. 
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind c t == ARRAY_SORT</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_array_sort"><code class="code">mk_array_sort</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_sort_kind"><code class="code">get_sort_kind</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_tuple_sort_mk_decl"><span class="keyword">val</span> get_tuple_sort_mk_decl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: [ <code class="code"> get_tuple_sort_mk_decl c t </code> ]
       Return the constructor declaration of the given tuple
       sort. 
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind c t == DATATYPE_SORT</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_tuple_sort"><code class="code">mk_tuple_sort</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_sort_kind"><code class="code">get_sort_kind</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_tuple_sort_num_fields"><span class="keyword">val</span> get_tuple_sort_num_fields</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> int</code></pre><div class="info">
Summary: [ <code class="code"> get_tuple_sort_num_fields c t </code> ]
       Return the number of fields of the given tuple sort. 
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind c t == DATATYPE_SORT</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_tuple_sort"><code class="code">mk_tuple_sort</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_sort_kind"><code class="code">get_sort_kind</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_tuple_sort_field_decl"><span class="keyword">val</span> get_tuple_sort_field_decl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> int -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: [ <code class="code"> get_tuple_sort_field_decl c t i </code> ]
       Return the i-th field declaration (i.e., projection function declaration)
       of the given tuple sort. 
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind t == DATATYPE_SORT</li>
<li><b>Precondition</b>: i &lt; get_tuple_sort_num_fields c t</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmk_tuple_sort"><code class="code">mk_tuple_sort</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_sort_kind"><code class="code">get_sort_kind</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_datatype_sort_num_constructors"><span class="keyword">val</span> get_datatype_sort_num_constructors</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> int</code></pre><div class="info">
Summary: Return number of constructors for datatype.
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind t == DATATYPE_SORT</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_constructor"><code class="code">get_datatype_sort_constructor</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_recognizer"><code class="code">get_datatype_sort_recognizer</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_constructor_accessor"><code class="code">get_datatype_sort_constructor_accessor</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_datatype_sort_constructor"><span class="keyword">val</span> get_datatype_sort_constructor</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> int -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: Return idx'th constructor.
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind t == DATATYPE_SORT</li>
<li><b>Precondition</b>: idx &lt; get_datatype_sort_num_constructors c t</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_num_constructors"><code class="code">get_datatype_sort_num_constructors</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_recognizer"><code class="code">get_datatype_sort_recognizer</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_constructor_accessor"><code class="code">get_datatype_sort_constructor_accessor</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_datatype_sort_recognizer"><span class="keyword">val</span> get_datatype_sort_recognizer</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> int -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: Return idx'th recognizer.
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind t == DATATYPE_SORT</li>
<li><b>Precondition</b>: idx &lt; get_datatype_sort_num_constructors c t</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_num_constructors"><code class="code">get_datatype_sort_num_constructors</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_constructor"><code class="code">get_datatype_sort_constructor</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_constructor_accessor"><code class="code">get_datatype_sort_constructor_accessor</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_datatype_sort_constructor_accessor"><span class="keyword">val</span> get_datatype_sort_constructor_accessor</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> int -> int -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: Return idx_a'th accessor for the idx_c'th constructor.
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind t == DATATYPE_SORT</li>
<li><b>Precondition</b>: idx_c &lt; get_datatype_sort_num_constructors c t</li>
<li><b>Precondition</b>: idx_a &lt; get_domain_size c get_datatype_sort_constructor c idx_c</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_num_constructors"><code class="code">get_datatype_sort_num_constructors</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_constructor"><code class="code">get_datatype_sort_constructor</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_datatype_sort_recognizer"><code class="code">get_datatype_sort_recognizer</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_relation_arity"><span class="keyword">val</span> get_relation_arity</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> int</code></pre><div class="info">
Summary: Return arity of relation.
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind s == RELATION_SORT</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_relation_column"><code class="code">get_relation_column</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_relation_column"><span class="keyword">val</span> get_relation_column</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> int -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Return sort at i'th column of relation sort.
<p>
<ul>
<li><b>Precondition</b>: get_sort_kind c s == RELATION_SORT</li>
<li><b>Precondition</b>: col &lt; get_relation_arity c s</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_relation_arity"><code class="code">get_relation_arity</code></a></li>
</ul>
<br>
</div>
<br>
<span id="3_FunctionDeclarations"><h3><div align=left>Function Declarations</div></h3></span><br>
<pre><span id="VALfunc_decl_to_ast"><span class="keyword">val</span> func_decl_to_ast</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Convert a <code class="code">func_decl</code> into <code class="code">ast</code>. <ul>
<li><b>Remarks</b>: <code class="code">func_decl_to_ast c f</code>  can be replaced by <code class="code">(f :&gt; ast)</code>.</li>
</ul>
<br>
</div>
<pre><span id="VALis_eq_func_decl"><span class="keyword">val</span> is_eq_func_decl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> bool</code></pre><div class="info">
Summary: compare terms.<ul>
<li><b>Remarks</b>: <code class="code">Pervasives.( = )</code> or <code class="code">Pervasives.compare</code> can also be used.</li>
</ul>
<br>
</div>
<pre><span id="VALget_func_decl_id"><span class="keyword">val</span> get_func_decl_id</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int</code></pre><div class="info">
Summary: Return a unique identifier for <code class="code">f</code>.<ul>
<li><b>Remarks</b>: Implicitly used by <code class="code">Pervasives.( = )</code> and <code class="code">Pervasives.compare</code>.</li>
</ul>
<br>
</div>
<pre><span id="VALget_decl_name"><span class="keyword">val</span> get_decl_name</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> <a href="Z3.html#TYPEsymbol">symbol</a></code></pre><div class="info">
Summary: Return the constant declaration name as a symbol.<br>
</div>
<pre><span id="VALget_decl_kind"><span class="keyword">val</span> get_decl_kind</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> <a href="Z3.html#TYPEdecl_kind">decl_kind</a></code></pre><div class="info">
Summary: Return declaration kind corresponding to declaration.<br>
</div>
<pre><span id="VALget_domain_size"><span class="keyword">val</span> get_domain_size</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int</code></pre><div class="info">
Summary: Return the number of parameters of the given declaration.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_arity"><code class="code">get_arity</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_arity"><span class="keyword">val</span> get_arity</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int</code></pre><div class="info">
Summary: Alias for <code class="code">get_domain_size</code>.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_domain_size"><code class="code">get_domain_size</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_domain"><span class="keyword">val</span> get_domain</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: [ <code class="code"> get_domain c d i </code> ]
       Return the sort of the i-th parameter of the given function declaration.
<p>
<ul>
<li><b>Precondition</b>: i &lt; get_domain_size d</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_domain_size"><code class="code">get_domain_size</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_domains"><span class="keyword">val</span> get_domains</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> <a href="Z3.html#TYPEsort">sort</a> array</code></pre><div class="info">
Summary: [ <code class="code"> get_domains c d </code> ] is the array of parameters of <code class="code">d</code>.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_domain_size"><code class="code">get_domain_size</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_domain"><code class="code">get_domain</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_range"><span class="keyword">val</span> get_range</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: [ <code class="code"> get_range c d </code> ]
       Return the range of the given declaration. 
<p>

       If <code class="code">d</code> is a constant (i.e., has zero arguments), then this
       function returns the sort of the constant.<br>
</div>
<pre><span id="VALget_decl_num_parameters"><span class="keyword">val</span> get_decl_num_parameters</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int</code></pre><div class="info">
Summary: Return the number of parameters associated with a declaration.<br>
</div>
<pre><span id="VALget_decl_parameter_kind"><span class="keyword">val</span> get_decl_parameter_kind</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int -> <a href="Z3.html#TYPEparameter_kind">parameter_kind</a></code></pre><div class="info">
Summary: Return the parameter type associated with a declaration.<br>
</div>
<pre><span id="VALget_decl_int_parameter"><span class="keyword">val</span> get_decl_int_parameter</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int -> int</code></pre><div class="info">
Summary: Return the integer value associated with an integer parameter.
<p>
<ul>
<li><b>Precondition</b>: get_decl_parameter_kind c d idx == PARAMETER_INT</li>
</ul>
<br>
</div>
<pre><span id="VALget_decl_double_parameter"><span class="keyword">val</span> get_decl_double_parameter</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int -> float</code></pre><div class="info">
Summary: Return the double value associated with an double parameter.
<p>
<ul>
<li><b>Precondition</b>: get_decl_parameter_kind c d idx == PARAMETER_DOUBLE</li>
</ul>
<br>
</div>
<pre><span id="VALget_decl_symbol_parameter"><span class="keyword">val</span> get_decl_symbol_parameter</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int -> <a href="Z3.html#TYPEsymbol">symbol</a></code></pre><div class="info">
Summary: Return the double value associated with an double parameter.
<p>
<ul>
<li><b>Precondition</b>: get_decl_parameter_kind c d idx == PARAMETER_SYMBOL</li>
</ul>
<br>
</div>
<pre><span id="VALget_decl_sort_parameter"><span class="keyword">val</span> get_decl_sort_parameter</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Return the sort value associated with a sort parameter.
<p>
<ul>
<li><b>Precondition</b>: get_decl_parameter_kind c d idx == PARAMETER_SORT</li>
</ul>
<br>
</div>
<pre><span id="VALget_decl_ast_parameter"><span class="keyword">val</span> get_decl_ast_parameter</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return the expresson value associated with an expression parameter.
<p>
<ul>
<li><b>Precondition</b>: get_decl_parameter_kind c d idx == PARAMETER_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_decl_func_decl_parameter"><span class="keyword">val</span> get_decl_func_decl_parameter</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: Return the expresson value associated with an expression parameter.
<p>
<ul>
<li><b>Precondition</b>: get_decl_parameter_kind c d idx == PARAMETER_FUNC_DECL</li>
</ul>
<br>
</div>
<pre><span id="VALget_decl_rational_parameter"><span class="keyword">val</span> get_decl_rational_parameter</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int -> string</code></pre><div class="info">
Summary: Return the rational value, as a string, associated with a rational parameter.
<p>
<ul>
<li><b>Precondition</b>: get_decl_parameter_kind c d idx == PARAMETER_RATIONAL</li>
</ul>
<br>
</div>
<br>
<span id="3_Applications"><h3><div align=left>Applications</div></h3></span><br>
<pre><span id="VALapp_to_ast"><span class="keyword">val</span> app_to_ast</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEapp">app</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Convert a <code class="code">app</code> into <code class="code">ast</code>. <ul>
<li><b>Remarks</b>: <code class="code">app_to_ast c a</code> can be replaced by <code class="code">(a :&gt; ast)</code>.</li>
</ul>
<br>
</div>
<pre><span id="VALget_app_decl"><span class="keyword">val</span> get_app_decl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEapp">app</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: Return the declaration of a constant or function application.<br>
</div>
<pre><span id="VALget_app_num_args"><span class="keyword">val</span> get_app_num_args</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEapp">app</a> -> int</code></pre><div class="info">
Summary: [ <code class="code"> get_app_num_args c a </code> ]
       Return the number of argument of an application. If <code class="code">t</code>
       is an constant, then the number of arguments is 0.<br>
</div>
<pre><span id="VALget_app_arg"><span class="keyword">val</span> get_app_arg</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEapp">app</a> -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> get_app_arg c a i </code> ]
       Return the i-th argument of the given application.
<p>
<ul>
<li><b>Precondition</b>: i &lt; get_num_args c a</li>
</ul>
<br>
</div>
<pre><span id="VALget_app_args"><span class="keyword">val</span> get_app_args</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEapp">app</a> -> <a href="Z3.html#TYPEast">ast</a> array</code></pre><div class="info">
Summary: [ <code class="code"> get_app_args c a </code> ] is the array of arguments of an application. If <code class="code">t</code> is a constant, then the array is empty.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_app_num_args"><code class="code">get_app_num_args</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_app_arg"><code class="code">get_app_arg</code></a></li>
</ul>
<br>
</div>
<br>
<span id="3_Terms"><h3><div align=left>Terms</div></h3></span><br>
<br><code><span id="TYPEbinder_type"><span class="keyword">type</span> <code class="type"></code>binder_type</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Forall</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Exists</span></code></td>

</tr></table>

<div class="info">
Summary: [ <code class="code"> binder_type </code> ] is a universal or existential quantifier.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#TYPEterm_refined"><code class="code">term_refined</code></a></li>
</ul>
<br>
</div>

<br><code><span id="TYPEterm_refined"><span class="keyword">type</span> <code class="type"></code>term_refined</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Term_numeral</span> <span class="keyword">of</span> <code class="type"><a href="Z3.html#TYPEnumeral_refined">numeral_refined</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Term_app</span> <span class="keyword">of</span> <code class="type"><a href="Z3.html#TYPEdecl_kind">decl_kind</a> * <a href="Z3.html#TYPEfunc_decl">func_decl</a> * <a href="Z3.html#TYPEast">ast</a> array</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Term_quantifier</span> <span class="keyword">of</span> <code class="type"><a href="Z3.html#TYPEbinder_type">binder_type</a> * int * <a href="Z3.html#TYPEast">ast</a> array array * (<a href="Z3.html#TYPEsymbol">symbol</a> * <a href="Z3.html#TYPEsort">sort</a>) array<br>        * <a href="Z3.html#TYPEast">ast</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Term_var</span> <span class="keyword">of</span> <code class="type">int * <a href="Z3.html#TYPEsort">sort</a></code></code></td>

</tr></table>

<div class="info">
Summary: [ <code class="code"> term_refined </code> ] is the refinement of a <a href="Z3.html#TYPEast"><code class="code">ast</code></a> .
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALterm_refine"><code class="code">term_refine</code></a></li>
</ul>
<br>
</div>

<br>
Summary: [ <code class="code"> mk_term c tr </code> ] constructs the term described by <code class="code">tr</code>.
<p>
<ul>
<li><b>Precondition</b>: <code class="code">tr</code> is not of form</li>
<li><b>See also</b>: <a href="Z3.html#VALterm_refine"><code class="code">term_refine</code></a></li>
</ul>
<br>
<pre><span id="VALterm_refine"><span class="keyword">val</span> term_refine</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEterm_refined">term_refined</a></code></pre><div class="info">
Summary: [ <code class="code"> term_refine c a </code> ] is the refined view of <code class="code">a</code>.<br>
</div>
<pre><span id="VALis_eq_ast"><span class="keyword">val</span> is_eq_ast</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool</code></pre><div class="info">
Summary: compare terms.<ul>
<li><b>Remarks</b>: <code class="code">Pervasives.( = )</code> or <code class="code">Pervasives.compare</code> can also be used.</li>
</ul>
<br>
</div>
<pre><span id="VALget_ast_id"><span class="keyword">val</span> get_ast_id</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int</code></pre><div class="info">
Summary: Return a unique identifier for <code class="code">t</code>.<ul>
<li><b>Remarks</b>: Implicitly used by <code class="code">Pervasives.compare</code> for values of type <code class="code">ast</code>, <code class="code">app</code>, <code class="code">sort</code>, <code class="code">func_decl</code>, and <code class="code">pattern</code>.</li>
</ul>
<br>
</div>
<pre><span id="VALget_ast_hash"><span class="keyword">val</span> get_ast_hash</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int</code></pre><div class="info">
Summary: Return a hash code for the given AST.<ul>
<li><b>Remarks</b>: Implicitly used by <code class="code">Hashtbl.hash</code> for values of type <code class="code">ast</code>, <code class="code">app</code>, <code class="code">sort</code>, <code class="code">func_decl</code>, and <code class="code">pattern</code>.</li>
</ul>
<br>
</div>
<pre><span id="VALget_sort"><span class="keyword">val</span> get_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Return the sort of an AST node.
<p>

       The AST node must be a constant, application, numeral, bound variable, or quantifier.<br>
</div>
<pre><span id="VALis_well_sorted"><span class="keyword">val</span> is_well_sorted</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool</code></pre><div class="info">
Summary: Return true if the given expression <code class="code">t</code> is well sorted.<br>
</div>
<pre><span id="VALget_bool_value"><span class="keyword">val</span> get_bool_value</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPElbool">lbool</a></code></pre><div class="info">
Summary: Return L_TRUE if <code class="code">a</code> is true, L_FALSE if it is false, and L_UNDEF otherwise.<br>
</div>
<pre><span id="VALget_ast_kind"><span class="keyword">val</span> get_ast_kind</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast_kind">ast_kind</a></code></pre><div class="info">
Summary: Return the kind of the given AST.<br>
</div>
<pre><span id="VALis_app"><span class="keyword">val</span> is_app</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool</code></pre><pre><span id="VALis_numeral_ast"><span class="keyword">val</span> is_numeral_ast</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool</code></pre><pre><span id="VALis_algebraic_number"><span class="keyword">val</span> is_algebraic_number</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool</code></pre><div class="info">
Summary: Return true if the give AST is a real algebraic number.<br>
</div>
<pre><span id="VALto_app"><span class="keyword">val</span> to_app</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEapp">app</a></code></pre><div class="info">
Summary: Convert an <code class="code">ast</code> into an <code class="code">APP_AST</code>. 
<p>
<ul>
<li><b>Precondition</b>: <pre> get_ast_kind c a == [APP_AST] </pre></li>
</ul>
<br>
</div>
<pre><span id="VALto_func_decl"><span class="keyword">val</span> to_func_decl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: Convert an AST into a FUNC_DECL_AST. This is just type casting.
<p>
<ul>
<li><b>Precondition</b>: <pre> get_ast_kind c a == FUNC_DECL_AST </pre></li>
</ul>
<br>
</div>
<br>
<span id="4_Numerals"><h4><div align=left>Numerals</div></h4></span><br>
<pre><span id="VALnumeral_refine"><span class="keyword">val</span> numeral_refine</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEnumeral_refined">numeral_refined</a></code></pre><div class="info">
Summary: [ <code class="code"> numeral_refine c a </code> ] is the refined view of <code class="code">a</code>.
<p>
<ul>
<li><b>Precondition</b>: <code class="code">get_ast_kind c a = NUMERAL_AST</code></li>
</ul>
<br>
</div>
<br>
<span id="5_LowlevelAPI"><h5><div align=left>Low-level API</div></h5></span><br>
<pre><span id="VALget_numeral_string"><span class="keyword">val</span> get_numeral_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> string</code></pre><div class="info">
Summary: Return numeral value, as a string of a numeric constant term
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind c a == NUMERAL_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_numeral_decimal_string"><span class="keyword">val</span> get_numeral_decimal_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int -> string</code></pre><div class="info">
Summary: Return numeral as a string in decimal notation.
       The result has at most <code class="code">precision</code> decimal places.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind c a == NUMERAL_AST || is_algebraic_number c a</li>
</ul>
<br>
</div>
<pre><span id="VALget_numerator"><span class="keyword">val</span> get_numerator</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return the numerator (as a numeral AST) of a numeral AST of sort Real.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind c a == NUMERAL_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_denominator"><span class="keyword">val</span> get_denominator</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return the denominator (as a numeral AST) of a numeral AST of sort Real.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind c a == NUMERAL_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_numeral_small"><span class="keyword">val</span> get_numeral_small</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool * int64 * int64</code></pre><div class="info">
Summary: Return numeral value, as a pair of 64 bit numbers if the representation fits.<br>
</div>
<pre><span id="VALget_numeral_int"><span class="keyword">val</span> get_numeral_int</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool * int</code></pre><div class="info">
Summary: [ <code class="code"> get_numeral_int c v </code> ]
       Similar to <a href="Z3.html#VALget_numeral_string"><code class="code">get_numeral_string</code></a>, but only succeeds if
       the value can fit in a machine int. Return TRUE if the call succeeded.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind c v == NUMERAL_AST</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_numeral_string"><code class="code">get_numeral_string</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_numeral_int64"><span class="keyword">val</span> get_numeral_int64</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool * int64</code></pre><div class="info">
Summary: [ <code class="code"> get_numeral_int64 c v </code> ]
       Similar to <a href="Z3.html#VALget_numeral_string"><code class="code">get_numeral_string</code></a>, but only succeeds if
       the value can fit in a machine long long int. Return TRUE if the call succeeded.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind c v == NUMERAL_AST</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_numeral_string"><code class="code">get_numeral_string</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_numeral_rational_int64"><span class="keyword">val</span> get_numeral_rational_int64</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool * int64 * int64</code></pre><div class="info">
Summary: [ <code class="code"> get_numeral_rational_int64 c x y</code> ]
       Similar to <a href="Z3.html#VALget_numeral_string"><code class="code">get_numeral_string</code></a>, but only succeeds if
       the value can fit as a rational number as machine long long int. Return TRUE if the call succeeded.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind c v == NUMERAL_AST</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_numeral_string"><code class="code">get_numeral_string</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_algebraic_number_lower"><span class="keyword">val</span> get_algebraic_number_lower</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return a lower bound for the given real algebraic number. 
       The interval isolating the number is smaller than 1/10^precision.
       The result is a numeral AST of sort Real.
<p>
<ul>
<li><b>Precondition</b>: is_algebraic_number c a</li>
</ul>
<br>
</div>
<pre><span id="VALget_algebraic_number_upper"><span class="keyword">val</span> get_algebraic_number_upper</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return a upper bound for the given real algebraic number. 
       The interval isolating the number is smaller than 1/10^precision.
       The result is a numeral AST of sort Real.
<p>
<ul>
<li><b>Precondition</b>: is_algebraic_number c a</li>
</ul>
<br>
</div>
<br>
<span id="4_Patterns"><h4><div align=left>Patterns</div></h4></span><br>
<pre><span id="VALpattern_to_ast"><span class="keyword">val</span> pattern_to_ast</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEpattern">pattern</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Convert a pattern into ast. <ul>
<li><b>Remarks</b>: <code class="code">pattern_to_ast c p</code>  can be replaced by <code class="code">(p :&gt; ast)</code>.</li>
</ul>
<br>
</div>
<pre><span id="VALget_pattern_terms"><span class="keyword">val</span> get_pattern_terms</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEpattern">pattern</a> -> <a href="Z3.html#TYPEast">ast</a> array</code></pre><div class="info">
Summary: [ <code class="code"> get_pattern_terms c p </code> ] is the ast's in pattern.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_pattern_num_terms"><code class="code">get_pattern_num_terms</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALget_pattern"><code class="code">get_pattern</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_pattern_num_terms"><span class="keyword">val</span> get_pattern_num_terms</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEpattern">pattern</a> -> int</code></pre><div class="info">
Summary: Return number of terms in pattern.<br>
</div>
<pre><span id="VALget_pattern"><span class="keyword">val</span> get_pattern</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEpattern">pattern</a> -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return i'th ast in pattern.<br>
</div>
<br>
<span id="4_Quantifiers"><h4><div align=left>Quantifiers</div></h4></span><br>
<pre><span id="VALget_index_value"><span class="keyword">val</span> get_index_value</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int</code></pre><div class="info">
Summary: Return index of de-Brujin bound variable.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind a == VAR_AST</li>
</ul>
<br>
</div>
<pre><span id="VALis_quantifier_forall"><span class="keyword">val</span> is_quantifier_forall</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool</code></pre><div class="info">
Summary: Determine if quantifier is universal.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind a == QUANTIFIER_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_quantifier_weight"><span class="keyword">val</span> get_quantifier_weight</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int</code></pre><div class="info">
Summary: Obtain weight of quantifier.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind a == QUANTIFIER_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_quantifier_num_patterns"><span class="keyword">val</span> get_quantifier_num_patterns</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int</code></pre><div class="info">
Summary: Return number of patterns used in quantifier.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind a == QUANTIFIER_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_quantifier_pattern_ast"><span class="keyword">val</span> get_quantifier_pattern_ast</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int -> <a href="Z3.html#TYPEpattern">pattern</a></code></pre><div class="info">
Summary: Return i'th pattern.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind a == QUANTIFIER_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_quantifier_num_no_patterns"><span class="keyword">val</span> get_quantifier_num_no_patterns</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int</code></pre><div class="info">
Summary: Return number of no_patterns used in quantifier.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind a == QUANTIFIER_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_quantifier_no_pattern_ast"><span class="keyword">val</span> get_quantifier_no_pattern_ast</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return i'th no_pattern.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind a == QUANTIFIER_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_quantifier_bound_name"><span class="keyword">val</span> get_quantifier_bound_name</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int -> <a href="Z3.html#TYPEsymbol">symbol</a></code></pre><div class="info">
Summary: Return symbol of the i'th bound variable.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind a == QUANTIFIER_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_quantifier_bound_sort"><span class="keyword">val</span> get_quantifier_bound_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Return sort of the i'th bound variable.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind a == QUANTIFIER_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_quantifier_body"><span class="keyword">val</span> get_quantifier_body</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return body of quantifier.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind a == QUANTIFIER_AST</li>
</ul>
<br>
</div>
<pre><span id="VALget_quantifier_num_bound"><span class="keyword">val</span> get_quantifier_num_bound</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> int</code></pre><div class="info">
Summary: Return number of bound variables of quantifier.
<p>
<ul>
<li><b>Precondition</b>: get_ast_kind a == QUANTIFIER_AST</li>
</ul>
<br>
</div>
<br>
<span id="3_Simplification"><h3><div align=left>Simplification</div></h3></span><br>
<pre><span id="VALsimplify"><span class="keyword">val</span> simplify</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Interface to simplifier.
<p>

        Provides an interface to the AST simplifier used by Z3.<br>
</div>
<pre><span id="VALsimplify_ex"><span class="keyword">val</span> simplify_ex</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEparams">params</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Interface to simplifier.
<p>

        Provides an interface to the AST simplifier used by Z3.
        This procedure is similar to <a href="Z3.html#VALsimplify"><code class="code">simplify</code></a>, but the behavior of the simplifier 
        can be configured using the given parameter set.<br>
</div>
<pre><span id="VALsimplify_get_help"><span class="keyword">val</span> simplify_get_help</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string</code></pre><div class="info">
Summary: Return a string describing all available parameters.<br>
</div>
<br>
<span id="2_Modifiers"><h2><div align=left>Modifiers</div></h2></span><br>
<pre><span id="VALupdate_term"><span class="keyword">val</span> update_term</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Update the arguments of term <code class="code">a</code> using the arguments <code class="code">args</code>.
       The number of arguments <code class="code">num_args</code> should coincide 
       with the number of arguments to <code class="code">a</code>.
       If <code class="code">a</code> is a quantifier, then num_args has to be 1.<br>
</div>
<pre><span id="VALsubstitute"><span class="keyword">val</span> substitute</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Substitute every occurrence of <em>from<code class="code">i</code> </em> in <code class="code">a</code> with <em>to<code class="code">i</code> </em>, for <code class="code">i</code> smaller than <code class="code">num_exprs</code>.
       The result is the new AST. The arrays <code class="code">from</code> and <code class="code">to</code> must have size <code class="code">num_exprs</code>.
       For every <code class="code">i</code> smaller than <code class="code">num_exprs</code>, we must have that sort of <em>from<code class="code">i</code> </em> must be equal to sort of <em>to<code class="code">i</code> </em>.<br>
</div>
<pre><span id="VALsubstitute_vars"><span class="keyword">val</span> substitute_vars</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Substitute the free variables in <code class="code">a</code> with the expressions in <code class="code">to</code>.
       For every <code class="code">i</code> smaller than <code class="code">num_exprs</code>, the variable with de-Bruijn index <code class="code">i</code> is replaced with term <em>to<code class="code">i</code> </em>.<br>
</div>
<pre><span id="VALtranslate"><span class="keyword">val</span> translate</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Translate/Copy the AST <code class="code">a</code> from context <code class="code">source</code> to context <code class="code">target</code>.
       AST <code class="code">a</code> must have been created using context <code class="code">source</code>.<ul>
<li><b>Precondition</b>: source != target</li>
</ul>
<br>
</div>
<br>
<span id="2_Models"><h2><div align=left>Models</div></h2></span><br>
<br><code><span id="TYPEmodel_refined"><span class="keyword">type</span> <code class="type"></code>model_refined</span> = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>sorts&nbsp;: <code class="type">(<a href="Z3.html#TYPEsort">sort</a>, <a href="Z3.html#TYPEast_vector">ast_vector</a>) Hashtbl.t</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>consts&nbsp;: <code class="type">(<a href="Z3.html#TYPEfunc_decl">func_decl</a>, <a href="Z3.html#TYPEast">ast</a>) Hashtbl.t</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>arrays&nbsp;: <code class="type">(<a href="Z3.html#TYPEfunc_decl">func_decl</a>, (<a href="Z3.html#TYPEast">ast</a>, <a href="Z3.html#TYPEast">ast</a>) Hashtbl.t * <a href="Z3.html#TYPEast">ast</a>) Hashtbl.t</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>funcs&nbsp;: <code class="type">(<a href="Z3.html#TYPEfunc_decl">func_decl</a>, (<a href="Z3.html#TYPEast">ast</a> array, <a href="Z3.html#TYPEast">ast</a>) Hashtbl.t * <a href="Z3.html#TYPEast">ast</a>) Hashtbl.t</code>;</code></td>

</tr></table>
}

<div class="info">
A model assigns uninterpreted sorts to finite universes of distinct values, constants to values,
   and arrays and functions to finite maps from argument values to result values plus a default
   value for all other arguments.<br>
</div>

<pre><span id="VALmodel_refine"><span class="keyword">val</span> model_refine</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> <a href="Z3.html#TYPEmodel_refined">model_refined</a></code></pre><div class="info">
Summary: <code class="code">model_refine c m</code> is the refined model of <code class="code">m</code>.<br>
</div>
<pre><span id="VALmodel_eval"><span class="keyword">val</span> model_eval</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool -> <a href="Z3.html#TYPEast">ast</a> option</code></pre><div class="info">
Summary: [ <code class="code"> model_eval c m t </code> ]
       Evaluate the AST node <code class="code">t</code> in the given model. 
<p>

        Return <code class="code">None</code> if the term was not successfully evaluated. 
<p>

       If <code class="code">model_completion</code> is TRUE, then Z3 will assign an interpretation for any constant or function that does
       not have an interpretation in <code class="code">m</code>. These constants and functions were essentially don't cares.
<p>

       The evaluation may fail for the following reasons:
<p>
<ul>
<li><code class="code">t</code> contains a quantifier.</li>
</ul>
<ul>
<li>the model <code class="code">m</code> is partial, that is, it doesn't have a complete interpretation for uninterpreted functions. 
       That is, the option <em>MODEL_PARTIAL=true </em> was used.</li>
</ul>
<ul>
<li><code class="code">t</code> is type incorrect.</li>
</ul>
<br>
</div>
<br>
<span id="4_LowlevelAPI"><h4><div align=left>Low-level API</div></h4></span><br>
<pre><span id="VALmodel_get_const_interp"><span class="keyword">val</span> model_get_const_interp</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> <a href="Z3.html#TYPEast">ast</a> option</code></pre><div class="info">
Summary: Return the interpretation (i.e., assignment) of constant <code class="code">a</code> in the model <code class="code">m</code>.
       Return  <code class="code">None</code>,  
       if the model does not assign an interpretation for <code class="code">a</code>. 
       That should be interpreted as: the value of <code class="code">a</code> does not matter.
<p>
<ul>
<li><b>Precondition</b>: get_arity c a == 0</li>
</ul>
<br>
</div>
<pre><span id="VALmodel_get_func_interp"><span class="keyword">val</span> model_get_func_interp</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> <a href="Z3.html#TYPEfunc_interp">func_interp</a> option</code></pre><div class="info">
Summary: Return the interpretation of the function <code class="code">f</code> in the model <code class="code">m</code>.
       Return  <code class="code">None</code>,  
       if the model does not assign an interpretation for <code class="code">f</code>. 
       That should be interpreted as: the <code class="code">f</code> does not matter.
<p>
<ul>
<li><b>Precondition</b>: get_arity c f &gt; 0</li>
</ul>
<br>
</div>
<pre><span id="VALmodel_get_num_consts"><span class="keyword">val</span> model_get_num_consts</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> int</code></pre><div class="info">
Summary: Return the number of constants assigned by the given model.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmodel_get_const_decl"><code class="code">model_get_const_decl</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmodel_get_const_decl"><span class="keyword">val</span> model_get_const_decl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> int -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: [ <code class="code"> model_get_const_decl c m i </code> ]
       Return the i-th constant in the given model. 
<p>
<ul>
<li><b>Precondition</b>: i &lt; model_get_num_consts c m</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmodel_eval"><code class="code">model_eval</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmodel_get_num_funcs"><span class="keyword">val</span> model_get_num_funcs</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> int</code></pre><div class="info">
Summary: Return the number of function interpretations in the given model.
<p>

       A function interpretation is represented as a finite map and an 'else' value.
       Each entry in the finite map represents the value of a function given a set of arguments.<br>
</div>
<pre><span id="VALmodel_get_func_decl"><span class="keyword">val</span> model_get_func_decl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> int -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: [ <code class="code"> model_get_func_decl c m i </code> ]
       Return the declaration of the i-th function in the given model.
<p>
<ul>
<li><b>Precondition</b>: i &lt; model_get_num_funcs c m</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmodel_get_num_funcs"><code class="code">model_get_num_funcs</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmodel_get_num_sorts"><span class="keyword">val</span> model_get_num_sorts</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> int</code></pre><div class="info">
Summary: Return the number of uninterpreted sorts that <code class="code">m</code> assigs an interpretation to.
<p>

       Z3 also provides an intepretation for uninterpreted sorts used in a formua.
       The interpretation for a sort <code class="code">s</code> is a finite set of distinct values. We say this finite set is
       the "universe" of <code class="code">s</code>.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmodel_get_sort"><code class="code">model_get_sort</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmodel_get_sort_universe"><code class="code">model_get_sort_universe</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmodel_get_sort"><span class="keyword">val</span> model_get_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> int -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: Return a uninterpreted sort that <code class="code">m</code> assigns an interpretation.
<p>
<ul>
<li><b>Precondition</b>: i &lt; model_get_num_sorts c m</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmodel_get_num_sorts"><code class="code">model_get_num_sorts</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmodel_get_sort_universe"><code class="code">model_get_sort_universe</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALmodel_get_sort_universe"><span class="keyword">val</span> model_get_sort_universe</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> <a href="Z3.html#TYPEsort">sort</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a></code></pre><div class="info">
Summary: Return the finite set of distinct values that represent the interpretation for sort <code class="code">s</code>.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALmodel_get_num_sorts"><code class="code">model_get_num_sorts</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALmodel_get_sort"><code class="code">model_get_sort</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALis_as_array"><span class="keyword">val</span> is_as_array</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool</code></pre><div class="info">
Summary: The <em>(_ as-array f) </em> AST node is a construct for assigning interpretations for arrays in Z3.
       It is the array such that forall indices <code class="code">i</code> we have that <em>(select (_ as-array f) i) </em> is equal to <em>(f i) </em>.
       This procedure returns TRUE if the <code class="code">a</code> is an <code class="code">as-array</code> AST node.
<p>

       Z3 current solvers have minimal support for <code class="code">as_array</code> nodes. 
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALget_as_array_func_decl"><code class="code">get_as_array_func_decl</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALget_as_array_func_decl"><span class="keyword">val</span> get_as_array_func_decl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: Return the function declaration <code class="code">f</code> associated with a <em>(_ as_array f) </em> node.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALis_as_array"><code class="code">is_as_array</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALfunc_interp_get_num_entries"><span class="keyword">val</span> func_interp_get_num_entries</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_interp">func_interp</a> -> int</code></pre><div class="info">
Summary: Return the number of entries in the given function interpretation.
<p>

       A function interpretation is represented as a finite map and an 'else' value.
       Each entry in the finite map represents the value of a function given a set of arguments.
       This procedure return the number of element in the finite map of <code class="code">f</code>.<br>
</div>
<pre><span id="VALfunc_interp_get_entry"><span class="keyword">val</span> func_interp_get_entry</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_interp">func_interp</a> -> int -> <a href="Z3.html#TYPEfunc_entry">func_entry</a></code></pre><div class="info">
Summary: Return a "point" of the given function intepretation. It represents the
       value of <code class="code">f</code> in a particular point.
<p>
<ul>
<li><b>Precondition</b>: i &lt; func_interp_get_num_entries c f</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALfunc_interp_get_num_entries"><code class="code">func_interp_get_num_entries</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALfunc_interp_get_else"><span class="keyword">val</span> func_interp_get_else</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_interp">func_interp</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return the 'else' value of the given function interpretation.
<p>

       A function interpretation is represented as a finite map and an 'else' value.
       This procedure returns the 'else' value.<br>
</div>
<pre><span id="VALfunc_interp_get_arity"><span class="keyword">val</span> func_interp_get_arity</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_interp">func_interp</a> -> int</code></pre><div class="info">
Summary: Return the arity (number of arguments) of the given function interpretation.<br>
</div>
<pre><span id="VALfunc_entry_get_value"><span class="keyword">val</span> func_entry_get_value</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_entry">func_entry</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return the value of this point. 
<p>

       A func_entry object represents an element in the finite map used to encode
       a function interpretation.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALfunc_interp_get_entry"><code class="code">func_interp_get_entry</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALfunc_entry_get_num_args"><span class="keyword">val</span> func_entry_get_num_args</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_entry">func_entry</a> -> int</code></pre><div class="info">
Summary: Return the number of arguments in a func_entry object.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALfunc_interp_get_entry"><code class="code">func_interp_get_entry</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALfunc_entry_get_arg"><span class="keyword">val</span> func_entry_get_arg</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_entry">func_entry</a> -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return an argument of a func_entry object.
<p>
<ul>
<li><b>Precondition</b>: i &lt; func_entry_get_num_args c e</li>
</ul>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALfunc_interp_get_entry"><code class="code">func_interp_get_entry</code></a></li>
</ul>
<br>
</div>
<br>
<span id="2_Interactionlogging"><h2><div align=left>Interaction logging.</div></h2></span><br>
<pre><span id="VALopen_log"><span class="keyword">val</span> open_log</span> : <code class="type">string -> bool</code></pre><div class="info">
Summary: Log interaction to a file.<br>
</div>
<pre><span id="VALappend_log"><span class="keyword">val</span> append_log</span> : <code class="type">string -> unit</code></pre><div class="info">
Summary: Append user-defined string to interaction log.
<p>

       The interaction log is opened using open_log.
       It contains the formulas that are checked using Z3.
       You can use this command to append comments, for instance.<br>
</div>
<pre><span id="VALclose_log"><span class="keyword">val</span> close_log</span> : <code class="type">unit -> unit</code></pre><div class="info">
Summary: Close interaction log.<br>
</div>
<pre><span id="VALtoggle_warning_messages"><span class="keyword">val</span> toggle_warning_messages</span> : <code class="type">bool -> unit</code></pre><div class="info">
Summary: Enable/disable printing warning messages to the console.
<p>

       Warnings are printed after passing <code class="code">true</code>, warning messages are
       suppressed after calling this method with <code class="code">false</code>.<br>
</div>
<br>
<span id="2_Stringconversion"><h2><div align=left>String conversion</div></h2></span><br>
<pre><span id="VALset_ast_print_mode"><span class="keyword">val</span> set_ast_print_mode</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_print_mode">ast_print_mode</a> -> unit</code></pre><div class="info">
Summary: Select mode for the format used for pretty-printing AST nodes.
<p>

       The default mode for pretty printing AST nodes is to produce
       SMT-LIB style output where common subexpressions are printed 
       at each occurrence. The mode is called PRINT_SMTLIB_FULL.
       To print shared common subexpressions only once, 
       use the PRINT_LOW_LEVEL mode.
       To print in way that conforms to SMT-LIB standards and uses let
       expressions to share common sub-expressions use PRINT_SMTLIB_COMPLIANT.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALast_to_string"><code class="code">ast_to_string</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALpattern_to_string"><code class="code">pattern_to_string</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALfunc_decl_to_string"><code class="code">func_decl_to_string</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALast_to_string"><span class="keyword">val</span> ast_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast">ast</a> -> string</code></pre><div class="info">
Summary: Convert the given AST node into a string.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALpattern_to_string"><code class="code">pattern_to_string</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALsort_to_string"><code class="code">sort_to_string</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALpattern_to_string"><span class="keyword">val</span> pattern_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEpattern">pattern</a> -> string</code></pre><pre><span id="VALsort_to_string"><span class="keyword">val</span> sort_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsort">sort</a> -> string</code></pre><pre><span id="VALfunc_decl_to_string"><span class="keyword">val</span> func_decl_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> string</code></pre><pre><span id="VALmodel_to_string"><span class="keyword">val</span> model_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEmodel">model</a> -> string</code></pre><div class="info">
Summary: Convert the given model into a string.<br>
</div>
<pre><span id="VALbenchmark_to_smtlib_string"><span class="keyword">val</span> benchmark_to_smtlib_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       string -> string -> string -> string -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEast">ast</a> -> string</code></pre><div class="info">
Summary: Convert the given benchmark into SMT-LIB formatted string.<br>
</div>
<br>
<span id="2_Parserinterface"><h2><div align=left>Parser interface</div></h2></span><br>
<pre><span id="VALparse_smtlib2_string"><span class="keyword">val</span> parse_smtlib2_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       string -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -><br>       <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsymbol">symbol</a> array -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> parse_smtlib2_string c str </code> ]
       Parse the given string using the SMT-LIB2 parser. 
<p>

       It returns a formula comprising of the conjunction of assertions in the scope
       (up to push/pop) at the end of the string.<br>
</div>
<pre><span id="VALparse_smtlib2_file"><span class="keyword">val</span> parse_smtlib2_file</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       string -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -><br>       <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsymbol">symbol</a> array -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Similar to <a href="Z3.html#VALparse_smtlib2_string"><code class="code">parse_smtlib2_string</code></a>, but reads the benchmark from a file.<br>
</div>
<pre><span id="VALparse_smtlib_string_x"><span class="keyword">val</span> parse_smtlib_string_x</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       string -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -><br>       <a href="Z3.html#TYPEsort">sort</a> array -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -><br>       <a href="Z3.html#TYPEfunc_decl">func_decl</a> array -> <a href="Z3.html#TYPEast">ast</a> array * <a href="Z3.html#TYPEast">ast</a> array * <a href="Z3.html#TYPEfunc_decl">func_decl</a> array</code></pre><div class="info">
Summary: [ <code class="code"> parse_smtlib_string_x c str sort_names sorts decl_names decls </code> ]
<p>

  Parse the given string using the SMT-LIB parser. 
<p>

  The symbol table of the parser can be initialized using the given sorts and declarations. 
  The symbols in the arrays <code class="code">sort_names</code> and <code class="code">decl_names</code> don't need to match the names
  of the sorts and declarations in the arrays <code class="code">sorts</code> and <code class="code">decls</code>. This is an useful feature
  since we can use arbitrary names to reference sorts and declarations defined using the API.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALparse_smtlib_file_x"><code class="code">parse_smtlib_file_x</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALparse_smtlib_file_x"><span class="keyword">val</span> parse_smtlib_file_x</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       string -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -><br>       <a href="Z3.html#TYPEsort">sort</a> array -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -><br>       <a href="Z3.html#TYPEfunc_decl">func_decl</a> array -> <a href="Z3.html#TYPEast">ast</a> array * <a href="Z3.html#TYPEast">ast</a> array * <a href="Z3.html#TYPEfunc_decl">func_decl</a> array</code></pre><div class="info">
Summary: Similar to <a href="Z3.html#VALparse_smtlib_string_x"><code class="code">parse_smtlib_string_x</code></a>, but reads the benchmark from a file.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALparse_smtlib_string_x"><code class="code">parse_smtlib_string_x</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALparse_smtlib_string_formula"><span class="keyword">val</span> parse_smtlib_string_formula</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       string -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -><br>       <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsymbol">symbol</a> array -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> parse_smtlib_string_formula c ... </code> ] calls <code class="code">(parse_smtlib_string c ...)</code> and returns the single formula produced.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALparse_smtlib_file_formula"><code class="code">parse_smtlib_file_formula</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALparse_smtlib_string_x"><code class="code">parse_smtlib_string_x</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALparse_smtlib_file_formula"><span class="keyword">val</span> parse_smtlib_file_formula</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       string -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -><br>       <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsymbol">symbol</a> array -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> array -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> parse_smtlib_file_formula c ... </code> ] calls <code class="code">(parse_smtlib_file c ...)</code> and returns the single formula produced.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALparse_smtlib_string_formula"><code class="code">parse_smtlib_string_formula</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALparse_smtlib_file_x"><code class="code">parse_smtlib_file_x</code></a></li>
</ul>
<br>
</div>
<br>
<span id="4_LowlevelAPI"><h4><div align=left>Low-level API</div></h4></span><br>
<pre><span id="VALparse_smtlib_string"><span class="keyword">val</span> parse_smtlib_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       string -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -><br>       <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsymbol">symbol</a> array -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> array -> unit</code></pre><div class="info">
Summary: [ <code class="code"> parse_smtlib_string c str sort_names sorts decl_names decls </code> ]
       Parse the given string using the SMT-LIB parser. 
<p>

       The symbol table of the parser can be initialized using the given sorts and declarations. 
       The symbols in the arrays <code class="code">sort_names</code> and <code class="code">decl_names</code> don't need to match the names
       of the sorts and declarations in the arrays <code class="code">sorts</code> and <code class="code">decls</code>. This is an useful feature
       since we can use arbitrary names to reference sorts and declarations defined using the C API.
<p>

       The formulas, assumptions and declarations defined in <code class="code">str</code> can be extracted using the functions:
       <a href="Z3.html#VALget_smtlib_num_formulas"><code class="code">get_smtlib_num_formulas</code></a>, <a href="Z3.html#VALget_smtlib_formula"><code class="code">get_smtlib_formula</code></a>, <a href="Z3.html#VALget_smtlib_num_assumptions"><code class="code">get_smtlib_num_assumptions</code></a>, <a href="Z3.html#VALget_smtlib_assumption"><code class="code">get_smtlib_assumption</code></a>, 
       <a href="Z3.html#VALget_smtlib_num_decls"><code class="code">get_smtlib_num_decls</code></a>, and <a href="Z3.html#VALget_smtlib_decl"><code class="code">get_smtlib_decl</code></a>.<br>
</div>
<pre><span id="VALparse_smtlib_file"><span class="keyword">val</span> parse_smtlib_file</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       string -><br>       <a href="Z3.html#TYPEsymbol">symbol</a> array -><br>       <a href="Z3.html#TYPEsort">sort</a> array -> <a href="Z3.html#TYPEsymbol">symbol</a> array -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> array -> unit</code></pre><div class="info">
Summary: Similar to <a href="Z3.html#VALparse_smtlib_string"><code class="code">parse_smtlib_string</code></a>, but reads the benchmark from a file.<br>
</div>
<pre><span id="VALget_smtlib_num_formulas"><span class="keyword">val</span> get_smtlib_num_formulas</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int</code></pre><div class="info">
Summary: Return the number of SMTLIB formulas parsed by the last call to <a href="Z3.html#VALparse_smtlib_string"><code class="code">parse_smtlib_string</code></a> or <a href="Z3.html#VALparse_smtlib_file"><code class="code">parse_smtlib_file</code></a>.<br>
</div>
<pre><span id="VALget_smtlib_formula"><span class="keyword">val</span> get_smtlib_formula</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> get_smtlib_formula c i </code> ]
       Return the i-th formula parsed by the last call to <a href="Z3.html#VALparse_smtlib_string"><code class="code">parse_smtlib_string</code></a> or <a href="Z3.html#VALparse_smtlib_file"><code class="code">parse_smtlib_file</code></a>.
<p>
<ul>
<li><b>Precondition</b>: i &lt; get_smtlib_num_formulas c</li>
</ul>
<br>
</div>
<pre><span id="VALget_smtlib_num_assumptions"><span class="keyword">val</span> get_smtlib_num_assumptions</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int</code></pre><div class="info">
Summary: Return the number of SMTLIB assumptions parsed by <a href="Z3.html#VALparse_smtlib_string"><code class="code">parse_smtlib_string</code></a> or <a href="Z3.html#VALparse_smtlib_file"><code class="code">parse_smtlib_file</code></a>.<br>
</div>
<pre><span id="VALget_smtlib_assumption"><span class="keyword">val</span> get_smtlib_assumption</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> get_smtlib_assumption c i </code> ]
       Return the i-th assumption parsed by the last call to <a href="Z3.html#VALparse_smtlib_string"><code class="code">parse_smtlib_string</code></a> or <a href="Z3.html#VALparse_smtlib_file"><code class="code">parse_smtlib_file</code></a>.
<p>
<ul>
<li><b>Precondition</b>: i &lt; get_smtlib_num_assumptions c</li>
</ul>
<br>
</div>
<pre><span id="VALget_smtlib_num_decls"><span class="keyword">val</span> get_smtlib_num_decls</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int</code></pre><div class="info">
Summary: Return the number of declarations parsed by <a href="Z3.html#VALparse_smtlib_string"><code class="code">parse_smtlib_string</code></a> or <a href="Z3.html#VALparse_smtlib_file"><code class="code">parse_smtlib_file</code></a>.<br>
</div>
<pre><span id="VALget_smtlib_decl"><span class="keyword">val</span> get_smtlib_decl</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEfunc_decl">func_decl</a></code></pre><div class="info">
Summary: [ <code class="code"> get_smtlib_decl c i </code> ]
       Return the i-th declaration parsed by the last call to <a href="Z3.html#VALparse_smtlib_string"><code class="code">parse_smtlib_string</code></a> or <a href="Z3.html#VALparse_smtlib_file"><code class="code">parse_smtlib_file</code></a>.
<p>
<ul>
<li><b>Precondition</b>: i &lt; get_smtlib_num_decls c</li>
</ul>
<br>
</div>
<pre><span id="VALget_smtlib_num_sorts"><span class="keyword">val</span> get_smtlib_num_sorts</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int</code></pre><div class="info">
Summary: Return the number of sorts parsed by <a href="Z3.html#VALparse_smtlib_string"><code class="code">parse_smtlib_string</code></a> or <a href="Z3.html#VALparse_smtlib_file"><code class="code">parse_smtlib_file</code></a>.<br>
</div>
<pre><span id="VALget_smtlib_sort"><span class="keyword">val</span> get_smtlib_sort</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> <a href="Z3.html#TYPEsort">sort</a></code></pre><div class="info">
Summary: [ <code class="code"> get_smtlib_sort c i </code> ]
       Return the i-th sort parsed by the last call to <a href="Z3.html#VALparse_smtlib_string"><code class="code">parse_smtlib_string</code></a> or <a href="Z3.html#VALparse_smtlib_file"><code class="code">parse_smtlib_file</code></a>.
<p>
<ul>
<li><b>Precondition</b>: i &lt; get_smtlib_num_sorts c</li>
</ul>
<br>
</div>
<pre><span id="VALparse_z3_string"><span class="keyword">val</span> parse_z3_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: [ <code class="code"> parse_z3_string c str </code> ]
       Parse the given string using the Z3 native parser.
<p>

       Return the conjunction of asserts made in the input.<br>
</div>
<pre><span id="VALparse_z3_file"><span class="keyword">val</span> parse_z3_file</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Similar to <a href="Z3.html#VALparse_z3_string"><code class="code">parse_z3_string</code></a>, but reads the benchmark from a file.<br>
</div>
<br>
<span id="2_ErrorHandling"><h2><div align=left>Error Handling</div></h2></span><br>
<pre><span id="VALset_error"><span class="keyword">val</span> set_error</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEerror_code">error_code</a> -> unit</code></pre><div class="info">
Summary: Set an error.<br>
</div>
<pre><span id="VALget_error_msg"><span class="keyword">val</span> get_error_msg</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEerror_code">error_code</a> -> string</code></pre><div class="info">
Summary: Return a string describing the given error code.<br>
</div>
<br>
<span id="2_Miscellaneous"><h2><div align=left>Miscellaneous</div></h2></span><br>
<pre><span id="VALget_version"><span class="keyword">val</span> get_version</span> : <code class="type">unit -> int * int * int * int</code></pre><div class="info">
Summary: Return Z3 version number information.<br>
</div>
<br>
<span id="2_Fixedpointfacilities"><h2><div align=left>Fixedpoint facilities</div></h2></span><br>
<pre><span id="VALmk_fixedpoint"><span class="keyword">val</span> mk_fixedpoint</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a></code></pre><div class="info">
Summary: Create a new fixedpoint context.<br>
</div>
<pre><span id="VALfixedpoint_add_rule"><span class="keyword">val</span> fixedpoint_add_rule</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> unit</code></pre><div class="info">
Summary: Add a universal Horn clause as a named rule.
       The <code class="code">horn_rule</code> should be of the form:
<p>

       <pre>
           horn_rule ::= (forall (bound-vars) horn_rule)
                      |  (=&gt; atoms horn_rule)
                      |  atom
       </pre><br>
</div>
<pre><span id="VALfixedpoint_add_fact"><span class="keyword">val</span> fixedpoint_add_fact</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> int array -> unit</code></pre><div class="info">
Summary: Add a Database fact.<br>
</div>
<pre><span id="VALfixedpoint_assert"><span class="keyword">val</span> fixedpoint_assert</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> <a href="Z3.html#TYPEast">ast</a> -> unit</code></pre><div class="info">
Summary: Assert a constraint to the fixedpoint context.
<p>

       The constraints are used as background axioms when the fixedpoint engine uses the PDR mode.
       They are ignored for standard Datalog mode.<br>
</div>
<pre><span id="VALfixedpoint_query"><span class="keyword">val</span> fixedpoint_query</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPElbool">lbool</a></code></pre><div class="info">
Summary: Pose a query against the asserted rules.
<p>

        <pre>
           query ::= (exists (bound-vars) query)
                 |  literals 
        </pre>
<p>

        query returns <ul>
<li>L_FALSE if the query is unsatisfiable.</li>
<li>L_TRUE if the query is satisfiable. Obtain the answer by calling <a href="Z3.html#VALfixedpoint_get_answer"><code class="code">fixedpoint_get_answer</code></a>.</li>
<li>L_UNDEF if the query was interrupted, timed out or otherwise failed.</li>
</ul>
<br>
</div>
<pre><span id="VALfixedpoint_query_relations"><span class="keyword">val</span> fixedpoint_query_relations</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> array -> <a href="Z3.html#TYPElbool">lbool</a></code></pre><div class="info">
Summary: Pose multiple queries against the asserted rules.
<p>

        The queries are encoded as relations (function declarations).
<p>

        query returns <ul>
<li>L_FALSE if the query is unsatisfiable.</li>
<li>L_TRUE if the query is satisfiable. Obtain the answer by calling <a href="Z3.html#VALfixedpoint_get_answer"><code class="code">fixedpoint_get_answer</code></a>.</li>
<li>L_UNDEF if the query was interrupted, timed out or otherwise failed.</li>
</ul>
<br>
</div>
<pre><span id="VALfixedpoint_get_answer"><span class="keyword">val</span> fixedpoint_get_answer</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Retrieve a formula that encodes satisfying answers to the query.
<p>

       When used in Datalog mode, the returned answer is a disjunction of conjuncts.
       Each conjunct encodes values of the bound variables of the query that are satisfied.
       In PDR mode, the returned answer is a single conjunction.
<p>

       The previous call to fixedpoint_query must have returned L_TRUE.<br>
</div>
<pre><span id="VALfixedpoint_get_reason_unknown"><span class="keyword">val</span> fixedpoint_get_reason_unknown</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> string</code></pre><div class="info">
Summary: Retrieve a string that describes the last status returned by <a href="Z3.html#VALfixedpoint_query"><code class="code">fixedpoint_query</code></a>.
<p>

       Use this method when <a href="Z3.html#VALfixedpoint_query"><code class="code">fixedpoint_query</code></a> returns L_UNDEF.<br>
</div>
<pre><span id="VALfixedpoint_get_statistics"><span class="keyword">val</span> fixedpoint_get_statistics</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> <a href="Z3.html#TYPEstats">stats</a></code></pre><div class="info">
Summary: Retrieve statistics information from the last call to <a href="Z3.html#VALfixedpoint_query"><code class="code">fixedpoint_query</code></a>.<br>
</div>
<pre><span id="VALfixedpoint_register_relation"><span class="keyword">val</span> fixedpoint_register_relation</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> unit</code></pre><div class="info">
Summary: Register relation as Fixedpoint defined.
       Fixedpoint defined relations have least-fixedpoint semantics.
       For example, the relation is empty if it does not occur
       in a head or a fact.<br>
</div>
<pre><span id="VALfixedpoint_set_predicate_representation"><span class="keyword">val</span> fixedpoint_set_predicate_representation</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> array -> unit</code></pre><div class="info">
Summary: Configure the predicate representation.
<p>

       It sets the predicate to use a set of domains given by the list of symbols.
       The domains given by the list of symbols must belong to a set
       of built-in domains.<br>
</div>
<pre><span id="VALfixedpoint_simplify_rules"><span class="keyword">val</span> fixedpoint_simplify_rules</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -><br>       <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPEfunc_decl">func_decl</a> array -> <a href="Z3.html#TYPEast_vector">ast_vector</a></code></pre><div class="info">
Summary: Simplify rules into a set of new rules that are returned.
        The simplification routines apply inlining, quantifier elimination, and other
        algebraic simplifications.<br>
</div>
<pre><span id="VALfixedpoint_to_string"><span class="keyword">val</span> fixedpoint_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEfixedpoint">fixedpoint</a> -> <a href="Z3.html#TYPEast">ast</a> array -> string</code></pre><div class="info">
Summary: Print the current rules and background axioms as a string.<br>
</div>
<br>
<span id="2_ASTvectors"><h2><div align=left>AST vectors</div></h2></span><br>
<pre><span id="VALmk_ast_vector"><span class="keyword">val</span> mk_ast_vector</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a></code></pre><div class="info">
Summary: Return an empty AST vector.<br>
</div>
<pre><span id="VALast_vector_size"><span class="keyword">val</span> ast_vector_size</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a> -> int</code></pre><div class="info">
Summary: Return the size of the given AST vector.<br>
</div>
<pre><span id="VALast_vector_get"><span class="keyword">val</span> ast_vector_get</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a> -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return the AST at position <code class="code">i</code> in the AST vector <code class="code">v</code>.
<p>
<ul>
<li><b>Precondition</b>: i &lt; ast_vector_size c v</li>
</ul>
<br>
</div>
<pre><span id="VALast_vector_set"><span class="keyword">val</span> ast_vector_set</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a> -> int -> <a href="Z3.html#TYPEast">ast</a> -> unit</code></pre><div class="info">
Summary: Update position <code class="code">i</code> of the AST vector <code class="code">v</code> with the AST <code class="code">a</code>. 
<p>
<ul>
<li><b>Precondition</b>: i &lt; ast_vector_size c v</li>
</ul>
<br>
</div>
<pre><span id="VALast_vector_resize"><span class="keyword">val</span> ast_vector_resize</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a> -> int -> unit</code></pre><div class="info">
Summary: Resize the AST vector <code class="code">v</code>.<br>
</div>
<pre><span id="VALast_vector_push"><span class="keyword">val</span> ast_vector_push</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a> -> <a href="Z3.html#TYPEast">ast</a> -> unit</code></pre><div class="info">
Summary: Add the AST <code class="code">a</code> in the end of the AST vector <code class="code">v</code>. The size of <code class="code">v</code> is increased by one.<br>
</div>
<pre><span id="VALast_vector_translate"><span class="keyword">val</span> ast_vector_translate</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a> -> <a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a></code></pre><div class="info">
Summary: Translate the AST vector <code class="code">v</code> from context <code class="code">s</code> into an AST vector in context <code class="code">t</code>.<br>
</div>
<pre><span id="VALast_vector_to_string"><span class="keyword">val</span> ast_vector_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a> -> string</code></pre><div class="info">
Summary: Convert AST vector into a string.<br>
</div>
<br>
<span id="2_ASTmaps"><h2><div align=left>AST maps</div></h2></span><br>
<pre><span id="VALmk_ast_map"><span class="keyword">val</span> mk_ast_map</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_map">ast_map</a></code></pre><div class="info">
Summary: Return an empty mapping from AST to AST<br>
</div>
<pre><span id="VALast_map_contains"><span class="keyword">val</span> ast_map_contains</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_map">ast_map</a> -> <a href="Z3.html#TYPEast">ast</a> -> bool</code></pre><div class="info">
Summary: Return true if the map <code class="code">m</code> contains the AST key <code class="code">k</code>.<br>
</div>
<pre><span id="VALast_map_find"><span class="keyword">val</span> ast_map_find</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_map">ast_map</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return the value associated with the key <code class="code">k</code>.
<p>

       The procedure invokes the error handler if <code class="code">k</code> is not in the map.<br>
</div>
<pre><span id="VALast_map_insert"><span class="keyword">val</span> ast_map_insert</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_map">ast_map</a> -> <a href="Z3.html#TYPEast">ast</a> -> <a href="Z3.html#TYPEast">ast</a> -> unit</code></pre><div class="info">
Summary: Store/Replace a new key, value pair in the given map.<br>
</div>
<pre><span id="VALast_map_erase"><span class="keyword">val</span> ast_map_erase</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_map">ast_map</a> -> <a href="Z3.html#TYPEast">ast</a> -> unit</code></pre><div class="info">
Summary: Erase a key from the map.<br>
</div>
<pre><span id="VALast_map_reset"><span class="keyword">val</span> ast_map_reset</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_map">ast_map</a> -> unit</code></pre><div class="info">
Summary: Remove all keys from the given map.<br>
</div>
<pre><span id="VALast_map_size"><span class="keyword">val</span> ast_map_size</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_map">ast_map</a> -> int</code></pre><div class="info">
Summary: Return the size of the given map.<br>
</div>
<pre><span id="VALast_map_keys"><span class="keyword">val</span> ast_map_keys</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_map">ast_map</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a></code></pre><div class="info">
Summary: Return the keys stored in the given map.<br>
</div>
<pre><span id="VALast_map_to_string"><span class="keyword">val</span> ast_map_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEast_map">ast_map</a> -> string</code></pre><div class="info">
Summary: Convert the given map into a string.<br>
</div>
<br>
<span id="2_Goals"><h2><div align=left>Goals</div></h2></span><br>
<pre><span id="VALmk_goal"><span class="keyword">val</span> mk_goal</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> bool -> bool -> bool -> <a href="Z3.html#TYPEgoal">goal</a></code></pre><div class="info">
Summary: Create a goal (aka problem). A goal is essentially a set
       of formulas, that can be solved and/or transformed using
       tactics and solvers.
<p>

       If models == true, then model generation is enabled for the new goal.
<p>

       If unsat_cores == true, then unsat core generation is enabled for the new goal.
<p>

       If proofs == true, then proof generation is enabled for the new goal. Remark, the 
       Z3 context c must have been created with proof generation support.<br>
</div>
<pre><span id="VALgoal_precision"><span class="keyword">val</span> goal_precision</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> <a href="Z3.html#TYPEgoal_prec">goal_prec</a></code></pre><div class="info">
Summary: Return the "precision" of the given goal. Goals can be transformed using over and under approximations.
       A under approximation is applied when the objective is to find a model for a given goal.
       An over approximation is applied when the objective is to find a proof for a given goal.<br>
</div>
<pre><span id="VALgoal_assert"><span class="keyword">val</span> goal_assert</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> <a href="Z3.html#TYPEast">ast</a> -> unit</code></pre><div class="info">
Summary: Add a new formula <code class="code">a</code> to the given goal.<br>
</div>
<pre><span id="VALgoal_inconsistent"><span class="keyword">val</span> goal_inconsistent</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> bool</code></pre><div class="info">
Summary: Return true if the given goal contains the formula <code class="code">false</code>.<br>
</div>
<pre><span id="VALgoal_depth"><span class="keyword">val</span> goal_depth</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> int</code></pre><div class="info">
Summary: Return the depth of the given goal. It tracks how many transformations were applied to it.<br>
</div>
<pre><span id="VALgoal_reset"><span class="keyword">val</span> goal_reset</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> unit</code></pre><div class="info">
Summary: Erase all formulas from the given goal.<br>
</div>
<pre><span id="VALgoal_size"><span class="keyword">val</span> goal_size</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> int</code></pre><div class="info">
Summary: Return the number of formulas in the given goal.<br>
</div>
<pre><span id="VALgoal_formula"><span class="keyword">val</span> goal_formula</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> int -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Return a formula from the given goal.
<p>
<ul>
<li><b>Precondition</b>: idx &lt; goal_size c g</li>
</ul>
<br>
</div>
<pre><span id="VALgoal_num_exprs"><span class="keyword">val</span> goal_num_exprs</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> int</code></pre><div class="info">
Summary: Return the number of formulas, subformulas and terms in the given goal.<br>
</div>
<pre><span id="VALgoal_is_decided_sat"><span class="keyword">val</span> goal_is_decided_sat</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> bool</code></pre><div class="info">
Summary: Return true if the goal is empty, and it is precise or the product of a under approximation.<br>
</div>
<pre><span id="VALgoal_is_decided_unsat"><span class="keyword">val</span> goal_is_decided_unsat</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> bool</code></pre><div class="info">
Summary: Return true if the goal contains false, and it is precise or the product of an over approximation.<br>
</div>
<pre><span id="VALgoal_translate"><span class="keyword">val</span> goal_translate</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> <a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a></code></pre><div class="info">
Summary: Copy a goal <code class="code">g</code> from the context <code class="code">source</code> to a the context <code class="code">target</code>.<br>
</div>
<pre><span id="VALgoal_to_string"><span class="keyword">val</span> goal_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> string</code></pre><div class="info">
Summary: Convert a goal into a string.<br>
</div>
<br>
<span id="2_TacticsandProbes"><h2><div align=left>Tactics and Probes</div></h2></span><br>
<pre><span id="VALmk_tactic"><span class="keyword">val</span> mk_tactic</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic associated with the given name.
       The complete list of tactics may be obtained using the procedures <a href="Z3.html#VALget_num_tactics"><code class="code">get_num_tactics</code></a> and <a href="Z3.html#VALget_tactic_name"><code class="code">get_tactic_name</code></a>.
       It may also be obtained using the command <em>(help-tactics) </em> in the SMT 2.0 front-end.
<p>

       Tactics are the basic building block for creating custom solvers for specific problem domains.<br>
</div>
<pre><span id="VALmk_probe"><span class="keyword">val</span> mk_probe</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> <a href="Z3.html#TYPEprobe">probe</a></code></pre><div class="info">
Summary: Return a probe associated with the given name.
       The complete list of probes may be obtained using the procedures <a href="Z3.html#VALget_num_probes"><code class="code">get_num_probes</code></a> and <a href="Z3.html#VALget_probe_name"><code class="code">get_probe_name</code></a>.
       It may also be obtained using the command <em>(help-tactics) </em> in the SMT 2.0 front-end.
<p>

       Probes are used to inspect a goal (aka problem) and collect information that may be used to decide
       which solver and/or preprocessing step will be used.<br>
</div>
<pre><span id="VALtactic_and_then"><span class="keyword">val</span> tactic_and_then</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that applies <code class="code">t1</code> to a given goal and <code class="code">t2</code>
       to every subgoal produced by t1.<br>
</div>
<pre><span id="VALtactic_or_else"><span class="keyword">val</span> tactic_or_else</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that first applies <code class="code">t1</code> to a given goal,
       if it fails then returns the result of <code class="code">t2</code> applied to the given goal.<br>
</div>
<pre><span id="VALtactic_par_or"><span class="keyword">val</span> tactic_par_or</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a> array -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that applies the given tactics in parallel.<br>
</div>
<pre><span id="VALtactic_par_and_then"><span class="keyword">val</span> tactic_par_and_then</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that applies <code class="code">t1</code> to a given goal and then <code class="code">t2</code>
       to every subgoal produced by t1. The subgoals are processed in parallel.<br>
</div>
<pre><span id="VALtactic_try_for"><span class="keyword">val</span> tactic_try_for</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> int -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that applies <code class="code">t</code> to a given goal for <code class="code">ms</code> milliseconds.
       If <code class="code">t</code> does not terminate in <code class="code">ms</code> milliseconds, then it fails.<br>
</div>
<pre><span id="VALtactic_when"><span class="keyword">val</span> tactic_when</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that applies <code class="code">t</code> to a given goal is the probe <code class="code">p</code> evaluates to true.
       If <code class="code">p</code> evaluates to false, then the new tactic behaves like the skip tactic.<br>
</div>
<pre><span id="VALtactic_cond"><span class="keyword">val</span> tactic_cond</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that applies <code class="code">t1</code> to a given goal if the probe <code class="code">p</code> evaluates to true,
       and <code class="code">t2</code> if <code class="code">p</code> evaluates to false.<br>
</div>
<pre><span id="VALtactic_repeat"><span class="keyword">val</span> tactic_repeat</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> int -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that keeps applying <code class="code">t</code> until the goal is not modified anymore or the maximum
       number of iterations <code class="code">max</code> is reached.<br>
</div>
<pre><span id="VALtactic_skip"><span class="keyword">val</span> tactic_skip</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that just return the given goal.<br>
</div>
<pre><span id="VALtactic_fail"><span class="keyword">val</span> tactic_fail</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that always fails.<br>
</div>
<pre><span id="VALtactic_fail_if"><span class="keyword">val</span> tactic_fail_if</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that fails if the probe <code class="code">p</code> evaluates to false.<br>
</div>
<pre><span id="VALtactic_fail_if_not_decided"><span class="keyword">val</span> tactic_fail_if_not_decided</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that fails if the goal is not trivially satisfiable (i.e., empty) or
       trivially unsatisfiable (i.e., contains false).<br>
</div>
<pre><span id="VALtactic_using_params"><span class="keyword">val</span> tactic_using_params</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEparams">params</a> -> <a href="Z3.html#TYPEtactic">tactic</a></code></pre><div class="info">
Summary: Return a tactic that applies <code class="code">t</code> using the given set of parameters.<br>
</div>
<pre><span id="VALprobe_const"><span class="keyword">val</span> probe_const</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> float -> <a href="Z3.html#TYPEprobe">probe</a></code></pre><div class="info">
Summary: Return a probe that always evaluates to val.<br>
</div>
<pre><span id="VALprobe_lt"><span class="keyword">val</span> probe_lt</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a></code></pre><div class="info">
Summary: Return a probe that evaluates to "true" when the value returned by <code class="code">p1</code> is less than the value returned by <code class="code">p2</code>.
<p>
<ul>
<li><b>Remarks</b>: For probes, "true" is any value different from 0.0.</li>
</ul>
<br>
</div>
<pre><span id="VALprobe_gt"><span class="keyword">val</span> probe_gt</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a></code></pre><div class="info">
Summary: Return a probe that evaluates to "true" when the value returned by <code class="code">p1</code> is greater than the value returned by <code class="code">p2</code>.
<p>
<ul>
<li><b>Remarks</b>: For probes, "true" is any value different from 0.0.</li>
</ul>
<br>
</div>
<pre><span id="VALprobe_le"><span class="keyword">val</span> probe_le</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a></code></pre><div class="info">
Summary: Return a probe that evaluates to "true" when the value returned by <code class="code">p1</code> is less than or equal to the value returned by <code class="code">p2</code>.
<p>
<ul>
<li><b>Remarks</b>: For probes, "true" is any value different from 0.0.</li>
</ul>
<br>
</div>
<pre><span id="VALprobe_ge"><span class="keyword">val</span> probe_ge</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a></code></pre><div class="info">
Summary: Return a probe that evaluates to "true" when the value returned by <code class="code">p1</code> is greater than or equal to the value returned by <code class="code">p2</code>.
<p>
<ul>
<li><b>Remarks</b>: For probes, "true" is any value different from 0.0.</li>
</ul>
<br>
</div>
<pre><span id="VALprobe_eq"><span class="keyword">val</span> probe_eq</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a></code></pre><div class="info">
Summary: Return a probe that evaluates to "true" when the value returned by <code class="code">p1</code> is equal to the value returned by <code class="code">p2</code>.
<p>
<ul>
<li><b>Remarks</b>: For probes, "true" is any value different from 0.0.</li>
</ul>
<br>
</div>
<pre><span id="VALprobe_and"><span class="keyword">val</span> probe_and</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a></code></pre><div class="info">
Summary: Return a probe that evaluates to "true" when <code class="code">p1</code> and <code class="code">p2</code> evaluates to true.
<p>
<ul>
<li><b>Remarks</b>: For probes, "true" is any value different from 0.0.</li>
</ul>
<br>
</div>
<pre><span id="VALprobe_or"><span class="keyword">val</span> probe_or</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a></code></pre><div class="info">
Summary: Return a probe that evaluates to "true" when <code class="code">p1</code> or <code class="code">p2</code> evaluates to true.
<p>
<ul>
<li><b>Remarks</b>: For probes, "true" is any value different from 0.0.</li>
</ul>
<br>
</div>
<pre><span id="VALprobe_not"><span class="keyword">val</span> probe_not</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEprobe">probe</a></code></pre><div class="info">
Summary: Return a probe that evaluates to "true" when <code class="code">p</code> does not evaluate to true.
<p>
<ul>
<li><b>Remarks</b>: For probes, "true" is any value different from 0.0.</li>
</ul>
<br>
</div>
<pre><span id="VALget_num_tactics"><span class="keyword">val</span> get_num_tactics</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int</code></pre><div class="info">
Summary: Return the number of builtin tactics available in Z3.<br>
</div>
<pre><span id="VALget_tactic_name"><span class="keyword">val</span> get_tactic_name</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> string</code></pre><div class="info">
Summary: Return the name of the idx tactic.
<p>
<ul>
<li><b>Precondition</b>: i &lt; get_num_tactics c</li>
</ul>
<br>
</div>
<pre><span id="VALget_num_probes"><span class="keyword">val</span> get_num_probes</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int</code></pre><div class="info">
Summary: Return the number of builtin probes available in Z3.<br>
</div>
<pre><span id="VALget_probe_name"><span class="keyword">val</span> get_probe_name</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> int -> string</code></pre><div class="info">
Summary: Return the name of the i probe.
<p>
<ul>
<li><b>Precondition</b>: i &lt; get_num_probes c</li>
</ul>
<br>
</div>
<pre><span id="VALtactic_get_help"><span class="keyword">val</span> tactic_get_help</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> string</code></pre><div class="info">
Summary: Return a string containing a description of parameters accepted by the given tactic.<br>
</div>
<pre><span id="VALtactic_get_descr"><span class="keyword">val</span> tactic_get_descr</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> string</code></pre><div class="info">
Summary: Return a string containing a description of the tactic with the given name.<br>
</div>
<pre><span id="VALprobe_get_descr"><span class="keyword">val</span> probe_get_descr</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> string -> string</code></pre><div class="info">
Summary: Return a string containing a description of the probe with the given name.<br>
</div>
<pre><span id="VALprobe_apply"><span class="keyword">val</span> probe_apply</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEprobe">probe</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> float</code></pre><div class="info">
Summary: Execute the probe over the goal. The probe always produce a double value.
       "Boolean" probes return 0.0 for false, and a value different from 0.0 for true.<br>
</div>
<pre><span id="VALtactic_apply"><span class="keyword">val</span> tactic_apply</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> <a href="Z3.html#TYPEapply_result">apply_result</a></code></pre><div class="info">
Summary: Apply tactic <code class="code">t</code> to the goal <code class="code">g</code>.<br>
</div>
<pre><span id="VALtactic_apply_ex"><span class="keyword">val</span> tactic_apply_ex</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEgoal">goal</a> -> <a href="Z3.html#TYPEparams">params</a> -> <a href="Z3.html#TYPEapply_result">apply_result</a></code></pre><div class="info">
Summary: Apply tactic <code class="code">t</code> to the goal <code class="code">g</code> using the parameter set <code class="code">p</code>.<br>
</div>
<pre><span id="VALapply_result_to_string"><span class="keyword">val</span> apply_result_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEapply_result">apply_result</a> -> string</code></pre><div class="info">
Summary: Convert the <code class="code">apply_result</code> object returned by <a href="Z3.html#VALtactic_apply"><code class="code">tactic_apply</code></a> into a string.<br>
</div>
<pre><span id="VALapply_result_get_num_subgoals"><span class="keyword">val</span> apply_result_get_num_subgoals</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEapply_result">apply_result</a> -> int</code></pre><div class="info">
Summary: Return the number of subgoals in the <code class="code">apply_result</code> object returned by <a href="Z3.html#VALtactic_apply"><code class="code">tactic_apply</code></a>.<br>
</div>
<pre><span id="VALapply_result_get_subgoal"><span class="keyword">val</span> apply_result_get_subgoal</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEapply_result">apply_result</a> -> int -> <a href="Z3.html#TYPEgoal">goal</a></code></pre><div class="info">
Summary: Return one of the subgoals in the <code class="code">apply_result</code> object returned by <a href="Z3.html#VALtactic_apply"><code class="code">tactic_apply</code></a>.
<p>
<ul>
<li><b>Precondition</b>: i &lt; apply_result_get_num_subgoals c r</li>
</ul>
<br>
</div>
<pre><span id="VALapply_result_convert_model"><span class="keyword">val</span> apply_result_convert_model</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEapply_result">apply_result</a> -> int -> <a href="Z3.html#TYPEmodel">model</a> -> <a href="Z3.html#TYPEmodel">model</a></code></pre><div class="info">
Summary: Convert a model for the subgoal <code class="code">apply_result_get_subgoal(c</code>, r, i) into a model for the original goal <code class="code">g</code>.
       Where <code class="code">g</code> is the goal used to create <code class="code">r</code> using <code class="code">tactic_apply(c</code>, t, g).<br>
</div>
<br>
<span id="2_Solvers"><h2><div align=left>Solvers</div></h2></span><br>
<pre><span id="VALmk_solver"><span class="keyword">val</span> mk_solver</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a></code></pre><div class="info">
Summary: Create a new (incremental) solver. This solver also uses a
       set of builtin tactics for handling the first check-sat command, and
       check-sat commands that take more than a given number of milliseconds to be solved.<br>
</div>
<pre><span id="VALmk_simple_solver"><span class="keyword">val</span> mk_simple_solver</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a></code></pre><div class="info">
Summary: Create a new (incremental) solver.<br>
</div>
<pre><span id="VALmk_solver_for_logic"><span class="keyword">val</span> mk_solver_for_logic</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsymbol">symbol</a> -> <a href="Z3.html#TYPEsolver">solver</a></code></pre><div class="info">
Summary: Create a new solver customized for the given logic.
       It behaves like <a href="Z3.html#VALmk_solver"><code class="code">mk_solver</code></a> if the logic is unknown or unsupported.<br>
</div>
<pre><span id="VALmk_solver_from_tactic"><span class="keyword">val</span> mk_solver_from_tactic</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEtactic">tactic</a> -> <a href="Z3.html#TYPEsolver">solver</a></code></pre><div class="info">
Summary: Create a new solver that is implemented using the given tactic.
       The solver supports the commands <a href="Z3.html#VALsolver_push"><code class="code">solver_push</code></a> and <a href="Z3.html#VALsolver_pop"><code class="code">solver_pop</code></a>, but it
       will always solve each <a href="Z3.html#VALsolver_check"><code class="code">solver_check</code></a> from scratch.<br>
</div>
<pre><span id="VALsolver_get_help"><span class="keyword">val</span> solver_get_help</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> string</code></pre><div class="info">
Summary: Return a string describing all solver available parameters.<br>
</div>
<pre><span id="VALsolver_set_params"><span class="keyword">val</span> solver_set_params</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> <a href="Z3.html#TYPEparams">params</a> -> unit</code></pre><div class="info">
Summary: Set the given solver using the given parameters.<br>
</div>
<pre><span id="VALsolver_push"><span class="keyword">val</span> solver_push</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> unit</code></pre><div class="info">
Summary: Create a backtracking point.
<p>

       The solver contains a stack of assertions. 
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALsolver_pop"><code class="code">solver_pop</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALsolver_pop"><span class="keyword">val</span> solver_pop</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> int -> unit</code></pre><div class="info">
Summary: Backtrack <code class="code">n</code> backtracking points.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALsolver_push"><code class="code">solver_push</code></a></li>
</ul>
<ul>
<li><b>Precondition</b>: n &lt;= solver_get_num_scopes c s</li>
</ul>
<br>
</div>
<pre><span id="VALsolver_reset"><span class="keyword">val</span> solver_reset</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> unit</code></pre><div class="info">
Summary: Remove all assertions from the solver.<br>
</div>
<pre><span id="VALsolver_get_num_scopes"><span class="keyword">val</span> solver_get_num_scopes</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> int</code></pre><div class="info">
Summary: Return the number of backtracking points.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALsolver_push"><code class="code">solver_push</code></a></li>
<li><b>See also</b>: <a href="Z3.html#VALsolver_pop"><code class="code">solver_pop</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALsolver_assert"><span class="keyword">val</span> solver_assert</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> <a href="Z3.html#TYPEast">ast</a> -> unit</code></pre><div class="info">
Summary: Assert a constraint into the solver.
<p>

       The functions <a href="Z3.html#VALsolver_check"><code class="code">solver_check</code></a> and <a href="Z3.html#VALsolver_check_assumptions"><code class="code">solver_check_assumptions</code></a> should be
       used to check whether the logical context is consistent or not.<br>
</div>
<pre><span id="VALsolver_get_assertions"><span class="keyword">val</span> solver_get_assertions</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a></code></pre><div class="info">
Summary: Return the set of asserted formulas as a goal object.<br>
</div>
<pre><span id="VALsolver_check"><span class="keyword">val</span> solver_check</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> <a href="Z3.html#TYPElbool">lbool</a></code></pre><div class="info">
Summary: Check whether the assertions in a given solver are consistent or not.
<p>

       The function <a href="Z3.html#VALsolver_get_model"><code class="code">solver_get_model</code></a> retrieves a model if the
       assertions are not unsatisfiable (i.e., the result is not \c
       L_FALSE) and model construction is enabled.
<p>

       The function <a href="Z3.html#VALsolver_get_proof"><code class="code">solver_get_proof</code></a> retrieves a proof if proof
       generation was enabled when the context was created, and the 
       assertions are unsatisfiable (i.e., the result is <code class="code">L_FALSE)</code>.<br>
</div>
<pre><span id="VALsolver_check_assumptions"><span class="keyword">val</span> solver_check_assumptions</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> <a href="Z3.html#TYPEast">ast</a> array -> <a href="Z3.html#TYPElbool">lbool</a></code></pre><div class="info">
Summary: Check whether the assertions in the given solver and
       optional assumptions are consistent or not.
<p>

       The function <a href="Z3.html#VALsolver_get_unsat_core"><code class="code">solver_get_unsat_core</code></a> retrieves the subset of the 
       assumptions used in the unsatisfiability proof produced by Z3.
<p>
<ul>
<li><b>See also</b>: <a href="Z3.html#VALsolver_check"><code class="code">solver_check</code></a></li>
</ul>
<br>
</div>
<pre><span id="VALsolver_get_model"><span class="keyword">val</span> solver_get_model</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> <a href="Z3.html#TYPEmodel">model</a></code></pre><div class="info">
Summary: Retrieve the model for the last <a href="Z3.html#VALsolver_check"><code class="code">solver_check</code></a> or <a href="Z3.html#VALsolver_check_assumptions"><code class="code">solver_check_assumptions</code></a>
<p>

       The error handler is invoked if a model is not available because 
       the commands above were not invoked for the given solver, or if the result was <code class="code">L_FALSE</code>.<br>
</div>
<pre><span id="VALsolver_get_proof"><span class="keyword">val</span> solver_get_proof</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> <a href="Z3.html#TYPEast">ast</a></code></pre><div class="info">
Summary: Retrieve the proof for the last <a href="Z3.html#VALsolver_check"><code class="code">solver_check</code></a> or <a href="Z3.html#VALsolver_check_assumptions"><code class="code">solver_check_assumptions</code></a>
<p>

       The error handler is invoked if proof generation is not enabled,
       or if the commands above were not invoked for the given solver,
       or if the result was different from <code class="code">L_FALSE</code>.<br>
</div>
<pre><span id="VALsolver_get_unsat_core"><span class="keyword">val</span> solver_get_unsat_core</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> <a href="Z3.html#TYPEast_vector">ast_vector</a></code></pre><div class="info">
Summary: Retrieve the unsat core for the last <a href="Z3.html#VALsolver_check_assumptions"><code class="code">solver_check_assumptions</code></a>
       The unsat core is a subset of the assumptions <code class="code">a</code>.<br>
</div>
<pre><span id="VALsolver_get_reason_unknown"><span class="keyword">val</span> solver_get_reason_unknown</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> string</code></pre><div class="info">
Summary: Return a brief justification for an "unknown" result (i.e., L_UNDEF) for
       the commands <a href="Z3.html#VALsolver_check"><code class="code">solver_check</code></a> and <a href="Z3.html#VALsolver_check_assumptions"><code class="code">solver_check_assumptions</code></a><br>
</div>
<pre><span id="VALsolver_get_statistics"><span class="keyword">val</span> solver_get_statistics</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> <a href="Z3.html#TYPEstats">stats</a></code></pre><div class="info">
Summary: Return statistics for the given solver.<br>
</div>
<pre><span id="VALsolver_to_string"><span class="keyword">val</span> solver_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEsolver">solver</a> -> string</code></pre><div class="info">
Summary: Convert a solver into a string.<br>
</div>
<br>
<span id="2_Statistics"><h2><div align=left>Statistics</div></h2></span><br>
<br><code><span id="TYPEstat_datum"><span class="keyword">type</span> <code class="type"></code>stat_datum</span> = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Stat_int</span> <span class="keyword">of</span> <code class="type">int</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Stat_float</span> <span class="keyword">of</span> <code class="type">float</code></code></td>

</tr></table>


<pre><span id="TYPEstats_refined"><span class="keyword">type</span> <code class="type"></code>stats_refined</span> = <code class="type">(string, <a href="Z3.html#TYPEstat_datum">stat_datum</a>) Hashtbl.t</code> </pre>

<pre><span id="VALstats_refine"><span class="keyword">val</span> stats_refine</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEstats">stats</a> -> <a href="Z3.html#TYPEstats_refined">stats_refined</a></code></pre><div class="info">
Summary: <code class="code">stats_refine c s</code> is the refined stats of <code class="code">s</code>.<br>
</div>
<pre><span id="VALstats_to_string"><span class="keyword">val</span> stats_to_string</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEstats">stats</a> -> string</code></pre><div class="info">
Summary: Convert a statistics into a string.<br>
</div>
<br>
<span id="4_LowlevelAPI"><h4><div align=left>Low-level API</div></h4></span><br>
<pre><span id="VALstats_size"><span class="keyword">val</span> stats_size</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEstats">stats</a> -> int</code></pre><div class="info">
Summary: Return the number of statistical data in <code class="code">s</code>.<br>
</div>
<pre><span id="VALstats_get_key"><span class="keyword">val</span> stats_get_key</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEstats">stats</a> -> int -> string</code></pre><div class="info">
Summary: Return the key (a string) for a particular statistical data.
<p>
<ul>
<li><b>Precondition</b>: idx &lt; stats_size c s</li>
</ul>
<br>
</div>
<pre><span id="VALstats_is_uint"><span class="keyword">val</span> stats_is_uint</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEstats">stats</a> -> int -> bool</code></pre><div class="info">
Summary: Return TRUE if the given statistical data is a unsigned int integer.
<p>
<ul>
<li><b>Precondition</b>: idx &lt; stats_size c s</li>
</ul>
<br>
</div>
<pre><span id="VALstats_is_double"><span class="keyword">val</span> stats_is_double</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEstats">stats</a> -> int -> bool</code></pre><div class="info">
Summary: Return TRUE if the given statistical data is a double.
<p>
<ul>
<li><b>Precondition</b>: idx &lt; stats_size c s</li>
</ul>
<br>
</div>
<pre><span id="VALstats_get_uint_value"><span class="keyword">val</span> stats_get_uint_value</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEstats">stats</a> -> int -> int</code></pre><div class="info">
Summary: Return the unsigned int value of the given statistical data.
<p>
<ul>
<li><b>Precondition</b>: idx &lt; stats_size c s &amp;&amp; stats_is_uint c s</li>
</ul>
<br>
</div>
<pre><span id="VALstats_get_double_value"><span class="keyword">val</span> stats_get_double_value</span> : <code class="type"><a href="Z3.html#TYPEcontext">context</a> -> <a href="Z3.html#TYPEstats">stats</a> -> int -> float</code></pre><div class="info">
Summary: Return the double value of the given statistical data.
<p>
<ul>
<li><b>Precondition</b>: idx &lt; stats_size c s &amp;&amp; stats_is_double c s</li>
</ul>
<br>
</div>
<br>
<span id="2_LegacyV3API"><h2><div align=left>Legacy V3 API</div></h2></span><br>
<pre><span class="keyword">module</span> <a href="Z3.V3.html">V3</a>: <code class="code">sig</code> <a href="Z3.V3.html">..</a> <code class="code">end</code></pre></body></html>