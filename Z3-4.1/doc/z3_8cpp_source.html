 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">
<table class="centered-small">
  <tr>
    <th><a href="index.html"><span>Home</span></a></th>
    <th> &bull; </th>
    <th><a href="documentation.html"><span>Docs</span></a></th>
    <th> &bull; </th>
    <th><a href="download.html"><span>Download</span></a></th>
    <th> &bull; </th>
    <th><a href="mail.html"><span>Mail</span></a></th>
    <th> &bull; </th>
    <th><a href="faq.html"><span>FAQ</span></a></th>
    <th> &bull; </th>
    <th><a href="awards.html"><span>Awards</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com"><span>MSR</span></a></th>
  </tr>
</table>
<p class="Z3Title"><img align="middle" src="z3.png" alt="Z3" /> An Efficient Theorem Prover</p>
<!-- Generated by Doxygen 1.6.3 -->
<h1>lib/z3.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include&lt;cstdio&gt;</span>
<a name="l00002"></a>00002 <span class="preprocessor">#include&lt;sstream&gt;</span>
<a name="l00003"></a>00003 <span class="preprocessor">#include&quot;simplifier.h&quot;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include&quot;ast_pp.h&quot;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include&quot;ast_ll_pp.h&quot;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include&quot;ast_smt_pp.h&quot;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include&quot;ast_dag_pp.h&quot;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include&quot;bv_decl_plugin.h&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include&quot;arith_decl_plugin.h&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include&quot;array_decl_plugin.h&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include&quot;arith_simplifier_plugin.h&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include&quot;basic_simplifier_plugin.h&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include&quot;datatype_decl_plugin.h&quot;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include&quot;memory_manager.h&quot;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include&quot;z3.h&quot;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include&quot;z3_private.h&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include&quot;version.h&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include&quot;well_sorted.h&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include&quot;smtparser.h&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include&quot;z3_solver.h&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include&quot;simplify_parser.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include&quot;pattern_validation.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include&quot;front_end_params.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include&quot;smt_solver.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include&quot;theory_arith.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include&quot;theory_bv.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include&quot;theory_array.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include&quot;expr_abstract.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include&quot;ref.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include&quot;model.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include&quot;model_v2_pp.h&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include&quot;model_smt2_pp.h&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include&quot;ast_smt_pp.h&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include&quot;user_smt_theory.h&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include&quot;dl_external_relation.h&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include&quot;dl_context.h&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include&quot;datalog_parser.h&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include&quot;dl_decl_plugin.h&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include&quot;dl_instruction.h&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include&quot;dl_compiler.h&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include&quot;dl_rule.h&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include&quot;smt2parser.h&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include&quot;expr_substitution.h&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include&quot;th_rewriter.h&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include&quot;z3_api_log.h&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include&quot;pp.h&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable : 4996)</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 std::ostream * g_z3_log = 0;
<a name="l00052"></a>00052 <span class="keywordtype">bool</span> g_z3_log_enabled   = <span class="keyword">false</span>;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">struct </span>config_params {
<a name="l00055"></a>00055     ini_params       m_ini;
<a name="l00056"></a>00056     front_end_params m_params;
<a name="l00057"></a>00057     config_params() { 
<a name="l00058"></a>00058         register_verbosity_level(m_ini);
<a name="l00059"></a>00059         register_warning(m_ini);
<a name="l00060"></a>00060         m_params.register_params(m_ini); 
<a name="l00061"></a>00061         register_pp_params(m_ini);
<a name="l00062"></a>00062     }
<a name="l00063"></a>00063     config_params(front_end_params <span class="keyword">const</span>&amp; p) : m_params(p) {
<a name="l00064"></a>00064         register_verbosity_level(m_ini);
<a name="l00065"></a>00065         register_warning(m_ini);
<a name="l00066"></a>00066         register_pp_params(m_ini);
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068 };
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="keyword">typedef</span> void (*reduce_app_callback_fptr)(<span class="keywordtype">void</span>*, func_decl*, unsigned, expr*<span class="keyword">const</span>*, expr**);
<a name="l00071"></a>00071 <span class="keyword">typedef</span> void (*reduce_assign_callback_fptr)(<span class="keywordtype">void</span>*, func_decl*, unsigned, expr*<span class="keyword">const</span>*, unsigned, expr*<span class="keyword">const</span>*);
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="keyword">class </span>external_relation_context_impl : <span class="keyword">public</span> datalog::external_relation_context {
<a name="l00074"></a>00074     ast_manager&amp;                m_manager;
<a name="l00075"></a>00075     front_end_params&amp;           m_params;
<a name="l00076"></a>00076     <span class="keywordtype">void</span>*                       m_state;
<a name="l00077"></a>00077     reduce_app_callback_fptr    m_reduce_app;
<a name="l00078"></a>00078     reduce_assign_callback_fptr m_reduce_assign;
<a name="l00079"></a>00079     datalog::dl_decl_plugin*    m_decl_plugin;
<a name="l00080"></a>00080     datalog::dl_decl_util       m_util;
<a name="l00081"></a>00081     datalog::context*           m_context;    
<a name="l00082"></a>00082     Z3_context                  m_z3_context;
<a name="l00083"></a>00083     ast_ref_vector&amp;             m_trail;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="keyword">public</span>:
<a name="l00086"></a>00086     external_relation_context_impl(ast_manager&amp; m, front_end_params&amp; p, Z3_context z3_context, ast_ref_vector&amp; trail) : 
<a name="l00087"></a>00087         m_manager(m),
<a name="l00088"></a>00088         m_params(p),
<a name="l00089"></a>00089         m_state(0), 
<a name="l00090"></a>00090         m_reduce_app(0), 
<a name="l00091"></a>00091         m_reduce_assign(0), 
<a name="l00092"></a>00092         m_decl_plugin(0),
<a name="l00093"></a>00093         m_util(m),
<a name="l00094"></a>00094         m_context(0),
<a name="l00095"></a>00095         m_z3_context(z3_context),
<a name="l00096"></a>00096         m_trail(trail) {}
<a name="l00097"></a>00097    
<a name="l00098"></a>00098     <span class="keyword">virtual</span> ~external_relation_context_impl() {
<a name="l00099"></a>00099         dealloc(m_context);
<a name="l00100"></a>00100     }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     <span class="keywordtype">void</span> init(<span class="keywordtype">void</span>* state, front_end_params&amp; p) {
<a name="l00103"></a>00103         SASSERT(!m_state);
<a name="l00104"></a>00104         m_state = state;
<a name="l00105"></a>00105         symbol name(<span class="stringliteral">&quot;datalog_relation&quot;</span>);
<a name="l00106"></a>00106         <span class="keywordflow">if</span> (m_manager.has_plugin(name)) {
<a name="l00107"></a>00107             m_decl_plugin = <span class="keyword">dynamic_cast&lt;</span>datalog::dl_decl_plugin*<span class="keyword">&gt;</span>
<a name="l00108"></a>00108                 (m_manager.get_plugin(m_manager.get_family_id(name)));
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110         <span class="keywordflow">else</span> {
<a name="l00111"></a>00111             m_decl_plugin = alloc(datalog::dl_decl_plugin);
<a name="l00112"></a>00112             m_manager.register_plugin(symbol(<span class="stringliteral">&quot;datalog_relation&quot;</span>), m_decl_plugin);
<a name="l00113"></a>00113         }
<a name="l00114"></a>00114         
<a name="l00115"></a>00115         <span class="keywordflow">if</span> (!m_context) {
<a name="l00116"></a>00116             m_context = alloc(datalog::context, m_manager, p);   
<a name="l00117"></a>00117         }
<a name="l00118"></a>00118         datalog::relation_manager&amp; r = m_context-&gt;get_rmanager();
<a name="l00119"></a>00119         r.register_plugin(alloc(datalog::external_relation_plugin, *<span class="keyword">this</span>, r));
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123     <span class="keywordtype">void</span>* get_state() {
<a name="l00124"></a>00124         <span class="keywordflow">return</span> m_state;
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127     <span class="keywordtype">void</span> register_relation(func_decl* f) {
<a name="l00128"></a>00128         ensure_context();
<a name="l00129"></a>00129         m_context-&gt;register_predicate(f);
<a name="l00130"></a>00130     }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132     <span class="keyword">virtual</span> family_id get_family_id()<span class="keyword"> const </span>{
<a name="l00133"></a>00133         <span class="keywordflow">return</span> m_util.get_family_id();
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     <span class="keywordtype">void</span> set_reduce_app(reduce_app_callback_fptr f) { m_reduce_app = f; }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     <span class="keywordtype">void</span> set_reduce_assign(reduce_assign_callback_fptr f) { m_reduce_assign = f; }   
<a name="l00139"></a>00139     
<a name="l00140"></a>00140     <span class="keyword">virtual</span> <span class="keywordtype">void</span> reduce(func_decl* f, <span class="keywordtype">unsigned</span> num_args, expr * <span class="keyword">const</span>* args, expr_ref&amp; result) {
<a name="l00141"></a>00141         expr* r = 0;
<a name="l00142"></a>00142         <span class="keywordflow">if</span> (m_reduce_app) {
<a name="l00143"></a>00143             m_reduce_app(m_z3_context, f, num_args, args, &amp;r);
<a name="l00144"></a>00144             result = r;
<a name="l00145"></a>00145             m_trail.push_back(f);
<a name="l00146"></a>00146             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_args; ++i) {
<a name="l00147"></a>00147                 m_trail.push_back(args[i]);
<a name="l00148"></a>00148             }
<a name="l00149"></a>00149             m_trail.push_back(r);
<a name="l00150"></a>00150         }
<a name="l00151"></a>00151         <span class="comment">// allow fallthrough.</span>
<a name="l00152"></a>00152         <span class="keywordflow">if</span> (r == 0) {
<a name="l00153"></a>00153             result = m_manager.mk_app(f, num_args, args);
<a name="l00154"></a>00154         }
<a name="l00155"></a>00155     }
<a name="l00156"></a>00156         
<a name="l00157"></a>00157     <span class="comment">// overwrite terms passed in outs vector with values computed by function.</span>
<a name="l00158"></a>00158     <span class="keyword">virtual</span> <span class="keywordtype">void</span> reduce_assign(func_decl* f, <span class="keywordtype">unsigned</span> num_args, expr * <span class="keyword">const</span>* args, <span class="keywordtype">unsigned</span> num_out, expr* <span class="keyword">const</span>* outs) {
<a name="l00159"></a>00159         <span class="keywordflow">if</span> (m_reduce_assign) {
<a name="l00160"></a>00160             m_trail.push_back(f);
<a name="l00161"></a>00161             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_args; ++i) {
<a name="l00162"></a>00162                 m_trail.push_back(args[i]);
<a name="l00163"></a>00163             }
<a name="l00164"></a>00164             m_reduce_assign(m_z3_context, f, num_args, args, num_out, outs);
<a name="l00165"></a>00165         }
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     datalog::dl_decl_util&amp; get_util() { <span class="keywordflow">return</span> m_util; }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170     <span class="keywordtype">void</span> add_rule(expr* rule, symbol <span class="keyword">const</span>&amp; name) {
<a name="l00171"></a>00171         ast_manager&amp; m = m_manager;
<a name="l00172"></a>00172         ensure_context();
<a name="l00173"></a>00173         datalog::rule_manager&amp; rm = m_context-&gt;get_rule_manager();
<a name="l00174"></a>00174         datalog::rule_ref_vector rules(rm);
<a name="l00175"></a>00175         <span class="keywordflow">if</span> (rm.mk_rule(rule, rules, <span class="keyword">false</span>, name)) {
<a name="l00176"></a>00176             m_context-&gt;add_rules(rules.size(), rules.c_ptr());
<a name="l00177"></a>00177         }
<a name="l00178"></a>00178         <span class="keywordflow">else</span> {
<a name="l00179"></a>00179             std::ostringstream strm;
<a name="l00180"></a>00180             strm &lt;&lt; mk_pp(rule, m) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; rm.error_msg();
<a name="l00181"></a>00181             fatal_error_msg(<span class="stringliteral">&quot;Rule is invalid %s&quot;</span>, strm.str().c_str()); 
<a name="l00182"></a>00182         }
<a name="l00183"></a>00183     }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185     <span class="keywordtype">void</span> query(expr* query, datalog::relation_base*&amp; result) {
<a name="l00186"></a>00186         <span class="keywordflow">if</span> (!m_context) {
<a name="l00187"></a>00187             fatal_error_msg(<span class="stringliteral">&quot;there is no datalog context&quot;</span>);
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189         datalog::context::execution_result r;
<a name="l00190"></a>00190         r = m_context-&gt;query(query, result);
<a name="l00191"></a>00191         <span class="keywordflow">switch</span>(r) {
<a name="l00192"></a>00192         <span class="keywordflow">case</span> datalog::context::INPUT_ERROR: {
<a name="l00193"></a>00193             datalog::rule_manager&amp; rm = 
<a name="l00194"></a>00194                 m_context-&gt;get_rule_manager();
<a name="l00195"></a>00195             fatal_error_msg(rm.error_msg().c_str());
<a name="l00196"></a>00196             <span class="keywordflow">break</span>;
<a name="l00197"></a>00197         }
<a name="l00198"></a>00198         <span class="keywordflow">case</span> datalog::context::OK:
<a name="l00199"></a>00199             <span class="keywordflow">break</span>;
<a name="l00200"></a>00200         <span class="keywordflow">case</span> datalog::context::TIMEOUT:            
<a name="l00201"></a>00201             fatal_error_msg(<span class="stringliteral">&quot;timeout&quot;</span>);
<a name="l00202"></a>00202             <span class="keywordflow">break</span>;
<a name="l00203"></a>00203         <span class="keywordflow">default</span>:
<a name="l00204"></a>00204             <span class="keywordflow">break</span>;
<a name="l00205"></a>00205         }
<a name="l00206"></a>00206     }    
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     <span class="keywordtype">void</span> set_predicate_representation(func_decl* f, <span class="keywordtype">unsigned</span> num_relations, symbol * <span class="keyword">const</span> relation_kinds) {
<a name="l00209"></a>00209         ensure_context();
<a name="l00210"></a>00210         m_context-&gt;set_predicate_representation(f, num_relations, relation_kinds);
<a name="l00211"></a>00211     }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213     <span class="keywordtype">void</span> display_smt2(
<a name="l00214"></a>00214         <span class="keywordtype">unsigned</span> num_axioms,  expr* <span class="keyword">const</span>* axioms,
<a name="l00215"></a>00215         <span class="keywordtype">unsigned</span> num_rules,   expr* <span class="keyword">const</span>* rules,
<a name="l00216"></a>00216         <span class="keywordtype">unsigned</span> num_queries, expr* <span class="keyword">const</span>* queries, std::ostream&amp; out) {
<a name="l00217"></a>00217         ensure_context();
<a name="l00218"></a>00218         m_context-&gt;display_smt2(num_axioms, axioms, num_rules, rules, num_queries, queries, out);      
<a name="l00219"></a>00219     } 
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="keyword">private</span>:
<a name="l00222"></a>00222     <span class="keywordtype">void</span> ensure_context() {
<a name="l00223"></a>00223         <span class="keywordflow">if</span> (!m_context) {
<a name="l00224"></a>00224             m_context = alloc(datalog::context, m_manager, m_params);   
<a name="l00225"></a>00225         }
<a name="l00226"></a>00226     }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 };
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="preprocessor">#ifdef _WINDOWS</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span><span class="preprocessor">#define SET_FMT &quot;SET(0x%p, &quot;</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span><span class="preprocessor">#define PTR_PREFIX &quot;0x&quot;</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span><span class="preprocessor">#define SET_FMT &quot;SET(%p, &quot;</span>
<a name="l00237"></a>00237 <span class="preprocessor"></span><span class="preprocessor">#define PTR_PREFIX &quot;&quot;</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span>
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <span class="preprocessor">#define CHECK_REF_COUNT(a) (reinterpret_cast&lt;ast const*&gt;(a)-&gt;get_ref_count() &gt; 0)</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span><span class="preprocessor">#define VALIDATE(a) SASSERT(!a || CHECK_REF_COUNT(a))</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span>
<a name="l00245"></a>00245 ast * to_ast(Z3_ast a) { VALIDATE(a); <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>ast *<span class="keyword">&gt;</span>(a); }
<a name="l00246"></a>00246 Z3_ast of_ast(ast* a) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Z3_ast<span class="keyword">&gt;</span>(a); }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 expr * to_expr(Z3_ast a) { VALIDATE(a); <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>expr*<span class="keyword">&gt;</span>(a); }
<a name="l00249"></a>00249 Z3_ast of_expr(expr* e) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Z3_ast<span class="keyword">&gt;</span>(e); }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 expr * <span class="keyword">const</span> * to_exprs(Z3_ast <span class="keyword">const</span>* a) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>expr* const*<span class="keyword">&gt;</span>(a); }
<a name="l00252"></a>00252 Z3_ast* <span class="keyword">const</span> * of_exprs(expr* <span class="keyword">const</span>* e) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Z3_ast* const*<span class="keyword">&gt;</span>(e); }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 app * to_app(Z3_app a) { VALIDATE(a); <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>app*<span class="keyword">&gt;</span>(a); }
<a name="l00255"></a>00255 app * to_app(Z3_ast a) { VALIDATE(a); <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>app*<span class="keyword">&gt;</span>(a); }
<a name="l00256"></a>00256 Z3_app of_app(app* a) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Z3_app<span class="keyword">&gt;</span>(a); }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 app * <span class="keyword">const</span>* to_apps(Z3_ast <span class="keyword">const</span>* a) { VALIDATE(a); <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>app * const*<span class="keyword">&gt;</span>(a); }
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 ast * <span class="keyword">const</span> * to_asts(Z3_ast <span class="keyword">const</span>* a) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>ast* const*<span class="keyword">&gt;</span>(a); }
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 sort * to_sort(Z3_sort a) { VALIDATE(a); <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>sort*<span class="keyword">&gt;</span>(a); }
<a name="l00263"></a>00263 Z3_sort of_sort(sort* s) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Z3_sort<span class="keyword">&gt;</span>(s); }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 sort * <span class="keyword">const</span> * to_sorts(Z3_sort <span class="keyword">const</span>* a) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>sort* const*<span class="keyword">&gt;</span>(a); }
<a name="l00266"></a>00266 Z3_sort <span class="keyword">const</span>* of_sorts(sort* <span class="keyword">const</span>* s) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Z3_sort const*<span class="keyword">&gt;</span>(s); }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 func_decl * to_func_decl(Z3_func_decl a) { VALIDATE(a); <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>func_decl*<span class="keyword">&gt;</span>(a); }
<a name="l00269"></a>00269 Z3_func_decl of_func_decl(func_decl* f) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Z3_func_decl<span class="keyword">&gt;</span>(f); }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 func_decl * <span class="keyword">const</span>* to_func_decls(Z3_func_decl <span class="keyword">const</span>* f) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>func_decl*const*<span class="keyword">&gt;</span>(f); }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 symbol to_symbol(Z3_symbol s) { <span class="keywordflow">return</span> symbol::mk_symbol_from_c_ptr(reinterpret_cast&lt;void*&gt;(s)); }
<a name="l00274"></a>00274 Z3_symbol of_symbol(symbol s) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Z3_symbol<span class="keyword">&gt;</span>(<span class="keyword">const_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(s.c_ptr())); }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 Z3_pattern of_pattern(ast* a) { VALIDATE(a); <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Z3_pattern<span class="keyword">&gt;</span>(a); }
<a name="l00277"></a>00277 app* to_pattern(Z3_pattern p) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>app*<span class="keyword">&gt;</span>(p); }
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 model * to_model(Z3_model m) { <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>model *<span class="keyword">&gt;</span>(m); }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="keywordtype">void</span> default_error_handler(<a class="code" href="group__capi.html#gaa9f9e7b1b5b81381fab96debbaaa638f" title="Z3 error codes (See Z3_get_error_code).">Z3_error_code</a> c) {
<a name="l00282"></a>00282    printf(<span class="stringliteral">&quot;Error: %s\n&quot;</span>,<a class="code" href="group__capi.html#gaf06357c49299efb8a0bdaeb3bc96c6d6" title="Return a string describing the given error code.">Z3_get_error_msg</a>(c));
<a name="l00283"></a>00283    exit(1);
<a name="l00284"></a>00284 }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 <span class="keyword">struct </span>_Z3_context {
<a name="l00287"></a>00287 
<a name="l00288"></a>00288     <span class="keyword">class </span>param_ini {
<a name="l00289"></a>00289         front_end_params&amp; m_params;
<a name="l00290"></a>00290     <span class="keyword">public</span>:
<a name="l00291"></a>00291         param_ini(front_end_params&amp; p) : m_params(p) {
<a name="l00292"></a>00292             p.open_trace_file();
<a name="l00293"></a>00293         }
<a name="l00294"></a>00294         ~param_ini() {
<a name="l00295"></a>00295             m_params.close_trace_file();
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297     };
<a name="l00298"></a>00298 
<a name="l00299"></a>00299     <span class="keyword">class </span>add_plugins {
<a name="l00300"></a>00300     <span class="keyword">public</span>:
<a name="l00301"></a>00301         add_plugins(ast_manager&amp; m) {
<a name="l00302"></a>00302             m.register_decl_plugins();
<a name="l00303"></a>00303         }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     };
<a name="l00306"></a>00306     front_end_params       m_params;
<a name="l00307"></a>00307     param_ini              m_param_ini;
<a name="l00308"></a>00308     <span class="keywordtype">bool</span>                   m_user_ref_count; 
<a name="l00309"></a>00309     ast_manager            m_manager;
<a name="l00310"></a>00310     add_plugins            m_plugins;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     arith_util             m_arith_util;
<a name="l00313"></a>00313     bv_util                m_bv_util;
<a name="l00314"></a>00314     smt::solver *          m_context;
<a name="l00315"></a>00315     FILE*                  m_fp;
<a name="l00316"></a>00316 
<a name="l00317"></a>00317     <span class="keywordtype">bool</span>                   m_close_fp;
<a name="l00318"></a>00318     ast_ref_vector         m_last_result; 
<a name="l00319"></a>00319     ast_ref_vector         m_ast_trail;  
<a name="l00320"></a>00320     unsigned_vector        m_ast_lim;
<a name="l00321"></a>00321     ptr_vector&lt;ast_ref_vector&gt; m_replay_stack;
<a name="l00322"></a>00322     
<a name="l00323"></a>00323     
<a name="l00324"></a>00324     family_id m_basic_fid;
<a name="l00325"></a>00325     family_id m_array_fid;
<a name="l00326"></a>00326     family_id m_arith_fid;
<a name="l00327"></a>00327     family_id m_bv_fid;
<a name="l00328"></a>00328     family_id m_dt_fid;
<a name="l00329"></a>00329     datatype_decl_plugin* m_dt_plugin;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331     buffer&lt;Z3_func_decl, false&gt; m_get_model_constants_buffer;
<a name="l00332"></a>00332     std::string                      m_is_numeral_buffer;
<a name="l00333"></a>00333     std::string                      m_numeral_ast_buffer;
<a name="l00334"></a>00334     std::string                      m_is_string_symbol_buffer;
<a name="l00335"></a>00335     std::string                      m_ast_to_string_buffer;
<a name="l00336"></a>00336     std::string                      m_model_to_string_buffer;
<a name="l00337"></a>00337     std::string                      m_value_to_string_buffer;
<a name="l00338"></a>00338     std::string                      m_context_to_string_buffer;
<a name="l00339"></a>00339     std::string                      m_statistics_to_string_buffer;
<a name="l00340"></a>00340     std::string                      m_parser_buffer;
<a name="l00341"></a>00341     std::string                      m_benchmark_to_smtlib_string_buffer;
<a name="l00342"></a>00342     std::string                      m_param_buffer;
<a name="l00343"></a>00343 
<a name="l00344"></a>00344     smtlib::parser *           m_smtlib_parser;
<a name="l00345"></a>00345     <span class="keywordtype">bool</span>                       m_smtlib_parser_has_decls;
<a name="l00346"></a>00346     ptr_vector&lt;func_decl&gt;      m_smtlib_parser_decls;
<a name="l00347"></a>00347     ptr_vector&lt;sort&gt;           m_smtlib_parser_sorts;
<a name="l00348"></a>00348 
<a name="l00349"></a>00349     <a class="code" href="group__capi.html#gaa9f9e7b1b5b81381fab96debbaaa638f" title="Z3 error codes (See Z3_get_error_code).">Z3_error_code</a>              m_error_code;
<a name="l00350"></a>00350     <a class="code" href="group__capi.html#ga4f0c179e183c96ebdaa639628c6cdbb2" title="Z3 custom error handler (See Z3_set_error_handler).">Z3_error_handler</a> *         m_error_handler;
<a name="l00351"></a>00351     <a class="code" href="group__capi.html#ga0112dc1e8e08a19bf7a4299bb09a9727" title="Z3 pretty printing modes (See Z3_set_ast_print_mode).">Z3_ast_print_mode</a>          m_print_mode;
<a name="l00352"></a>00352     <span class="keywordtype">bool</span>                       m_searching;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     <span class="comment">// datalog</span>
<a name="l00355"></a>00355     external_relation_context_impl m_datalog_external;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357     _Z3_context(config_params* p, <span class="keywordtype">bool</span> user_ref_count = <span class="keyword">false</span>):
<a name="l00358"></a>00358         m_params(p ? p-&gt;m_params : front_end_params()),
<a name="l00359"></a>00359         m_param_ini(m_params),
<a name="l00360"></a>00360         m_user_ref_count(user_ref_count),
<a name="l00361"></a>00361         m_manager(m_params.m_proof_mode, m_params.m_trace_stream),
<a name="l00362"></a>00362         m_plugins(m_manager),
<a name="l00363"></a>00363         m_arith_util(m_manager),
<a name="l00364"></a>00364         m_bv_util(m_manager),
<a name="l00365"></a>00365         m_context(0),
<a name="l00366"></a>00366         m_fp(0),
<a name="l00367"></a>00367         m_last_result(m_manager),
<a name="l00368"></a>00368         m_ast_trail(m_manager),
<a name="l00369"></a>00369         m_replay_stack(),
<a name="l00370"></a>00370         m_basic_fid(m_manager.get_basic_family_id()),
<a name="l00371"></a>00371         m_array_fid(null_family_id),
<a name="l00372"></a>00372         m_arith_fid(null_family_id),
<a name="l00373"></a>00373         m_bv_fid(null_family_id),
<a name="l00374"></a>00374         m_dt_fid(null_family_id),
<a name="l00375"></a>00375         m_smtlib_parser(0),
<a name="l00376"></a>00376         m_smtlib_parser_has_decls(false), 
<a name="l00377"></a>00377         m_error_code(Z3_OK),
<a name="l00378"></a>00378         m_print_mode(Z3_PRINT_SMTLIB_FULL),
<a name="l00379"></a>00379         m_searching(false),
<a name="l00380"></a>00380         m_datalog_external(m_manager, m_params, this, m_ast_trail) 
<a name="l00381"></a>00381     {
<a name="l00382"></a>00382         z3_bound_num_procs();
<a name="l00383"></a>00383 
<a name="l00384"></a>00384         <span class="comment">//</span>
<a name="l00385"></a>00385         <span class="comment">// Configuration parameter settings.</span>
<a name="l00386"></a>00386         <span class="comment">//</span>
<a name="l00387"></a>00387         
<a name="l00388"></a>00388         memory::set_high_watermark(static_cast&lt;size_t&gt;(m_params.m_memory_high_watermark)*1024*1024);
<a name="l00389"></a>00389         memory::set_max_size(static_cast&lt;size_t&gt;(m_params.m_memory_max_size)*1024*1024);
<a name="l00390"></a>00390         <span class="keywordflow">if</span> (m_params.m_debug_ref_count) {
<a name="l00391"></a>00391             m_manager.debug_ref_count();
<a name="l00392"></a>00392         }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394         m_error_handler=&amp;default_error_handler;
<a name="l00395"></a>00395         
<a name="l00396"></a>00396         m_arith_fid = m_manager.get_family_id(<span class="stringliteral">&quot;arith&quot;</span>);
<a name="l00397"></a>00397         m_bv_fid    = m_manager.get_family_id(<span class="stringliteral">&quot;bv&quot;</span>);
<a name="l00398"></a>00398         m_array_fid = m_manager.get_family_id(<span class="stringliteral">&quot;array&quot;</span>);
<a name="l00399"></a>00399         m_dt_fid    = m_manager.get_family_id(<span class="stringliteral">&quot;datatype&quot;</span>);
<a name="l00400"></a>00400         m_dt_plugin = <span class="keyword">static_cast&lt;</span>datatype_decl_plugin*<span class="keyword">&gt;</span>(m_manager.get_plugin(m_dt_fid));
<a name="l00401"></a>00401 
<a name="l00402"></a>00402         <span class="keywordflow">if</span> (!m_user_ref_count) {
<a name="l00403"></a>00403             m_replay_stack.push_back(0);
<a name="l00404"></a>00404         }
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407     <span class="keywordtype">void</span> reset_parser() {
<a name="l00408"></a>00408         <span class="keywordflow">if</span> (m_smtlib_parser) {
<a name="l00409"></a>00409             dealloc(m_smtlib_parser);
<a name="l00410"></a>00410             m_smtlib_parser = 0;
<a name="l00411"></a>00411             m_smtlib_parser_has_decls = <span class="keyword">false</span>;
<a name="l00412"></a>00412             m_smtlib_parser_decls.reset();
<a name="l00413"></a>00413             m_smtlib_parser_sorts.reset();
<a name="l00414"></a>00414         }
<a name="l00415"></a>00415         SASSERT(!m_smtlib_parser_has_decls);
<a name="l00416"></a>00416     }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418     ~_Z3_context() {
<a name="l00419"></a>00419         <span class="keywordflow">if</span> (!m_user_ref_count) {
<a name="l00420"></a>00420             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; m_replay_stack.size(); ++i) {
<a name="l00421"></a>00421                 dealloc(m_replay_stack[i]);
<a name="l00422"></a>00422             }
<a name="l00423"></a>00423         }
<a name="l00424"></a>00424         reset_parser();
<a name="l00425"></a>00425         dealloc(m_context);
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="keywordtype">void</span> extract_smtlib_parser_decls() {
<a name="l00429"></a>00429         <span class="keywordflow">if</span> (m_smtlib_parser) {
<a name="l00430"></a>00430             <span class="keywordflow">if</span> (!m_smtlib_parser_has_decls) {
<a name="l00431"></a>00431                 smtlib::symtable * table = m_smtlib_parser-&gt;get_benchmark()-&gt;get_symtable();
<a name="l00432"></a>00432                 table-&gt;get_func_decls(m_smtlib_parser_decls);
<a name="l00433"></a>00433                 table-&gt;get_sorts(m_smtlib_parser_sorts);
<a name="l00434"></a>00434                 m_smtlib_parser_has_decls = <span class="keyword">true</span>;
<a name="l00435"></a>00435             }
<a name="l00436"></a>00436         }
<a name="l00437"></a>00437 
<a name="l00438"></a>00438         <span class="keywordflow">else</span> {
<a name="l00439"></a>00439             m_smtlib_parser_decls.reset();
<a name="l00440"></a>00440             m_smtlib_parser_sorts.reset();
<a name="l00441"></a>00441         }
<a name="l00442"></a>00442     }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444     smt::solver &amp; get_context() {
<a name="l00445"></a>00445         <span class="keywordflow">if</span> (!m_context) {
<a name="l00446"></a>00446             m_context = alloc(smt::solver, m_manager, m_params);
<a name="l00447"></a>00447         }
<a name="l00448"></a>00448         <span class="keywordflow">return</span> *m_context;
<a name="l00449"></a>00449     }
<a name="l00450"></a>00450 
<a name="l00451"></a>00451     <span class="keywordtype">void</span> assert_cnstr(expr* a) {
<a name="l00452"></a>00452         get_context().assert_expr(a);
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     lbool <a class="code" href="group__capi__ex.html#ga4ac4375063bd700cce15158ba6e761be" title="Check whether the logical context is satisfiable, and compare the result with the...">check</a>(model** m) {
<a name="l00456"></a>00456         flet&lt;bool&gt; searching(m_searching, <span class="keyword">true</span>);
<a name="l00457"></a>00457         lbool r;
<a name="l00458"></a>00458         r = get_context().check();
<a name="l00459"></a>00459         <span class="keywordflow">if</span> (r != l_false &amp;&amp; m) {
<a name="l00460"></a>00460             model_ref mref;
<a name="l00461"></a>00461             get_context().get_model(mref);
<a name="l00462"></a>00462             *m = mref.detach();
<a name="l00463"></a>00463         }
<a name="l00464"></a>00464         <span class="keywordflow">return</span> r;
<a name="l00465"></a>00465     }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467     expr* mk_numeral_core(rational <span class="keyword">const</span>&amp; n, sort* s) {
<a name="l00468"></a>00468         expr* e = 0;
<a name="l00469"></a>00469         family_id fid  = s-&gt;get_family_id();
<a name="l00470"></a>00470         <span class="keywordflow">if</span> (fid == m_arith_fid) {
<a name="l00471"></a>00471             e = m_arith_util.mk_numeral(n, s);
<a name="l00472"></a>00472         }
<a name="l00473"></a>00473         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid == m_bv_fid) {
<a name="l00474"></a>00474             e = m_bv_util.mk_numeral(n, s);
<a name="l00475"></a>00475         }
<a name="l00476"></a>00476         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid == datalog_get_family_id() &amp;&amp; n.is_uint64()) {
<a name="l00477"></a>00477             uint64 sz;
<a name="l00478"></a>00478             <span class="keywordflow">if</span> (datalog_get_util().try_get_size(s, sz) &amp;&amp; 
<a name="l00479"></a>00479                 sz &lt;= n.get_uint64()) {
<a name="l00480"></a>00480                 invoke_error_handler(Z3_INVALID_ARG);
<a name="l00481"></a>00481             }
<a name="l00482"></a>00482             e = datalog_get_util().mk_constant(n.get_uint64(), s);
<a name="l00483"></a>00483         }
<a name="l00484"></a>00484         <span class="keywordflow">else</span> {
<a name="l00485"></a>00485             invoke_error_handler(Z3_INVALID_ARG);
<a name="l00486"></a>00486         }
<a name="l00487"></a>00487         save_ast_trail(e);
<a name="l00488"></a>00488         <span class="keywordflow">return</span> e;    
<a name="l00489"></a>00489     }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491     expr* mk_and(<span class="keywordtype">unsigned</span> num_exprs, expr* <span class="keyword">const</span>* exprs) {
<a name="l00492"></a>00492         <span class="keywordflow">switch</span>(num_exprs) {
<a name="l00493"></a>00493         <span class="keywordflow">case</span> 0: 
<a name="l00494"></a>00494             <span class="keywordflow">return</span> m_manager.mk_true(); 
<a name="l00495"></a>00495         <span class="keywordflow">case</span> 1: 
<a name="l00496"></a>00496             save_ast_trail(exprs[0]);
<a name="l00497"></a>00497             <span class="keywordflow">return</span> exprs[0];
<a name="l00498"></a>00498         <span class="keywordflow">default</span>: {
<a name="l00499"></a>00499             expr* a = m_manager.mk_and(num_exprs, exprs);
<a name="l00500"></a>00500             save_ast_trail(a);
<a name="l00501"></a>00501             <span class="keywordflow">return</span> a;
<a name="l00502"></a>00502         }
<a name="l00503"></a>00503         }
<a name="l00504"></a>00504     }
<a name="l00505"></a>00505     
<a name="l00506"></a>00506 
<a name="l00507"></a>00507     <span class="keywordtype">void</span> push() {
<a name="l00508"></a>00508         get_context().push();
<a name="l00509"></a>00509         <span class="keywordflow">if</span> (!m_user_ref_count) {
<a name="l00510"></a>00510             m_ast_lim.push_back(m_ast_trail.size());
<a name="l00511"></a>00511             m_replay_stack.push_back(0);
<a name="l00512"></a>00512         }
<a name="l00513"></a>00513     }
<a name="l00514"></a>00514 
<a name="l00515"></a>00515     <span class="keywordtype">void</span> pop(<span class="keywordtype">unsigned</span> num_scopes) {
<a name="l00516"></a>00516         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_scopes; ++i) {
<a name="l00517"></a>00517             <span class="keywordflow">if</span> (!m_user_ref_count) {
<a name="l00518"></a>00518                 <span class="keywordtype">unsigned</span> sz = m_ast_lim.back();
<a name="l00519"></a>00519                 m_ast_lim.pop_back();
<a name="l00520"></a>00520                 dealloc(m_replay_stack.back());
<a name="l00521"></a>00521                 m_replay_stack.pop_back();
<a name="l00522"></a>00522                 <span class="keywordflow">while</span> (m_ast_trail.size() &gt; sz) {
<a name="l00523"></a>00523                     m_ast_trail.pop_back();
<a name="l00524"></a>00524                 }
<a name="l00525"></a>00525             }
<a name="l00526"></a>00526         }
<a name="l00527"></a>00527         get_context().pop(num_scopes);
<a name="l00528"></a>00528     }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 
<a name="l00531"></a>00531     <span class="keywordtype">void</span> persist_ast(ast* n, <span class="keywordtype">unsigned</span> num_scopes) {
<a name="l00532"></a>00532         <span class="comment">// persist_ast is irrelevant when m_user_ref_count == true</span>
<a name="l00533"></a>00533         <span class="keywordflow">if</span> (m_user_ref_count)
<a name="l00534"></a>00534             <span class="keywordflow">return</span>;
<a name="l00535"></a>00535         <span class="keywordflow">if</span> (num_scopes &gt; m_ast_lim.size()) {
<a name="l00536"></a>00536             num_scopes = m_ast_lim.size();
<a name="l00537"></a>00537         }
<a name="l00538"></a>00538         SASSERT(m_replay_stack.size() &gt; num_scopes);
<a name="l00539"></a>00539         <span class="keywordtype">unsigned</span> j = m_replay_stack.size() - num_scopes - 1;
<a name="l00540"></a>00540         <span class="keywordflow">if</span> (!m_replay_stack[j]) {
<a name="l00541"></a>00541             m_replay_stack[j] = alloc(ast_ref_vector, m_manager);
<a name="l00542"></a>00542         }
<a name="l00543"></a>00543         m_replay_stack[j]-&gt;push_back(n);
<a name="l00544"></a>00544     }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546     <span class="keywordtype">void</span> save_ast_trail(ast * n) {
<a name="l00547"></a>00547         <span class="keywordflow">if</span> (m_user_ref_count) {
<a name="l00548"></a>00548             m_last_result.reset();
<a name="l00549"></a>00549             m_last_result.push_back(n);
<a name="l00550"></a>00550         }
<a name="l00551"></a>00551         <span class="keywordflow">else</span> {
<a name="l00552"></a>00552             m_ast_trail.push_back(n);
<a name="l00553"></a>00553         }
<a name="l00554"></a>00554     }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     <span class="keywordtype">void</span> reset_last_result() {
<a name="l00557"></a>00557         <span class="keywordflow">if</span> (m_user_ref_count)
<a name="l00558"></a>00558             m_last_result.reset();
<a name="l00559"></a>00559     }
<a name="l00560"></a>00560     
<a name="l00561"></a>00561     <span class="keywordtype">void</span> save_multiple_ast_trail(ast * n) {
<a name="l00562"></a>00562         <span class="keywordflow">if</span> (m_user_ref_count)
<a name="l00563"></a>00563             m_last_result.push_back(n);
<a name="l00564"></a>00564         <span class="keywordflow">else</span>
<a name="l00565"></a>00565             m_ast_trail.push_back(n);
<a name="l00566"></a>00566     }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="keywordtype">void</span> invoke_error_handler(<a class="code" href="group__capi.html#gaa9f9e7b1b5b81381fab96debbaaa638f" title="Z3 error codes (See Z3_get_error_code).">Z3_error_code</a> c) {
<a name="l00569"></a>00569         <span class="keywordflow">if</span> (m_error_handler) {
<a name="l00570"></a>00570             <span class="keywordflow">if</span> (g_z3_log) {
<a name="l00571"></a>00571                 <span class="comment">// error handler can do crazy stuff such as longjmp</span>
<a name="l00572"></a>00572                 g_z3_log_enabled = <span class="keyword">true</span>;
<a name="l00573"></a>00573             }
<a name="l00574"></a>00574             m_error_handler(c);
<a name="l00575"></a>00575         }
<a name="l00576"></a>00576     }
<a name="l00577"></a>00577     
<a name="l00578"></a>00578     <span class="keyword">static</span> <span class="keywordtype">void</span> out_of_memory_handler(<span class="keywordtype">void</span>* _ctx) {
<a name="l00579"></a>00579         _Z3_context* ctx = <span class="keyword">static_cast&lt;</span>_Z3_context*<span class="keyword">&gt;</span>(_ctx);
<a name="l00580"></a>00580         <span class="keywordflow">if</span> (ctx) {
<a name="l00581"></a>00581             ctx-&gt;invoke_error_handler(Z3_MEMOUT_FAIL);
<a name="l00582"></a>00582         }
<a name="l00583"></a>00583     }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585     <span class="comment">// ---------------------</span>
<a name="l00586"></a>00586     <span class="comment">// Datalog</span>
<a name="l00587"></a>00587 
<a name="l00588"></a>00588     family_id datalog_get_family_id()<span class="keyword"> const </span>{
<a name="l00589"></a>00589         <span class="keywordflow">return</span> m_datalog_external.get_family_id();
<a name="l00590"></a>00590     }
<a name="l00591"></a>00591 
<a name="l00592"></a>00592     <span class="keywordtype">void</span> datalog_set_state(<span class="keywordtype">void</span>* state) {
<a name="l00593"></a>00593         SASSERT(!m_datalog_external.get_state());
<a name="l00594"></a>00594         m_datalog_external.init(state, m_params);
<a name="l00595"></a>00595     }
<a name="l00596"></a>00596 
<a name="l00597"></a>00597     datalog::dl_decl_util&amp; datalog_get_util() {
<a name="l00598"></a>00598         <span class="keywordflow">return</span> m_datalog_external.get_util();
<a name="l00599"></a>00599     }
<a name="l00600"></a>00600     
<a name="l00601"></a>00601     <span class="keywordtype">void</span>* datalog_get_state() {
<a name="l00602"></a>00602         <span class="keywordflow">return</span> m_datalog_external.get_state();
<a name="l00603"></a>00603     }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605     <span class="keywordtype">void</span> datalog_display_smt2(
<a name="l00606"></a>00606         <span class="keywordtype">unsigned</span> num_axioms, expr* <span class="keyword">const</span>* axioms,
<a name="l00607"></a>00607         <span class="keywordtype">unsigned</span> num_rules,  expr* <span class="keyword">const</span>* rules,
<a name="l00608"></a>00608         <span class="keywordtype">unsigned</span> num_queries, expr* <span class="keyword">const</span>* queries, std::ostream&amp; out) {
<a name="l00609"></a>00609         m_datalog_external.display_smt2(num_axioms, axioms, num_rules, rules, num_queries, queries, out);
<a name="l00610"></a>00610     }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612     <span class="keywordtype">void</span> datalog_parse_file(<a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> filename) {
<a name="l00613"></a>00613         <span class="comment">//</span>
<a name="l00614"></a>00614         <span class="comment">// parse the file and perform queries in the file.</span>
<a name="l00615"></a>00615         <span class="comment">// </span>
<a name="l00616"></a>00616         datalog::context ctx(m_manager, m_params);
<a name="l00617"></a>00617         datalog::parser* p = datalog::parser::create(ctx, m_manager);
<a name="l00618"></a>00618         datalog::relation_manager&amp; r = ctx.get_rmanager();
<a name="l00619"></a>00619         r.register_plugin(alloc(datalog::external_relation_plugin, m_datalog_external, r));
<a name="l00620"></a>00620 
<a name="l00621"></a>00621         <span class="keywordflow">if</span> (!p-&gt;parse_file(filename)) {
<a name="l00622"></a>00622             verbose_stream() &lt;&lt; <span class="stringliteral">&quot;ERROR: failed to parse file\n&quot;</span>;
<a name="l00623"></a>00623             <span class="keywordflow">return</span>;
<a name="l00624"></a>00624         }
<a name="l00625"></a>00625         dealloc(p);
<a name="l00626"></a>00626         ctx.close();
<a name="l00627"></a>00627 
<a name="l00628"></a>00628         ctx.saturate();
<a name="l00629"></a>00629 
<a name="l00630"></a>00630         ctx.display(std::cout);
<a name="l00631"></a>00631         <span class="comment">//</span>
<a name="l00632"></a>00632         <span class="comment">// TBD: output should be given as a set of tables.</span>
<a name="l00633"></a>00633         <span class="comment">// the decision what display is up to caller.</span>
<a name="l00634"></a>00634         <span class="comment">//</span>
<a name="l00635"></a>00635     }
<a name="l00636"></a>00636 
<a name="l00637"></a>00637     <span class="keywordtype">void</span> datalog_simplify_rules(<span class="keywordtype">unsigned</span> num_rules, expr* <span class="keyword">const</span>* rule_exprs, 
<a name="l00638"></a>00638                                 <span class="keywordtype">unsigned</span> num_outputs, func_decl* <span class="keyword">const</span>* outputs,
<a name="l00639"></a>00639                                 expr_ref_vector&amp; result) {
<a name="l00640"></a>00640         datalog::context ctx(m_manager, m_params);
<a name="l00641"></a>00641         datalog::rule_manager&amp; rm = ctx.get_rule_manager();
<a name="l00642"></a>00642         datalog::rule_ref_vector rules(rm);
<a name="l00643"></a>00643         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_rules; ++i) {
<a name="l00644"></a>00644             expr* rule = rule_exprs[i], *body, *head;
<a name="l00645"></a>00645             <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00646"></a>00646                 <span class="keywordflow">if</span> (is_quantifier(rule)) {
<a name="l00647"></a>00647                     rule = to_quantifier(rule)-&gt;get_expr();
<a name="l00648"></a>00648                 }
<a name="l00649"></a>00649                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_manager.is_implies(rule, body, head)) {
<a name="l00650"></a>00650                     rule = head;
<a name="l00651"></a>00651                 }
<a name="l00652"></a>00652                 <span class="keywordflow">else</span> {
<a name="l00653"></a>00653                     <span class="keywordflow">break</span>;
<a name="l00654"></a>00654                 }
<a name="l00655"></a>00655             }
<a name="l00656"></a>00656             <span class="keywordflow">if</span> (is_app(rule)) {
<a name="l00657"></a>00657                 func_decl* r = to_app(rule)-&gt;get_decl();
<a name="l00658"></a>00658                 <span class="keywordflow">if</span> (!ctx.is_predicate(r)) {
<a name="l00659"></a>00659                     ctx.register_predicate(r);
<a name="l00660"></a>00660                     <span class="keywordflow">if</span> (num_outputs == 0) {
<a name="l00661"></a>00661                         ctx.set_output_predicate(r);
<a name="l00662"></a>00662                     }
<a name="l00663"></a>00663                 }
<a name="l00664"></a>00664             }
<a name="l00665"></a>00665         }
<a name="l00666"></a>00666         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_outputs; ++i) {
<a name="l00667"></a>00667             ctx.set_output_predicate(outputs[i]);
<a name="l00668"></a>00668         }
<a name="l00669"></a>00669         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_rules; ++i) {
<a name="l00670"></a>00670             expr* rule = rule_exprs[i];
<a name="l00671"></a>00671             <span class="keywordflow">if</span> (!rm.mk_rule(rule, rules, <span class="keyword">false</span>)) {
<a name="l00672"></a>00672                 std::ostringstream strm;
<a name="l00673"></a>00673                 strm &lt;&lt; mk_pp(rule, m_manager) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; rm.error_msg();
<a name="l00674"></a>00674                 fatal_error_msg(<span class="stringliteral">&quot;Rule is invalid %s&quot;</span>, strm.str().c_str()); 
<a name="l00675"></a>00675             }
<a name="l00676"></a>00676         }
<a name="l00677"></a>00677         ctx.add_rules(rules.size(), rules.c_ptr());
<a name="l00678"></a>00678         ctx.apply_default_transformation();
<a name="l00679"></a>00679         datalog::rule_set <span class="keyword">const</span>&amp; new_rules = ctx.get_rules();
<a name="l00680"></a>00680         datalog::rule_set::iterator it = new_rules.begin(), end = new_rules.end();
<a name="l00681"></a>00681         <span class="keywordflow">for</span> (; it != end; ++it) {
<a name="l00682"></a>00682             datalog::rule* r = *it;
<a name="l00683"></a>00683             expr_ref fml(m_manager);
<a name="l00684"></a>00684             r-&gt;to_formula(fml);
<a name="l00685"></a>00685             result.push_back(fml);
<a name="l00686"></a>00686         }
<a name="l00687"></a>00687     }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     <span class="keywordtype">void</span> datalog_register_relation(func_decl* f) {
<a name="l00690"></a>00690         m_datalog_external.register_relation(f);
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693     <span class="keywordtype">void</span> datalog_set_reduce_assign_callback(<a class="code" href="group__capi.html#ga906365bab6a522a0eb4d6b8e2b601df4" title="The following utilities allows adding user-defined domains.">Z3_datalog_reduce_assign_callback_fptr</a> f) {
<a name="l00694"></a>00694         m_datalog_external.set_reduce_assign((reduce_assign_callback_fptr) f);
<a name="l00695"></a>00695     }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697     <span class="keywordtype">void</span> datalog_set_reduce_app_callback(Z3_datalog_reduce_app_callback_fptr f) {
<a name="l00698"></a>00698         m_datalog_external.set_reduce_app((reduce_app_callback_fptr) f);
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701     <span class="keywordtype">void</span> datalog_add_rule(expr* fml, symbol <span class="keyword">const</span>&amp; name) {
<a name="l00702"></a>00702         m_datalog_external.add_rule(fml, name);
<a name="l00703"></a>00703     }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705     <span class="keywordtype">void</span> datalog_set_predicate_representation(func_decl* f, <span class="keywordtype">unsigned</span> num_relations, symbol * <span class="keyword">const</span> relation_kinds) {
<a name="l00706"></a>00706         m_datalog_external.set_predicate_representation(f, num_relations, relation_kinds);
<a name="l00707"></a>00707     }
<a name="l00708"></a>00708 
<a name="l00709"></a>00709     <span class="keywordtype">void</span> datalog_query(expr* query, expr_ref&amp; query_result) {
<a name="l00710"></a>00710         datalog::relation_base* result = 0;
<a name="l00711"></a>00711         m_datalog_external.query(query, result);
<a name="l00712"></a>00712         query_result = m_manager.mk_true();
<a name="l00713"></a>00713         <span class="keywordflow">if</span> (result) {
<a name="l00714"></a>00714             result-&gt;to_formula(query_result);
<a name="l00715"></a>00715             result-&gt;deallocate();
<a name="l00716"></a>00716         }
<a name="l00717"></a>00717     }
<a name="l00718"></a>00718 
<a name="l00719"></a>00719     __uint64 datalog_get_sort_size(sort* s) {
<a name="l00720"></a>00720         __uint64 result = 0;
<a name="l00721"></a>00721         VERIFY(m_datalog_external.get_util().try_get_size(s, result));
<a name="l00722"></a>00722         <span class="keywordflow">return</span> result;
<a name="l00723"></a>00723     }
<a name="l00724"></a>00724 
<a name="l00725"></a>00725     <span class="keywordtype">bool</span> datalog_is_numeral(expr* e, rational&amp; r) {
<a name="l00726"></a>00726         uint64 v;
<a name="l00727"></a>00727         <span class="keywordflow">if</span> (m_datalog_external.get_util().try_get_constant(e, v)) {
<a name="l00728"></a>00728             r = rational(v, rational::ui64());
<a name="l00729"></a>00729             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00730"></a>00730         }
<a name="l00731"></a>00731         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00732"></a>00732     }
<a name="l00733"></a>00733 
<a name="l00734"></a>00734 };
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 _Z3_context* mk_c(Z3_context c) { 
<a name="l00737"></a>00737     <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>_Z3_context*<span class="keyword">&gt;</span>(c); 
<a name="l00738"></a>00738 }
<a name="l00739"></a>00739 
<a name="l00740"></a>00740 smt::user_theory * mk_t(Z3_theory t) {
<a name="l00741"></a>00741     <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>smt::user_theory*<span class="keyword">&gt;</span>(t);
<a name="l00742"></a>00742 }
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 <span class="preprocessor">#define RESET_ERROR_CODE() { mk_c(c)-&gt;m_error_code = Z3_OK; }</span>
<a name="l00745"></a>00745 <span class="preprocessor"></span><span class="preprocessor">#define SET_ERROR_CODE(ERR) { mk_c(c)-&gt;m_error_code = ERR; if (ERR != Z3_OK) mk_c(c)-&gt;invoke_error_handler(ERR); }</span>
<a name="l00746"></a>00746 <span class="preprocessor"></span>
<a name="l00747"></a>00747 <span class="preprocessor">#define CHECK_NON_NULL(_p_,_ret) { if (_p_ == 0) { SET_ERROR_CODE(Z3_INVALID_ARG); return _ret; } }</span>
<a name="l00748"></a>00748 <span class="preprocessor"></span><span class="preprocessor">#define CHECK_VALID_AST(_a_) { if (_a_ == 0 || !CHECK_REF_COUNT(_a_)) { SET_ERROR_CODE(Z3_INVALID_ARG); } }</span>
<a name="l00749"></a>00749 <span class="preprocessor"></span>
<a name="l00750"></a>00750 
<a name="l00751"></a>00751 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00752"></a>00752 
<a name="l00753"></a><a class="code" href="group__capi.html#ga7d6c40d9b79fe8a8851cc8540970787f">00753</a>     Z3_config Z3_API <a class="code" href="group__capi.html#ga7d6c40d9b79fe8a8851cc8540970787f" title="Create a configuration.">Z3_mk_config</a>() {
<a name="l00754"></a>00754         LOG_Z3_mk_config();
<a name="l00755"></a>00755         memory::initialize(0);
<a name="l00756"></a>00756         Z3_config r = <span class="keyword">reinterpret_cast&lt;</span>Z3_config<span class="keyword">&gt;</span>(alloc(config_params));
<a name="l00757"></a>00757         RETURN_Z3(r);
<a name="l00758"></a>00758     }
<a name="l00759"></a>00759     
<a name="l00760"></a>00760     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga5e620acf5d55d0271097c9bb97219774" title="Delete the given configuration object.">Z3_del_config</a>(Z3_config c) {
<a name="l00761"></a>00761         LOG_Z3_del_config(c);
<a name="l00762"></a>00762         dealloc((reinterpret_cast&lt;config_params*&gt;(c)));
<a name="l00763"></a>00763     }
<a name="l00764"></a>00764     
<a name="l00765"></a>00765     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga001ade87a1671fe77d7e53ed0f4f1ec3" title="Set a configuration parameter.">Z3_set_param_value</a>(Z3_config c, <span class="keyword">const</span> <span class="keywordtype">char</span>* param_id, <span class="keyword">const</span> <span class="keywordtype">char</span>* param_value) {
<a name="l00766"></a>00766         LOG_Z3_set_param_value(c, param_id, param_value);
<a name="l00767"></a>00767         config_params* p = <span class="keyword">reinterpret_cast&lt;</span>config_params*<span class="keyword">&gt;</span>(c);
<a name="l00768"></a>00768         p-&gt;m_ini.set_param_value(param_id, param_value);
<a name="l00769"></a>00769     }
<a name="l00770"></a>00770 
<a name="l00771"></a>00771     
<a name="l00772"></a>00772     Z3_context Z3_API <a class="code" href="group__capi.html#ga0bd93cfab4d749dd3e2f2a4416820a46" title="Create a context using the given configuration.">Z3_mk_context</a>(Z3_config c) {
<a name="l00773"></a>00773         LOG_Z3_mk_context(c);
<a name="l00774"></a>00774         memory::initialize(0);
<a name="l00775"></a>00775         Z3_context r = alloc(_Z3_context, reinterpret_cast&lt;config_params*&gt;(c), <span class="keyword">false</span>);
<a name="l00776"></a>00776         RETURN_Z3(r);
<a name="l00777"></a>00777     }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779     Z3_context Z3_API <a class="code" href="group__capi.html#ga98acd59d946eceb4f261bc50489216ee" title="Create a context using the given configuration. This function is similar to Z3_mk_context...">Z3_mk_context_rc</a>(Z3_config c) {
<a name="l00780"></a>00780         LOG_Z3_mk_context_rc(c);
<a name="l00781"></a>00781         memory::initialize(0);
<a name="l00782"></a>00782         Z3_context r = alloc(_Z3_context, reinterpret_cast&lt;config_params*&gt;(c), <span class="keyword">true</span>);
<a name="l00783"></a>00783         RETURN_Z3(r);
<a name="l00784"></a>00784     }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga556eae80ed43ab13e1e7dc3b38c35200" title="Delete the given logical context.">Z3_del_context</a>(Z3_context c) {
<a name="l00787"></a>00787         LOG_Z3_del_context(c);
<a name="l00788"></a>00788         RESET_ERROR_CODE();
<a name="l00789"></a>00789         dealloc(mk_c(c));
<a name="l00790"></a>00790     }
<a name="l00791"></a>00791 
<a name="l00792"></a><a class="code" href="group__capi.html#ga8a00a2247dff1311ce2d991d4ea0e295">00792</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga8a00a2247dff1311ce2d991d4ea0e295" title="Enable/disable printing warning messages to the console.">Z3_toggle_warning_messages</a>(__in <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> enabled) {
<a name="l00793"></a>00793         LOG_Z3_toggle_warning_messages(enabled);
<a name="l00794"></a>00794         enable_warning_messages(enabled != 0);
<a name="l00795"></a>00795     }
<a name="l00796"></a>00796 
<a name="l00797"></a><a class="code" href="group__capi.html#gadc86e04357d53c4ea8b47d3b83352feb">00797</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#gadc86e04357d53c4ea8b47d3b83352feb" title="Update a mutable configuration parameter.">Z3_update_param_value</a>(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> param_id, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> param_value) {
<a name="l00798"></a>00798         LOG_Z3_update_param_value(c, param_id, param_value);
<a name="l00799"></a>00799         ini_params ini;        
<a name="l00800"></a>00800         mk_c(c)-&gt;m_params.register_params(ini);
<a name="l00801"></a>00801         register_pp_params(ini);
<a name="l00802"></a>00802         register_verbosity_level(ini);
<a name="l00803"></a>00803         register_warning(ini);
<a name="l00804"></a>00804         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_context) {
<a name="l00805"></a>00805             ini.freeze();
<a name="l00806"></a>00806         }
<a name="l00807"></a>00807         ini.set_param_value(param_id, param_value);
<a name="l00808"></a>00808     }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#gaea45aea33c6d0557ba68706ef9f0ee9c" title="Get a configuration parameter.">Z3_get_param_value</a>(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> param_id, __out_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a>* param_value) {
<a name="l00811"></a>00811         LOG_Z3_get_param_value(c, param_id, param_value);
<a name="l00812"></a>00812         ini_params ini;        
<a name="l00813"></a>00813         mk_c(c)-&gt;m_params.register_params(ini);
<a name="l00814"></a>00814         register_verbosity_level(ini);
<a name="l00815"></a>00815         register_pp_params(ini);
<a name="l00816"></a>00816         register_warning(ini);
<a name="l00817"></a>00817         std::string param_value_s;
<a name="l00818"></a>00818         <span class="keywordflow">if</span> (!ini.get_param_value(param_id, param_value_s)) {
<a name="l00819"></a>00819             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00820"></a>00820         }
<a name="l00821"></a>00821         mk_c(c)-&gt;m_param_buffer = param_value_s;
<a name="l00822"></a>00822         <span class="keywordflow">if</span> (param_value) {
<a name="l00823"></a>00823             *param_value = mk_c(c)-&gt;m_param_buffer.c_str();
<a name="l00824"></a>00824         }
<a name="l00825"></a>00825         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00826"></a>00826     }
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 <span class="preprocessor">#define CHECK_SEARCHING(c) if (mk_c(c)-&gt;m_searching) { SET_ERROR_CODE(Z3_INVALID_USAGE); } // TBD: error code could be fixed.</span>
<a name="l00829"></a>00829 <span class="preprocessor"></span>
<a name="l00830"></a>00830     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga4a11514494fbf3467b89f0a80ac81e7a" title="Increment the reference counter of the given AST. The context c should have been...">Z3_inc_ref</a>(Z3_context c, Z3_ast a) {
<a name="l00831"></a>00831         LOG_Z3_inc_ref(c, a);
<a name="l00832"></a>00832         RESET_ERROR_CODE();
<a name="l00833"></a>00833         mk_c(c)-&gt;m_manager.inc_ref(to_ast(a));
<a name="l00834"></a>00834     }
<a name="l00835"></a>00835 
<a name="l00836"></a>00836     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga9cd52225142c085630495044acc68bd2" title="Decrement the reference counter of the given AST. The context c should have been...">Z3_dec_ref</a>(Z3_context c, Z3_ast a) {
<a name="l00837"></a>00837         LOG_Z3_dec_ref(c, a);
<a name="l00838"></a>00838         RESET_ERROR_CODE();
<a name="l00839"></a>00839         <span class="keywordflow">if</span> (to_ast(a)-&gt;get_ref_count() == 0) {
<a name="l00840"></a>00840             SET_ERROR_CODE(Z3_DEC_REF_ERROR);
<a name="l00841"></a>00841             <span class="keywordflow">return</span>;
<a name="l00842"></a>00842         }
<a name="l00843"></a>00843         mk_c(c)-&gt;m_manager.dec_ref(to_ast(a));
<a name="l00844"></a>00844     }
<a name="l00845"></a>00845 
<a name="l00846"></a><a class="code" href="group__capi.html#gac11f9016b4128a4bab9e3c103a1d61ef">00846</a>     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#gac11f9016b4128a4bab9e3c103a1d61ef" title="Set the SMTLIB logic to be used in the given logical context. It is incorrect to...">Z3_set_logic</a>(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> logic) {
<a name="l00847"></a>00847         LOG_Z3_set_logic(c, logic);
<a name="l00848"></a>00848         RESET_ERROR_CODE();
<a name="l00849"></a>00849         <span class="keywordflow">return</span> mk_c(c)-&gt;get_context().set_logic(symbol(logic));
<a name="l00850"></a>00850     }
<a name="l00851"></a>00851     
<a name="l00852"></a>00852     Z3_symbol Z3_API <a class="code" href="group__capi.html#ga3df806baf6124df3e63a58cf23e12411" title="Create a Z3 symbol using an integer.">Z3_mk_int_symbol</a>(Z3_context c, <span class="keywordtype">int</span> i) {
<a name="l00853"></a>00853         LOG_Z3_mk_int_symbol(c, i);
<a name="l00854"></a>00854         RESET_ERROR_CODE();
<a name="l00855"></a>00855         <span class="keywordflow">if</span> (i &lt; 0 || i &gt;= (<span class="keywordtype">int</span>)((UINT_MAX &gt;&gt; PTR_ALIGNMENT))) {
<a name="l00856"></a>00856             SET_ERROR_CODE(Z3_IOB);
<a name="l00857"></a>00857         }
<a name="l00858"></a>00858         Z3_symbol result = of_symbol(symbol(i));
<a name="l00859"></a>00859         <span class="keywordflow">return</span> result;
<a name="l00860"></a>00860     }
<a name="l00861"></a>00861     
<a name="l00862"></a>00862     Z3_symbol Z3_API <a class="code" href="group__capi.html#gafebb0d3c212927cf7834c3a20a84ecae" title="Create a Z3 symbol using a C string.">Z3_mk_string_symbol</a>(Z3_context c, <span class="keyword">const</span> <span class="keywordtype">char</span>* str) {
<a name="l00863"></a>00863         LOG_Z3_mk_string_symbol(c, str);
<a name="l00864"></a>00864         RESET_ERROR_CODE();
<a name="l00865"></a>00865         Z3_symbol result = of_symbol(symbol(str));
<a name="l00866"></a>00866         <span class="keywordflow">return</span> result;
<a name="l00867"></a>00867     }
<a name="l00868"></a>00868    
<a name="l00869"></a><a class="code" href="group__capi.html#ga7ed6a177f4d2308f5719afb3844a0c1a">00869</a>     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga7ed6a177f4d2308f5719afb3844a0c1a" title="compare sorts.">Z3_is_eq_sort</a>(__in Z3_context, __in Z3_sort s1, __in Z3_sort s2) {
<a name="l00870"></a>00870         <span class="keywordflow">return</span> s1 == s2;
<a name="l00871"></a>00871     }
<a name="l00872"></a>00872     
<a name="l00873"></a>00873     Z3_sort Z3_API <a class="code" href="group__capi.html#ga736e88741af1c178cbebf94c49aa42de" title="Create a free (uninterpreted) type using the given name (symbol).">Z3_mk_uninterpreted_sort</a>(Z3_context c, Z3_symbol name) {
<a name="l00874"></a>00874         LOG_Z3_mk_uninterpreted_sort(c, name);
<a name="l00875"></a>00875         RESET_ERROR_CODE();
<a name="l00876"></a>00876         sort* ty = mk_c(c)-&gt;m_manager.mk_sort(to_symbol(name));
<a name="l00877"></a>00877         mk_c(c)-&gt;save_ast_trail(ty);
<a name="l00878"></a>00878         RETURN_Z3(of_sort(ty));
<a name="l00879"></a>00879     }
<a name="l00880"></a>00880 
<a name="l00881"></a>00881     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga10b4c8088013ecd876054c6817e61640" title="compare terms.">Z3_is_eq_ast</a>(__in Z3_context, __in Z3_ast s1, __in Z3_ast s2) {
<a name="l00882"></a>00882         <span class="keywordflow">return</span> s1 == s2;
<a name="l00883"></a>00883     }
<a name="l00884"></a>00884 
<a name="l00885"></a>00885     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga7a6bd5c178798bb12594663ba71104bb" title="compare terms.">Z3_is_eq_func_decl</a>(__in Z3_context, __in Z3_func_decl s1, __in Z3_func_decl s2) {
<a name="l00886"></a>00886         <span class="keywordflow">return</span> s1 == s2;
<a name="l00887"></a>00887     }
<a name="l00888"></a>00888     
<a name="l00889"></a>00889     Z3_func_decl Z3_API <a class="code" href="group__capi.html#gaa5c5e2602a44d5f1373f077434859ca2" title="Declare a constant or function.">Z3_mk_func_decl</a>(Z3_context c, Z3_symbol s, <span class="keywordtype">unsigned</span> domain_size, Z3_sort <span class="keyword">const</span>* domain, 
<a name="l00890"></a>00890                                         Z3_sort range) {
<a name="l00891"></a>00891         LOG_Z3_mk_func_decl(c, s, domain_size, domain, range);
<a name="l00892"></a>00892         RESET_ERROR_CODE();
<a name="l00893"></a>00893         func_decl* d = mk_c(c)-&gt;m_manager.mk_func_decl(to_symbol(s), 
<a name="l00894"></a>00894                                                        domain_size, 
<a name="l00895"></a>00895                                                        to_sorts(domain),
<a name="l00896"></a>00896                                                        to_sort(range));
<a name="l00897"></a>00897         
<a name="l00898"></a>00898         mk_c(c)-&gt;save_ast_trail(d);
<a name="l00899"></a>00899         RETURN_Z3(of_func_decl(d));
<a name="l00900"></a>00900     }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902     <span class="keyword">static</span> <span class="keywordtype">void</span> check_sorts(Z3_context c, ast * n) {
<a name="l00903"></a>00903         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l00904"></a>00904         <span class="keywordflow">if</span> (!m.check_sorts(n)) {
<a name="l00905"></a>00905             <span class="keywordflow">switch</span>(n-&gt;get_kind()) {
<a name="l00906"></a>00906             <span class="keywordflow">case</span> AST_APP: {
<a name="l00907"></a>00907                 std::ostringstream buffer;
<a name="l00908"></a>00908                 app* a = to_app(n);
<a name="l00909"></a>00909                 buffer &lt;&lt; mk_pp(a-&gt;get_decl(), m) &lt;&lt; <span class="stringliteral">&quot; applied to: &quot;</span>;
<a name="l00910"></a>00910                 <span class="keywordflow">if</span> (a-&gt;get_num_args() &gt; 1) buffer &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00911"></a>00911                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; a-&gt;get_num_args(); ++i) {
<a name="l00912"></a>00912                     buffer &lt;&lt; mk_bounded_pp(a-&gt;get_arg(i), m, 3) &lt;&lt; <span class="stringliteral">&quot; of sort &quot;</span>;
<a name="l00913"></a>00913                     buffer &lt;&lt; mk_pp(m.get_sort(a-&gt;get_arg(i)), m) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00914"></a>00914                 }
<a name="l00915"></a>00915                 warning_msg(<span class="stringliteral">&quot;%s&quot;</span>,buffer.str().c_str());
<a name="l00916"></a>00916                 <span class="keywordflow">break</span>;
<a name="l00917"></a>00917             }
<a name="l00918"></a>00918             <span class="keywordflow">case</span> AST_VAR:
<a name="l00919"></a>00919             <span class="keywordflow">case</span> AST_QUANTIFIER:
<a name="l00920"></a>00920             <span class="keywordflow">case</span> AST_SORT:
<a name="l00921"></a>00921             <span class="keywordflow">case</span> AST_FUNC_DECL:
<a name="l00922"></a>00922                 <span class="keywordflow">break</span>;
<a name="l00923"></a>00923             }
<a name="l00924"></a>00924             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l00925"></a>00925         }
<a name="l00926"></a>00926     }
<a name="l00927"></a>00927 
<a name="l00928"></a>00928     Z3_ast Z3_API <a class="code" href="group__capi.html#ga33a202d86bf628bfab9b6f437536cebe" title="Create a constant or function application.">Z3_mk_app</a>(Z3_context c, Z3_func_decl d, <span class="keywordtype">unsigned</span> num_args, Z3_ast <span class="keyword">const</span> * args) {
<a name="l00929"></a>00929         LOG_Z3_mk_app(c, d, num_args, args);
<a name="l00930"></a>00930         RESET_ERROR_CODE();   
<a name="l00931"></a>00931         ptr_vector&lt;expr&gt; arg_list;
<a name="l00932"></a>00932         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_args; ++i) {
<a name="l00933"></a>00933             arg_list.push_back(to_expr(args[i]));
<a name="l00934"></a>00934         }
<a name="l00935"></a>00935         func_decl* _d = <span class="keyword">reinterpret_cast&lt;</span>func_decl*<span class="keyword">&gt;</span>(d);
<a name="l00936"></a>00936         app* a = mk_c(c)-&gt;m_manager.mk_app(_d, num_args, arg_list.c_ptr());   
<a name="l00937"></a>00937         mk_c(c)-&gt;save_ast_trail(a);
<a name="l00938"></a>00938         check_sorts(c, a);
<a name="l00939"></a>00939         RETURN_Z3(of_ast(a));
<a name="l00940"></a>00940     }
<a name="l00941"></a>00941     
<a name="l00942"></a>00942     Z3_ast Z3_API <a class="code" href="group__capi.html#ga093c9703393f33ae282ec5e8729354ef" title="Declare and create a constant.">Z3_mk_const</a>(Z3_context c, Z3_symbol s, Z3_sort ty) {
<a name="l00943"></a>00943         LOG_Z3_mk_const(c, s, ty);
<a name="l00944"></a>00944         RESET_ERROR_CODE();  
<a name="l00945"></a>00945         app* a = mk_c(c)-&gt;m_manager.mk_const(mk_c(c)-&gt;m_manager.mk_const_decl(to_symbol(s), to_sort(ty)));
<a name="l00946"></a>00946         mk_c(c)-&gt;save_ast_trail(a);
<a name="l00947"></a>00947         RETURN_Z3(of_ast(a));
<a name="l00948"></a>00948     }
<a name="l00949"></a>00949     
<a name="l00950"></a><a class="code" href="group__capi.html#ga9c766b9d17c0d4f219fbd19214fc5eb5">00950</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga9c766b9d17c0d4f219fbd19214fc5eb5" title="Create a labeled formula.">Z3_mk_label</a>(__in Z3_context c, __in Z3_symbol s, <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> is_pos, Z3_ast f) {
<a name="l00951"></a>00951         LOG_Z3_mk_label(c, s, is_pos, f);
<a name="l00952"></a>00952         RESET_ERROR_CODE(); 
<a name="l00953"></a>00953         expr* _f = to_expr(f);
<a name="l00954"></a>00954         <span class="keywordflow">if</span> (!mk_c(c)-&gt;m_manager.is_bool(_f)) {
<a name="l00955"></a>00955             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l00956"></a>00956             <span class="keywordflow">return</span> f;
<a name="l00957"></a>00957         }
<a name="l00958"></a>00958         expr* a = mk_c(c)-&gt;m_manager.mk_label(is_pos != 0, to_symbol(s), _f);
<a name="l00959"></a>00959         mk_c(c)-&gt;save_ast_trail(a);
<a name="l00960"></a>00960         RETURN_Z3(of_ast(a));
<a name="l00961"></a>00961     }
<a name="l00962"></a>00962 
<a name="l00963"></a>00963     Z3_func_decl Z3_API <a class="code" href="group__capi.html#gaee44886cfdb2ae492e72b99966f29afe" title="Declare a fresh constant or function.">Z3_mk_fresh_func_decl</a>(Z3_context c, <span class="keyword">const</span> <span class="keywordtype">char</span> * prefix, <span class="keywordtype">unsigned</span> domain_size,
<a name="l00964"></a>00964                                               Z3_sort <span class="keyword">const</span> domain[], Z3_sort range) {
<a name="l00965"></a>00965         LOG_Z3_mk_fresh_func_decl(c, prefix, domain_size, domain, range);
<a name="l00966"></a>00966         RESET_ERROR_CODE();
<a name="l00967"></a>00967         <span class="keywordflow">if</span> (prefix == 0) {
<a name="l00968"></a>00968             prefix = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00969"></a>00969         }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971         func_decl* d = mk_c(c)-&gt;m_manager.mk_fresh_func_decl(prefix, 
<a name="l00972"></a>00972                                                              domain_size, 
<a name="l00973"></a>00973                                                              reinterpret_cast&lt;sort*const*&gt;(domain),
<a name="l00974"></a>00974                                                              to_sort(range));
<a name="l00975"></a>00975         
<a name="l00976"></a>00976         mk_c(c)-&gt;save_ast_trail(d);
<a name="l00977"></a>00977         RETURN_Z3(of_func_decl(d));
<a name="l00978"></a>00978     }
<a name="l00979"></a>00979     
<a name="l00980"></a>00980     Z3_ast Z3_API <a class="code" href="group__capi.html#ga4505b27b8f8077cbe3246fd22298e4ba" title="Declare and create a fresh constant.">Z3_mk_fresh_const</a>(Z3_context c, <span class="keyword">const</span> <span class="keywordtype">char</span> * prefix, Z3_sort ty) {
<a name="l00981"></a>00981         LOG_Z3_mk_fresh_const(c, prefix, ty);
<a name="l00982"></a>00982         RESET_ERROR_CODE();
<a name="l00983"></a>00983         <span class="keywordflow">if</span> (prefix == 0) {
<a name="l00984"></a>00984             prefix = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00985"></a>00985         }
<a name="l00986"></a>00986         app* a = mk_c(c)-&gt;m_manager.mk_fresh_const(prefix, to_sort(ty));
<a name="l00987"></a>00987         mk_c(c)-&gt;save_ast_trail(a);
<a name="l00988"></a>00988         RETURN_Z3(of_ast(a));
<a name="l00989"></a>00989     }
<a name="l00990"></a>00990 
<a name="l00991"></a>00991     <span class="keywordtype">bool</span> is_numeral_sort(Z3_context c, Z3_sort ty) {
<a name="l00992"></a>00992         sort * _ty = to_sort(ty);
<a name="l00993"></a>00993         family_id fid  = _ty-&gt;get_family_id();
<a name="l00994"></a>00994         <span class="keywordflow">if</span> (fid != mk_c(c)-&gt;m_arith_fid &amp;&amp; 
<a name="l00995"></a>00995             fid != mk_c(c)-&gt;m_bv_fid &amp;&amp;
<a name="l00996"></a>00996             fid != mk_c(c)-&gt;datalog_get_family_id()) {
<a name="l00997"></a>00997             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00998"></a>00998         }
<a name="l00999"></a>00999         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01000"></a>01000     }
<a name="l01001"></a>01001 
<a name="l01002"></a>01002     <span class="keywordtype">bool</span> check_numeral_sort(Z3_context c, Z3_sort ty) {
<a name="l01003"></a>01003         <span class="keywordtype">bool</span> is_num = is_numeral_sort(c, ty);
<a name="l01004"></a>01004         <span class="keywordflow">if</span> (!is_num) {
<a name="l01005"></a>01005             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01006"></a>01006         }
<a name="l01007"></a>01007         <span class="keywordflow">return</span> is_num;
<a name="l01008"></a>01008     }
<a name="l01009"></a>01009     
<a name="l01010"></a>01010     Z3_ast Z3_API <a class="code" href="group__capi.html#gac8aca397e32ca33618d8024bff32948c" title="Create a numeral of a given sort.">Z3_mk_numeral</a>(Z3_context c, <span class="keyword">const</span> <span class="keywordtype">char</span>* n, Z3_sort ty) {
<a name="l01011"></a>01011         LOG_Z3_mk_numeral(c, n, ty);
<a name="l01012"></a>01012         RESET_ERROR_CODE();          
<a name="l01013"></a>01013         <span class="keywordflow">if</span> (!check_numeral_sort(c, ty)) {
<a name="l01014"></a>01014             RETURN_Z3(0);
<a name="l01015"></a>01015         }
<a name="l01016"></a>01016         <span class="keywordflow">if</span> (!n) {
<a name="l01017"></a>01017             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01018"></a>01018             RETURN_Z3(0);
<a name="l01019"></a>01019         }
<a name="l01020"></a>01020         std::string fixed_num;
<a name="l01021"></a>01021         <span class="keywordtype">char</span> <span class="keyword">const</span>* m = n;
<a name="l01022"></a>01022         <span class="keywordflow">while</span> (*m) {
<a name="l01023"></a>01023             <span class="keywordflow">if</span> (!((<span class="charliteral">&#39;0&#39;</span> &lt;= *m &amp;&amp; *m &lt;= <span class="charliteral">&#39;9&#39;</span>) ||
<a name="l01024"></a>01024                   (<span class="charliteral">&#39;/&#39;</span> == *m) || (<span class="charliteral">&#39;-&#39;</span> == *m) ||
<a name="l01025"></a>01025                   (<span class="charliteral">&#39; &#39;</span> == *m) || (<span class="charliteral">&#39;\n&#39;</span> == *m) ||
<a name="l01026"></a>01026                   (<span class="charliteral">&#39;.&#39;</span> == *m))) {
<a name="l01027"></a>01027                 fatal_error_msg(<span class="stringliteral">&quot;Illegal character &#39;%c&#39;; expecting rational numeral&quot;</span>, *m);
<a name="l01028"></a>01028                 SET_ERROR_CODE(Z3_PARSER_ERROR);
<a name="l01029"></a>01029                 <span class="keywordflow">return</span> 0;
<a name="l01030"></a>01030             }
<a name="l01031"></a>01031             ++m;
<a name="l01032"></a>01032         }
<a name="l01033"></a>01033         ast * a = mk_c(c)-&gt;mk_numeral_core(rational(n), to_sort(ty));
<a name="l01034"></a>01034         RETURN_Z3(of_ast(a));
<a name="l01035"></a>01035     }
<a name="l01036"></a>01036     
<a name="l01037"></a><a class="code" href="group__capi.html#gabe0bbc1e01a084a75506a62e5e6900b3">01037</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#gabe0bbc1e01a084a75506a62e5e6900b3" title="Create a real from a fraction.">Z3_mk_real</a>(__in Z3_context c, __in_z <span class="keywordtype">int</span> num, __in_z <span class="keywordtype">int</span> den) {
<a name="l01038"></a>01038         LOG_Z3_mk_real(c, num, den);
<a name="l01039"></a>01039         RESET_ERROR_CODE();          
<a name="l01040"></a>01040         <span class="keywordflow">if</span> (den == 0) {
<a name="l01041"></a>01041             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01042"></a>01042             RETURN_Z3(0);
<a name="l01043"></a>01043         }
<a name="l01044"></a>01044         sort* s = mk_c(c)-&gt;m_manager.mk_sort(mk_c(c)-&gt;m_arith_fid, REAL_SORT);
<a name="l01045"></a>01045         ast* a = mk_c(c)-&gt;mk_numeral_core(rational(num, den), s);
<a name="l01046"></a>01046         RETURN_Z3(of_ast(a));
<a name="l01047"></a>01047     }
<a name="l01048"></a>01048 
<a name="l01049"></a>01049     Z3_ast Z3_API <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(Z3_context c, <span class="keywordtype">int</span> value, Z3_sort ty) {
<a name="l01050"></a>01050         LOG_Z3_mk_int(c, value, ty);
<a name="l01051"></a>01051         RESET_ERROR_CODE();  
<a name="l01052"></a>01052         <span class="keywordflow">if</span> (!check_numeral_sort(c, ty)) {
<a name="l01053"></a>01053             RETURN_Z3(0);
<a name="l01054"></a>01054         }
<a name="l01055"></a>01055         ast * a = mk_c(c)-&gt;mk_numeral_core(rational(value), to_sort(ty));
<a name="l01056"></a>01056         RETURN_Z3(of_ast(a)); 
<a name="l01057"></a>01057     }
<a name="l01058"></a>01058     
<a name="l01059"></a>01059     Z3_ast Z3_API <a class="code" href="group__capi.html#ga7201b6231b61421c005457206760a121" title="Create a numeral of a given sort.">Z3_mk_unsigned_int</a>(Z3_context c, <span class="keywordtype">unsigned</span> value, Z3_sort ty) {
<a name="l01060"></a>01060         LOG_Z3_mk_unsigned_int(c, value, ty);
<a name="l01061"></a>01061         RESET_ERROR_CODE();   
<a name="l01062"></a>01062         <span class="keywordflow">if</span> (!check_numeral_sort(c, ty)) {
<a name="l01063"></a>01063             RETURN_Z3(0);
<a name="l01064"></a>01064         }
<a name="l01065"></a>01065         ast * a = mk_c(c)-&gt;mk_numeral_core(rational(value), to_sort(ty));
<a name="l01066"></a>01066         RETURN_Z3(of_ast(a));
<a name="l01067"></a>01067     }
<a name="l01068"></a>01068     
<a name="l01069"></a>01069     Z3_ast Z3_API <a class="code" href="group__capi.html#ga42cc319787d485d9cb665d80e02d206f" title="Create a numeral of a given sort.">Z3_mk_int64</a>(Z3_context c, <span class="keywordtype">long</span> <span class="keywordtype">long</span> value, Z3_sort ty) {
<a name="l01070"></a>01070         LOG_Z3_mk_int64(c, value, ty);
<a name="l01071"></a>01071         RESET_ERROR_CODE();  
<a name="l01072"></a>01072         <span class="keywordflow">if</span> (!check_numeral_sort(c, ty)) {
<a name="l01073"></a>01073             RETURN_Z3(0);
<a name="l01074"></a>01074         }
<a name="l01075"></a>01075         rational n(value, rational::i64());
<a name="l01076"></a>01076         ast* a = mk_c(c)-&gt;mk_numeral_core(n, to_sort(ty));
<a name="l01077"></a>01077         RETURN_Z3(of_ast(a));
<a name="l01078"></a>01078     }
<a name="l01079"></a>01079     
<a name="l01080"></a>01080     Z3_ast Z3_API <a class="code" href="group__capi.html#ga88a165138162a8bac401672f0a1b7891" title="Create a numeral of a given sort.">Z3_mk_unsigned_int64</a>(Z3_context c, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> value, Z3_sort ty) {
<a name="l01081"></a>01081         LOG_Z3_mk_unsigned_int64(c, value, ty);
<a name="l01082"></a>01082         RESET_ERROR_CODE(); 
<a name="l01083"></a>01083         <span class="keywordflow">if</span> (!check_numeral_sort(c, ty)) {
<a name="l01084"></a>01084             RETURN_Z3(0);
<a name="l01085"></a>01085         }
<a name="l01086"></a>01086         rational n(value, rational::ui64());
<a name="l01087"></a>01087         ast * a = mk_c(c)-&gt;mk_numeral_core(n, to_sort(ty));
<a name="l01088"></a>01088         RETURN_Z3(of_ast(a));
<a name="l01089"></a>01089     }
<a name="l01090"></a>01090 
<a name="l01091"></a>01091     Z3_ast Z3_API <a class="code" href="group__capi.html#ga784ca1c49cd9f6a97071dcd68103e2d1" title="Create a quantifier - universal or existential, with pattern hints.">Z3_mk_quantifier</a>(
<a name="l01092"></a>01092         Z3_context c, 
<a name="l01093"></a>01093         <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> is_forall, 
<a name="l01094"></a>01094         <span class="keywordtype">unsigned</span> weight, 
<a name="l01095"></a>01095         <span class="keywordtype">unsigned</span> num_patterns, Z3_pattern <span class="keyword">const</span> patterns[], 
<a name="l01096"></a>01096         <span class="keywordtype">unsigned</span> num_decls, Z3_sort <span class="keyword">const</span> sorts[], 
<a name="l01097"></a>01097         Z3_symbol <span class="keyword">const</span> decl_names[], 
<a name="l01098"></a>01098         Z3_ast body) 
<a name="l01099"></a>01099     {
<a name="l01100"></a>01100         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga6f6dac9e028f5cf9c7bc89288bbdcf64" title="Create a quantifier - universal or existential, with pattern hints, no patterns,...">Z3_mk_quantifier_ex</a>(
<a name="l01101"></a>01101             c, 
<a name="l01102"></a>01102             is_forall, 
<a name="l01103"></a>01103             weight,
<a name="l01104"></a>01104             0,
<a name="l01105"></a>01105             0,
<a name="l01106"></a>01106             num_patterns, patterns,
<a name="l01107"></a>01107             0, 0,
<a name="l01108"></a>01108             num_decls, sorts,
<a name="l01109"></a>01109             decl_names,
<a name="l01110"></a>01110             body
<a name="l01111"></a>01111             );
<a name="l01112"></a>01112 
<a name="l01113"></a>01113     }
<a name="l01114"></a>01114 
<a name="l01115"></a>01115     Z3_ast mk_quantifier_ex_core(
<a name="l01116"></a>01116         __in Z3_context c, 
<a name="l01117"></a>01117         __in <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> is_forall, 
<a name="l01118"></a>01118         __in <span class="keywordtype">unsigned</span> weight, 
<a name="l01119"></a>01119         __in Z3_symbol quantifier_id,
<a name="l01120"></a>01120         __in Z3_symbol skolem_id,
<a name="l01121"></a>01121         __in <span class="keywordtype">unsigned</span> num_patterns, __in_ecount(num_patterns) Z3_pattern <span class="keyword">const</span> patterns[], 
<a name="l01122"></a>01122         __in <span class="keywordtype">unsigned</span> num_no_patterns, __in_ecount(num_no_patterns) Z3_ast <span class="keyword">const</span> no_patterns[], 
<a name="l01123"></a>01123         __in <span class="keywordtype">unsigned</span> num_decls, __in_ecount(num_decls) Z3_sort <span class="keyword">const</span> sorts[], 
<a name="l01124"></a>01124         __in_ecount(num_decls) Z3_symbol <span class="keyword">const</span> decl_names[], 
<a name="l01125"></a>01125         __in Z3_ast body) {
<a name="l01126"></a>01126 
<a name="l01127"></a>01127         RESET_ERROR_CODE();
<a name="l01128"></a>01128         <span class="keywordflow">if</span> (!mk_c(c)-&gt;m_manager.is_bool(to_expr(body))) {
<a name="l01129"></a>01129             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l01130"></a>01130         }
<a name="l01131"></a>01131         <span class="keywordflow">if</span> (num_patterns &gt; 0 &amp;&amp; num_no_patterns &gt; 0) {
<a name="l01132"></a>01132             SET_ERROR_CODE(Z3_INVALID_USAGE);
<a name="l01133"></a>01133         }
<a name="l01134"></a>01134         expr * <span class="keyword">const</span>* ps = <span class="keyword">reinterpret_cast&lt;</span>expr * const*<span class="keyword">&gt;</span>(patterns);
<a name="l01135"></a>01135         expr * <span class="keyword">const</span>* no_ps = <span class="keyword">reinterpret_cast&lt;</span>expr * const*<span class="keyword">&gt;</span>(no_patterns);
<a name="l01136"></a>01136         pattern_validator v(mk_c(c)-&gt;m_manager);
<a name="l01137"></a>01137         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_patterns; i++) {
<a name="l01138"></a>01138             <span class="keywordflow">if</span> (!v(num_decls, ps[i])) {
<a name="l01139"></a>01139                 SET_ERROR_CODE(Z3_INVALID_PATTERN);
<a name="l01140"></a>01140                 <span class="keywordflow">return</span> 0;
<a name="l01141"></a>01141             }
<a name="l01142"></a>01142         }
<a name="l01143"></a>01143 
<a name="l01144"></a>01144         sort* <span class="keyword">const</span>* ts = <span class="keyword">reinterpret_cast&lt;</span>sort * const*<span class="keyword">&gt;</span>(sorts);
<a name="l01145"></a>01145         svector&lt;symbol&gt; names;
<a name="l01146"></a>01146         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_decls; ++i) {
<a name="l01147"></a>01147             names.push_back(to_symbol(decl_names[i]));
<a name="l01148"></a>01148         }
<a name="l01149"></a>01149         expr_ref result(mk_c(c)-&gt;m_manager);
<a name="l01150"></a>01150         <span class="keywordflow">if</span> (num_decls &gt; 0) {
<a name="l01151"></a>01151             result = mk_c(c)-&gt;m_manager.mk_quantifier(
<a name="l01152"></a>01152                 (0 != is_forall), 
<a name="l01153"></a>01153                 names.size(), ts, names.c_ptr(), to_expr(body),            
<a name="l01154"></a>01154                 weight, 
<a name="l01155"></a>01155                 to_symbol(quantifier_id),
<a name="l01156"></a>01156                 to_symbol(skolem_id),
<a name="l01157"></a>01157                 num_patterns, ps,
<a name="l01158"></a>01158                 num_no_patterns, no_ps
<a name="l01159"></a>01159                 );
<a name="l01160"></a>01160         }
<a name="l01161"></a>01161         <span class="keywordflow">else</span> {
<a name="l01162"></a>01162             result = to_expr(body);
<a name="l01163"></a>01163         }
<a name="l01164"></a>01164         mk_c(c)-&gt;save_ast_trail(result.get());
<a name="l01165"></a>01165         <span class="keywordflow">return</span> of_ast(result.get());
<a name="l01166"></a>01166     }
<a name="l01167"></a>01167 
<a name="l01168"></a><a class="code" href="group__capi.html#ga6f6dac9e028f5cf9c7bc89288bbdcf64">01168</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga6f6dac9e028f5cf9c7bc89288bbdcf64" title="Create a quantifier - universal or existential, with pattern hints, no patterns,...">Z3_mk_quantifier_ex</a>(
<a name="l01169"></a>01169         __in Z3_context c, 
<a name="l01170"></a>01170         __in <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> is_forall, 
<a name="l01171"></a>01171         __in <span class="keywordtype">unsigned</span> weight, 
<a name="l01172"></a>01172         __in Z3_symbol quantifier_id,
<a name="l01173"></a>01173         __in Z3_symbol skolem_id,
<a name="l01174"></a>01174         __in <span class="keywordtype">unsigned</span> num_patterns, __in_ecount(num_patterns) Z3_pattern <span class="keyword">const</span> patterns[], 
<a name="l01175"></a>01175         __in <span class="keywordtype">unsigned</span> num_no_patterns, __in_ecount(num_no_patterns) Z3_ast <span class="keyword">const</span> no_patterns[], 
<a name="l01176"></a>01176         __in <span class="keywordtype">unsigned</span> num_decls, __in_ecount(num_decls) Z3_sort <span class="keyword">const</span> sorts[], 
<a name="l01177"></a>01177         __in_ecount(num_decls) Z3_symbol <span class="keyword">const</span> decl_names[], 
<a name="l01178"></a>01178         __in Z3_ast body)
<a name="l01179"></a>01179     {
<a name="l01180"></a>01180         LOG_Z3_mk_quantifier_ex(c, is_forall, weight, quantifier_id, skolem_id, num_patterns, patterns, 
<a name="l01181"></a>01181                                 num_no_patterns, no_patterns, num_decls, sorts, decl_names, body);
<a name="l01182"></a>01182         Z3_ast r = mk_quantifier_ex_core(c, is_forall, weight, quantifier_id, skolem_id, num_patterns, patterns, 
<a name="l01183"></a>01183                                          num_no_patterns, no_patterns, num_decls, sorts, decl_names, body);
<a name="l01184"></a>01184         RETURN_Z3(r);
<a name="l01185"></a>01185     }
<a name="l01186"></a>01186     
<a name="l01187"></a>01187     Z3_ast Z3_API <a class="code" href="group__capi.html#ga7e975b7d7ac96de1db73d8f71166c663" title="Create a forall formula.">Z3_mk_forall</a>(Z3_context c, 
<a name="l01188"></a>01188                                <span class="keywordtype">unsigned</span> weight, 
<a name="l01189"></a>01189                                <span class="keywordtype">unsigned</span> num_patterns, Z3_pattern <span class="keyword">const</span> patterns[], 
<a name="l01190"></a>01190                                <span class="keywordtype">unsigned</span> num_decls, Z3_sort <span class="keyword">const</span> types[], 
<a name="l01191"></a>01191                                Z3_symbol <span class="keyword">const</span> decl_names[], 
<a name="l01192"></a>01192                                Z3_ast body) {
<a name="l01193"></a>01193         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga784ca1c49cd9f6a97071dcd68103e2d1" title="Create a quantifier - universal or existential, with pattern hints.">Z3_mk_quantifier</a>(c, 1, weight, num_patterns, patterns, num_decls, types, decl_names, body);
<a name="l01194"></a>01194     }
<a name="l01195"></a>01195     
<a name="l01196"></a>01196     Z3_ast Z3_API <a class="code" href="group__capi.html#ga4ffce34ff9117e6243283f11d87c1407" title="Create an exists formula. Similar to Z3_mk_forall.">Z3_mk_exists</a>(Z3_context c, 
<a name="l01197"></a>01197                                <span class="keywordtype">unsigned</span> weight, 
<a name="l01198"></a>01198                                <span class="keywordtype">unsigned</span> num_patterns, Z3_pattern <span class="keyword">const</span> patterns[], 
<a name="l01199"></a>01199                                <span class="keywordtype">unsigned</span> num_decls, Z3_sort <span class="keyword">const</span> types[], 
<a name="l01200"></a>01200                                Z3_symbol <span class="keyword">const</span> decl_names[], 
<a name="l01201"></a>01201                                Z3_ast body) {
<a name="l01202"></a>01202         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga784ca1c49cd9f6a97071dcd68103e2d1" title="Create a quantifier - universal or existential, with pattern hints.">Z3_mk_quantifier</a>(c, 0, weight, num_patterns, patterns, num_decls, types, decl_names, body);
<a name="l01203"></a>01203     }
<a name="l01204"></a>01204 
<a name="l01205"></a>01205 
<a name="l01206"></a>01206     Z3_ast Z3_API <a class="code" href="group__capi.html#gab64af4d3c7e346b10ac7b1ef008fb360" title="Create a universal or existential quantifier using a list of constants that will...">Z3_mk_quantifier_const_ex</a>(__in Z3_context c, 
<a name="l01207"></a>01207                                             <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> is_forall,
<a name="l01208"></a>01208                                             <span class="keywordtype">unsigned</span> weight,
<a name="l01209"></a>01209                                             __in Z3_symbol quantifier_id,
<a name="l01210"></a>01210                                             __in Z3_symbol skolem_id,
<a name="l01211"></a>01211                                             <span class="keywordtype">unsigned</span> num_bound,
<a name="l01212"></a>01212                                             __in Z3_app <span class="keyword">const</span> bound[],
<a name="l01213"></a>01213                                             <span class="keywordtype">unsigned</span> num_patterns,
<a name="l01214"></a>01214                                             __in Z3_pattern <span class="keyword">const</span> patterns[],
<a name="l01215"></a>01215                                             <span class="keywordtype">unsigned</span> num_no_patterns,
<a name="l01216"></a>01216                                             __in Z3_ast <span class="keyword">const</span> no_patterns[],
<a name="l01217"></a>01217                                             __in Z3_ast body) {
<a name="l01218"></a>01218         LOG_Z3_mk_quantifier_const_ex(c, is_forall, weight, quantifier_id, skolem_id, num_bound, bound, num_patterns, patterns,
<a name="l01219"></a>01219                                       num_no_patterns, no_patterns, body);
<a name="l01220"></a>01220         svector&lt;Z3_symbol&gt; names;
<a name="l01221"></a>01221         svector&lt;Z3_sort&gt; types;
<a name="l01222"></a>01222         ptr_vector&lt;expr&gt; bound_asts;
<a name="l01223"></a>01223         <span class="keywordflow">if</span> (num_patterns &gt; 0 &amp;&amp; num_no_patterns &gt; 0) {
<a name="l01224"></a>01224             SET_ERROR_CODE(Z3_INVALID_USAGE);
<a name="l01225"></a>01225         }
<a name="l01226"></a>01226         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_bound; ++i) {
<a name="l01227"></a>01227             app* a = to_app(bound[i]);
<a name="l01228"></a>01228             SASSERT(a-&gt;get_kind() == AST_APP);
<a name="l01229"></a>01229             symbol s(to_app(a)-&gt;get_decl()-&gt;get_name());
<a name="l01230"></a>01230             names.push_back(of_symbol(s));
<a name="l01231"></a>01231             types.push_back(of_sort(mk_c(c)-&gt;m_manager.get_sort(a)));
<a name="l01232"></a>01232             bound_asts.push_back(a);
<a name="l01233"></a>01233         }
<a name="l01234"></a>01234         <span class="comment">// Abstract patterns</span>
<a name="l01235"></a>01235         svector&lt;Z3_pattern&gt; _patterns;
<a name="l01236"></a>01236         expr_ref_vector pinned(mk_c(c)-&gt;m_manager);
<a name="l01237"></a>01237         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_patterns; ++i) {
<a name="l01238"></a>01238             expr_ref result(mk_c(c)-&gt;m_manager);
<a name="l01239"></a>01239             app* pat = to_pattern(patterns[i]);
<a name="l01240"></a>01240             SASSERT(mk_c(c)-&gt;m_manager.is_pattern(pat));
<a name="l01241"></a>01241             expr_abstract(mk_c(c)-&gt;m_manager, 0, num_bound, bound_asts.c_ptr(), pat, result);
<a name="l01242"></a>01242             SASSERT(result.get()-&gt;get_kind() == AST_APP);        
<a name="l01243"></a>01243             pinned.push_back(result.get());
<a name="l01244"></a>01244             SASSERT(mk_c(c)-&gt;m_manager.is_pattern(result.get()));
<a name="l01245"></a>01245             _patterns.push_back(of_pattern(result.get()));
<a name="l01246"></a>01246         }
<a name="l01247"></a>01247         svector&lt;Z3_ast&gt; _no_patterns;
<a name="l01248"></a>01248         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_no_patterns; ++i) {
<a name="l01249"></a>01249             expr_ref result(mk_c(c)-&gt;m_manager);
<a name="l01250"></a>01250             <span class="keywordflow">if</span> (!is_app(to_expr(no_patterns[i]))) {
<a name="l01251"></a>01251                 SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01252"></a>01252                 RETURN_Z3(0);
<a name="l01253"></a>01253             }
<a name="l01254"></a>01254             app* pat = to_app(to_expr(no_patterns[i]));
<a name="l01255"></a>01255             expr_abstract(mk_c(c)-&gt;m_manager, 0, num_bound, bound_asts.c_ptr(), pat, result);
<a name="l01256"></a>01256             SASSERT(result.get()-&gt;get_kind() == AST_APP);        
<a name="l01257"></a>01257             pinned.push_back(result.get());
<a name="l01258"></a>01258             _no_patterns.push_back(of_ast(result.get()));
<a name="l01259"></a>01259         }
<a name="l01260"></a>01260         expr_ref abs_body(mk_c(c)-&gt;m_manager);
<a name="l01261"></a>01261         expr_abstract(mk_c(c)-&gt;m_manager, 0, num_bound, bound_asts.c_ptr(), to_expr(body), abs_body);
<a name="l01262"></a>01262 
<a name="l01263"></a>01263         Z3_ast result = mk_quantifier_ex_core(c, is_forall, weight, 
<a name="l01264"></a>01264                                               quantifier_id,
<a name="l01265"></a>01265                                               skolem_id,
<a name="l01266"></a>01266                                               num_patterns, _patterns.c_ptr(), 
<a name="l01267"></a>01267                                               num_no_patterns, _no_patterns.c_ptr(),
<a name="l01268"></a>01268                                               names.size(), types.c_ptr(), names.c_ptr(), 
<a name="l01269"></a>01269                                               of_ast(abs_body.get()));
<a name="l01270"></a>01270         RETURN_Z3(result);
<a name="l01271"></a>01271     }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273     Z3_ast Z3_API <a class="code" href="group__capi.html#gacc58526413077544d7161575d94f9dad" title="Create a universal or existential quantifier using a list of constants that will...">Z3_mk_quantifier_const</a>(__in Z3_context c, 
<a name="l01274"></a>01274                                          <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> is_forall,
<a name="l01275"></a>01275                                          <span class="keywordtype">unsigned</span> weight,
<a name="l01276"></a>01276                                          <span class="keywordtype">unsigned</span> num_bound,
<a name="l01277"></a>01277                                          __in Z3_app <span class="keyword">const</span> bound[],
<a name="l01278"></a>01278                                          <span class="keywordtype">unsigned</span> num_patterns,
<a name="l01279"></a>01279                                          __in Z3_pattern <span class="keyword">const</span> patterns[],
<a name="l01280"></a>01280                                          __in Z3_ast body) {
<a name="l01281"></a>01281         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gab64af4d3c7e346b10ac7b1ef008fb360" title="Create a universal or existential quantifier using a list of constants that will...">Z3_mk_quantifier_const_ex</a>(c, is_forall, weight, 0, 0, 
<a name="l01282"></a>01282                                          num_bound, bound, 
<a name="l01283"></a>01283                                          num_patterns, patterns,
<a name="l01284"></a>01284                                          0, 0,
<a name="l01285"></a>01285                                          body);
<a name="l01286"></a>01286     }
<a name="l01287"></a>01287 
<a name="l01288"></a>01288     Z3_ast Z3_API <a class="code" href="group__capi.html#gabdb40b3ac220bce5a3801e6d29fb3bb6" title="Create a universal quantifier using a list of constants that will form the set of...">Z3_mk_forall_const</a>(__in Z3_context c, 
<a name="l01289"></a>01289                                      <span class="keywordtype">unsigned</span> weight,
<a name="l01290"></a>01290                                      <span class="keywordtype">unsigned</span> num_bound,
<a name="l01291"></a>01291                                      __in Z3_app <span class="keyword">const</span> bound[],
<a name="l01292"></a>01292                                      <span class="keywordtype">unsigned</span> num_patterns,
<a name="l01293"></a>01293                                      __in Z3_pattern <span class="keyword">const</span> patterns[],
<a name="l01294"></a>01294                                      __in Z3_ast body) {
<a name="l01295"></a>01295         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gacc58526413077544d7161575d94f9dad" title="Create a universal or existential quantifier using a list of constants that will...">Z3_mk_quantifier_const</a>(c, <span class="keyword">true</span>, weight, num_bound, bound, num_patterns, patterns, body);
<a name="l01296"></a>01296     }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298     Z3_ast Z3_API <a class="code" href="group__capi.html#ga2011bea0f4445d58ec4d7cefe4499ceb" title="Similar to Z3_mk_forall_const.">Z3_mk_exists_const</a>(__in Z3_context c, 
<a name="l01299"></a>01299                                      <span class="keywordtype">unsigned</span> weight,
<a name="l01300"></a>01300                                      <span class="keywordtype">unsigned</span> num_bound,
<a name="l01301"></a>01301                                      __in Z3_app <span class="keyword">const</span> bound[],
<a name="l01302"></a>01302                                      <span class="keywordtype">unsigned</span> num_patterns,
<a name="l01303"></a>01303                                      __in Z3_pattern <span class="keyword">const</span> patterns[],
<a name="l01304"></a>01304                                      __in Z3_ast body) {
<a name="l01305"></a>01305         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gacc58526413077544d7161575d94f9dad" title="Create a universal or existential quantifier using a list of constants that will...">Z3_mk_quantifier_const</a>(c, <span class="keyword">false</span>, weight, num_bound, bound, num_patterns, patterns, body);
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307     
<a name="l01308"></a>01308     Z3_pattern Z3_API <a class="code" href="group__capi.html#gaf15c95b66dc3b0af735774ee401a6f85" title="Create a pattern for quantifier instantiation.">Z3_mk_pattern</a>(Z3_context c, <span class="keywordtype">unsigned</span> num_patterns, Z3_ast <span class="keyword">const</span> terms[]) {
<a name="l01309"></a>01309         LOG_Z3_mk_pattern(c, num_patterns, terms);
<a name="l01310"></a>01310         RESET_ERROR_CODE();
<a name="l01311"></a>01311         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_patterns; ++i) {
<a name="l01312"></a>01312             <span class="keywordflow">if</span> (!is_app(to_expr(terms[i]))) {
<a name="l01313"></a>01313                 SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01314"></a>01314                 RETURN_Z3(0);
<a name="l01315"></a>01315             }
<a name="l01316"></a>01316         }
<a name="l01317"></a>01317         app* a = mk_c(c)-&gt;m_manager.mk_pattern(num_patterns, reinterpret_cast&lt;app*const*&gt;(to_exprs(terms)));
<a name="l01318"></a>01318         mk_c(c)-&gt;save_ast_trail(a);
<a name="l01319"></a>01319         RETURN_Z3(of_pattern(a));
<a name="l01320"></a>01320     }
<a name="l01321"></a>01321     
<a name="l01322"></a>01322     Z3_ast Z3_API <a class="code" href="group__capi.html#ga1d4da8849fca699b345322f8ee1fa31e" title="Create a bound variable.">Z3_mk_bound</a>(Z3_context c, <span class="keywordtype">unsigned</span> index, Z3_sort ty) {
<a name="l01323"></a>01323         LOG_Z3_mk_bound(c, index, ty);
<a name="l01324"></a>01324         RESET_ERROR_CODE();
<a name="l01325"></a>01325         ast* a = mk_c(c)-&gt;m_manager.mk_var(index, to_sort(ty));
<a name="l01326"></a>01326         mk_c(c)-&gt;save_ast_trail(a);
<a name="l01327"></a>01327         RETURN_Z3(of_ast(a));
<a name="l01328"></a>01328     }
<a name="l01329"></a>01329     
<a name="l01330"></a>01330     Z3_ast Z3_API <a class="code" href="group__capi.html#gae898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(Z3_context c) {
<a name="l01331"></a>01331         LOG_Z3_mk_true(c);
<a name="l01332"></a>01332         RESET_ERROR_CODE();
<a name="l01333"></a>01333         Z3_ast r = of_ast(mk_c(c)-&gt;m_manager.mk_true());
<a name="l01334"></a>01334         RETURN_Z3(r);
<a name="l01335"></a>01335     }
<a name="l01336"></a>01336     
<a name="l01337"></a>01337     Z3_ast Z3_API <a class="code" href="group__capi.html#ga5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(Z3_context c) {
<a name="l01338"></a>01338         LOG_Z3_mk_false(c);
<a name="l01339"></a>01339         RESET_ERROR_CODE();
<a name="l01340"></a>01340         Z3_ast r = of_ast(mk_c(c)-&gt;m_manager.mk_false());
<a name="l01341"></a>01341         RETURN_Z3(r);
<a name="l01342"></a>01342     }
<a name="l01343"></a>01343 
<a name="l01344"></a>01344 <span class="preprocessor">#define SKIP ((void) 0)</span>
<a name="l01345"></a>01345 <span class="preprocessor"></span>
<a name="l01346"></a>01346 <span class="preprocessor">#define MK_UNARY_BODY(NAME, FID, OP, EXTRA_CODE)                \</span>
<a name="l01347"></a>01347 <span class="preprocessor">    RESET_ERROR_CODE();                                         \</span>
<a name="l01348"></a>01348 <span class="preprocessor">    EXTRA_CODE;                                                 \</span>
<a name="l01349"></a>01349 <span class="preprocessor">    expr * _n = to_expr(n);                                     \</span>
<a name="l01350"></a>01350 <span class="preprocessor">    ast* a = mk_c(c)-&gt;m_manager.mk_app(FID, OP, 0, 0, 1, &amp;_n);  \</span>
<a name="l01351"></a>01351 <span class="preprocessor">    mk_c(c)-&gt;save_ast_trail(a);                                 \</span>
<a name="l01352"></a>01352 <span class="preprocessor">    check_sorts(c, a);                                          \</span>
<a name="l01353"></a>01353 <span class="preprocessor">    RETURN_Z3(of_ast(a));          </span>
<a name="l01354"></a>01354 <span class="preprocessor"></span>
<a name="l01355"></a>01355 <span class="preprocessor">#define MK_UNARY(NAME, FID, OP, EXTRA_CODE)     \</span>
<a name="l01356"></a>01356 <span class="preprocessor">Z3_ast Z3_API NAME(Z3_context c, Z3_ast n) {    \</span>
<a name="l01357"></a>01357 <span class="preprocessor">    LOG_ ## NAME(c, n);                         \</span>
<a name="l01358"></a>01358 <span class="preprocessor">    MK_UNARY_BODY(NAME, FID, OP, EXTRA_CODE);   \</span>
<a name="l01359"></a>01359 <span class="preprocessor">}</span>
<a name="l01360"></a>01360 <span class="preprocessor"></span>
<a name="l01361"></a>01361 <span class="preprocessor">#define MK_BINARY_BODY(NAME, FID, OP, EXTRA_CODE)               \</span>
<a name="l01362"></a>01362 <span class="preprocessor">    RESET_ERROR_CODE();                                         \</span>
<a name="l01363"></a>01363 <span class="preprocessor">    EXTRA_CODE;                                                 \</span>
<a name="l01364"></a>01364 <span class="preprocessor">    expr * args[2] = { to_expr(n1), to_expr(n2) };              \</span>
<a name="l01365"></a>01365 <span class="preprocessor">    ast* a = mk_c(c)-&gt;m_manager.mk_app(FID, OP, 0, 0, 2, args); \</span>
<a name="l01366"></a>01366 <span class="preprocessor">    mk_c(c)-&gt;save_ast_trail(a);                                 \</span>
<a name="l01367"></a>01367 <span class="preprocessor">    check_sorts(c, a);                                          \</span>
<a name="l01368"></a>01368 <span class="preprocessor">    RETURN_Z3(of_ast(a));</span>
<a name="l01369"></a>01369 <span class="preprocessor"></span>
<a name="l01370"></a>01370 <span class="preprocessor">#define MK_BINARY(NAME, FID, OP, EXTRA_CODE)                    \</span>
<a name="l01371"></a>01371 <span class="preprocessor">Z3_ast Z3_API NAME(Z3_context c, Z3_ast n1, Z3_ast n2) {        \</span>
<a name="l01372"></a>01372 <span class="preprocessor">    LOG_ ## NAME(c, n1, n2);                                    \</span>
<a name="l01373"></a>01373 <span class="preprocessor">    MK_BINARY_BODY(NAME, FID, OP, EXTRA_CODE);                  \</span>
<a name="l01374"></a>01374 <span class="preprocessor">}</span>
<a name="l01375"></a>01375 <span class="preprocessor"></span>
<a name="l01376"></a>01376 <span class="preprocessor">#define MK_NARY(NAME, FID, OP, EXTRA_CODE)                                              \</span>
<a name="l01377"></a>01377 <span class="preprocessor">Z3_ast Z3_API NAME(Z3_context c, unsigned num_args, Z3_ast const* args) {               \</span>
<a name="l01378"></a>01378 <span class="preprocessor">    LOG_ ## NAME(c, num_args, args);                                                    \</span>
<a name="l01379"></a>01379 <span class="preprocessor">    RESET_ERROR_CODE();                                                                 \</span>
<a name="l01380"></a>01380 <span class="preprocessor">    EXTRA_CODE;                                                                         \</span>
<a name="l01381"></a>01381 <span class="preprocessor">    ast* a = mk_c(c)-&gt;m_manager.mk_app(FID, OP, 0, 0, num_args, to_exprs(args));        \</span>
<a name="l01382"></a>01382 <span class="preprocessor">    mk_c(c)-&gt;save_ast_trail(a);                                                         \</span>
<a name="l01383"></a>01383 <span class="preprocessor">    check_sorts(c, a);                                                                  \</span>
<a name="l01384"></a>01384 <span class="preprocessor">    RETURN_Z3(of_ast(a));                                                               \</span>
<a name="l01385"></a>01385 <span class="preprocessor">}</span>
<a name="l01386"></a>01386 <span class="preprocessor"></span>
<a name="l01387"></a>01387     MK_UNARY(<a class="code" href="group__capi.html#ga3329538091996eb7b3dc677760a61072" title="Create an AST node representing not(a).">Z3_mk_not</a>, mk_c(c)-&gt;m_basic_fid, OP_NOT, SKIP);
<a name="l01388"></a>01388     MK_BINARY(<a class="code" href="group__capi.html#ga95a19ce675b70e22bb0401f7137af37c" title="Create an AST node representing l = r.">Z3_mk_eq</a>, mk_c(c)-&gt;m_basic_fid, OP_EQ, SKIP);
<a name="l01389"></a>01389     MK_NARY(<a class="code" href="group__capi.html#gaa076d3a668e0ec97d61744403153ecf7" title="Create an AST node representing distinct(args[0], ..., args[num_args-1]).">Z3_mk_distinct</a>, mk_c(c)-&gt;m_basic_fid, OP_DISTINCT, SKIP);
<a name="l01390"></a>01390     MK_BINARY(<a class="code" href="group__capi.html#ga930a8e844d345fbebc498ac43a696042" title="Create an AST node representing t1 iff t2.">Z3_mk_iff</a>, mk_c(c)-&gt;m_basic_fid, OP_IFF, SKIP);
<a name="l01391"></a>01391     MK_BINARY(<a class="code" href="group__capi.html#gac829c0e25bbbd30343bf073f7b524517" title="Create an AST node representing t1 implies t2.">Z3_mk_implies</a>, mk_c(c)-&gt;m_basic_fid, OP_IMPLIES, SKIP);
<a name="l01392"></a>01392     MK_BINARY(<a class="code" href="group__capi.html#gacc6d1b848032dec0c4617b594d4229ec" title="Create an AST node representing t1 xor t2.">Z3_mk_xor</a>, mk_c(c)-&gt;m_basic_fid, OP_XOR, SKIP);
<a name="l01393"></a>01393     MK_NARY(<a class="code" href="group__capi.html#gacde98ce4a8ed1dde50b9669db4838c61" title="Create an AST node representing args[0] and ... and args[num_args-1].">Z3_mk_and</a>, mk_c(c)-&gt;m_basic_fid, OP_AND, SKIP);
<a name="l01394"></a>01394     MK_NARY(<a class="code" href="group__capi.html#ga00866d16331d505620a6c515302021f9" title="Create an AST node representing args[0] or ... or args[num_args-1].">Z3_mk_or</a>, mk_c(c)-&gt;m_basic_fid, OP_OR, SKIP);
<a name="l01395"></a>01395 
<a name="l01396"></a>01396     Z3_ast mk_ite_core(Z3_context c, Z3_ast t1, Z3_ast t2, Z3_ast t3) {
<a name="l01397"></a>01397         expr * result = mk_c(c)-&gt;m_manager.mk_ite(to_expr(t1), to_expr(t2), to_expr(t3));
<a name="l01398"></a>01398         mk_c(c)-&gt;save_ast_trail(result);
<a name="l01399"></a>01399         check_sorts(c, result); 
<a name="l01400"></a>01400         <span class="keywordflow">return</span> of_ast(result);
<a name="l01401"></a>01401     }
<a name="l01402"></a>01402     
<a name="l01403"></a>01403     Z3_ast Z3_API <a class="code" href="group__capi.html#ga94417eed5c36e1ad48bcfc8ad6e83547" title="Create an AST node representing an if-then-else: ite(t1, t2, t3).">Z3_mk_ite</a>(Z3_context c, Z3_ast t1, Z3_ast t2, Z3_ast t3) {
<a name="l01404"></a>01404         LOG_Z3_mk_ite(c, t1, t2, t3);
<a name="l01405"></a>01405         RESET_ERROR_CODE();                                               
<a name="l01406"></a>01406         Z3_ast r = mk_ite_core(c, t1, t2, t3);
<a name="l01407"></a>01407         RETURN_Z3(r);
<a name="l01408"></a>01408     }
<a name="l01409"></a>01409 
<a name="l01410"></a>01410 <span class="comment">// ------------------------</span>
<a name="l01411"></a>01411     
<a name="l01412"></a>01412 <span class="preprocessor">#define MK_ARITH_OP(NAME, OP) MK_NARY(NAME, mk_c(c)-&gt;m_arith_fid, OP, SKIP)</span>
<a name="l01413"></a>01413 <span class="preprocessor"></span><span class="preprocessor">#define MK_BINARY_ARITH_OP(NAME, OP) MK_BINARY(NAME, mk_c(c)-&gt;m_arith_fid, OP, SKIP)</span>
<a name="l01414"></a>01414 <span class="preprocessor"></span><span class="preprocessor">#define MK_ARITH_PRED(NAME, OP) MK_BINARY(NAME, mk_c(c)-&gt;m_arith_fid, OP, SKIP)</span>
<a name="l01415"></a>01415 <span class="preprocessor"></span>    
<a name="l01416"></a>01416     MK_ARITH_OP(<a class="code" href="group__capi.html#ga4e4ac0a4e53eee0b4b0ef159ed7d0cd5" title="Create an AST node representing args[0] + ... + args[num_args-1].">Z3_mk_add</a>, OP_ADD);
<a name="l01417"></a>01417     MK_ARITH_OP(<a class="code" href="group__capi.html#gab9affbf8401a18eea474b59ad4adc890" title="Create an AST node representing args[0] * ... * args[num_args-1].">Z3_mk_mul</a>, OP_MUL);
<a name="l01418"></a>01418     MK_BINARY_ARITH_OP(<a class="code" href="group__capi.html#ga8e350ac77e6b8fe805f57efe196e7713" title="Create an AST node representing arg1 mod arg2.">Z3_mk_mod</a>, OP_MOD);
<a name="l01419"></a>01419     MK_BINARY_ARITH_OP(<a class="code" href="group__capi.html#ga2fcdb17f9039bbdaddf8a30d037bd9ff" title="Create an AST node representing arg1 rem arg2.">Z3_mk_rem</a>, OP_REM);
<a name="l01420"></a>01420 
<a name="l01421"></a>01421     Z3_ast Z3_API <a class="code" href="group__capi.html#ga1ac60ee8307af8d0b900375914194ff3" title="Create an AST node representing arg1 div arg2.">Z3_mk_div</a>(Z3_context c, Z3_ast n1, Z3_ast n2) {                
<a name="l01422"></a>01422         LOG_Z3_mk_div(c, n1, n2);
<a name="l01423"></a>01423         RESET_ERROR_CODE();                                                 
<a name="l01424"></a>01424         decl_kind k = OP_IDIV;
<a name="l01425"></a>01425         sort* ty = mk_c(c)-&gt;m_manager.get_sort(to_expr(n1));
<a name="l01426"></a>01426         sort* real_ty = mk_c(c)-&gt;m_manager.mk_sort(mk_c(c)-&gt;m_arith_fid, REAL_SORT);
<a name="l01427"></a>01427         <span class="keywordflow">if</span> (ty == real_ty) {
<a name="l01428"></a>01428             k = OP_DIV;
<a name="l01429"></a>01429         }
<a name="l01430"></a>01430         expr * args[2] = { to_expr(n1), to_expr(n2) };                         
<a name="l01431"></a>01431         ast* a = mk_c(c)-&gt;m_manager.mk_app(mk_c(c)-&gt;m_arith_fid, k, 0, 0, 2, args);       
<a name="l01432"></a>01432         mk_c(c)-&gt;save_ast_trail(a);                                         
<a name="l01433"></a>01433         check_sorts(c, a);                                                  
<a name="l01434"></a>01434         RETURN_Z3(of_ast(a));
<a name="l01435"></a>01435     }
<a name="l01436"></a>01436 
<a name="l01437"></a>01437     MK_ARITH_PRED(<a class="code" href="group__capi.html#ga58a3dc67c5de52cf599c346803ba1534" title="Create less than.">Z3_mk_lt</a>,  OP_LT);
<a name="l01438"></a>01438     MK_ARITH_PRED(<a class="code" href="group__capi.html#ga46167b86067586bb742c0557d7babfd3" title="Create greater than.">Z3_mk_gt</a>,  OP_GT);
<a name="l01439"></a>01439     MK_ARITH_PRED(<a class="code" href="group__capi.html#gaa9a33d11096841f4e8c407f1578bc0bf" title="Create less than or equal to.">Z3_mk_le</a>,  OP_LE);
<a name="l01440"></a>01440     MK_ARITH_PRED(<a class="code" href="group__capi.html#gad9245cbadb80b192323d01a8360fb942" title="Create greater than or equal to.">Z3_mk_ge</a>,  OP_GE);
<a name="l01441"></a>01441     MK_UNARY(<a class="code" href="group__capi.html#ga7130641e614c7ebafd28ae16a7681a21" title="Coerce an integer to a real.">Z3_mk_int2real</a>, mk_c(c)-&gt;m_arith_fid, OP_TO_REAL, SKIP);
<a name="l01442"></a>01442     MK_UNARY(<a class="code" href="group__capi.html#ga759b6563ba1204aae55289009a3fdc6d" title="Coerce a real to an integer.">Z3_mk_real2int</a>, mk_c(c)-&gt;m_arith_fid, OP_TO_INT, SKIP);
<a name="l01443"></a>01443     MK_UNARY(<a class="code" href="group__capi.html#gaac2ad0fb04e4900fdb4add438d137ad3" title="Check if a real number is an integer.">Z3_mk_is_int</a>,   mk_c(c)-&gt;m_arith_fid, OP_IS_INT, SKIP);
<a name="l01444"></a>01444 
<a name="l01445"></a>01445     
<a name="l01446"></a>01446 <span class="preprocessor">#define MK_BV_UNARY(NAME, OP) MK_UNARY(NAME, mk_c(c)-&gt;m_bv_fid, OP, SKIP)</span>
<a name="l01447"></a>01447 <span class="preprocessor"></span><span class="preprocessor">#define MK_BV_BINARY(NAME, OP) MK_BINARY(NAME, mk_c(c)-&gt;m_bv_fid, OP, SKIP)</span>
<a name="l01448"></a>01448 <span class="preprocessor"></span>    
<a name="l01449"></a>01449     MK_BV_UNARY(<a class="code" href="group__capi.html#ga36cf75c92c54c1ca633a230344f23080" title="Bitwise negation.">Z3_mk_bvnot</a>, OP_BNOT);
<a name="l01450"></a>01450     MK_BV_UNARY(<a class="code" href="group__capi.html#gaccc04f2b58903279b1b3be589b00a7d8" title="Take conjunction of bits in vector, return vector of length 1.">Z3_mk_bvredand</a>, OP_BREDAND);
<a name="l01451"></a>01451     MK_BV_UNARY(<a class="code" href="group__capi.html#gafd18e127c0586abf47ad9cd96895f7d2" title="Take disjunction of bits in vector, return vector of length 1.">Z3_mk_bvredor</a>, OP_BREDOR);
<a name="l01452"></a>01452     MK_BV_BINARY(<a class="code" href="group__capi.html#gab96e0ea55334cbcd5a0e79323b57615d" title="Bitwise and.">Z3_mk_bvand</a>, OP_BAND);
<a name="l01453"></a>01453     MK_BV_BINARY(<a class="code" href="group__capi.html#ga77a6ae233fb3371d187c6d559b2843f5" title="Bitwise or.">Z3_mk_bvor</a>, OP_BOR);
<a name="l01454"></a>01454     MK_BV_BINARY(<a class="code" href="group__capi.html#ga0a3821ea00b1c762205f73e4bc29e7d8" title="Bitwise exclusive-or.">Z3_mk_bvxor</a>, OP_BXOR);
<a name="l01455"></a>01455     MK_BV_BINARY(<a class="code" href="group__capi.html#ga96dc37d36efd658fff5b2b4df49b0e61" title="Bitwise nand.">Z3_mk_bvnand</a>, OP_BNAND);
<a name="l01456"></a>01456     MK_BV_BINARY(<a class="code" href="group__capi.html#gabf15059e9e8a2eafe4929fdfd259aadb" title="Bitwise nor.">Z3_mk_bvnor</a>, OP_BNOR);
<a name="l01457"></a>01457     MK_BV_BINARY(<a class="code" href="group__capi.html#ga784f5ca36a4b03b93c67242cc94b21d6" title="Bitwise xnor.">Z3_mk_bvxnor</a>, OP_BXNOR);
<a name="l01458"></a>01458     MK_BV_BINARY(<a class="code" href="group__capi.html#ga819814e33573f3f9948b32fdc5311158" title="Standard two&amp;#39;s complement addition.">Z3_mk_bvadd</a>, OP_BADD);
<a name="l01459"></a>01459     MK_BV_BINARY(<a class="code" href="group__capi.html#ga6abd3dde2a1ceff1704cf7221a72258c" title="Standard two&amp;#39;s complement multiplication.">Z3_mk_bvmul</a>, OP_BMUL);
<a name="l01460"></a>01460     MK_BV_BINARY(<a class="code" href="group__capi.html#ga56ce0cd61666c6f8cf5777286f590544" title="Unsigned division.">Z3_mk_bvudiv</a>, OP_BUDIV);
<a name="l01461"></a>01461     MK_BV_BINARY(<a class="code" href="group__capi.html#gad240fedb2fda1c1005b8e9d3c7f3d5a0" title="Two&amp;#39;s complement signed division.">Z3_mk_bvsdiv</a>, OP_BSDIV);
<a name="l01462"></a>01462     MK_BV_BINARY(<a class="code" href="group__capi.html#ga5df4298ec835e43ddc9e3e0bae690c8d" title="Unsigned remainder.">Z3_mk_bvurem</a>, OP_BUREM);
<a name="l01463"></a>01463     MK_BV_BINARY(<a class="code" href="group__capi.html#ga46c18a3042fca174fe659d3185693db1" title="Two&amp;#39;s complement signed remainder (sign follows dividend).">Z3_mk_bvsrem</a>, OP_BSREM);
<a name="l01464"></a>01464     MK_BV_BINARY(<a class="code" href="group__capi.html#ga95dac8e6eecb50f63cb82038560e0879" title="Two&amp;#39;s complement signed remainder (sign follows divisor).">Z3_mk_bvsmod</a>, OP_BSMOD);
<a name="l01465"></a>01465     MK_BV_BINARY(<a class="code" href="group__capi.html#gab738b89de0410e70c089d3ac9e696e87" title="Unsigned less than or equal to.">Z3_mk_bvule</a>, OP_ULEQ);
<a name="l01466"></a>01466     MK_BV_BINARY(<a class="code" href="group__capi.html#gab7c026feb93e7d2eab180e96f1e6255d" title="Two&amp;#39;s complement signed less than or equal to.">Z3_mk_bvsle</a>, OP_SLEQ);
<a name="l01467"></a>01467     MK_BV_BINARY(<a class="code" href="group__capi.html#gade58fbfcf61b67bf8c4a441490d3c4df" title="Unsigned greater than or equal to.">Z3_mk_bvuge</a>, OP_UGEQ);
<a name="l01468"></a>01468     MK_BV_BINARY(<a class="code" href="group__capi.html#gaeec3414c0e8a90a6aa5a23af36bf6dc5" title="Two&amp;#39;s complement signed greater than or equal to.">Z3_mk_bvsge</a>, OP_SGEQ);
<a name="l01469"></a>01469     MK_BV_BINARY(<a class="code" href="group__capi.html#ga5774b22e93abcaf9b594672af6c7c3c4" title="Unsigned less than.">Z3_mk_bvult</a>, OP_ULT);
<a name="l01470"></a>01470     MK_BV_BINARY(<a class="code" href="group__capi.html#ga8ce08af4ed1fbdf08d4d6e63d171663a" title="Two&amp;#39;s complement signed less than.">Z3_mk_bvslt</a>, OP_SLT);
<a name="l01471"></a>01471     MK_BV_BINARY(<a class="code" href="group__capi.html#ga063ab9f16246c99e5c1c893613927ee3" title="Unsigned greater than.">Z3_mk_bvugt</a>, OP_UGT);
<a name="l01472"></a>01472     MK_BV_BINARY(<a class="code" href="group__capi.html#ga4e93a985aa2a7812c7c11a2c65d7c5f0" title="Two&amp;#39;s complement signed greater than.">Z3_mk_bvsgt</a>, OP_SGT);
<a name="l01473"></a>01473     MK_BV_BINARY(<a class="code" href="group__capi.html#gae774128fa5e9ff7458a36bd10e6ca0fa" title="Concatenate the given bit-vectors.">Z3_mk_concat</a>, OP_CONCAT);
<a name="l01474"></a>01474     MK_BV_BINARY(<a class="code" href="group__capi.html#gac8d5e776c786c1172fa0d7dfede454e1" title="Shift left.">Z3_mk_bvshl</a>, OP_BSHL);
<a name="l01475"></a>01475     MK_BV_BINARY(<a class="code" href="group__capi.html#gac59645a6edadad79a201f417e4e0c512" title="Logical shift right.">Z3_mk_bvlshr</a>, OP_BLSHR);
<a name="l01476"></a>01476     MK_BV_BINARY(<a class="code" href="group__capi.html#ga674b580ad605ba1c2c9f9d3748be87c4" title="Arithmetic shift right.">Z3_mk_bvashr</a>, OP_BASHR);
<a name="l01477"></a>01477     MK_BV_BINARY(<a class="code" href="group__capi.html#gaf46f1cb80e5a56044591a76e7c89e5e7" title="Rotate bits of t1 to the left t2 times.">Z3_mk_ext_rotate_left</a>, OP_EXT_ROTATE_LEFT);
<a name="l01478"></a>01478     MK_BV_BINARY(<a class="code" href="group__capi.html#gabb227526c592b523879083f12aab281f" title="Rotate bits of t1 to the right t2 times.">Z3_mk_ext_rotate_right</a>, OP_EXT_ROTATE_RIGHT);
<a name="l01479"></a>01479 
<a name="l01480"></a>01480     Z3_ast mk_extract_core(Z3_context c, <span class="keywordtype">unsigned</span> high, <span class="keywordtype">unsigned</span> low, Z3_ast n) {
<a name="l01481"></a>01481         expr * _n = to_expr(n);
<a name="l01482"></a>01482         parameter params[2] = { parameter(high), parameter(low) };
<a name="l01483"></a>01483         expr * a = mk_c(c)-&gt;m_manager.mk_app(mk_c(c)-&gt;m_bv_fid, OP_EXTRACT, 2, params, 1, &amp;_n);
<a name="l01484"></a>01484         mk_c(c)-&gt;save_ast_trail(a);  
<a name="l01485"></a>01485         check_sorts(c, a);
<a name="l01486"></a>01486         <span class="keywordflow">return</span> of_ast(a);
<a name="l01487"></a>01487     }
<a name="l01488"></a>01488     
<a name="l01489"></a>01489     Z3_ast Z3_API <a class="code" href="group__capi.html#ga32d2fe7563f3e6b114c1b97b205d4317" title="Extract the bits high down to low from a bitvector of size m to yield a new bitvector...">Z3_mk_extract</a>(Z3_context c, <span class="keywordtype">unsigned</span> high, <span class="keywordtype">unsigned</span> low, Z3_ast n) {
<a name="l01490"></a>01490         LOG_Z3_mk_extract(c, high, low, n);
<a name="l01491"></a>01491         RESET_ERROR_CODE();
<a name="l01492"></a>01492         Z3_ast r = mk_extract_core(c, high, low, n);
<a name="l01493"></a>01493         RETURN_Z3(r);
<a name="l01494"></a>01494     }
<a name="l01495"></a>01495     
<a name="l01496"></a>01496 <span class="preprocessor">#define MK_BV_PUNARY(NAME, OP)                                                  \</span>
<a name="l01497"></a>01497 <span class="preprocessor">Z3_ast Z3_API NAME(Z3_context c, unsigned i, Z3_ast n) {                        \</span>
<a name="l01498"></a>01498 <span class="preprocessor">    LOG_ ## NAME(c, i, n);                                                      \</span>
<a name="l01499"></a>01499 <span class="preprocessor">    RESET_ERROR_CODE();                                                         \</span>
<a name="l01500"></a>01500 <span class="preprocessor">    expr * _n = to_expr(n);                                                     \</span>
<a name="l01501"></a>01501 <span class="preprocessor">    parameter p(i);                                                             \</span>
<a name="l01502"></a>01502 <span class="preprocessor">    ast* a = mk_c(c)-&gt;m_manager.mk_app(mk_c(c)-&gt;m_bv_fid, OP, 1, &amp;p, 1, &amp;_n);   \</span>
<a name="l01503"></a>01503 <span class="preprocessor">    mk_c(c)-&gt;save_ast_trail(a);                                                 \</span>
<a name="l01504"></a>01504 <span class="preprocessor">    check_sorts(c, a);                                                          \</span>
<a name="l01505"></a>01505 <span class="preprocessor">    RETURN_Z3(of_ast(a));                                                       \</span>
<a name="l01506"></a>01506 <span class="preprocessor">}</span>
<a name="l01507"></a>01507 <span class="preprocessor"></span>
<a name="l01508"></a>01508     MK_BV_PUNARY(<a class="code" href="group__capi.html#gad29099270b36d0680bb54b560353c10e" title="Sign-extend of the given bit-vector to the (signed) equivalent bitvector of size...">Z3_mk_sign_ext</a>, OP_SIGN_EXT);
<a name="l01509"></a>01509     MK_BV_PUNARY(<a class="code" href="group__capi.html#gac9322fae11365a78640baf9078c428b3" title="Extend the given bit-vector with zeros to the (unsigned) equivalent bitvector of...">Z3_mk_zero_ext</a>, OP_ZERO_EXT);
<a name="l01510"></a>01510     MK_BV_PUNARY(<a class="code" href="group__capi.html#ga03e81721502ea225c264d1f556c9119d" title="Repeat the given bit-vector up length i.">Z3_mk_repeat</a>,   OP_REPEAT);
<a name="l01511"></a>01511     MK_BV_PUNARY(<a class="code" href="group__capi.html#ga4932b7d08fea079dd903cd857a52dcda" title="Rotate bits of t1 to the left i times.">Z3_mk_rotate_left</a>, OP_ROTATE_LEFT);
<a name="l01512"></a>01512     MK_BV_PUNARY(<a class="code" href="group__capi.html#ga3b94e1bf87ecd1a1858af8ebc1da4a1c" title="Rotate bits of t1 to the right i times.">Z3_mk_rotate_right</a>, OP_ROTATE_RIGHT);
<a name="l01513"></a>01513     MK_BV_PUNARY(<a class="code" href="group__capi.html#ga35f89eb05df43fbd9cce7200cc1f30b5" title="Create an n bit bit-vector from the integer argument t1.">Z3_mk_int2bv</a>, OP_INT2BV);
<a name="l01514"></a>01514 
<a name="l01515"></a>01515     Z3_ast Z3_API <a class="code" href="group__capi.html#gac87b227dc3821d57258d7f53a28323d4" title="Create an integer from the bit-vector argument t1. If is_signed is false, then the...">Z3_mk_bv2int</a>(Z3_context c, Z3_ast n, <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> is_signed) {
<a name="l01516"></a>01516         LOG_Z3_mk_bv2int(c, n, is_signed);
<a name="l01517"></a>01517         RESET_ERROR_CODE();                                                         
<a name="l01518"></a>01518         Z3_sort int_s = <a class="code" href="group__capi.html#ga6cd426ab5748653b77d389fd3eac1015" title="Create an integer type.">Z3_mk_int_sort</a>(c);
<a name="l01519"></a>01519         <span class="keywordflow">if</span> (is_signed) {
<a name="l01520"></a>01520             Z3_ast r = <a class="code" href="group__capi.html#gac87b227dc3821d57258d7f53a28323d4" title="Create an integer from the bit-vector argument t1. If is_signed is false, then the...">Z3_mk_bv2int</a>(c, n, <span class="keyword">false</span>);
<a name="l01521"></a>01521             Z3_sort s = <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, n);
<a name="l01522"></a>01522             <span class="keywordtype">unsigned</span> sz = <a class="code" href="group__capi.html#ga8fc3550edace7bc046e16d1f96ddb419" title="Return the size of the given bit-vector sort.">Z3_get_bv_sort_size</a>(c, s);
<a name="l01523"></a>01523             rational max_bound = power(rational(2), sz);
<a name="l01524"></a>01524             Z3_ast bound = <a class="code" href="group__capi.html#gac8aca397e32ca33618d8024bff32948c" title="Create a numeral of a given sort.">Z3_mk_numeral</a>(c, max_bound.to_string().c_str(), int_s);
<a name="l01525"></a>01525             Z3_ast pred = <a class="code" href="group__capi.html#ga8ce08af4ed1fbdf08d4d6e63d171663a" title="Two&amp;#39;s complement signed less than.">Z3_mk_bvslt</a>(c, n, <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, 0, s));        
<a name="l01526"></a>01526             <span class="comment">// if n &lt;_sigend 0 then r - s^sz else r</span>
<a name="l01527"></a>01527             Z3_ast args[2] = { r, bound };
<a name="l01528"></a>01528             Z3_ast res = <a class="code" href="group__capi.html#ga94417eed5c36e1ad48bcfc8ad6e83547" title="Create an AST node representing an if-then-else: ite(t1, t2, t3).">Z3_mk_ite</a>(c, pred, <a class="code" href="group__capi.html#ga4f5fea9b683f9e674fd8f14d676cc9a9" title="Create an AST node representing args[0] - ... - args[num_args - 1].">Z3_mk_sub</a>(c, 2, args), r);
<a name="l01529"></a>01529             RETURN_Z3(res);
<a name="l01530"></a>01530         }
<a name="l01531"></a>01531         <span class="keywordflow">else</span> {
<a name="l01532"></a>01532             expr * _n = to_expr(n);                                                     
<a name="l01533"></a>01533             parameter p(to_sort(int_s));                                                             
<a name="l01534"></a>01534             ast* a = mk_c(c)-&gt;m_manager.mk_app(mk_c(c)-&gt;m_bv_fid, OP_BV2INT, 1, &amp;p, 1, &amp;_n);   
<a name="l01535"></a>01535             mk_c(c)-&gt;save_ast_trail(a);                                                 
<a name="l01536"></a>01536             check_sorts(c, a);                                                          
<a name="l01537"></a>01537             RETURN_Z3(of_ast(a)); 
<a name="l01538"></a>01538         }
<a name="l01539"></a>01539     }
<a name="l01540"></a>01540 
<a name="l01550"></a>01550     Z3_ast Z3_API Z3_mk_bvmsb(__in Z3_context c, __in Z3_sort s) {
<a name="l01551"></a>01551         <span class="comment">// Not logging this one, since it is just syntax sugar.</span>
<a name="l01552"></a>01552         <span class="keywordtype">unsigned</span> sz = <a class="code" href="group__capi.html#ga8fc3550edace7bc046e16d1f96ddb419" title="Return the size of the given bit-vector sort.">Z3_get_bv_sort_size</a>(c, s);
<a name="l01553"></a>01553         <span class="keywordflow">if</span> (sz == 0) {
<a name="l01554"></a>01554             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01555"></a>01555             <span class="keywordflow">return</span> 0;
<a name="l01556"></a>01556         }
<a name="l01557"></a>01557         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gac8d5e776c786c1172fa0d7dfede454e1" title="Shift left.">Z3_mk_bvshl</a>(c, <a class="code" href="group__capi.html#ga42cc319787d485d9cb665d80e02d206f" title="Create a numeral of a given sort.">Z3_mk_int64</a>(c, 1, s), <a class="code" href="group__capi.html#ga42cc319787d485d9cb665d80e02d206f" title="Create a numeral of a given sort.">Z3_mk_int64</a>(c, sz - 1, s));
<a name="l01558"></a>01558     }
<a name="l01559"></a>01559 
<a name="l01560"></a>01560     Z3_ast Z3_mk_bvsmin(__in Z3_context c, __in Z3_sort s) {
<a name="l01561"></a>01561         <span class="keywordflow">return</span> Z3_mk_bvmsb(c, s);
<a name="l01562"></a>01562     }
<a name="l01563"></a>01563 
<a name="l01564"></a>01564     Z3_ast Z3_mk_bvsmax(__in Z3_context c, __in Z3_sort s) {
<a name="l01565"></a>01565         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga36cf75c92c54c1ca633a230344f23080" title="Bitwise negation.">Z3_mk_bvnot</a>(c, Z3_mk_bvmsb(c, s));
<a name="l01566"></a>01566     }
<a name="l01567"></a>01567 
<a name="l01568"></a>01568     Z3_ast Z3_mk_bvumax(__in Z3_context c, __in Z3_sort s) {
<a name="l01569"></a>01569         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, -1, s);
<a name="l01570"></a>01570     }
<a name="l01571"></a>01571 
<a name="l01572"></a><a class="code" href="group__capi.html#ga88f6b5ec876f05e0d7ba51e96c4b077f">01572</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga88f6b5ec876f05e0d7ba51e96c4b077f" title="Create a predicate that checks that the bit-wise addition of t1 and t2 does not overflow...">Z3_mk_bvadd_no_overflow</a>(__in Z3_context c, __in Z3_ast t1, __in Z3_ast t2, <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> is_signed) {
<a name="l01573"></a>01573         <span class="keywordflow">if</span> (is_signed) {
<a name="l01574"></a>01574             Z3_ast zero = <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, 0, <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, t1));
<a name="l01575"></a>01575             Z3_ast r = <a class="code" href="group__capi.html#ga819814e33573f3f9948b32fdc5311158" title="Standard two&amp;#39;s complement addition.">Z3_mk_bvadd</a>(c, t1, t2);
<a name="l01576"></a>01576             Z3_ast args[2] = { <a class="code" href="group__capi.html#ga8ce08af4ed1fbdf08d4d6e63d171663a" title="Two&amp;#39;s complement signed less than.">Z3_mk_bvslt</a>(c, zero, t1), <a class="code" href="group__capi.html#ga8ce08af4ed1fbdf08d4d6e63d171663a" title="Two&amp;#39;s complement signed less than.">Z3_mk_bvslt</a>(c, zero, t2) };
<a name="l01577"></a>01577             Z3_ast args_pos = <a class="code" href="group__capi.html#gacde98ce4a8ed1dde50b9669db4838c61" title="Create an AST node representing args[0] and ... and args[num_args-1].">Z3_mk_and</a>(c, 2, args);
<a name="l01578"></a>01578             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gac829c0e25bbbd30343bf073f7b524517" title="Create an AST node representing t1 implies t2.">Z3_mk_implies</a>(c, args_pos, <a class="code" href="group__capi.html#ga8ce08af4ed1fbdf08d4d6e63d171663a" title="Two&amp;#39;s complement signed less than.">Z3_mk_bvslt</a>(c, zero, r));
<a name="l01579"></a>01579         }
<a name="l01580"></a>01580         <span class="keywordflow">else</span> {
<a name="l01581"></a>01581             <span class="keywordtype">unsigned</span> sz = <a class="code" href="group__capi.html#ga8fc3550edace7bc046e16d1f96ddb419" title="Return the size of the given bit-vector sort.">Z3_get_bv_sort_size</a>(c, <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, t1));
<a name="l01582"></a>01582             t1 = <a class="code" href="group__capi.html#gac9322fae11365a78640baf9078c428b3" title="Extend the given bit-vector with zeros to the (unsigned) equivalent bitvector of...">Z3_mk_zero_ext</a>(c, 1, t1);
<a name="l01583"></a>01583             t2 = <a class="code" href="group__capi.html#gac9322fae11365a78640baf9078c428b3" title="Extend the given bit-vector with zeros to the (unsigned) equivalent bitvector of...">Z3_mk_zero_ext</a>(c, 1, t2);
<a name="l01584"></a>01584             Z3_ast r = <a class="code" href="group__capi.html#ga819814e33573f3f9948b32fdc5311158" title="Standard two&amp;#39;s complement addition.">Z3_mk_bvadd</a>(c, t1, t2);
<a name="l01585"></a>01585             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga95a19ce675b70e22bb0401f7137af37c" title="Create an AST node representing l = r.">Z3_mk_eq</a>(c, <a class="code" href="group__capi.html#ga32d2fe7563f3e6b114c1b97b205d4317" title="Extract the bits high down to low from a bitvector of size m to yield a new bitvector...">Z3_mk_extract</a>(c, sz, sz, r), <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, 0, <a class="code" href="group__capi.html#gaeed000a1bbb84b6ca6fdaac6cf0c1688" title="Create a bit-vector type of the given size.">Z3_mk_bv_sort</a>(c, 1)));
<a name="l01586"></a>01586         }
<a name="l01587"></a>01587     }
<a name="l01588"></a>01588 
<a name="l01589"></a>01589     <span class="comment">// only for signed machine integers</span>
<a name="l01590"></a><a class="code" href="group__capi.html#ga1e2b1927cf4e50000c1600d47a152947">01590</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga1e2b1927cf4e50000c1600d47a152947" title="Create a predicate that checks that the bit-wise signed addition of t1 and t2 does...">Z3_mk_bvadd_no_underflow</a>(__in Z3_context c, __in Z3_ast t1, __in Z3_ast t2) {
<a name="l01591"></a>01591         Z3_ast zero = <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, 0, <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, t1));
<a name="l01592"></a>01592         Z3_ast r = <a class="code" href="group__capi.html#ga819814e33573f3f9948b32fdc5311158" title="Standard two&amp;#39;s complement addition.">Z3_mk_bvadd</a>(c, t1, t2);
<a name="l01593"></a>01593         Z3_ast args[2] = { <a class="code" href="group__capi.html#ga8ce08af4ed1fbdf08d4d6e63d171663a" title="Two&amp;#39;s complement signed less than.">Z3_mk_bvslt</a>(c, t1, zero), <a class="code" href="group__capi.html#ga8ce08af4ed1fbdf08d4d6e63d171663a" title="Two&amp;#39;s complement signed less than.">Z3_mk_bvslt</a>(c, t2, zero) };
<a name="l01594"></a>01594         Z3_ast args_neg = <a class="code" href="group__capi.html#gacde98ce4a8ed1dde50b9669db4838c61" title="Create an AST node representing args[0] and ... and args[num_args-1].">Z3_mk_and</a>(c, 2, args);
<a name="l01595"></a>01595         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gac829c0e25bbbd30343bf073f7b524517" title="Create an AST node representing t1 implies t2.">Z3_mk_implies</a>(c, args_neg, <a class="code" href="group__capi.html#ga8ce08af4ed1fbdf08d4d6e63d171663a" title="Two&amp;#39;s complement signed less than.">Z3_mk_bvslt</a>(c, r, zero));
<a name="l01596"></a>01596     }
<a name="l01597"></a>01597 
<a name="l01598"></a>01598     <span class="comment">// only for signed machine integers</span>
<a name="l01599"></a><a class="code" href="group__capi.html#ga785f8127b87e0b42130e6d8f52167d7c">01599</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga785f8127b87e0b42130e6d8f52167d7c" title="Create a predicate that checks that the bit-wise signed subtraction of t1 and t2...">Z3_mk_bvsub_no_overflow</a>(__in Z3_context c, __in Z3_ast t1, __in Z3_ast t2) {
<a name="l01600"></a>01600         Z3_sort s = <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, t2);
<a name="l01601"></a>01601         Z3_ast minus_t2 = <a class="code" href="group__capi.html#ga0c78be00c03eda4ed6a983224ed5c7b7" title="Standard two&amp;#39;s complement unary minus.">Z3_mk_bvneg</a>(c, t2);
<a name="l01602"></a>01602         Z3_ast min = Z3_mk_bvsmin(c, s);
<a name="l01603"></a>01603         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga94417eed5c36e1ad48bcfc8ad6e83547" title="Create an AST node representing an if-then-else: ite(t1, t2, t3).">Z3_mk_ite</a>(c, <a class="code" href="group__capi.html#ga95a19ce675b70e22bb0401f7137af37c" title="Create an AST node representing l = r.">Z3_mk_eq</a>(c, t2, min), 
<a name="l01604"></a>01604                          <a class="code" href="group__capi.html#ga8ce08af4ed1fbdf08d4d6e63d171663a" title="Two&amp;#39;s complement signed less than.">Z3_mk_bvslt</a>(c, t1, <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, 0, s)),
<a name="l01605"></a>01605                          <a class="code" href="group__capi.html#ga88f6b5ec876f05e0d7ba51e96c4b077f" title="Create a predicate that checks that the bit-wise addition of t1 and t2 does not overflow...">Z3_mk_bvadd_no_overflow</a>(c, t1, minus_t2, <span class="keyword">true</span>));
<a name="l01606"></a>01606     }
<a name="l01607"></a>01607 
<a name="l01608"></a><a class="code" href="group__capi.html#ga6480850f9fa01e14aea936c88ff184c4">01608</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga6480850f9fa01e14aea936c88ff184c4" title="Create a predicate that checks that the bit-wise subtraction of t1 and t2 does not...">Z3_mk_bvsub_no_underflow</a>(__in Z3_context c, __in Z3_ast t1, __in Z3_ast t2, <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> is_signed) {
<a name="l01609"></a>01609         <span class="keywordflow">if</span> (is_signed) {
<a name="l01610"></a>01610             Z3_ast zero = <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, 0, <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, t1));
<a name="l01611"></a>01611             Z3_ast minus_t2 = <a class="code" href="group__capi.html#ga0c78be00c03eda4ed6a983224ed5c7b7" title="Standard two&amp;#39;s complement unary minus.">Z3_mk_bvneg</a>(c, t2);
<a name="l01612"></a>01612             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gac829c0e25bbbd30343bf073f7b524517" title="Create an AST node representing t1 implies t2.">Z3_mk_implies</a>(c, <a class="code" href="group__capi.html#ga8ce08af4ed1fbdf08d4d6e63d171663a" title="Two&amp;#39;s complement signed less than.">Z3_mk_bvslt</a>(c, zero, t2), <a class="code" href="group__capi.html#ga1e2b1927cf4e50000c1600d47a152947" title="Create a predicate that checks that the bit-wise signed addition of t1 and t2 does...">Z3_mk_bvadd_no_underflow</a>(c, t1, minus_t2));
<a name="l01613"></a>01613         }
<a name="l01614"></a>01614         <span class="keywordflow">else</span> {
<a name="l01615"></a>01615             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gab738b89de0410e70c089d3ac9e696e87" title="Unsigned less than or equal to.">Z3_mk_bvule</a>(c, t2, t1);
<a name="l01616"></a>01616         }
<a name="l01617"></a>01617     }
<a name="l01618"></a>01618 
<a name="l01619"></a><a class="code" href="group__capi.html#ga86f4415719d295a2f6845c70b3aaa1df">01619</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga86f4415719d295a2f6845c70b3aaa1df" title="Create a predicate that checks that the bit-wise multiplication of t1 and t2 does...">Z3_mk_bvmul_no_overflow</a>(__in Z3_context c, __in Z3_ast n1, __in Z3_ast n2, <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> is_signed) {
<a name="l01620"></a>01620         LOG_Z3_mk_bvmul_no_overflow(c, n1, n2, is_signed);
<a name="l01621"></a>01621         <span class="keywordflow">if</span> (is_signed) {
<a name="l01622"></a>01622             MK_BINARY_BODY(<a class="code" href="group__capi.html#ga86f4415719d295a2f6845c70b3aaa1df" title="Create a predicate that checks that the bit-wise multiplication of t1 and t2 does...">Z3_mk_bvmul_no_overflow</a>, mk_c(c)-&gt;m_bv_fid, OP_BSMUL_NO_OVFL, SKIP);
<a name="l01623"></a>01623         }
<a name="l01624"></a>01624         <span class="keywordflow">else</span> {
<a name="l01625"></a>01625             MK_BINARY_BODY(<a class="code" href="group__capi.html#ga86f4415719d295a2f6845c70b3aaa1df" title="Create a predicate that checks that the bit-wise multiplication of t1 and t2 does...">Z3_mk_bvmul_no_overflow</a>, mk_c(c)-&gt;m_bv_fid, OP_BUMUL_NO_OVFL, SKIP);
<a name="l01626"></a>01626         }
<a name="l01627"></a>01627     }
<a name="l01628"></a>01628 
<a name="l01629"></a>01629     <span class="comment">// only for signed machine integers</span>
<a name="l01630"></a><a class="code" href="group__capi.html#ga501ccc01d737aad3ede5699741717fda">01630</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga501ccc01d737aad3ede5699741717fda" title="Create a predicate that checks that the bit-wise signed multiplication of t1 and...">Z3_mk_bvmul_no_underflow</a>(__in Z3_context c, __in Z3_ast n1, __in Z3_ast n2) {
<a name="l01631"></a>01631         LOG_Z3_mk_bvmul_no_underflow(c, n1, n2);
<a name="l01632"></a>01632         MK_BINARY_BODY(<a class="code" href="group__capi.html#ga501ccc01d737aad3ede5699741717fda" title="Create a predicate that checks that the bit-wise signed multiplication of t1 and...">Z3_mk_bvmul_no_underflow</a>, mk_c(c)-&gt;m_bv_fid, OP_BSMUL_NO_UDFL, SKIP);
<a name="l01633"></a>01633     }
<a name="l01634"></a>01634 
<a name="l01635"></a>01635     <span class="comment">// only for signed machine integers</span>
<a name="l01636"></a><a class="code" href="group__capi.html#gae9c5d72605ddcd0e76657341eaccb6c7">01636</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#gae9c5d72605ddcd0e76657341eaccb6c7" title="Check that bit-wise negation does not overflow when t1 is interpreted as a signed...">Z3_mk_bvneg_no_overflow</a>(__in Z3_context c, __in Z3_ast t) {
<a name="l01637"></a>01637         Z3_ast min = Z3_mk_bvsmin(c, <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, t));
<a name="l01638"></a>01638         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga3329538091996eb7b3dc677760a61072" title="Create an AST node representing not(a).">Z3_mk_not</a>(c, <a class="code" href="group__capi.html#ga95a19ce675b70e22bb0401f7137af37c" title="Create an AST node representing l = r.">Z3_mk_eq</a>(c, t, min));
<a name="l01639"></a>01639     }
<a name="l01640"></a>01640     
<a name="l01641"></a>01641     <span class="comment">// only for signed machine integers</span>
<a name="l01642"></a><a class="code" href="group__capi.html#gaa17e7b2c33dfe2abbd74d390927ae83e">01642</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#gaa17e7b2c33dfe2abbd74d390927ae83e" title="Create a predicate that checks that the bit-wise signed division of t1 and t2 does...">Z3_mk_bvsdiv_no_overflow</a>(__in Z3_context c, __in Z3_ast t1, __in Z3_ast t2) {
<a name="l01643"></a>01643         Z3_sort s = <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, t1);
<a name="l01644"></a>01644         Z3_ast min = Z3_mk_bvmsb(c, s);
<a name="l01645"></a>01645         Z3_ast args[2] = { <a class="code" href="group__capi.html#ga95a19ce675b70e22bb0401f7137af37c" title="Create an AST node representing l = r.">Z3_mk_eq</a>(c, t1, min),
<a name="l01646"></a>01646                            <a class="code" href="group__capi.html#ga95a19ce675b70e22bb0401f7137af37c" title="Create an AST node representing l = r.">Z3_mk_eq</a>(c, t2, <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, -1, s)) };
<a name="l01647"></a>01647         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga3329538091996eb7b3dc677760a61072" title="Create an AST node representing not(a).">Z3_mk_not</a>(c, <a class="code" href="group__capi.html#gacde98ce4a8ed1dde50b9669db4838c61" title="Create an AST node representing args[0] and ... and args[num_args-1].">Z3_mk_and</a>(c, 2, args));
<a name="l01648"></a>01648     }
<a name="l01649"></a>01649     
<a name="l01650"></a>01650     Z3_ast Z3_API <a class="code" href="group__capi.html#ga688c9aa1347888c7a51be4e46c19178e" title="Standard two&amp;#39;s complement subtraction.">Z3_mk_bvsub</a>(Z3_context c, Z3_ast n1, Z3_ast n2) {
<a name="l01651"></a>01651         LOG_Z3_mk_bvsub(c, n1, n2);
<a name="l01652"></a>01652         <span class="comment">// TODO: Do we really need this pre_simplifier hack?</span>
<a name="l01653"></a>01653         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_params.m_pre_simplify_expr) {
<a name="l01654"></a>01654             Z3_ast m1 = <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, -1, <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, n2));
<a name="l01655"></a>01655             Z3_ast r = <a class="code" href="group__capi.html#ga819814e33573f3f9948b32fdc5311158" title="Standard two&amp;#39;s complement addition.">Z3_mk_bvadd</a>(c, n1, <a class="code" href="group__capi.html#ga6abd3dde2a1ceff1704cf7221a72258c" title="Standard two&amp;#39;s complement multiplication.">Z3_mk_bvmul</a>(c, m1, n2));
<a name="l01656"></a>01656             RETURN_Z3(r);
<a name="l01657"></a>01657         }
<a name="l01658"></a>01658         MK_BINARY_BODY(<a class="code" href="group__capi.html#ga688c9aa1347888c7a51be4e46c19178e" title="Standard two&amp;#39;s complement subtraction.">Z3_mk_bvsub</a>, mk_c(c)-&gt;m_bv_fid, OP_BSUB, SKIP);
<a name="l01659"></a>01659     }
<a name="l01660"></a>01660 
<a name="l01661"></a>01661     Z3_ast Z3_API <a class="code" href="group__capi.html#ga0c78be00c03eda4ed6a983224ed5c7b7" title="Standard two&amp;#39;s complement unary minus.">Z3_mk_bvneg</a>(Z3_context c, Z3_ast n) {
<a name="l01662"></a>01662         LOG_Z3_mk_bvneg(c, n);
<a name="l01663"></a>01663         <span class="comment">// TODO: Do we really need this pre_simplifier hack? </span>
<a name="l01664"></a>01664         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_params.m_pre_simplify_expr) {
<a name="l01665"></a>01665             Z3_ast m1 = <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, -1, <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, n));
<a name="l01666"></a>01666             Z3_ast r  = <a class="code" href="group__capi.html#ga6abd3dde2a1ceff1704cf7221a72258c" title="Standard two&amp;#39;s complement multiplication.">Z3_mk_bvmul</a>(c, m1, n);
<a name="l01667"></a>01667             RETURN_Z3(r);
<a name="l01668"></a>01668         }
<a name="l01669"></a>01669         MK_UNARY_BODY(<a class="code" href="group__capi.html#ga0c78be00c03eda4ed6a983224ed5c7b7" title="Standard two&amp;#39;s complement unary minus.">Z3_mk_bvneg</a>, mk_c(c)-&gt;m_bv_fid, OP_BNEG, SKIP);
<a name="l01670"></a>01670     }
<a name="l01671"></a>01671 
<a name="l01672"></a>01672     Z3_ast Z3_API <a class="code" href="group__capi.html#ga4f5fea9b683f9e674fd8f14d676cc9a9" title="Create an AST node representing args[0] - ... - args[num_args - 1].">Z3_mk_sub</a>(Z3_context c, <span class="keywordtype">unsigned</span> num_args, Z3_ast <span class="keyword">const</span> args[]) {
<a name="l01673"></a>01673         LOG_Z3_mk_sub(c, num_args, args);
<a name="l01674"></a>01674         RESET_ERROR_CODE();
<a name="l01675"></a>01675         <span class="keywordflow">if</span> (num_args == 0) {
<a name="l01676"></a>01676             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01677"></a>01677             RETURN_Z3(0);
<a name="l01678"></a>01678         }
<a name="l01679"></a>01679         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_params.m_pre_simplify_expr) {
<a name="l01680"></a>01680             <span class="comment">// Do not use logging here... the function is implemented using API primitives</span>
<a name="l01681"></a>01681             Z3_ast m1 = <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, -1, <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, args[0]));
<a name="l01682"></a>01682             Z3_ast args1[2] = { args[0], 0 };
<a name="l01683"></a>01683             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 1; i &lt; num_args; ++i) {
<a name="l01684"></a>01684                 Z3_ast args2[3] = { m1, args[i] };
<a name="l01685"></a>01685                 args1[1] = <a class="code" href="group__capi.html#gab9affbf8401a18eea474b59ad4adc890" title="Create an AST node representing args[0] * ... * args[num_args-1].">Z3_mk_mul</a>(c, 2, args2);
<a name="l01686"></a>01686                 args1[0] = <a class="code" href="group__capi.html#ga4e4ac0a4e53eee0b4b0ef159ed7d0cd5" title="Create an AST node representing args[0] + ... + args[num_args-1].">Z3_mk_add</a>(c, 2, args1);
<a name="l01687"></a>01687             }
<a name="l01688"></a>01688             RETURN_Z3(args1[0]);
<a name="l01689"></a>01689         }
<a name="l01690"></a>01690         <span class="keywordflow">else</span> {
<a name="l01691"></a>01691             expr* r = to_expr(args[0]);
<a name="l01692"></a>01692             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 1; i &lt; num_args; ++i) {
<a name="l01693"></a>01693                 expr* args1[2] = { r, to_expr(args[i]) };
<a name="l01694"></a>01694                 r = mk_c(c)-&gt;m_manager.mk_app(mk_c(c)-&gt;m_arith_fid, OP_SUB, 0, 0, 2, args1);
<a name="l01695"></a>01695                 check_sorts(c, r);
<a name="l01696"></a>01696             }
<a name="l01697"></a>01697             mk_c(c)-&gt;save_ast_trail(r);
<a name="l01698"></a>01698             RETURN_Z3(of_expr(r));
<a name="l01699"></a>01699         }
<a name="l01700"></a>01700     }
<a name="l01701"></a>01701 
<a name="l01702"></a>01702     Z3_ast Z3_API <a class="code" href="group__capi.html#gadcd2929ad732937e25f34277ce4988ea" title="Create an AST node representing -arg.">Z3_mk_unary_minus</a>(Z3_context c, Z3_ast n) {
<a name="l01703"></a>01703         LOG_Z3_mk_unary_minus(c, n);
<a name="l01704"></a>01704         RESET_ERROR_CODE();
<a name="l01705"></a>01705         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_params.m_pre_simplify_expr) {
<a name="l01706"></a>01706             Z3_ast m1 = <a class="code" href="group__capi.html#ga8779204998136569c3e166c34cfd3e2c" title="Create a numeral of a given sort.">Z3_mk_int</a>(c, -1, <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(c, n));
<a name="l01707"></a>01707             Z3_ast args[2] = { m1, n };
<a name="l01708"></a>01708             Z3_ast r = <a class="code" href="group__capi.html#gab9affbf8401a18eea474b59ad4adc890" title="Create an AST node representing args[0] * ... * args[num_args-1].">Z3_mk_mul</a>(c, 2, args);
<a name="l01709"></a>01709             RETURN_Z3(r);
<a name="l01710"></a>01710         }
<a name="l01711"></a>01711         MK_UNARY_BODY(<a class="code" href="group__capi.html#gadcd2929ad732937e25f34277ce4988ea" title="Create an AST node representing -arg.">Z3_mk_unary_minus</a>, mk_c(c)-&gt;m_arith_fid, OP_UMINUS, SKIP);
<a name="l01712"></a>01712     }
<a name="l01713"></a>01713         
<a name="l01714"></a>01714     Z3_sort Z3_API <a class="code" href="group__capi.html#gacdc73510b69a010b71793d429015f342" title="Create the Boolean type.">Z3_mk_bool_sort</a>(Z3_context c) {
<a name="l01715"></a>01715         LOG_Z3_mk_bool_sort(c);
<a name="l01716"></a>01716         RESET_ERROR_CODE();
<a name="l01717"></a>01717         Z3_sort r = of_sort(mk_c(c)-&gt;m_manager.mk_sort(mk_c(c)-&gt;m_manager.get_basic_family_id(), BOOL_SORT));
<a name="l01718"></a>01718         RETURN_Z3(r);
<a name="l01719"></a>01719     }
<a name="l01720"></a>01720     
<a name="l01721"></a>01721     Z3_sort Z3_API <a class="code" href="group__capi.html#ga6cd426ab5748653b77d389fd3eac1015" title="Create an integer type.">Z3_mk_int_sort</a>(Z3_context c) {
<a name="l01722"></a>01722         LOG_Z3_mk_int_sort(c);
<a name="l01723"></a>01723         RESET_ERROR_CODE();
<a name="l01724"></a>01724         Z3_sort r = of_sort(mk_c(c)-&gt;m_manager.mk_sort(mk_c(c)-&gt;m_arith_fid, INT_SORT));
<a name="l01725"></a>01725         RETURN_Z3(r);
<a name="l01726"></a>01726     }
<a name="l01727"></a>01727     
<a name="l01728"></a>01728     Z3_sort Z3_API <a class="code" href="group__capi.html#ga40ef93b9738485caed6dc84631c3c1a0" title="Create a real type.">Z3_mk_real_sort</a>(Z3_context c) {
<a name="l01729"></a>01729         LOG_Z3_mk_real_sort(c);
<a name="l01730"></a>01730         RESET_ERROR_CODE();
<a name="l01731"></a>01731         Z3_sort r = of_sort(mk_c(c)-&gt;m_manager.mk_sort(mk_c(c)-&gt;m_arith_fid, REAL_SORT));
<a name="l01732"></a>01732         RETURN_Z3(r);
<a name="l01733"></a>01733     }
<a name="l01734"></a>01734     
<a name="l01735"></a>01735     Z3_sort Z3_API <a class="code" href="group__capi.html#gaeed000a1bbb84b6ca6fdaac6cf0c1688" title="Create a bit-vector type of the given size.">Z3_mk_bv_sort</a>(Z3_context c, <span class="keywordtype">unsigned</span> sz) {
<a name="l01736"></a>01736         LOG_Z3_mk_bv_sort(c, sz);
<a name="l01737"></a>01737         RESET_ERROR_CODE(); 
<a name="l01738"></a>01738         <span class="keywordflow">if</span> (sz == 0) {
<a name="l01739"></a>01739             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01740"></a>01740         }
<a name="l01741"></a>01741         parameter p(sz);
<a name="l01742"></a>01742         Z3_sort r = of_sort(mk_c(c)-&gt;m_manager.mk_sort(mk_c(c)-&gt;m_bv_fid, BV_SORT, 1, &amp;p));
<a name="l01743"></a>01743         RETURN_Z3(r);
<a name="l01744"></a>01744     }
<a name="l01745"></a>01745     
<a name="l01746"></a>01746     Z3_sort Z3_API <a class="code" href="group__capi.html#gafe617994cce1b516f46128e448c84445" title="Create an array type.">Z3_mk_array_sort</a>(Z3_context c, Z3_sort domain, Z3_sort range) {
<a name="l01747"></a>01747         LOG_Z3_mk_array_sort(c, domain, range);
<a name="l01748"></a>01748         RESET_ERROR_CODE();  
<a name="l01749"></a>01749         parameter params[2]  = { parameter(to_sort(domain)), parameter(to_sort(range)) };
<a name="l01750"></a>01750         sort * ty =  mk_c(c)-&gt;m_manager.mk_sort(mk_c(c)-&gt;m_array_fid, ARRAY_SORT, 2, params);
<a name="l01751"></a>01751         mk_c(c)-&gt;save_ast_trail(ty);
<a name="l01752"></a>01752         RETURN_Z3(of_sort(ty));
<a name="l01753"></a>01753     }
<a name="l01754"></a>01754     
<a name="l01755"></a>01755     Z3_ast Z3_API <a class="code" href="group__capi.html#ga38f423f3683379e7f597a7fe59eccb67" title="Array read. The argument a is the array and i is the index of the array that gets...">Z3_mk_select</a>(Z3_context c, Z3_ast a, Z3_ast i) {
<a name="l01756"></a>01756         LOG_Z3_mk_select(c, a, i);
<a name="l01757"></a>01757         RESET_ERROR_CODE();
<a name="l01758"></a>01758         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l01759"></a>01759         expr * _a        = to_expr(a);
<a name="l01760"></a>01760         expr * _i        = to_expr(i);
<a name="l01761"></a>01761         sort * a_ty = m.get_sort(_a);
<a name="l01762"></a>01762         sort * i_ty = m.get_sort(_i);
<a name="l01763"></a>01763         <span class="keywordflow">if</span> (a_ty-&gt;get_family_id() != mk_c(c)-&gt;m_array_fid) {
<a name="l01764"></a>01764             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l01765"></a>01765             RETURN_Z3(0);
<a name="l01766"></a>01766         }
<a name="l01767"></a>01767         sort * domain[2] = {a_ty, i_ty};
<a name="l01768"></a>01768         func_decl * d   = m.mk_func_decl(mk_c(c)-&gt;m_array_fid, OP_SELECT, 2, a_ty-&gt;get_parameters(), 2, domain);
<a name="l01769"></a>01769         expr * args[2]        = {_a, _i};
<a name="l01770"></a>01770         app * r        = m.mk_app(d, 2, args);
<a name="l01771"></a>01771         mk_c(c)-&gt;save_ast_trail(r);
<a name="l01772"></a>01772         check_sorts(c, r);
<a name="l01773"></a>01773         RETURN_Z3(of_ast(r));
<a name="l01774"></a>01774     }
<a name="l01775"></a>01775     
<a name="l01776"></a>01776     Z3_ast Z3_API <a class="code" href="group__capi.html#gae305a4f54b4a64f7e5973ae6ccb13593" title="Array update.">Z3_mk_store</a>(Z3_context c, Z3_ast a, Z3_ast i, Z3_ast v) {
<a name="l01777"></a>01777         LOG_Z3_mk_store(c, a, i, v);
<a name="l01778"></a>01778         RESET_ERROR_CODE();
<a name="l01779"></a>01779         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l01780"></a>01780         expr * _a        = to_expr(a);
<a name="l01781"></a>01781         expr * _i        = to_expr(i);
<a name="l01782"></a>01782         expr * _v        = to_expr(v);
<a name="l01783"></a>01783         sort * a_ty = m.get_sort(_a);
<a name="l01784"></a>01784         sort * i_ty = m.get_sort(_i);
<a name="l01785"></a>01785         sort * v_ty = m.get_sort(_v);
<a name="l01786"></a>01786         <span class="keywordflow">if</span> (a_ty-&gt;get_family_id() != mk_c(c)-&gt;m_array_fid) {
<a name="l01787"></a>01787             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l01788"></a>01788             RETURN_Z3(0);
<a name="l01789"></a>01789         }
<a name="l01790"></a>01790         sort * domain[3] = {a_ty, i_ty, v_ty};
<a name="l01791"></a>01791         func_decl * d   = m.mk_func_decl(mk_c(c)-&gt;m_array_fid, OP_STORE, 2, a_ty-&gt;get_parameters(), 3, domain);
<a name="l01792"></a>01792         expr * args[3]        = {_a, _i, _v};
<a name="l01793"></a>01793         app * r        = m.mk_app(d, 3, args);
<a name="l01794"></a>01794         mk_c(c)-&gt;save_ast_trail(r);
<a name="l01795"></a>01795         check_sorts(c, r);
<a name="l01796"></a>01796         RETURN_Z3(of_ast(r));
<a name="l01797"></a>01797     }
<a name="l01798"></a>01798   
<a name="l01799"></a><a class="code" href="group__capi.html#ga9150242d9430a8c3d55d2ca3b9a4362d">01799</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga9150242d9430a8c3d55d2ca3b9a4362d" title="map f on the the argument arrays.">Z3_mk_map</a>(__in Z3_context c, __in Z3_func_decl f, <span class="keywordtype">unsigned</span> n, __in Z3_ast <span class="keyword">const</span>* args) {
<a name="l01800"></a>01800         LOG_Z3_mk_map(c, f, n, args);
<a name="l01801"></a>01801         RESET_ERROR_CODE();
<a name="l01802"></a>01802         <span class="keywordflow">if</span> (n == 0) {
<a name="l01803"></a>01803             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01804"></a>01804             RETURN_Z3(0);
<a name="l01805"></a>01805         }
<a name="l01806"></a>01806         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l01807"></a>01807         func_decl* _f      = to_func_decl(f);
<a name="l01808"></a>01808         expr* <span class="keyword">const</span>* _args = to_exprs(args);
<a name="l01809"></a>01809         
<a name="l01810"></a>01810         ptr_vector&lt;sort&gt; domain;
<a name="l01811"></a>01811         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) {
<a name="l01812"></a>01812             domain.push_back(m.get_sort(_args[i]));
<a name="l01813"></a>01813         }
<a name="l01814"></a>01814         parameter param(_f);
<a name="l01815"></a>01815         func_decl * d = m.mk_func_decl(mk_c(c)-&gt;m_array_fid, OP_ARRAY_MAP, 1, &amp;param, n, domain.c_ptr());
<a name="l01816"></a>01816         app* r = m.mk_app(d, n, _args);
<a name="l01817"></a>01817         mk_c(c)-&gt;save_ast_trail(r);
<a name="l01818"></a>01818         check_sorts(c, r);
<a name="l01819"></a>01819         RETURN_Z3(of_ast(r));
<a name="l01820"></a>01820     }
<a name="l01821"></a>01821 
<a name="l01822"></a>01822     Z3_sort Z3_API <a class="code" href="group__capi.html#ga7156b9c0a76a28fae46c81f8e3cdf0f1" title="Create a tuple type.">Z3_mk_tuple_sort</a>(Z3_context c, 
<a name="l01823"></a>01823                                     Z3_symbol name,
<a name="l01824"></a>01824                                     <span class="keywordtype">unsigned</span> num_fields, 
<a name="l01825"></a>01825                                     Z3_symbol <span class="keyword">const</span> field_names[],
<a name="l01826"></a>01826                                     Z3_sort <span class="keyword">const</span> field_sorts[],
<a name="l01827"></a>01827                                     Z3_func_decl * mk_tuple_decl,
<a name="l01828"></a>01828                                     Z3_func_decl proj_decls[]) {
<a name="l01829"></a>01829         LOG_Z3_mk_tuple_sort(c, name, num_fields, field_names, field_sorts, mk_tuple_decl, proj_decls);
<a name="l01830"></a>01830         RESET_ERROR_CODE(); 
<a name="l01831"></a>01831         mk_c(c)-&gt;reset_last_result();
<a name="l01832"></a>01832         ast_manager&amp; m = mk_c(c)-&gt;m_manager;
<a name="l01833"></a>01833         datatype_util dt_util(m);
<a name="l01834"></a>01834 
<a name="l01835"></a>01835         sort_ref_vector tuples(m);
<a name="l01836"></a>01836         sort* tuple;
<a name="l01837"></a>01837         std::string recognizer_s(<span class="stringliteral">&quot;is_&quot;</span>);
<a name="l01838"></a>01838         recognizer_s += to_symbol(name).str();
<a name="l01839"></a>01839         symbol recognizer(recognizer_s.c_str());
<a name="l01840"></a>01840         
<a name="l01841"></a>01841         ptr_vector&lt;accessor_decl&gt; acc;
<a name="l01842"></a>01842         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_fields; ++i) {
<a name="l01843"></a>01843             acc.push_back(mk_accessor_decl(to_symbol(field_names[i]), type_ref(to_sort(field_sorts[i]))));
<a name="l01844"></a>01844         }
<a name="l01845"></a>01845 
<a name="l01846"></a>01846         constructor_decl* constrs[1] = { mk_constructor_decl(to_symbol(name), recognizer, acc.size(), acc.c_ptr()) };
<a name="l01847"></a>01847         
<a name="l01848"></a>01848         {
<a name="l01849"></a>01849             datatype_decl * dt = mk_datatype_decl(to_symbol(name), 1, constrs);
<a name="l01850"></a>01850             <span class="keywordtype">bool</span> is_ok = mk_c(c)-&gt;m_dt_plugin-&gt;mk_datatypes(1, &amp;dt, tuples);
<a name="l01851"></a>01851             del_datatype_decl(dt);
<a name="l01852"></a>01852 
<a name="l01853"></a>01853             <span class="keywordflow">if</span> (!is_ok) {
<a name="l01854"></a>01854                 SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01855"></a>01855                 RETURN_Z3(0);
<a name="l01856"></a>01856             }
<a name="l01857"></a>01857         }
<a name="l01858"></a>01858 
<a name="l01859"></a>01859         <span class="comment">// create tuple type</span>
<a name="l01860"></a>01860         SASSERT(tuples.size() == 1);        
<a name="l01861"></a>01861         tuple = tuples[0].get();
<a name="l01862"></a>01862         mk_c(c)-&gt;save_multiple_ast_trail(tuple);
<a name="l01863"></a>01863 
<a name="l01864"></a>01864         <span class="comment">// create constructor</span>
<a name="l01865"></a>01865         SASSERT(dt_util.is_datatype(tuple));
<a name="l01866"></a>01866         SASSERT(!dt_util.is_recursive(tuple));
<a name="l01867"></a>01867         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * decls = dt_util.get_datatype_constructors(tuple);
<a name="l01868"></a>01868         func_decl* decl = (*decls)[0];
<a name="l01869"></a>01869         mk_c(c)-&gt;save_multiple_ast_trail(decl);        
<a name="l01870"></a>01870         *mk_tuple_decl = of_func_decl(decl);
<a name="l01871"></a>01871         
<a name="l01872"></a>01872         <span class="comment">// Create projections</span>
<a name="l01873"></a>01873         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * accs = dt_util.get_constructor_accessors(decl);
<a name="l01874"></a>01874         <span class="keywordflow">if</span> (!accs) {
<a name="l01875"></a>01875             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01876"></a>01876             RETURN_Z3(0);
<a name="l01877"></a>01877         }
<a name="l01878"></a>01878         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> &amp; _accs = *accs;
<a name="l01879"></a>01879         SASSERT(_accs.size() == num_fields);
<a name="l01880"></a>01880         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; _accs.size(); i++) {
<a name="l01881"></a>01881             mk_c(c)-&gt;save_multiple_ast_trail(_accs[i]);
<a name="l01882"></a>01882             proj_decls[i] = of_func_decl(_accs[i]);
<a name="l01883"></a>01883         }
<a name="l01884"></a>01884         RETURN_Z3_mk_tuple_sort(of_sort(tuple));
<a name="l01885"></a>01885     }
<a name="l01886"></a>01886     
<a name="l01887"></a><a class="code" href="group__capi.html#ga8d4c1550f5f1bdefbe957bcd0ea4324a">01887</a>     Z3_sort Z3_API <a class="code" href="group__capi.html#ga8d4c1550f5f1bdefbe957bcd0ea4324a" title="Create a enumeration sort.">Z3_mk_enumeration_sort</a>(__in Z3_context c, 
<a name="l01888"></a>01888                                           __in Z3_symbol name,
<a name="l01889"></a>01889                                           __in <span class="keywordtype">unsigned</span> n,
<a name="l01890"></a>01890                                           __in_ecount(n)  Z3_symbol <span class="keyword">const</span> enum_names[],
<a name="l01891"></a>01891                                           __out_ecount(n) Z3_func_decl enum_consts[],
<a name="l01892"></a>01892                                           __out_ecount(n) Z3_func_decl enum_testers[]) {
<a name="l01893"></a>01893         LOG_Z3_mk_enumeration_sort(c, name, n, enum_names, enum_consts, enum_testers);
<a name="l01894"></a>01894         RESET_ERROR_CODE();
<a name="l01895"></a>01895         mk_c(c)-&gt;reset_last_result();
<a name="l01896"></a>01896         ast_manager&amp; m = mk_c(c)-&gt;m_manager;
<a name="l01897"></a>01897         datatype_util dt_util(m);
<a name="l01898"></a>01898 
<a name="l01899"></a>01899         sort_ref_vector sorts(m);
<a name="l01900"></a>01900         sort* e;
<a name="l01901"></a>01901         
<a name="l01902"></a>01902         ptr_vector&lt;constructor_decl&gt; constrs;
<a name="l01903"></a>01903         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) {
<a name="l01904"></a>01904             symbol e_name(to_symbol(enum_names[i]));
<a name="l01905"></a>01905             std::string recognizer_s(<span class="stringliteral">&quot;is_&quot;</span>);
<a name="l01906"></a>01906             recognizer_s += e_name.str();
<a name="l01907"></a>01907             symbol recognizer(recognizer_s.c_str());
<a name="l01908"></a>01908 
<a name="l01909"></a>01909             constrs.push_back(mk_constructor_decl(e_name, recognizer, 0, 0));
<a name="l01910"></a>01910         }
<a name="l01911"></a>01911 
<a name="l01912"></a>01912 
<a name="l01913"></a>01913         {
<a name="l01914"></a>01914             datatype_decl * dt = mk_datatype_decl(to_symbol(name), n, constrs.c_ptr());
<a name="l01915"></a>01915             <span class="keywordtype">bool</span> is_ok = mk_c(c)-&gt;m_dt_plugin-&gt;mk_datatypes(1, &amp;dt, sorts);
<a name="l01916"></a>01916             del_datatype_decl(dt);
<a name="l01917"></a>01917 
<a name="l01918"></a>01918             <span class="keywordflow">if</span> (!is_ok) {
<a name="l01919"></a>01919                 SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01920"></a>01920                 RETURN_Z3(0);
<a name="l01921"></a>01921             }
<a name="l01922"></a>01922         }
<a name="l01923"></a>01923             
<a name="l01924"></a>01924         <span class="comment">// create enum type.</span>
<a name="l01925"></a>01925         SASSERT(sorts.size() == 1);        
<a name="l01926"></a>01926         e = sorts[0].get();
<a name="l01927"></a>01927         mk_c(c)-&gt;save_multiple_ast_trail(e);
<a name="l01928"></a>01928 
<a name="l01929"></a>01929         <span class="comment">// create constructor</span>
<a name="l01930"></a>01930         SASSERT(dt_util.is_datatype(e));
<a name="l01931"></a>01931         SASSERT(!dt_util.is_recursive(e));
<a name="l01932"></a>01932         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * decls = dt_util.get_datatype_constructors(e);
<a name="l01933"></a>01933         SASSERT(decls &amp;&amp; decls-&gt;size() == n);
<a name="l01934"></a>01934         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; n; ++i) {
<a name="l01935"></a>01935             func_decl* decl = (*decls)[i];
<a name="l01936"></a>01936             mk_c(c)-&gt;save_multiple_ast_trail(decl);    
<a name="l01937"></a>01937             enum_consts[i] = of_func_decl(decl);
<a name="l01938"></a>01938             decl = dt_util.get_constructor_recognizer(decl);
<a name="l01939"></a>01939             mk_c(c)-&gt;save_multiple_ast_trail(decl);    
<a name="l01940"></a>01940             enum_testers[i] = of_func_decl(decl);
<a name="l01941"></a>01941         }
<a name="l01942"></a>01942 
<a name="l01943"></a>01943         RETURN_Z3_mk_enumeration_sort(of_sort(e));
<a name="l01944"></a>01944     }
<a name="l01945"></a>01945 
<a name="l01946"></a><a class="code" href="group__capi.html#ga7026ae7f8f1e8f50a8103acdc723d3c0">01946</a>     Z3_sort Z3_API <a class="code" href="group__capi.html#ga7026ae7f8f1e8f50a8103acdc723d3c0" title="Create a list sort.">Z3_mk_list_sort</a>(__in Z3_context c,
<a name="l01947"></a>01947                                    __in Z3_symbol name,
<a name="l01948"></a>01948                                    __in Z3_sort   elem_sort,
<a name="l01949"></a>01949                                    __out Z3_func_decl* nil_decl,
<a name="l01950"></a>01950                                    __out Z3_func_decl* is_nil_decl,
<a name="l01951"></a>01951                                    __out Z3_func_decl* cons_decl,
<a name="l01952"></a>01952                                    __out Z3_func_decl* is_cons_decl,
<a name="l01953"></a>01953                                    __out Z3_func_decl* head_decl,
<a name="l01954"></a>01954                                    __out Z3_func_decl* tail_decl
<a name="l01955"></a>01955                                    ) {
<a name="l01956"></a>01956         LOG_Z3_mk_list_sort(c, name, elem_sort, nil_decl, is_nil_decl, cons_decl, is_cons_decl, head_decl, tail_decl);
<a name="l01957"></a>01957         ast_manager&amp; m = mk_c(c)-&gt;m_manager;
<a name="l01958"></a>01958         mk_c(c)-&gt;reset_last_result();
<a name="l01959"></a>01959         datatype_util data_util(m);
<a name="l01960"></a>01960         accessor_decl* head_tail[2] = { 
<a name="l01961"></a>01961             mk_accessor_decl(symbol(<span class="stringliteral">&quot;head&quot;</span>), type_ref(to_sort(elem_sort))),
<a name="l01962"></a>01962             mk_accessor_decl(symbol(<span class="stringliteral">&quot;tail&quot;</span>), type_ref(0))
<a name="l01963"></a>01963         };
<a name="l01964"></a>01964         constructor_decl* constrs[2] = { 
<a name="l01965"></a>01965             mk_constructor_decl(symbol(<span class="stringliteral">&quot;nil&quot;</span>), symbol(<span class="stringliteral">&quot;is_nil&quot;</span>), 0, 0),
<a name="l01966"></a>01966             <span class="comment">// Leo: SMT 2.0 document uses &#39;insert&#39; instead of cons</span>
<a name="l01967"></a>01967             mk_constructor_decl(symbol(<span class="stringliteral">&quot;cons&quot;</span>), symbol(<span class="stringliteral">&quot;is_cons&quot;</span>), 2, head_tail)
<a name="l01968"></a>01968         };
<a name="l01969"></a>01969 
<a name="l01970"></a>01970         sort_ref_vector sorts(m);
<a name="l01971"></a>01971         {
<a name="l01972"></a>01972             datatype_decl * decl = mk_datatype_decl(to_symbol(name), 2, constrs);
<a name="l01973"></a>01973             <span class="keywordtype">bool</span> is_ok = mk_c(c)-&gt;m_dt_plugin-&gt;mk_datatypes(1, &amp;decl, sorts);
<a name="l01974"></a>01974             del_datatype_decl(decl);
<a name="l01975"></a>01975 
<a name="l01976"></a>01976             <span class="keywordflow">if</span> (!is_ok) {
<a name="l01977"></a>01977                 SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l01978"></a>01978                 RETURN_Z3(0);
<a name="l01979"></a>01979             }
<a name="l01980"></a>01980         }
<a name="l01981"></a>01981         sort * s = sorts.get(0);
<a name="l01982"></a>01982 
<a name="l01983"></a>01983         mk_c(c)-&gt;save_multiple_ast_trail(s);
<a name="l01984"></a>01984         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span>&amp; cnstrs = *data_util.get_datatype_constructors(s);
<a name="l01985"></a>01985         SASSERT(cnstrs.size() == 2);
<a name="l01986"></a>01986         func_decl* f;
<a name="l01987"></a>01987         <span class="keywordflow">if</span> (nil_decl) {
<a name="l01988"></a>01988             f = cnstrs[0];
<a name="l01989"></a>01989             mk_c(c)-&gt;save_multiple_ast_trail(f);            
<a name="l01990"></a>01990             *nil_decl = of_func_decl(f);
<a name="l01991"></a>01991         }
<a name="l01992"></a>01992         <span class="keywordflow">if</span> (is_nil_decl) {
<a name="l01993"></a>01993             f = data_util.get_constructor_recognizer(cnstrs[0]);
<a name="l01994"></a>01994             mk_c(c)-&gt;save_multiple_ast_trail(f);            
<a name="l01995"></a>01995             *is_nil_decl = of_func_decl(f);
<a name="l01996"></a>01996         }
<a name="l01997"></a>01997         <span class="keywordflow">if</span> (cons_decl) {
<a name="l01998"></a>01998             f = cnstrs[1];
<a name="l01999"></a>01999             mk_c(c)-&gt;save_multiple_ast_trail(f);                        
<a name="l02000"></a>02000             *cons_decl = of_func_decl(f);
<a name="l02001"></a>02001         }
<a name="l02002"></a>02002         <span class="keywordflow">if</span> (is_cons_decl) {
<a name="l02003"></a>02003             f = data_util.get_constructor_recognizer(cnstrs[1]);
<a name="l02004"></a>02004             mk_c(c)-&gt;save_multiple_ast_trail(f);                        
<a name="l02005"></a>02005             *is_cons_decl = of_func_decl(f);
<a name="l02006"></a>02006         }
<a name="l02007"></a>02007         <span class="keywordflow">if</span> (head_decl) {
<a name="l02008"></a>02008             ptr_vector&lt;func_decl&gt; <span class="keyword">const</span>* acc = data_util.get_constructor_accessors(cnstrs[1]);
<a name="l02009"></a>02009             SASSERT(acc);
<a name="l02010"></a>02010             SASSERT(acc-&gt;size() == 2);
<a name="l02011"></a>02011             f = (*acc)[0];
<a name="l02012"></a>02012             mk_c(c)-&gt;save_multiple_ast_trail(f);                        
<a name="l02013"></a>02013             *head_decl = of_func_decl(f);
<a name="l02014"></a>02014         }
<a name="l02015"></a>02015         <span class="keywordflow">if</span> (tail_decl) {
<a name="l02016"></a>02016             ptr_vector&lt;func_decl&gt; <span class="keyword">const</span>* acc = data_util.get_constructor_accessors(cnstrs[1]);
<a name="l02017"></a>02017             SASSERT(acc);
<a name="l02018"></a>02018             SASSERT(acc-&gt;size() == 2);
<a name="l02019"></a>02019             f = (*acc)[1];
<a name="l02020"></a>02020             mk_c(c)-&gt;save_multiple_ast_trail(f);                        
<a name="l02021"></a>02021             *tail_decl = of_func_decl(f);
<a name="l02022"></a>02022         }
<a name="l02023"></a>02023         RETURN_Z3_mk_list_sort(of_sort(s));
<a name="l02024"></a>02024     }
<a name="l02025"></a>02025 
<a name="l02026"></a>02026     <span class="keyword">struct </span>constructor {
<a name="l02027"></a>02027         symbol           m_name;
<a name="l02028"></a>02028         symbol           m_tester;
<a name="l02029"></a>02029         svector&lt;symbol&gt;  m_field_names;
<a name="l02030"></a>02030         sort_ref_vector  m_sorts;
<a name="l02031"></a>02031         unsigned_vector  m_sort_refs;
<a name="l02032"></a>02032         func_decl_ref    m_constructor;
<a name="l02033"></a>02033         constructor(ast_manager&amp; m) : m_sorts(m), m_constructor(m) {}
<a name="l02034"></a>02034     };
<a name="l02035"></a>02035 
<a name="l02036"></a><a class="code" href="group__capi.html#ga9f9ef0759dda51396ab7874c676cec7e">02036</a>     Z3_constructor Z3_API <a class="code" href="group__capi.html#ga9f9ef0759dda51396ab7874c676cec7e" title="Create a constructor.">Z3_mk_constructor</a>(__in Z3_context c,
<a name="l02037"></a>02037                                             __in Z3_symbol name,
<a name="l02038"></a>02038                                             __in Z3_symbol tester,
<a name="l02039"></a>02039                                             __in <span class="keywordtype">unsigned</span> num_fields,
<a name="l02040"></a>02040                                             __in_ecount(num_fields) Z3_symbol <span class="keyword">const</span> field_names[],
<a name="l02041"></a>02041                                             __in_ecount(num_fields) Z3_sort <span class="keyword">const</span> sorts[],
<a name="l02042"></a>02042                                             __in_ecount(num_fields) <span class="keywordtype">unsigned</span> sort_refs[]
<a name="l02043"></a>02043                                             ) {
<a name="l02044"></a>02044         LOG_Z3_mk_constructor(c, name, tester, num_fields, field_names, sorts, sort_refs);
<a name="l02045"></a>02045         RESET_ERROR_CODE();  
<a name="l02046"></a>02046         ast_manager&amp; m = mk_c(c)-&gt;m_manager;
<a name="l02047"></a>02047         constructor* cnstr = alloc(constructor, m);
<a name="l02048"></a>02048         cnstr-&gt;m_name = to_symbol(name);
<a name="l02049"></a>02049         cnstr-&gt;m_tester = to_symbol(tester);
<a name="l02050"></a>02050         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_fields; ++i) {
<a name="l02051"></a>02051             cnstr-&gt;m_field_names.push_back(to_symbol(field_names[i]));
<a name="l02052"></a>02052             cnstr-&gt;m_sorts.push_back(to_sort(sorts[i]));
<a name="l02053"></a>02053             cnstr-&gt;m_sort_refs.push_back(sort_refs[i]);
<a name="l02054"></a>02054         }
<a name="l02055"></a>02055         RETURN_Z3(reinterpret_cast&lt;Z3_constructor&gt;(cnstr));
<a name="l02056"></a>02056     }
<a name="l02057"></a>02057 
<a name="l02058"></a>02058 
<a name="l02059"></a><a class="code" href="group__capi.html#ga72e643039b46b1e0b82c543479e3bb7f">02059</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga72e643039b46b1e0b82c543479e3bb7f" title="Query constructor for declared funcions.">Z3_query_constructor</a>(__in Z3_context c,
<a name="l02060"></a>02060                                      __in Z3_constructor constr,
<a name="l02061"></a>02061                                      __in <span class="keywordtype">unsigned</span> num_fields,
<a name="l02062"></a>02062                                      __out Z3_func_decl* constructor_decl,
<a name="l02063"></a>02063                                      __out Z3_func_decl* tester,
<a name="l02064"></a>02064                                      __out_ecount(num_fields) Z3_func_decl accessors[]) {
<a name="l02065"></a>02065         LOG_Z3_query_constructor(c, constr, num_fields, constructor_decl, tester, accessors);
<a name="l02066"></a>02066         RESET_ERROR_CODE();
<a name="l02067"></a>02067         mk_c(c)-&gt;reset_last_result();
<a name="l02068"></a>02068         <span class="keywordflow">if</span> (!constr) {
<a name="l02069"></a>02069             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02070"></a>02070             <span class="keywordflow">return</span>;
<a name="l02071"></a>02071         }
<a name="l02072"></a>02072         ast_manager&amp; m = mk_c(c)-&gt;m_manager;
<a name="l02073"></a>02073         datatype_util data_util(m);
<a name="l02074"></a>02074         func_decl* f = <span class="keyword">reinterpret_cast&lt;</span>constructor*<span class="keyword">&gt;</span>(constr)-&gt;m_constructor.get();
<a name="l02075"></a>02075 
<a name="l02076"></a>02076         <span class="keywordflow">if</span> (!f) {
<a name="l02077"></a>02077             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02078"></a>02078             <span class="keywordflow">return</span>;
<a name="l02079"></a>02079         }    
<a name="l02080"></a>02080         <span class="keywordflow">if</span> (constructor_decl) {
<a name="l02081"></a>02081             mk_c(c)-&gt;save_multiple_ast_trail(f);
<a name="l02082"></a>02082             *constructor_decl = of_func_decl(f);
<a name="l02083"></a>02083         }
<a name="l02084"></a>02084         <span class="keywordflow">if</span> (tester) {
<a name="l02085"></a>02085             func_decl* f2 = data_util.get_constructor_recognizer(f);
<a name="l02086"></a>02086             mk_c(c)-&gt;save_multiple_ast_trail(f2);
<a name="l02087"></a>02087             *tester = of_func_decl(f2);
<a name="l02088"></a>02088         }
<a name="l02089"></a>02089         
<a name="l02090"></a>02090         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span>* accs = data_util.get_constructor_accessors(f);
<a name="l02091"></a>02091         <span class="keywordflow">if</span> (!accs &amp;&amp; num_fields &gt; 0) {
<a name="l02092"></a>02092             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02093"></a>02093             <span class="keywordflow">return</span>;            
<a name="l02094"></a>02094         }
<a name="l02095"></a>02095         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_fields; ++i) {
<a name="l02096"></a>02096             func_decl* f2 = (*accs)[i];
<a name="l02097"></a>02097             mk_c(c)-&gt;save_multiple_ast_trail(f2);            
<a name="l02098"></a>02098             accessors[i] = of_func_decl(f2);
<a name="l02099"></a>02099         }
<a name="l02100"></a>02100         RETURN_Z3_query_constructor;
<a name="l02101"></a>02101     }
<a name="l02102"></a>02102 
<a name="l02103"></a><a class="code" href="group__capi.html#ga63816efdbce93734c72f395b6a6a9e35">02103</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga63816efdbce93734c72f395b6a6a9e35" title="Reclaim memory allocated to constructor.">Z3_del_constructor</a>(__in Z3_context c, __in Z3_constructor constr) {
<a name="l02104"></a>02104         LOG_Z3_del_constructor(c, constr);
<a name="l02105"></a>02105         RESET_ERROR_CODE();
<a name="l02106"></a>02106         dealloc(reinterpret_cast&lt;constructor*&gt;(constr));
<a name="l02107"></a>02107     }
<a name="l02108"></a>02108 
<a name="l02109"></a>02109     <span class="keyword">static</span> datatype_decl* mk_datatype_decl(__in Z3_context c, 
<a name="l02110"></a>02110                                            __in Z3_symbol name,
<a name="l02111"></a>02111                                            __in <span class="keywordtype">unsigned</span> num_constructors,
<a name="l02112"></a>02112                                            __inout_ecount(num_constructors) Z3_constructor constructors[]) {
<a name="l02113"></a>02113         ptr_vector&lt;constructor_decl&gt; constrs;
<a name="l02114"></a>02114         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_constructors; ++i) {
<a name="l02115"></a>02115             constructor* cn = <span class="keyword">reinterpret_cast&lt;</span>constructor*<span class="keyword">&gt;</span>(constructors[i]);
<a name="l02116"></a>02116             ptr_vector&lt;accessor_decl&gt; acc;
<a name="l02117"></a>02117             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; cn-&gt;m_sorts.size(); ++j) {
<a name="l02118"></a>02118                 <span class="keywordflow">if</span> (cn-&gt;m_sorts[j].get()) {
<a name="l02119"></a>02119                     acc.push_back(mk_accessor_decl(cn-&gt;m_field_names[j], type_ref(cn-&gt;m_sorts[j].get())));
<a name="l02120"></a>02120                 }
<a name="l02121"></a>02121                 <span class="keywordflow">else</span> {
<a name="l02122"></a>02122                     acc.push_back(mk_accessor_decl(cn-&gt;m_field_names[j], type_ref(cn-&gt;m_sort_refs[j])));
<a name="l02123"></a>02123                 }
<a name="l02124"></a>02124             }
<a name="l02125"></a>02125             constrs.push_back(mk_constructor_decl(cn-&gt;m_name, cn-&gt;m_tester, acc.size(), acc.c_ptr()));
<a name="l02126"></a>02126         }
<a name="l02127"></a>02127         <span class="keywordflow">return</span> mk_datatype_decl(to_symbol(name), num_constructors, constrs.c_ptr());        
<a name="l02128"></a>02128     }
<a name="l02129"></a>02129 
<a name="l02130"></a><a class="code" href="group__capi.html#gab6809d53327d807da9158abdf75df387">02130</a>     Z3_sort Z3_API <a class="code" href="group__capi.html#gab6809d53327d807da9158abdf75df387" title="Create datatype, such as lists, trees, records, enumerations or unions of records...">Z3_mk_datatype</a>(__in Z3_context c,
<a name="l02131"></a>02131                                   __in Z3_symbol name,
<a name="l02132"></a>02132                                   __in <span class="keywordtype">unsigned</span> num_constructors,
<a name="l02133"></a>02133                                   __inout_ecount(num_constructors) Z3_constructor constructors[]) {
<a name="l02134"></a>02134         LOG_Z3_mk_datatype(c, name, num_constructors, constructors);
<a name="l02135"></a>02135         RESET_ERROR_CODE();
<a name="l02136"></a>02136         ast_manager&amp; m = mk_c(c)-&gt;m_manager;        
<a name="l02137"></a>02137         datatype_util data_util(m);
<a name="l02138"></a>02138         
<a name="l02139"></a>02139         sort_ref_vector sorts(m);
<a name="l02140"></a>02140         {
<a name="l02141"></a>02141             datatype_decl * data = mk_datatype_decl(c, name, num_constructors, constructors);
<a name="l02142"></a>02142             <span class="keywordtype">bool</span> is_ok = mk_c(c)-&gt;m_dt_plugin-&gt;mk_datatypes(1, &amp;data, sorts);
<a name="l02143"></a>02143             del_datatype_decl(data);
<a name="l02144"></a>02144 
<a name="l02145"></a>02145             <span class="keywordflow">if</span> (!is_ok) {
<a name="l02146"></a>02146                 SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02147"></a>02147                 RETURN_Z3(0);
<a name="l02148"></a>02148             }
<a name="l02149"></a>02149         }
<a name="l02150"></a>02150         sort * s = sorts.get(0);
<a name="l02151"></a>02151 
<a name="l02152"></a>02152         mk_c(c)-&gt;save_ast_trail(s);
<a name="l02153"></a>02153         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span>* cnstrs = data_util.get_datatype_constructors(s);
<a name="l02154"></a>02154         
<a name="l02155"></a>02155         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_constructors; ++i) {
<a name="l02156"></a>02156             constructor* cn = <span class="keyword">reinterpret_cast&lt;</span>constructor*<span class="keyword">&gt;</span>(constructors[i]);
<a name="l02157"></a>02157             cn-&gt;m_constructor = (*cnstrs)[i];
<a name="l02158"></a>02158         }
<a name="l02159"></a>02159         RETURN_Z3_mk_datatype(of_sort(s));
<a name="l02160"></a>02160     }
<a name="l02161"></a>02161 
<a name="l02162"></a>02162     <span class="keyword">typedef</span> ptr_vector&lt;constructor&gt; constructor_list;
<a name="l02163"></a>02163 
<a name="l02164"></a><a class="code" href="group__capi.html#gab784bcdbacfc08c2313de5f86edbb0c1">02164</a>     Z3_constructor_list Z3_API <a class="code" href="group__capi.html#gab784bcdbacfc08c2313de5f86edbb0c1" title="Create list of constructors.">Z3_mk_constructor_list</a>(__in Z3_context c,
<a name="l02165"></a>02165                                                       __in <span class="keywordtype">unsigned</span> num_constructors,
<a name="l02166"></a>02166                                                       __in_ecount(num_constructors) Z3_constructor <span class="keyword">const</span> constructors[]) {
<a name="l02167"></a>02167         LOG_Z3_mk_constructor_list(c, num_constructors, constructors);
<a name="l02168"></a>02168         constructor_list* result = alloc(ptr_vector&lt;constructor&gt;);
<a name="l02169"></a>02169         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_constructors; ++i) {
<a name="l02170"></a>02170             result-&gt;push_back(reinterpret_cast&lt;constructor*&gt;(constructors[i]));
<a name="l02171"></a>02171         }
<a name="l02172"></a>02172         RETURN_Z3(reinterpret_cast&lt;Z3_constructor_list&gt;(result));
<a name="l02173"></a>02173     }
<a name="l02174"></a>02174 
<a name="l02175"></a><a class="code" href="group__capi.html#gad7f91f3d9618323c8145f34acadbff96">02175</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#gad7f91f3d9618323c8145f34acadbff96" title="reclaim memory allocated for constructor list.">Z3_del_constructor_list</a>(__in Z3_context c, __in Z3_constructor_list clist) {
<a name="l02176"></a>02176         LOG_Z3_del_constructor_list(c, clist);
<a name="l02177"></a>02177         dealloc(reinterpret_cast&lt;constructor_list*&gt;(clist));
<a name="l02178"></a>02178     }
<a name="l02179"></a>02179 
<a name="l02180"></a><a class="code" href="group__capi.html#ga78cfbf17d313baac0943273d5ff2edf4">02180</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga78cfbf17d313baac0943273d5ff2edf4" title="Create mutually recursive datatypes.">Z3_mk_datatypes</a>(__in Z3_context c,
<a name="l02181"></a>02181                                 __in <span class="keywordtype">unsigned</span> num_sorts,
<a name="l02182"></a>02182                                 __in_ecount(num_sorts) Z3_symbol <span class="keyword">const</span> sort_names[],
<a name="l02183"></a>02183                                 __out_ecount(num_sorts) Z3_sort sorts[],
<a name="l02184"></a>02184                                 __inout_ecount(num_sorts) Z3_constructor_list constructor_lists[]) {
<a name="l02185"></a>02185         LOG_Z3_mk_datatypes(c, num_sorts, sort_names, sorts, constructor_lists);
<a name="l02186"></a>02186         RESET_ERROR_CODE();
<a name="l02187"></a>02187         ast_manager&amp; m = mk_c(c)-&gt;m_manager;        
<a name="l02188"></a>02188         mk_c(c)-&gt;reset_last_result();
<a name="l02189"></a>02189         datatype_util data_util(m);
<a name="l02190"></a>02190 
<a name="l02191"></a>02191         ptr_vector&lt;datatype_decl&gt; datas;
<a name="l02192"></a>02192         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_sorts; ++i) {
<a name="l02193"></a>02193             constructor_list* cl = <span class="keyword">reinterpret_cast&lt;</span>constructor_list*<span class="keyword">&gt;</span>(constructor_lists[i]);
<a name="l02194"></a>02194             datas.push_back(mk_datatype_decl(c,sort_names[i], cl-&gt;size(), <span class="keyword">reinterpret_cast&lt;</span>Z3_constructor*<span class="keyword">&gt;</span>(cl-&gt;c_ptr())));
<a name="l02195"></a>02195         }
<a name="l02196"></a>02196         sort_ref_vector _sorts(m);
<a name="l02197"></a>02197         <span class="keywordtype">bool</span> ok = mk_c(c)-&gt;m_dt_plugin-&gt;mk_datatypes(datas.size(), datas.c_ptr(), _sorts);
<a name="l02198"></a>02198         del_datatype_decls(datas.size(), datas.c_ptr());
<a name="l02199"></a>02199         
<a name="l02200"></a>02200         <span class="keywordflow">if</span> (!ok) {
<a name="l02201"></a>02201             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02202"></a>02202             <span class="keywordflow">return</span>;
<a name="l02203"></a>02203         }
<a name="l02204"></a>02204 
<a name="l02205"></a>02205         SASSERT(_sorts.size() == num_sorts);
<a name="l02206"></a>02206         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; _sorts.size(); ++i) {
<a name="l02207"></a>02207             sort* s = _sorts[i].get();
<a name="l02208"></a>02208             mk_c(c)-&gt;save_multiple_ast_trail(s);
<a name="l02209"></a>02209             sorts[i] = of_sort(s);
<a name="l02210"></a>02210             constructor_list* cl = <span class="keyword">reinterpret_cast&lt;</span>constructor_list*<span class="keyword">&gt;</span>(constructor_lists[i]);
<a name="l02211"></a>02211             ptr_vector&lt;func_decl&gt; <span class="keyword">const</span>* cnstrs = data_util.get_datatype_constructors(s);
<a name="l02212"></a>02212             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; cl-&gt;size(); ++j) {
<a name="l02213"></a>02213                 constructor* cn = (*cl)[j];                
<a name="l02214"></a>02214                 cn-&gt;m_constructor = (*cnstrs)[j];                
<a name="l02215"></a>02215             }
<a name="l02216"></a>02216         }
<a name="l02217"></a>02217         RETURN_Z3_mk_datatypes;
<a name="l02218"></a>02218     }
<a name="l02219"></a>02219     
<a name="l02220"></a>02220     Z3_ast Z3_API <a class="code" href="group__capi.html#gae259256eb0f2c10e48fc6227760b7fda" title="Convert a APP_AST into an AST. This is just type casting.">Z3_app_to_ast</a>(Z3_context c, Z3_app a) { 
<a name="l02221"></a>02221         RESET_ERROR_CODE();
<a name="l02222"></a>02222         <span class="keywordflow">return</span> (Z3_ast)(a); 
<a name="l02223"></a>02223     }    
<a name="l02224"></a>02224 
<a name="l02225"></a>02225     Z3_ast Z3_API <a class="code" href="group__capi.html#ga57c27f2c4e9eccf17072a84c6cecb1db" title="Convert a Z3_sort into Z3_ast. This is just type casting.">Z3_sort_to_ast</a>(Z3_context c, Z3_sort s) { 
<a name="l02226"></a>02226         RESET_ERROR_CODE();
<a name="l02227"></a>02227         <span class="keywordflow">return</span> (Z3_ast)(s); 
<a name="l02228"></a>02228     }    
<a name="l02229"></a>02229 
<a name="l02230"></a>02230     Z3_ast Z3_API <a class="code" href="group__capi.html#gadc82da786f3b558de8ded05bf6478902" title="Convert a Z3_func_decl into Z3_ast. This is just type casting.">Z3_func_decl_to_ast</a>(Z3_context c, Z3_func_decl f) { 
<a name="l02231"></a>02231         RESET_ERROR_CODE();
<a name="l02232"></a>02232         <span class="keywordflow">return</span> (Z3_ast)(f); 
<a name="l02233"></a>02233     }    
<a name="l02234"></a>02234 
<a name="l02235"></a>02235     Z3_ast Z3_API <a class="code" href="group__capi.html#gafe4334258b639fa1f8754375b9b56fd7" title="Convert a Z3_pattern into Z3_ast. This is just type casting.">Z3_pattern_to_ast</a>(Z3_context c, Z3_pattern p) { 
<a name="l02236"></a>02236         RESET_ERROR_CODE();
<a name="l02237"></a>02237         <span class="keywordflow">return</span> (Z3_ast)(p); 
<a name="l02238"></a>02238     }    
<a name="l02239"></a>02239     
<a name="l02240"></a>02240     <span class="comment">// ------------------------</span>
<a name="l02241"></a>02241 
<a name="l02242"></a><a class="code" href="group__capi.html#ga8013f85120357e869a02a95eec5b3b2e">02242</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga8013f85120357e869a02a95eec5b3b2e" title="Return a unique identifier for t.">Z3_get_ast_id</a>(__in Z3_context c, Z3_ast t) {
<a name="l02243"></a>02243         LOG_Z3_get_ast_id(c, t);
<a name="l02244"></a>02244         <span class="keywordflow">return</span> to_expr(t)-&gt;get_id();
<a name="l02245"></a>02245     }
<a name="l02246"></a>02246 
<a name="l02247"></a><a class="code" href="group__capi.html#ga9af7c1bed8732834bdde297d782315ed">02247</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga9af7c1bed8732834bdde297d782315ed" title="Return a unique identifier for f.">Z3_get_func_decl_id</a>(__in Z3_context c, Z3_func_decl f) {
<a name="l02248"></a>02248         LOG_Z3_get_func_decl_id(c, f);
<a name="l02249"></a>02249         <span class="keywordflow">return</span> to_func_decl(f)-&gt;get_id();
<a name="l02250"></a>02250     }
<a name="l02251"></a>02251 
<a name="l02252"></a><a class="code" href="group__capi.html#gaa7588862e0ea372d8b4b689da52e3f63">02252</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#gaa7588862e0ea372d8b4b689da52e3f63" title="Return a unique identifier for s.">Z3_get_sort_id</a>(__in Z3_context c, Z3_sort s) {
<a name="l02253"></a>02253         LOG_Z3_get_sort_id(c, s);
<a name="l02254"></a>02254         <span class="keywordflow">return</span> to_sort(s)-&gt;get_id();
<a name="l02255"></a>02255     }
<a name="l02256"></a>02256 
<a name="l02257"></a>02257 
<a name="l02258"></a>02258 
<a name="l02259"></a>02259     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> <a class="code" href="group__capi.html#ga3c48228a749a8d1ead768b858f1aaf6d" title="Return true if the given expression t is well sorted.">Z3_is_well_sorted</a>(Z3_context c, Z3_ast t) {
<a name="l02260"></a>02260         LOG_Z3_is_well_sorted(c, t);
<a name="l02261"></a>02261         RESET_ERROR_CODE();
<a name="l02262"></a>02262         <span class="keywordflow">return</span> is_well_sorted(mk_c(c)-&gt;m_manager, to_expr(t));
<a name="l02263"></a>02263     }
<a name="l02264"></a>02264 
<a name="l02265"></a>02265     <a class="code" href="group__capi.html#ga98dc3da030c7846e3e79f4cdab902662" title="In Z3, a symbol can be represented using integers and strings (See Z3_get_symbol_kind)...">Z3_symbol_kind</a> <a class="code" href="group__capi.html#ga67ffc0773e8d329ddbab7bd7f751ecd2" title="Return Z3_INT_SYMBOL if the symbol was constructed using Z3_mk_int_symbol, and Z3_STRING_SYMBOL...">Z3_get_symbol_kind</a>(Z3_context c, Z3_symbol s) {
<a name="l02266"></a>02266         LOG_Z3_get_symbol_kind(c, s);
<a name="l02267"></a>02267         RESET_ERROR_CODE();
<a name="l02268"></a>02268         symbol _s = to_symbol(s);
<a name="l02269"></a>02269         <span class="keywordflow">return</span> _s.is_numerical() ? Z3_INT_SYMBOL : Z3_STRING_SYMBOL;
<a name="l02270"></a>02270     }
<a name="l02271"></a>02271     
<a name="l02272"></a>02272     <span class="keywordtype">int</span> Z3_API <a class="code" href="group__capi.html#ga36fbbd2c1d0cb41c8c7784f60a84a488" title="Return the symbol int value.">Z3_get_symbol_int</a>(Z3_context c, Z3_symbol s) {
<a name="l02273"></a>02273         LOG_Z3_get_symbol_int(c, s);
<a name="l02274"></a>02274         RESET_ERROR_CODE();
<a name="l02275"></a>02275         symbol _s = to_symbol(s);
<a name="l02276"></a>02276         <span class="keywordflow">if</span> (_s.is_numerical()) {
<a name="l02277"></a>02277             <span class="keywordflow">return</span> _s.get_num();
<a name="l02278"></a>02278         }
<a name="l02279"></a>02279         SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02280"></a>02280         <span class="keywordflow">return</span> -1;
<a name="l02281"></a>02281     }
<a name="l02282"></a>02282     
<a name="l02283"></a>02283     <span class="keywordtype">char</span> <span class="keyword">const</span> * Z3_API <a class="code" href="group__capi.html#gaf1683d9464f377e5089ce6ebf2a9bd31" title="Return the symbol name.">Z3_get_symbol_string</a>(Z3_context c, Z3_symbol s) {
<a name="l02284"></a>02284         LOG_Z3_get_symbol_string(c, s);
<a name="l02285"></a>02285         RESET_ERROR_CODE();
<a name="l02286"></a>02286         symbol _s = to_symbol(s);
<a name="l02287"></a>02287         <span class="keywordflow">if</span> (_s.is_numerical()) {
<a name="l02288"></a>02288             std::ostringstream buffer;
<a name="l02289"></a>02289             buffer &lt;&lt; _s.get_num();
<a name="l02290"></a>02290             mk_c(c)-&gt;m_is_string_symbol_buffer = buffer.str().c_str();
<a name="l02291"></a>02291         }
<a name="l02292"></a>02292         <span class="keywordflow">else</span> {
<a name="l02293"></a>02293             mk_c(c)-&gt;m_is_string_symbol_buffer = _s.bare_str();
<a name="l02294"></a>02294         }
<a name="l02295"></a>02295         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(mk_c(c)-&gt;m_is_string_symbol_buffer.c_str());
<a name="l02296"></a>02296     }
<a name="l02297"></a>02297     
<a name="l02298"></a>02298     
<a name="l02299"></a>02299     <a class="code" href="group__capi.html#ga015148ad21a032e79a496629651dedb8" title="The different kinds of Z3 AST (abstract syntax trees). That is, terms, formulas and...">Z3_ast_kind</a> Z3_API <a class="code" href="group__capi.html#ga4c43608feea4cae363ef9c520c239a5c" title="Return the kind of the given AST.">Z3_get_ast_kind</a>(Z3_context c, Z3_ast a) {
<a name="l02300"></a>02300         LOG_Z3_get_ast_kind(c, a);
<a name="l02301"></a>02301         RESET_ERROR_CODE();
<a name="l02302"></a>02302         CHECK_VALID_AST(a);
<a name="l02303"></a>02303         expr* e = to_expr(a);
<a name="l02304"></a>02304         <span class="keywordflow">switch</span> (e-&gt;get_kind()) {
<a name="l02305"></a>02305         <span class="keywordflow">case</span> AST_APP:        
<a name="l02306"></a>02306             <span class="keywordflow">if</span> (is_numeral_sort(c, of_sort(mk_c(c)-&gt;m_manager.get_sort(e)))) {
<a name="l02307"></a>02307                 <span class="keywordflow">return</span> Z3_NUMERAL_AST;
<a name="l02308"></a>02308             }            
<a name="l02309"></a>02309             <span class="keywordflow">return</span> Z3_APP_AST;
<a name="l02310"></a>02310         <span class="keywordflow">case</span> AST_VAR:        <span class="keywordflow">return</span> Z3_VAR_AST;
<a name="l02311"></a>02311         <span class="keywordflow">case</span> AST_QUANTIFIER: <span class="keywordflow">return</span> Z3_QUANTIFIER_AST;
<a name="l02312"></a>02312         <span class="keywordflow">default</span>:             <span class="keywordflow">return</span> Z3_UNKNOWN_AST;
<a name="l02313"></a>02313         }
<a name="l02314"></a>02314     }
<a name="l02315"></a>02315     
<a name="l02316"></a>02316     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API Z3_is_app(Z3_context c, Z3_ast a) {
<a name="l02317"></a>02317         LOG_Z3_is_app(c, a);
<a name="l02318"></a>02318         RESET_ERROR_CODE();
<a name="l02319"></a>02319         <span class="keywordflow">return</span> is_app(reinterpret_cast&lt;ast*&gt;(a));
<a name="l02320"></a>02320     }
<a name="l02321"></a>02321     
<a name="l02322"></a>02322     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API Z3_is_numeral_ast(Z3_context c, Z3_ast a) {
<a name="l02323"></a>02323         LOG_Z3_is_numeral_ast(c, a);
<a name="l02324"></a>02324         RESET_ERROR_CODE();
<a name="l02325"></a>02325         expr* e = to_expr(a);
<a name="l02326"></a>02326         <span class="keywordflow">return</span> 
<a name="l02327"></a>02327             mk_c(c)-&gt;m_arith_util.is_numeral(e) ||
<a name="l02328"></a>02328             mk_c(c)-&gt;m_bv_util.is_numeral(e);
<a name="l02329"></a>02329     }
<a name="l02330"></a>02330     
<a name="l02331"></a>02331     Z3_app Z3_API <a class="code" href="group__capi.html#gaf9345fd0822d7e9928dd4ab14a09765b" title="Convert an AST into a APP_AST. This is just type casting.">Z3_to_app</a>(Z3_context c, Z3_ast a) {
<a name="l02332"></a>02332         LOG_Z3_to_app(c, a);
<a name="l02333"></a>02333         RESET_ERROR_CODE();   
<a name="l02334"></a>02334         SASSERT(is_app(reinterpret_cast&lt;ast*&gt;(a)));
<a name="l02335"></a>02335         RETURN_Z3(of_app(reinterpret_cast&lt;app*&gt;(a)));
<a name="l02336"></a>02336     }
<a name="l02337"></a>02337         
<a name="l02338"></a>02338     Z3_func_decl Z3_API <a class="code" href="group__capi.html#ga4ffab51c30484a32edc65194573cfd28" title="Return the declaration of a constant or function application.">Z3_get_app_decl</a>(Z3_context c, Z3_app a) {
<a name="l02339"></a>02339         LOG_Z3_get_app_decl(c, a);
<a name="l02340"></a>02340         RESET_ERROR_CODE(); 
<a name="l02341"></a>02341         <span class="keywordflow">if</span> (!is_app(reinterpret_cast&lt;ast*&gt;(a))) {
<a name="l02342"></a>02342             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02343"></a>02343             RETURN_Z3(0);
<a name="l02344"></a>02344         }
<a name="l02345"></a>02345         RETURN_Z3(of_func_decl(to_app(a)-&gt;get_decl()));
<a name="l02346"></a>02346     }
<a name="l02347"></a>02347 
<a name="l02348"></a>02348     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#gae8ad520b79b46c323863bacffa0e12c0" title="Return the number of argument of an application. If t is an constant, then the number...">Z3_get_app_num_args</a>(Z3_context c, Z3_app a) {
<a name="l02349"></a>02349         LOG_Z3_get_app_num_args(c, a);
<a name="l02350"></a>02350         RESET_ERROR_CODE();           
<a name="l02351"></a>02351         <span class="keywordflow">return</span> to_app(a)-&gt;get_num_args();
<a name="l02352"></a>02352     }
<a name="l02353"></a>02353 
<a name="l02354"></a>02354     Z3_ast Z3_API <a class="code" href="group__capi.html#ga49a576b11f9f6ca4a94670e538a84c6b" title="Return the i-th argument of the given application.">Z3_get_app_arg</a>(Z3_context c, Z3_app a, <span class="keywordtype">unsigned</span> i) {
<a name="l02355"></a>02355         LOG_Z3_get_app_arg(c, a, i);
<a name="l02356"></a>02356         RESET_ERROR_CODE();  
<a name="l02357"></a>02357         <span class="keywordflow">if</span> (!is_app(reinterpret_cast&lt;ast*&gt;(a))) {
<a name="l02358"></a>02358             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02359"></a>02359             RETURN_Z3(0);
<a name="l02360"></a>02360         }
<a name="l02361"></a>02361         <span class="keywordflow">if</span> (i &gt;= to_app(a)-&gt;get_num_args()) {
<a name="l02362"></a>02362             SET_ERROR_CODE(Z3_IOB);
<a name="l02363"></a>02363             RETURN_Z3(0);
<a name="l02364"></a>02364         }
<a name="l02365"></a>02365         RETURN_Z3(of_ast(to_app(a)-&gt;get_arg(i)));
<a name="l02366"></a>02366     }
<a name="l02367"></a>02367     
<a name="l02368"></a>02368     Z3_symbol Z3_API <a class="code" href="group__capi.html#ga741b1bf11cb92aa2ec9ef2fef73ff129" title="Return the constant declaration name as a symbol.">Z3_get_decl_name</a>(Z3_context c, Z3_func_decl d) {
<a name="l02369"></a>02369         LOG_Z3_get_decl_name(c, d);
<a name="l02370"></a>02370         RESET_ERROR_CODE();  
<a name="l02371"></a>02371         <span class="keywordflow">return</span> of_symbol(to_func_decl(d)-&gt;get_name());
<a name="l02372"></a>02372     }
<a name="l02373"></a>02373 
<a name="l02374"></a><a class="code" href="group__capi.html#ga7267c77bab241e7ce5ab9ec12ba3ee2f">02374</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga7267c77bab241e7ce5ab9ec12ba3ee2f" title="Return the number of parameters associated with a declaration.">Z3_get_decl_num_parameters</a>(__in Z3_context c, __in Z3_func_decl d) {
<a name="l02375"></a>02375         LOG_Z3_get_decl_num_parameters(c, d);
<a name="l02376"></a>02376         RESET_ERROR_CODE();
<a name="l02377"></a>02377         <span class="keywordflow">return</span> to_func_decl(d)-&gt;get_num_parameters();
<a name="l02378"></a>02378     }
<a name="l02379"></a>02379 
<a name="l02380"></a><a class="code" href="group__capi.html#gad5358fc2b548bc7b1e3058a447f937e5">02380</a>     <a class="code" href="group__capi.html#ga78e078a95f8bb6b65918cb1e2ac48216" title="The different kinds of parameters that can be associated with function symbols.">Z3_parameter_kind</a> Z3_API <a class="code" href="group__capi.html#gad5358fc2b548bc7b1e3058a447f937e5" title="Return the parameter type associated with a declaration.">Z3_get_decl_parameter_kind</a>(__in Z3_context c, __in Z3_func_decl d, <span class="keywordtype">unsigned</span> idx) {
<a name="l02381"></a>02381         LOG_Z3_get_decl_parameter_kind(c, d, idx);
<a name="l02382"></a>02382         RESET_ERROR_CODE();
<a name="l02383"></a>02383         <span class="keywordflow">if</span> (idx &gt;= to_func_decl(d)-&gt;get_num_parameters()) {
<a name="l02384"></a>02384             SET_ERROR_CODE(Z3_IOB);
<a name="l02385"></a>02385             <span class="keywordflow">return</span> Z3_PARAMETER_INT;
<a name="l02386"></a>02386         }
<a name="l02387"></a>02387         parameter <span class="keyword">const</span>&amp; p = to_func_decl(d)-&gt;get_parameters()[idx];
<a name="l02388"></a>02388         <span class="keywordflow">if</span> (p.is_int()) {
<a name="l02389"></a>02389             <span class="keywordflow">return</span> Z3_PARAMETER_INT;
<a name="l02390"></a>02390         }
<a name="l02391"></a>02391         <span class="keywordflow">if</span> (p.is_double()) {
<a name="l02392"></a>02392             <span class="keywordflow">return</span> Z3_PARAMETER_DOUBLE;
<a name="l02393"></a>02393         }
<a name="l02394"></a>02394         <span class="keywordflow">if</span> (p.is_symbol()) {
<a name="l02395"></a>02395             <span class="keywordflow">return</span> Z3_PARAMETER_SYMBOL;
<a name="l02396"></a>02396         }
<a name="l02397"></a>02397         <span class="keywordflow">if</span> (p.is_rational()) {
<a name="l02398"></a>02398             <span class="keywordflow">return</span> Z3_PARAMETER_RATIONAL;
<a name="l02399"></a>02399         }
<a name="l02400"></a>02400         <span class="keywordflow">if</span> (p.is_ast() &amp;&amp; is_sort(p.get_ast())) {
<a name="l02401"></a>02401             <span class="keywordflow">return</span> Z3_PARAMETER_SORT;
<a name="l02402"></a>02402         }
<a name="l02403"></a>02403         <span class="keywordflow">if</span> (p.is_ast() &amp;&amp; is_expr(p.get_ast())) {
<a name="l02404"></a>02404             <span class="keywordflow">return</span> Z3_PARAMETER_AST;        
<a name="l02405"></a>02405         }
<a name="l02406"></a>02406         SASSERT(p.is_ast() &amp;&amp; is_func_decl(p.get_ast()));
<a name="l02407"></a>02407         <span class="keywordflow">return</span> Z3_PARAMETER_FUNC_DECL;        
<a name="l02408"></a>02408     }
<a name="l02409"></a>02409 
<a name="l02410"></a><a class="code" href="group__capi.html#ga4d74da355a2a19b205ad526117d33f6f">02410</a>     <span class="keywordtype">int</span> Z3_API <a class="code" href="group__capi.html#ga4d74da355a2a19b205ad526117d33f6f" title="Return the integer value associated with an integer parameter.">Z3_get_decl_int_parameter</a>(__in Z3_context c, __in Z3_func_decl d, <span class="keywordtype">unsigned</span> idx) {
<a name="l02411"></a>02411         LOG_Z3_get_decl_int_parameter(c, d, idx);
<a name="l02412"></a>02412         RESET_ERROR_CODE();
<a name="l02413"></a>02413         <span class="keywordflow">if</span> (idx &gt;= to_func_decl(d)-&gt;get_num_parameters()) {
<a name="l02414"></a>02414             SET_ERROR_CODE(Z3_IOB);
<a name="l02415"></a>02415             <span class="keywordflow">return</span> 0;
<a name="l02416"></a>02416         }        
<a name="l02417"></a>02417         parameter <span class="keyword">const</span>&amp; p = to_func_decl(d)-&gt;get_parameters()[idx];
<a name="l02418"></a>02418         <span class="keywordflow">if</span> (!p.is_int()) {
<a name="l02419"></a>02419             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02420"></a>02420             <span class="keywordflow">return</span> 0;
<a name="l02421"></a>02421         }
<a name="l02422"></a>02422         <span class="keywordflow">return</span> p.get_int();        
<a name="l02423"></a>02423     }
<a name="l02424"></a>02424 
<a name="l02425"></a><a class="code" href="group__capi.html#gafa8462db6c761de0e8d7fadee7f9a59e">02425</a>     <span class="keywordtype">double</span> Z3_API <a class="code" href="group__capi.html#gafa8462db6c761de0e8d7fadee7f9a59e" title="Return the double value associated with an double parameter.">Z3_get_decl_double_parameter</a>(__in Z3_context c, __in Z3_func_decl d, <span class="keywordtype">unsigned</span> idx) {
<a name="l02426"></a>02426         LOG_Z3_get_decl_double_parameter(c, d, idx);
<a name="l02427"></a>02427         RESET_ERROR_CODE();
<a name="l02428"></a>02428         <span class="keywordflow">if</span> (idx &gt;= to_func_decl(d)-&gt;get_num_parameters()) {
<a name="l02429"></a>02429             SET_ERROR_CODE(Z3_IOB);
<a name="l02430"></a>02430             <span class="keywordflow">return</span> 0;
<a name="l02431"></a>02431         }        
<a name="l02432"></a>02432         parameter <span class="keyword">const</span>&amp; p = to_func_decl(d)-&gt;get_parameters()[idx];
<a name="l02433"></a>02433         <span class="keywordflow">if</span> (!p.is_double()) {
<a name="l02434"></a>02434             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02435"></a>02435             <span class="keywordflow">return</span> 0;
<a name="l02436"></a>02436         }
<a name="l02437"></a>02437         <span class="keywordflow">return</span> p.get_double();        
<a name="l02438"></a>02438     }
<a name="l02439"></a>02439 
<a name="l02440"></a><a class="code" href="group__capi.html#gaa462276de2a80336d89bee0b99579ee9">02440</a>     Z3_symbol Z3_API <a class="code" href="group__capi.html#gaa462276de2a80336d89bee0b99579ee9" title="Return the double value associated with an double parameter.">Z3_get_decl_symbol_parameter</a>(__in Z3_context c, __in Z3_func_decl d, <span class="keywordtype">unsigned</span> idx) {
<a name="l02441"></a>02441         LOG_Z3_get_decl_symbol_parameter(c, d, idx);
<a name="l02442"></a>02442         RESET_ERROR_CODE();
<a name="l02443"></a>02443         <span class="keywordflow">if</span> (idx &gt;= to_func_decl(d)-&gt;get_num_parameters()) {
<a name="l02444"></a>02444             SET_ERROR_CODE(Z3_IOB);
<a name="l02445"></a>02445             <span class="keywordflow">return</span> 0;
<a name="l02446"></a>02446         }        
<a name="l02447"></a>02447         parameter <span class="keyword">const</span>&amp; p = to_func_decl(d)-&gt;get_parameters()[idx];
<a name="l02448"></a>02448         <span class="keywordflow">if</span> (!p.is_symbol()) {
<a name="l02449"></a>02449             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02450"></a>02450             <span class="keywordflow">return</span> 0;
<a name="l02451"></a>02451         }
<a name="l02452"></a>02452         <span class="keywordflow">return</span> of_symbol(p.get_symbol());        
<a name="l02453"></a>02453     }
<a name="l02454"></a>02454 
<a name="l02455"></a><a class="code" href="group__capi.html#ga8c89e51ead3718b084a9e223a3a42c0f">02455</a>     Z3_sort Z3_API <a class="code" href="group__capi.html#ga8c89e51ead3718b084a9e223a3a42c0f" title="Return the sort value associated with a sort parameter.">Z3_get_decl_sort_parameter</a>(__in Z3_context c, __in Z3_func_decl d, <span class="keywordtype">unsigned</span> idx) {
<a name="l02456"></a>02456         LOG_Z3_get_decl_sort_parameter(c, d, idx);
<a name="l02457"></a>02457         RESET_ERROR_CODE();
<a name="l02458"></a>02458         <span class="keywordflow">if</span> (idx &gt;= to_func_decl(d)-&gt;get_num_parameters()) {
<a name="l02459"></a>02459             SET_ERROR_CODE(Z3_IOB);
<a name="l02460"></a>02460             RETURN_Z3(0);
<a name="l02461"></a>02461         }        
<a name="l02462"></a>02462         parameter <span class="keyword">const</span>&amp; p = to_func_decl(d)-&gt;get_parameters()[idx];
<a name="l02463"></a>02463         <span class="keywordflow">if</span> (!p.is_ast() || !is_sort(p.get_ast())) {
<a name="l02464"></a>02464             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02465"></a>02465             RETURN_Z3(0);
<a name="l02466"></a>02466         }
<a name="l02467"></a>02467         RETURN_Z3(of_sort(to_sort(p.get_ast())));
<a name="l02468"></a>02468     }
<a name="l02469"></a>02469 
<a name="l02470"></a><a class="code" href="group__capi.html#ga9f37cba53c967162c8d35948f43453ab">02470</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga9f37cba53c967162c8d35948f43453ab" title="Return the expresson value associated with an expression parameter.">Z3_get_decl_ast_parameter</a>(__in Z3_context c, __in Z3_func_decl d, <span class="keywordtype">unsigned</span> idx) {
<a name="l02471"></a>02471         LOG_Z3_get_decl_ast_parameter(c, d, idx);
<a name="l02472"></a>02472         RESET_ERROR_CODE();
<a name="l02473"></a>02473         <span class="keywordflow">if</span> (idx &gt;= to_func_decl(d)-&gt;get_num_parameters()) {
<a name="l02474"></a>02474             SET_ERROR_CODE(Z3_IOB);
<a name="l02475"></a>02475             RETURN_Z3(0);
<a name="l02476"></a>02476         }        
<a name="l02477"></a>02477         parameter <span class="keyword">const</span>&amp; p = to_func_decl(d)-&gt;get_parameters()[idx];
<a name="l02478"></a>02478         <span class="keywordflow">if</span> (!p.is_ast() || !is_expr(p.get_ast())) {
<a name="l02479"></a>02479             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02480"></a>02480             RETURN_Z3(0);
<a name="l02481"></a>02481         }
<a name="l02482"></a>02482         RETURN_Z3(of_ast(p.get_ast()));
<a name="l02483"></a>02483     }
<a name="l02484"></a>02484 
<a name="l02485"></a><a class="code" href="group__capi.html#gad4d671917f88a00e4e32e00f578f54f3">02485</a>     Z3_func_decl Z3_API <a class="code" href="group__capi.html#gad4d671917f88a00e4e32e00f578f54f3" title="Return the expresson value associated with an expression parameter.">Z3_get_decl_func_decl_parameter</a>(__in Z3_context c, __in Z3_func_decl d, <span class="keywordtype">unsigned</span> idx) {
<a name="l02486"></a>02486         LOG_Z3_get_decl_func_decl_parameter(c, d, idx);
<a name="l02487"></a>02487         RESET_ERROR_CODE();
<a name="l02488"></a>02488         <span class="keywordflow">if</span> (idx &gt;= to_func_decl(d)-&gt;get_num_parameters()) {
<a name="l02489"></a>02489             SET_ERROR_CODE(Z3_IOB);
<a name="l02490"></a>02490             RETURN_Z3(0);
<a name="l02491"></a>02491         }        
<a name="l02492"></a>02492         parameter <span class="keyword">const</span>&amp; p = to_func_decl(d)-&gt;get_parameters()[idx];
<a name="l02493"></a>02493         <span class="keywordflow">if</span> (!p.is_ast() || !is_func_decl(p.get_ast())) {
<a name="l02494"></a>02494             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02495"></a>02495             RETURN_Z3(0);
<a name="l02496"></a>02496         }
<a name="l02497"></a>02497         RETURN_Z3(of_func_decl(to_func_decl(p.get_ast())));
<a name="l02498"></a>02498     }
<a name="l02499"></a>02499 
<a name="l02500"></a><a class="code" href="group__capi.html#gac84dd80d9b6b3f76a5012c084f60a4d4">02500</a>     <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> Z3_API <a class="code" href="group__capi.html#gac84dd80d9b6b3f76a5012c084f60a4d4" title="Return the rational value, as a string, associated with a rational parameter.">Z3_get_decl_rational_parameter</a>(__in Z3_context c, __in Z3_func_decl d, <span class="keywordtype">unsigned</span> idx) {
<a name="l02501"></a>02501         LOG_Z3_get_decl_rational_parameter(c, d, idx);
<a name="l02502"></a>02502         RESET_ERROR_CODE();
<a name="l02503"></a>02503         <span class="keywordflow">if</span> (idx &gt;= to_func_decl(d)-&gt;get_num_parameters()) {
<a name="l02504"></a>02504             SET_ERROR_CODE(Z3_IOB);
<a name="l02505"></a>02505             <span class="keywordflow">return</span> 0;
<a name="l02506"></a>02506         }        
<a name="l02507"></a>02507         parameter <span class="keyword">const</span>&amp; p = to_func_decl(d)-&gt;get_parameters()[idx];
<a name="l02508"></a>02508         <span class="keywordflow">if</span> (!p.is_rational()) {
<a name="l02509"></a>02509             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02510"></a>02510             <span class="keywordflow">return</span> 0;
<a name="l02511"></a>02511         }
<a name="l02512"></a>02512         mk_c(c)-&gt;m_numeral_ast_buffer = p.get_rational().to_string();
<a name="l02513"></a>02513         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(mk_c(c)-&gt;m_numeral_ast_buffer.c_str());            
<a name="l02514"></a>02514     }
<a name="l02515"></a>02515 
<a name="l02516"></a>02516     
<a name="l02517"></a>02517     Z3_symbol Z3_API <a class="code" href="group__capi.html#gaefff01e612e5ebb1117af870ee3a9237" title="Return the sort name as a symbol.">Z3_get_sort_name</a>(Z3_context c, Z3_sort t) {
<a name="l02518"></a>02518         LOG_Z3_get_sort_name(c, t);
<a name="l02519"></a>02519         RESET_ERROR_CODE();  
<a name="l02520"></a>02520         <span class="keywordflow">return</span> of_symbol(to_sort(t)-&gt;get_name());
<a name="l02521"></a>02521     }
<a name="l02522"></a>02522     
<a name="l02523"></a>02523     Z3_sort Z3_API <a class="code" href="group__capi.html#ga0a4dac7e9397ff067136354cd33cb933" title="Return the sort of an AST node.">Z3_get_sort</a>(Z3_context c, Z3_ast a) {
<a name="l02524"></a>02524         LOG_Z3_get_sort(c, a);
<a name="l02525"></a>02525         RESET_ERROR_CODE(); 
<a name="l02526"></a>02526         Z3_sort r = of_sort(mk_c(c)-&gt;m_manager.get_sort(to_expr(a)));
<a name="l02527"></a>02527         RETURN_Z3(r);
<a name="l02528"></a>02528     }
<a name="l02529"></a>02529     
<a name="l02530"></a>02530     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga0c7965cc0cd9c266765620de6c66873e" title="Alias for Z3_get_domain_size.">Z3_get_arity</a>(Z3_context c, Z3_func_decl d) {
<a name="l02531"></a>02531         LOG_Z3_get_arity(c, d);
<a name="l02532"></a>02532         RESET_ERROR_CODE();  
<a name="l02533"></a>02533         <span class="keywordflow">return</span> to_func_decl(d)-&gt;get_arity();
<a name="l02534"></a>02534     }
<a name="l02535"></a>02535 
<a name="l02536"></a>02536     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga3a2c7d27579336a03adc587cec833bf9" title="Return the number of parameters of the given declaration.">Z3_get_domain_size</a>(Z3_context c, Z3_func_decl d) {
<a name="l02537"></a>02537         LOG_Z3_get_domain_size(c, d);
<a name="l02538"></a>02538         RESET_ERROR_CODE();   
<a name="l02539"></a>02539         <span class="keywordflow">return</span> to_func_decl(d)-&gt;get_arity();
<a name="l02540"></a>02540     }
<a name="l02541"></a>02541 
<a name="l02542"></a>02542     
<a name="l02543"></a>02543     Z3_sort Z3_API <a class="code" href="group__capi.html#gaa648c7b589597e76cd5ffcfb2c917b24" title="Return the sort of the i-th parameter of the given function declaration.">Z3_get_domain</a>(Z3_context c, Z3_func_decl d, <span class="keywordtype">unsigned</span> i) {
<a name="l02544"></a>02544         LOG_Z3_get_domain(c, d, i);
<a name="l02545"></a>02545         RESET_ERROR_CODE();   
<a name="l02546"></a>02546         <span class="keywordflow">if</span> (i &gt;= to_func_decl(d)-&gt;get_arity()) {
<a name="l02547"></a>02547             SET_ERROR_CODE(Z3_IOB);
<a name="l02548"></a>02548             RETURN_Z3(0);
<a name="l02549"></a>02549         }
<a name="l02550"></a>02550         Z3_sort r = of_sort(to_func_decl(d)-&gt;get_domain(i));
<a name="l02551"></a>02551         RETURN_Z3(r);
<a name="l02552"></a>02552     }
<a name="l02553"></a>02553     
<a name="l02554"></a>02554     Z3_sort Z3_API <a class="code" href="group__capi.html#gaf996fe33bd42bea8fa8ddf44fcf0bd77" title="Return the range of the given declaration.">Z3_get_range</a>(Z3_context c, Z3_func_decl d) {
<a name="l02555"></a>02555         LOG_Z3_get_range(c, d);
<a name="l02556"></a>02556         RESET_ERROR_CODE();  
<a name="l02557"></a>02557         CHECK_VALID_AST(d);
<a name="l02558"></a>02558         Z3_sort r = of_sort(to_func_decl(d)-&gt;get_range());
<a name="l02559"></a>02559         RETURN_Z3(r);
<a name="l02560"></a>02560     }
<a name="l02561"></a>02561     
<a name="l02562"></a>02562     <a class="code" href="group__capi.html#ga4cd6ad05aba48f4b679f0c13310ed2a4" title="The different kinds of Z3 types (See Z3_get_sort_kind).">Z3_sort_kind</a> <a class="code" href="group__capi.html#ga6d694951de4c7f115ed472eb32ef963c" title="Return the sort kind (e.g., array, tuple, int, bool, etc).">Z3_get_sort_kind</a>(Z3_context c, Z3_sort t) {
<a name="l02563"></a>02563         LOG_Z3_get_sort_kind(c, t);
<a name="l02564"></a>02564         RESET_ERROR_CODE();   
<a name="l02565"></a>02565         CHECK_VALID_AST(t);
<a name="l02566"></a>02566         family_id fid = to_sort(t)-&gt;get_family_id();
<a name="l02567"></a>02567         decl_kind k   = to_sort(t)-&gt;get_decl_kind();
<a name="l02568"></a>02568         <span class="keywordflow">if</span> (fid == null_family_id) {
<a name="l02569"></a>02569             <span class="keywordflow">return</span> Z3_UNINTERPRETED_SORT;
<a name="l02570"></a>02570         }
<a name="l02571"></a>02571         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid == mk_c(c)-&gt;m_manager.get_basic_family_id() &amp;&amp; k == BOOL_SORT) {
<a name="l02572"></a>02572             <span class="keywordflow">return</span> Z3_BOOL_SORT;
<a name="l02573"></a>02573         }
<a name="l02574"></a>02574         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid == mk_c(c)-&gt;m_arith_fid &amp;&amp; k == INT_SORT) {
<a name="l02575"></a>02575             <span class="keywordflow">return</span> Z3_INT_SORT;
<a name="l02576"></a>02576         }
<a name="l02577"></a>02577         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid == mk_c(c)-&gt;m_arith_fid &amp;&amp; k == REAL_SORT) {
<a name="l02578"></a>02578             <span class="keywordflow">return</span> Z3_REAL_SORT;
<a name="l02579"></a>02579         }
<a name="l02580"></a>02580         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid == mk_c(c)-&gt;m_bv_fid &amp;&amp; k == BV_SORT) {
<a name="l02581"></a>02581             <span class="keywordflow">return</span> Z3_BV_SORT;
<a name="l02582"></a>02582         }
<a name="l02583"></a>02583         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid == mk_c(c)-&gt;m_array_fid &amp;&amp; k == ARRAY_SORT) {
<a name="l02584"></a>02584             <span class="keywordflow">return</span> Z3_ARRAY_SORT;
<a name="l02585"></a>02585         }
<a name="l02586"></a>02586         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid == mk_c(c)-&gt;m_dt_fid &amp;&amp; k == DATATYPE_SORT) {
<a name="l02587"></a>02587             <span class="keywordflow">return</span> Z3_DATATYPE_SORT;
<a name="l02588"></a>02588         }
<a name="l02589"></a>02589         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid == mk_c(c)-&gt;datalog_get_family_id() &amp;&amp; k == datalog::DL_RELATION_SORT) {
<a name="l02590"></a>02590             <span class="keywordflow">return</span> Z3_RELATION_SORT;
<a name="l02591"></a>02591         }
<a name="l02592"></a>02592         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fid == mk_c(c)-&gt;datalog_get_family_id() &amp;&amp; k == datalog::DL_FINITE_SORT) {
<a name="l02593"></a>02593             <span class="keywordflow">return</span> Z3_FINITE_DOMAIN_SORT;
<a name="l02594"></a>02594         }
<a name="l02595"></a>02595         <span class="keywordflow">else</span> {
<a name="l02596"></a>02596             <span class="keywordflow">return</span> Z3_UNKNOWN_SORT;
<a name="l02597"></a>02597         }
<a name="l02598"></a>02598     }
<a name="l02599"></a>02599 
<a name="l02600"></a>02600     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga8fc3550edace7bc046e16d1f96ddb419" title="Return the size of the given bit-vector sort.">Z3_get_bv_sort_size</a>(Z3_context c, Z3_sort t) {
<a name="l02601"></a>02601         LOG_Z3_get_bv_sort_size(c, t);
<a name="l02602"></a>02602         RESET_ERROR_CODE(); 
<a name="l02603"></a>02603         CHECK_VALID_AST(t);
<a name="l02604"></a>02604         <span class="keywordflow">if</span> (to_sort(t)-&gt;get_family_id() == mk_c(c)-&gt;m_bv_fid &amp;&amp; to_sort(t)-&gt;get_decl_kind() == BV_SORT) {
<a name="l02605"></a>02605             <span class="keywordflow">return</span> to_sort(t)-&gt;get_parameter(0).get_int();
<a name="l02606"></a>02606         }
<a name="l02607"></a>02607         SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02608"></a>02608         <span class="keywordflow">return</span> 0;
<a name="l02609"></a>02609     }
<a name="l02610"></a>02610     
<a name="l02611"></a>02611     Z3_sort Z3_API <a class="code" href="group__capi.html#ga9753605ed27131dee29abcfb21e1dc9a" title="Return the domain of the given array sort.">Z3_get_array_sort_domain</a>(Z3_context c, Z3_sort t) {
<a name="l02612"></a>02612         LOG_Z3_get_array_sort_domain(c, t);
<a name="l02613"></a>02613         RESET_ERROR_CODE();
<a name="l02614"></a>02614         CHECK_VALID_AST(t); 
<a name="l02615"></a>02615         <span class="keywordflow">if</span> (to_sort(t)-&gt;get_family_id() == mk_c(c)-&gt;m_array_fid &amp;&amp; 
<a name="l02616"></a>02616             to_sort(t)-&gt;get_decl_kind() == ARRAY_SORT) {
<a name="l02617"></a>02617             Z3_sort r = <span class="keyword">reinterpret_cast&lt;</span>Z3_sort<span class="keyword">&gt;</span>(to_sort(t)-&gt;get_parameter(0).get_ast());
<a name="l02618"></a>02618             RETURN_Z3(r);
<a name="l02619"></a>02619         }
<a name="l02620"></a>02620         SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02621"></a>02621         RETURN_Z3(0);
<a name="l02622"></a>02622     }
<a name="l02623"></a>02623     
<a name="l02624"></a>02624     Z3_sort Z3_API <a class="code" href="group__capi.html#ga72832f8215d6232ce1fef9774d1bf192" title="Return the range of the given array sort.">Z3_get_array_sort_range</a>(Z3_context c, Z3_sort t) {
<a name="l02625"></a>02625         LOG_Z3_get_array_sort_range(c, t);
<a name="l02626"></a>02626         RESET_ERROR_CODE(); 
<a name="l02627"></a>02627         CHECK_VALID_AST(t);
<a name="l02628"></a>02628         <span class="keywordflow">if</span> (to_sort(t)-&gt;get_family_id() == mk_c(c)-&gt;m_array_fid &amp;&amp; 
<a name="l02629"></a>02629             to_sort(t)-&gt;get_decl_kind() == ARRAY_SORT) {
<a name="l02630"></a>02630             Z3_sort r = <span class="keyword">reinterpret_cast&lt;</span>Z3_sort<span class="keyword">&gt;</span>(to_sort(t)-&gt;get_parameter(1).get_ast());
<a name="l02631"></a>02631             RETURN_Z3(r);
<a name="l02632"></a>02632         }
<a name="l02633"></a>02633         SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02634"></a>02634         RETURN_Z3(0);
<a name="l02635"></a>02635     }
<a name="l02636"></a>02636 
<a name="l02637"></a>02637     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#gae9ab82612fd84f5ce7991ade7d7ad920" title="Return number of constructors for datatype.">Z3_get_datatype_sort_num_constructors</a>(Z3_context c, Z3_sort t) {
<a name="l02638"></a>02638         LOG_Z3_get_datatype_sort_num_constructors(c, t);
<a name="l02639"></a>02639         RESET_ERROR_CODE();
<a name="l02640"></a>02640         CHECK_VALID_AST(t);
<a name="l02641"></a>02641         sort * _t = to_sort(t);
<a name="l02642"></a>02642         datatype_util dt_util(mk_c(c)-&gt;m_manager);
<a name="l02643"></a>02643         
<a name="l02644"></a>02644         <span class="keywordflow">if</span> (!dt_util.is_datatype(_t)) {
<a name="l02645"></a>02645             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02646"></a>02646             <span class="keywordflow">return</span> 0;            
<a name="l02647"></a>02647         }
<a name="l02648"></a>02648         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * decls = dt_util.get_datatype_constructors(_t);
<a name="l02649"></a>02649         <span class="keywordflow">if</span> (!decls) {
<a name="l02650"></a>02650             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02651"></a>02651             <span class="keywordflow">return</span> 0;                        
<a name="l02652"></a>02652         }
<a name="l02653"></a>02653         <span class="keywordflow">return</span> decls-&gt;size();
<a name="l02654"></a>02654     }
<a name="l02655"></a>02655 
<a name="l02656"></a>02656     Z3_func_decl get_datatype_sort_constructor_core(Z3_context c, Z3_sort t, <span class="keywordtype">unsigned</span> idx) {
<a name="l02657"></a>02657         RESET_ERROR_CODE();
<a name="l02658"></a>02658         CHECK_VALID_AST(t);   
<a name="l02659"></a>02659         sort * _t = to_sort(t);
<a name="l02660"></a>02660         datatype_util dt_util(mk_c(c)-&gt;m_manager);
<a name="l02661"></a>02661         <span class="keywordflow">if</span> (!dt_util.is_datatype(_t)) {
<a name="l02662"></a>02662             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02663"></a>02663             <span class="keywordflow">return</span> 0;
<a name="l02664"></a>02664         }
<a name="l02665"></a>02665         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * decls = dt_util.get_datatype_constructors(_t);
<a name="l02666"></a>02666         <span class="keywordflow">if</span> (!decls || idx &gt;= decls-&gt;size()) {
<a name="l02667"></a>02667             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02668"></a>02668             <span class="keywordflow">return</span> 0;
<a name="l02669"></a>02669         }
<a name="l02670"></a>02670         func_decl* decl = (*decls)[idx];
<a name="l02671"></a>02671         mk_c(c)-&gt;save_ast_trail(decl);
<a name="l02672"></a>02672         <span class="keywordflow">return</span> of_func_decl(decl);
<a name="l02673"></a>02673     }
<a name="l02674"></a>02674 
<a name="l02675"></a>02675     Z3_func_decl Z3_API <a class="code" href="group__capi.html#gaa5630cbd0f28d2bda21dc5376fe86a9b" title="Return idx&amp;#39;th constructor.">Z3_get_datatype_sort_constructor</a>(Z3_context c, Z3_sort t, <span class="keywordtype">unsigned</span> idx) {
<a name="l02676"></a>02676         LOG_Z3_get_datatype_sort_constructor(c, t, idx);
<a name="l02677"></a>02677         Z3_func_decl r = get_datatype_sort_constructor_core(c, t, idx);
<a name="l02678"></a>02678         RETURN_Z3(r);
<a name="l02679"></a>02679     }
<a name="l02680"></a>02680 
<a name="l02681"></a>02681     Z3_func_decl Z3_API <a class="code" href="group__capi.html#gacf79f46d05b3ed69684d47eaf242319c" title="Return idx&amp;#39;th recognizer.">Z3_get_datatype_sort_recognizer</a>(Z3_context c, Z3_sort t, <span class="keywordtype">unsigned</span> idx) {
<a name="l02682"></a>02682         LOG_Z3_get_datatype_sort_recognizer(c, t, idx);
<a name="l02683"></a>02683         RESET_ERROR_CODE();   
<a name="l02684"></a>02684         sort * _t = to_sort(t);
<a name="l02685"></a>02685         datatype_util dt_util(mk_c(c)-&gt;m_manager);
<a name="l02686"></a>02686         
<a name="l02687"></a>02687         <span class="keywordflow">if</span> (!dt_util.is_datatype(_t)) {
<a name="l02688"></a>02688             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02689"></a>02689             RETURN_Z3(0);
<a name="l02690"></a>02690         }
<a name="l02691"></a>02691         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * decls = dt_util.get_datatype_constructors(_t);
<a name="l02692"></a>02692         <span class="keywordflow">if</span> (!decls || idx &gt;= decls-&gt;size()) {
<a name="l02693"></a>02693             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02694"></a>02694             RETURN_Z3(0);                        
<a name="l02695"></a>02695         }
<a name="l02696"></a>02696         func_decl* decl = (*decls)[idx];
<a name="l02697"></a>02697         decl = dt_util.get_constructor_recognizer(decl);
<a name="l02698"></a>02698         mk_c(c)-&gt;save_ast_trail(decl);
<a name="l02699"></a>02699         RETURN_Z3(of_func_decl(decl));
<a name="l02700"></a>02700     }
<a name="l02701"></a>02701 
<a name="l02702"></a>02702     Z3_func_decl Z3_API <a class="code" href="group__capi.html#gab0ade72138d0479409f47cef21972eb2" title="Return idx_a&amp;#39;th accessor for the idx_c&amp;#39;th constructor.">Z3_get_datatype_sort_constructor_accessor</a>(Z3_context c, Z3_sort t, <span class="keywordtype">unsigned</span> idx_c, <span class="keywordtype">unsigned</span> idx_a) {
<a name="l02703"></a>02703         LOG_Z3_get_datatype_sort_constructor_accessor(c, t, idx_c, idx_a);
<a name="l02704"></a>02704         RESET_ERROR_CODE();  
<a name="l02705"></a>02705         sort * _t = to_sort(t);
<a name="l02706"></a>02706         datatype_util dt_util(mk_c(c)-&gt;m_manager);
<a name="l02707"></a>02707         
<a name="l02708"></a>02708         <span class="keywordflow">if</span> (!dt_util.is_datatype(_t)) {
<a name="l02709"></a>02709             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02710"></a>02710             RETURN_Z3(0);            
<a name="l02711"></a>02711         }
<a name="l02712"></a>02712         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * decls = dt_util.get_datatype_constructors(_t);
<a name="l02713"></a>02713         <span class="keywordflow">if</span> (!decls || idx_c &gt;= decls-&gt;size()) {
<a name="l02714"></a>02714             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02715"></a>02715             RETURN_Z3(0);                        
<a name="l02716"></a>02716         }
<a name="l02717"></a>02717         func_decl* decl = (*decls)[idx_c];
<a name="l02718"></a>02718         <span class="keywordflow">if</span> (decl-&gt;get_arity() &lt;= idx_a) {
<a name="l02719"></a>02719             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02720"></a>02720             RETURN_Z3(0);                        
<a name="l02721"></a>02721         }
<a name="l02722"></a>02722         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * accs = dt_util.get_constructor_accessors(decl);
<a name="l02723"></a>02723         SASSERT(accs &amp;&amp; accs-&gt;size() == decl-&gt;get_arity());
<a name="l02724"></a>02724         <span class="keywordflow">if</span> (!accs || accs-&gt;size() &lt;= idx_a) {
<a name="l02725"></a>02725             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02726"></a>02726             RETURN_Z3(0);                        
<a name="l02727"></a>02727         }
<a name="l02728"></a>02728         decl = (*accs)[idx_a];
<a name="l02729"></a>02729         mk_c(c)-&gt;save_ast_trail(decl);
<a name="l02730"></a>02730         RETURN_Z3(of_func_decl(decl)); 
<a name="l02731"></a>02731     }
<a name="l02732"></a>02732 
<a name="l02733"></a>02733     Z3_func_decl Z3_API <a class="code" href="group__capi.html#gad16a0317b4ed90ccb4037f7e624bfd88" title="Return the constructor declaration of the given tuple sort.">Z3_get_tuple_sort_mk_decl</a>(Z3_context c, Z3_sort t) {
<a name="l02734"></a>02734         LOG_Z3_get_tuple_sort_mk_decl(c, t);
<a name="l02735"></a>02735         RESET_ERROR_CODE();  
<a name="l02736"></a>02736         sort * tuple = to_sort(t);
<a name="l02737"></a>02737         datatype_util dt_util(mk_c(c)-&gt;m_manager);
<a name="l02738"></a>02738         <span class="keywordflow">if</span> (!dt_util.is_datatype(tuple) || dt_util.is_recursive(tuple) || dt_util.get_datatype_num_constructors(tuple) != 1) {
<a name="l02739"></a>02739             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02740"></a>02740             RETURN_Z3(0);
<a name="l02741"></a>02741         }
<a name="l02742"></a>02742         Z3_func_decl r = get_datatype_sort_constructor_core(c, t, 0);
<a name="l02743"></a>02743         RETURN_Z3(r);
<a name="l02744"></a>02744     }
<a name="l02745"></a>02745     
<a name="l02746"></a>02746     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#gaff3ba6ad93295a4b4d8a8d3c06b7aa72" title="Return the number of fields of the given tuple sort.">Z3_get_tuple_sort_num_fields</a>(Z3_context c, Z3_sort t) {
<a name="l02747"></a>02747         LOG_Z3_get_tuple_sort_num_fields(c, t);
<a name="l02748"></a>02748         RESET_ERROR_CODE();   
<a name="l02749"></a>02749         sort * tuple = to_sort(t);
<a name="l02750"></a>02750         datatype_util dt_util(mk_c(c)-&gt;m_manager);
<a name="l02751"></a>02751         <span class="keywordflow">if</span> (!dt_util.is_datatype(tuple) || dt_util.is_recursive(tuple) || dt_util.get_datatype_num_constructors(tuple) != 1) {
<a name="l02752"></a>02752             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02753"></a>02753             <span class="keywordflow">return</span> 0;            
<a name="l02754"></a>02754         }
<a name="l02755"></a>02755         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * decls = dt_util.get_datatype_constructors(tuple);
<a name="l02756"></a>02756         <span class="keywordflow">if</span> (!decls || decls-&gt;size() != 1) {
<a name="l02757"></a>02757             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02758"></a>02758             <span class="keywordflow">return</span> 0;                        
<a name="l02759"></a>02759         }
<a name="l02760"></a>02760         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * accs = dt_util.get_constructor_accessors((*decls)[0]);
<a name="l02761"></a>02761         <span class="keywordflow">if</span> (!accs) {
<a name="l02762"></a>02762             <span class="keywordflow">return</span> 0;                        
<a name="l02763"></a>02763         }
<a name="l02764"></a>02764         <span class="keywordflow">return</span> accs-&gt;size();
<a name="l02765"></a>02765     }
<a name="l02766"></a>02766     
<a name="l02767"></a>02767     Z3_func_decl Z3_API <a class="code" href="group__capi.html#gae17ed9db93c03f4f60a336c95fb60c44" title="Return the i-th field declaration (i.e., projection function declaration) of the...">Z3_get_tuple_sort_field_decl</a>(Z3_context c, Z3_sort t, <span class="keywordtype">unsigned</span> i) {
<a name="l02768"></a>02768         LOG_Z3_get_tuple_sort_field_decl(c, t, i);
<a name="l02769"></a>02769         RESET_ERROR_CODE();  
<a name="l02770"></a>02770         sort * tuple = to_sort(t);
<a name="l02771"></a>02771         datatype_util dt_util(mk_c(c)-&gt;m_manager);
<a name="l02772"></a>02772         <span class="keywordflow">if</span> (!dt_util.is_datatype(tuple) || dt_util.is_recursive(tuple) || dt_util.get_datatype_num_constructors(tuple) != 1) {
<a name="l02773"></a>02773             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02774"></a>02774             RETURN_Z3(0);
<a name="l02775"></a>02775         }
<a name="l02776"></a>02776         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * decls = dt_util.get_datatype_constructors(tuple);
<a name="l02777"></a>02777         <span class="keywordflow">if</span> (!decls || decls-&gt;size() != 1) {
<a name="l02778"></a>02778             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02779"></a>02779             RETURN_Z3(0);
<a name="l02780"></a>02780         }
<a name="l02781"></a>02781         ptr_vector&lt;func_decl&gt; <span class="keyword">const</span> * accs = dt_util.get_constructor_accessors((*decls)[0]);
<a name="l02782"></a>02782         <span class="keywordflow">if</span> (!accs) {
<a name="l02783"></a>02783             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02784"></a>02784             RETURN_Z3(0);
<a name="l02785"></a>02785         }
<a name="l02786"></a>02786         <span class="keywordflow">if</span> (accs-&gt;size() &lt;= i) {
<a name="l02787"></a>02787             SET_ERROR_CODE(Z3_IOB);
<a name="l02788"></a>02788             RETURN_Z3(0);
<a name="l02789"></a>02789         }
<a name="l02790"></a>02790         func_decl* acc = (*accs)[i];
<a name="l02791"></a>02791         mk_c(c)-&gt;save_ast_trail(acc);
<a name="l02792"></a>02792         RETURN_Z3(of_func_decl(acc));
<a name="l02793"></a>02793     }
<a name="l02794"></a>02794 
<a name="l02795"></a><a class="code" href="group__capi.html#gab9df718d19407dad33a795f1ca7adbe3">02795</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#gab9df718d19407dad33a795f1ca7adbe3" title="Return arity of relation.">Z3_get_relation_arity</a>(__in Z3_context c, __in Z3_sort s) {
<a name="l02796"></a>02796         LOG_Z3_get_relation_arity(c, s);
<a name="l02797"></a>02797         RESET_ERROR_CODE();  
<a name="l02798"></a>02798         sort * r = to_sort(s);
<a name="l02799"></a>02799         <span class="keywordflow">if</span> (<a class="code" href="group__capi.html#ga6d694951de4c7f115ed472eb32ef963c" title="Return the sort kind (e.g., array, tuple, int, bool, etc).">Z3_get_sort_kind</a>(c, s) != Z3_RELATION_SORT) {
<a name="l02800"></a>02800             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02801"></a>02801             <span class="keywordflow">return</span> 0;
<a name="l02802"></a>02802         }
<a name="l02803"></a>02803         <span class="keywordflow">return</span> r-&gt;get_num_parameters();
<a name="l02804"></a>02804     }
<a name="l02805"></a>02805 
<a name="l02806"></a><a class="code" href="group__capi.html#gaab7078b1cb0a47a8813eede8ef39a574">02806</a>     Z3_sort Z3_API <a class="code" href="group__capi.html#gaab7078b1cb0a47a8813eede8ef39a574" title="Return sort at i&amp;#39;th column of relation sort.">Z3_get_relation_column</a>(__in Z3_context c, __in Z3_sort s, <span class="keywordtype">unsigned</span> col) {
<a name="l02807"></a>02807         LOG_Z3_get_relation_column(c, s, col);
<a name="l02808"></a>02808         RESET_ERROR_CODE();  
<a name="l02809"></a>02809         sort * r = to_sort(s);
<a name="l02810"></a>02810         <span class="keywordflow">if</span> (<a class="code" href="group__capi.html#ga6d694951de4c7f115ed472eb32ef963c" title="Return the sort kind (e.g., array, tuple, int, bool, etc).">Z3_get_sort_kind</a>(c, s) != Z3_RELATION_SORT) {
<a name="l02811"></a>02811             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02812"></a>02812             RETURN_Z3(0);
<a name="l02813"></a>02813         }
<a name="l02814"></a>02814         <span class="keywordflow">if</span> (col &gt;= r-&gt;get_num_parameters()) {
<a name="l02815"></a>02815             SET_ERROR_CODE(Z3_IOB);
<a name="l02816"></a>02816             RETURN_Z3(0);
<a name="l02817"></a>02817         }
<a name="l02818"></a>02818         parameter <span class="keyword">const</span>&amp; p = r-&gt;get_parameter(col);
<a name="l02819"></a>02819         <span class="keywordflow">if</span> (!p.is_ast() || !is_sort(p.get_ast())) {
<a name="l02820"></a>02820             UNREACHABLE();
<a name="l02821"></a>02821             warning_msg(<span class="stringliteral">&quot;Sort parameter expected at %d&quot;</span>, col);
<a name="l02822"></a>02822             SET_ERROR_CODE(Z3_INTERNAL_FATAL);
<a name="l02823"></a>02823             RETURN_Z3(0);
<a name="l02824"></a>02824         }
<a name="l02825"></a>02825         Z3_sort res = of_sort(to_sort(p.get_ast()));
<a name="l02826"></a>02826         RETURN_Z3(res);
<a name="l02827"></a>02827     }
<a name="l02828"></a>02828 
<a name="l02829"></a><a class="code" href="group__capi.html#ga932395cac12c8348f6b333034a984c80">02829</a>     Z3_sort Z3_API <a class="code" href="group__capi.html#ga932395cac12c8348f6b333034a984c80" title="Create a named finite domain sort.">Z3_mk_finite_domain_sort</a>(__in Z3_context c, __in Z3_symbol name, __in <span class="keywordtype">unsigned</span> __int64 size) {
<a name="l02830"></a>02830         LOG_Z3_mk_finite_domain_sort(c, name, size);
<a name="l02831"></a>02831         RESET_ERROR_CODE();
<a name="l02832"></a>02832         sort* s = mk_c(c)-&gt;datalog_get_util().mk_sort(to_symbol(name), size);
<a name="l02833"></a>02833         mk_c(c)-&gt;save_ast_trail(s);
<a name="l02834"></a>02834         <span class="keywordflow">return</span> of_sort(s);
<a name="l02835"></a>02835         RETURN_Z3(of_sort(s));
<a name="l02836"></a>02836     }
<a name="l02837"></a>02837 
<a name="l02838"></a><a class="code" href="group__capi.html#gaca48e68b56b0900023143d7e9c696b41">02838</a>     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#gaca48e68b56b0900023143d7e9c696b41" title="Store the size of the sort in r. Return Z3_TRUE if the call succeeded. That is, Z3_get_sort_kind(s)...">Z3_get_finite_domain_sort_size</a>(__in Z3_context c, __in Z3_sort s, __out <span class="keywordtype">unsigned</span> __int64 * out) {
<a name="l02839"></a>02839         <span class="keywordflow">if</span> (<a class="code" href="group__capi.html#ga6d694951de4c7f115ed472eb32ef963c" title="Return the sort kind (e.g., array, tuple, int, bool, etc).">Z3_get_sort_kind</a>(c, s) != Z3_FINITE_DOMAIN_SORT) {
<a name="l02840"></a>02840             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l02841"></a>02841         }
<a name="l02842"></a>02842         <span class="comment">// must start loggging here, since function uses Z3_get_sort_kind above</span>
<a name="l02843"></a>02843         LOG_Z3_get_finite_domain_sort_size(c, s, out);
<a name="l02844"></a>02844         RESET_ERROR_CODE();  
<a name="l02845"></a>02845         *out = mk_c(c)-&gt;datalog_get_sort_size(to_sort(s));
<a name="l02846"></a>02846         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l02847"></a>02847 
<a name="l02848"></a>02848     }
<a name="l02849"></a>02849 
<a name="l02850"></a>02850     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#gad651ad68c7a060cbb5616349233cb10f" title="Create a backtracking point.">Z3_push</a>(Z3_context c) {
<a name="l02851"></a>02851         LOG_Z3_push(c);
<a name="l02852"></a>02852         RESET_ERROR_CODE();
<a name="l02853"></a>02853         CHECK_SEARCHING(c);
<a name="l02854"></a>02854         mk_c(c)-&gt;push();
<a name="l02855"></a>02855     }
<a name="l02856"></a>02856         
<a name="l02857"></a>02857     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#gab2b3a542006c86c8d86dc37872f88b61" title="Backtrack.">Z3_pop</a>(Z3_context c, <span class="keywordtype">unsigned</span> num_scopes) {
<a name="l02858"></a>02858         LOG_Z3_pop(c, num_scopes);
<a name="l02859"></a>02859         RESET_ERROR_CODE();
<a name="l02860"></a>02860         CHECK_SEARCHING(c);
<a name="l02861"></a>02861         <span class="keywordflow">if</span> (num_scopes &gt; mk_c(c)-&gt;get_context().get_scope_level()) {
<a name="l02862"></a>02862             warning_msg(<span class="stringliteral">&quot;Pop is called without a matching Push&quot;</span>);
<a name="l02863"></a>02863             SET_ERROR_CODE(Z3_IOB);
<a name="l02864"></a>02864         }
<a name="l02865"></a>02865         <span class="keywordflow">if</span> (num_scopes &gt; 0) {
<a name="l02866"></a>02866             mk_c(c)-&gt;pop(num_scopes);
<a name="l02867"></a>02867         }
<a name="l02868"></a>02868     }
<a name="l02869"></a>02869 
<a name="l02870"></a><a class="code" href="group__capi.html#ga676dc88a0b2ce9fb736be803bc3247f0">02870</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga676dc88a0b2ce9fb736be803bc3247f0" title="Retrieve the current scope level.">Z3_get_num_scopes</a>(__in Z3_context c) {
<a name="l02871"></a>02871         LOG_Z3_get_num_scopes(c);
<a name="l02872"></a>02872         <span class="keywordflow">return</span> mk_c(c)-&gt;m_ast_lim.size();
<a name="l02873"></a>02873     }
<a name="l02874"></a>02874 
<a name="l02875"></a>02875     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#gaa2d548abec8f6f479e29a9a6b5baefc0" title="Persist AST through num_scopes pops. This function is only relevant if c was created...">Z3_persist_ast</a>(__in Z3_context c, __in Z3_ast n, <span class="keywordtype">unsigned</span> num_scopes) {
<a name="l02876"></a>02876         LOG_Z3_persist_ast(c, n, num_scopes);
<a name="l02877"></a>02877         RESET_ERROR_CODE();
<a name="l02878"></a>02878         CHECK_VALID_AST(to_ast(n));
<a name="l02879"></a>02879         mk_c(c)-&gt;persist_ast(to_ast(n), num_scopes);
<a name="l02880"></a>02880     }
<a name="l02881"></a>02881 
<a name="l02882"></a>02882     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga1a05ff73a564ae7256a2257048a4680a" title="Assert a constraing into the logical context.">Z3_assert_cnstr</a>(Z3_context c, Z3_ast a) {
<a name="l02883"></a>02883         LOG_Z3_assert_cnstr(c, a);
<a name="l02884"></a>02884         RESET_ERROR_CODE();
<a name="l02885"></a>02885         CHECK_VALID_AST(to_expr(a));        
<a name="l02886"></a>02886         mk_c(c)-&gt;assert_cnstr(to_expr(a));
<a name="l02887"></a>02887     }
<a name="l02888"></a>02888     
<a name="l02889"></a>02889     <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> Z3_API <a class="code" href="group__capi.html#gaff310fef80ac8a82d0a51417e073ec0a" title="Check whether the given logical context is consistent or not.">Z3_check_and_get_model</a>(Z3_context c, Z3_model * m) {
<a name="l02890"></a>02890         LOG_Z3_check_and_get_model(c, m);
<a name="l02891"></a>02891         RESET_ERROR_CODE();
<a name="l02892"></a>02892         CHECK_SEARCHING(c);
<a name="l02893"></a>02893         flet&lt;bool&gt; _model(mk_c(c)-&gt;m_params.m_model, <span class="keyword">true</span>);
<a name="l02894"></a>02894         lbool result;
<a name="l02895"></a>02895         <span class="keywordflow">if</span> (m) {
<a name="l02896"></a>02896             model * _m = 0;
<a name="l02897"></a>02897             result = mk_c(c)-&gt;check(&amp;_m);
<a name="l02898"></a>02898             *m = <span class="keyword">reinterpret_cast&lt;</span>Z3_model<span class="keyword">&gt;</span>(_m);
<a name="l02899"></a>02899         }
<a name="l02900"></a>02900         <span class="keywordflow">else</span> {
<a name="l02901"></a>02901             result = mk_c(c)-&gt;check(0);
<a name="l02902"></a>02902         }
<a name="l02903"></a>02903         RETURN_Z3_check_and_get_model <span class="keyword">static_cast&lt;</span><a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a><span class="keyword">&gt;</span>(result);
<a name="l02904"></a>02904     }
<a name="l02905"></a>02905     
<a name="l02906"></a>02906     <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> Z3_API <a class="code" href="group__capi.html#ga72055cfbae81bd174abed32a83e50b03" title="Check whether the given logical context is consistent or not.">Z3_check</a>(Z3_context c) {
<a name="l02907"></a>02907         <span class="comment">// This is just syntax sugar... </span>
<a name="l02908"></a>02908         RESET_ERROR_CODE();   
<a name="l02909"></a>02909         CHECK_SEARCHING(c);
<a name="l02910"></a>02910         <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> r = <a class="code" href="group__capi.html#gaff310fef80ac8a82d0a51417e073ec0a" title="Check whether the given logical context is consistent or not.">Z3_check_and_get_model</a>(c, 0);
<a name="l02911"></a>02911         <span class="keywordflow">return</span> r;
<a name="l02912"></a>02912     }
<a name="l02913"></a>02913 
<a name="l02914"></a><a class="code" href="group__capi.html#ga5aab1bb6c4a879a5c40bd94e5e5ac1c6">02914</a>     <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> Z3_API <a class="code" href="group__capi.html#ga5aab1bb6c4a879a5c40bd94e5e5ac1c6" title="Retrieve congruence class representatives for terms.">Z3_get_implied_equalities</a>(__in Z3_context c, 
<a name="l02915"></a>02915                                               __in <span class="keywordtype">unsigned</span> num_terms,
<a name="l02916"></a>02916                                               __in_ecount(num_terms) Z3_ast <span class="keyword">const</span> terms[],
<a name="l02917"></a>02917                                               __out_ecount(num_terms) <span class="keywordtype">unsigned</span> class_ids[]) {
<a name="l02918"></a>02918         LOG_Z3_get_implied_equalities(c, num_terms, terms, class_ids);
<a name="l02919"></a>02919         RESET_ERROR_CODE();
<a name="l02920"></a>02920         CHECK_SEARCHING(c);
<a name="l02921"></a>02921         NOT_IMPLEMENTED_YET();
<a name="l02922"></a>02922 <span class="preprocessor">#if 0</span>
<a name="l02923"></a>02923 <span class="preprocessor"></span>        <span class="comment">// TODO put it back</span>
<a name="l02924"></a>02924         lbool result = mk_c(c)-&gt;get_context().get_implied_equalities(num_terms,to_exprs(terms),class_ids,0,0);
<a name="l02925"></a>02925         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a><span class="keyword">&gt;</span>(result); 
<a name="l02926"></a>02926 <span class="preprocessor">#endif</span>
<a name="l02927"></a>02927 <span class="preprocessor"></span>        <span class="keywordflow">return</span> Z3_L_UNDEF;
<a name="l02928"></a>02928     }
<a name="l02929"></a>02929 
<a name="l02930"></a>02930     
<a name="l02931"></a><a class="code" href="group__capi.html#ga289e6cfc3207ee0beb4f9dc8dd4e378b">02931</a>     <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> Z3_API <a class="code" href="group__capi.html#ga289e6cfc3207ee0beb4f9dc8dd4e378b" title="Check whether the given logical context and optional assumptions is consistent or...">Z3_check_assumptions</a>(__in Z3_context c, 
<a name="l02932"></a>02932                                          __in <span class="keywordtype">unsigned</span> num_assumptions, __in_ecount(num_assumptions) Z3_ast <span class="keyword">const</span> assumptions[], 
<a name="l02933"></a>02933                                          __out Z3_model * m, __out Z3_ast* proof, 
<a name="l02934"></a>02934                                          __inout <span class="keywordtype">unsigned</span>* core_size, __inout_ecount(num_assumptions) Z3_ast core[]) {
<a name="l02935"></a>02935         LOG_Z3_check_assumptions(c, num_assumptions, assumptions, m, proof, core_size, core);
<a name="l02936"></a>02936         RESET_ERROR_CODE();
<a name="l02937"></a>02937         CHECK_SEARCHING(c);
<a name="l02938"></a>02938         expr * <span class="keyword">const</span>* _assumptions = to_exprs(assumptions);
<a name="l02939"></a>02939         flet&lt;bool&gt; _model(mk_c(c)-&gt;m_params.m_model, <span class="keyword">true</span>);
<a name="l02940"></a>02940         
<a name="l02941"></a>02941         lbool result;
<a name="l02942"></a>02942         result = mk_c(c)-&gt;get_context().check(num_assumptions, _assumptions);
<a name="l02943"></a>02943         <span class="keywordflow">if</span> (result != l_false &amp;&amp; m) {
<a name="l02944"></a>02944             model_ref mref;
<a name="l02945"></a>02945             mk_c(c)-&gt;get_context().get_model(mref);
<a name="l02946"></a>02946             *m = <span class="keyword">reinterpret_cast&lt;</span>Z3_model<span class="keyword">&gt;</span>(mref.detach());
<a name="l02947"></a>02947         }
<a name="l02948"></a>02948         <span class="keywordflow">if</span> (result == l_false &amp;&amp; core_size) {
<a name="l02949"></a>02949             *core_size = mk_c(c)-&gt;get_context().get_unsat_core_size();
<a name="l02950"></a>02950             <span class="keywordflow">if</span> (*core_size &gt; num_assumptions) {
<a name="l02951"></a>02951                 SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l02952"></a>02952             }
<a name="l02953"></a>02953             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; *core_size; ++i) {
<a name="l02954"></a>02954                 core[i] = of_ast(mk_c(c)-&gt;get_context().get_unsat_core_expr(i));
<a name="l02955"></a>02955             }
<a name="l02956"></a>02956         }
<a name="l02957"></a>02957         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (core_size) {
<a name="l02958"></a>02958             *core_size = 0;
<a name="l02959"></a>02959         }
<a name="l02960"></a>02960         <span class="keywordflow">if</span> (result == l_false &amp;&amp; proof) {
<a name="l02961"></a>02961             *proof = of_ast(mk_c(c)-&gt;get_context().get_proof());
<a name="l02962"></a>02962         }
<a name="l02963"></a>02963         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (proof) {
<a name="l02964"></a>02964             *proof = 0; <span class="comment">// breaks abstraction.</span>
<a name="l02965"></a>02965         }
<a name="l02966"></a>02966         RETURN_Z3_check_assumptions <span class="keyword">static_cast&lt;</span><a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a><span class="keyword">&gt;</span>(result);         
<a name="l02967"></a>02967     }
<a name="l02968"></a>02968 
<a name="l02969"></a>02969     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga0cc98d3ce68047f873e119bccaabdbee" title="Delete a model object.">Z3_del_model</a>(Z3_context c, Z3_model  m) {
<a name="l02970"></a>02970         LOG_Z3_del_model(c, m);
<a name="l02971"></a>02971         model * _m = to_model(m);
<a name="l02972"></a>02972         <span class="keywordflow">if</span> (_m) {
<a name="l02973"></a>02973             _m-&gt;dec_ref();
<a name="l02974"></a>02974         }
<a name="l02975"></a>02975     }
<a name="l02976"></a>02976     
<a name="l02977"></a><a class="code" href="group__capi.html#ga3d00a3a21612b8279e4646e8117defb9">02977</a>     <a class="code" href="group__capi.html#ga2f784aea70df12574a63d2f71e674215" title="The different kinds of search failure types.">Z3_search_failure</a> Z3_API <a class="code" href="group__capi.html#ga3d00a3a21612b8279e4646e8117defb9" title="Retrieve reason for search failure.">Z3_get_search_failure</a>(__in Z3_context c) {
<a name="l02978"></a>02978         LOG_Z3_get_search_failure(c);
<a name="l02979"></a>02979         CHECK_SEARCHING(c);
<a name="l02980"></a>02980         smt::failure f = mk_c(c)-&gt;get_context().last_failure();
<a name="l02981"></a>02981         <span class="keywordflow">switch</span>(f) {
<a name="l02982"></a>02982         <span class="keywordflow">case</span> smt::OK: <span class="keywordflow">return</span> Z3_NO_FAILURE;
<a name="l02983"></a>02983         <span class="keywordflow">case</span> smt::UNKNOWN: <span class="keywordflow">return</span> Z3_UNKNOWN;
<a name="l02984"></a>02984         <span class="keywordflow">case</span> smt::TIMEOUT: <span class="keywordflow">return</span> Z3_TIMEOUT;
<a name="l02985"></a>02985         <span class="keywordflow">case</span> smt::MEMOUT: <span class="keywordflow">return</span> Z3_MEMOUT_WATERMARK;
<a name="l02986"></a>02986         <span class="keywordflow">case</span> smt::CANCELED: <span class="keywordflow">return</span> Z3_CANCELED;
<a name="l02987"></a>02987         <span class="keywordflow">case</span> smt::NUM_CONFLICTS: <span class="keywordflow">return</span> Z3_NUM_CONFLICTS;
<a name="l02988"></a>02988         <span class="keywordflow">case</span> smt::THEORY: <span class="keywordflow">return</span> Z3_THEORY;
<a name="l02989"></a>02989         <span class="keywordflow">case</span> smt::QUANTIFIERS: <span class="keywordflow">return</span> Z3_QUANTIFIERS;
<a name="l02990"></a>02990         <span class="keywordflow">default</span>:
<a name="l02991"></a>02991             UNREACHABLE();
<a name="l02992"></a>02992             <span class="keywordflow">break</span>;
<a name="l02993"></a>02993         }
<a name="l02994"></a>02994         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="group__capi.html#ga2f784aea70df12574a63d2f71e674215" title="The different kinds of search failure types.">Z3_search_failure</a><span class="keyword">&gt;</span>(f);
<a name="l02995"></a>02995     }
<a name="l02996"></a>02996 
<a name="l02997"></a>02997 
<a name="l02998"></a>02998     <span class="keyword">class </span>labeled_literal {
<a name="l02999"></a>02999         expr_ref m_literal;
<a name="l03000"></a>03000         symbol   m_label;
<a name="l03001"></a>03001         <span class="keywordtype">bool</span>     m_enabled;
<a name="l03002"></a>03002     <span class="keyword">public</span>:
<a name="l03003"></a>03003         labeled_literal(ast_manager&amp; m, expr* l, symbol <span class="keyword">const</span>&amp; n) : m_literal(l,m), m_label(n), m_enabled(true) {}
<a name="l03004"></a>03004         labeled_literal(ast_manager&amp; m, expr* l) : m_literal(l,m), m_label(), m_enabled(true) {}
<a name="l03005"></a>03005         <span class="keywordtype">bool</span> is_enabled()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_enabled; }
<a name="l03006"></a>03006         <span class="keywordtype">void</span> disable() { m_enabled = <span class="keyword">false</span>; }
<a name="l03007"></a>03007         symbol <span class="keyword">const</span>&amp; get_label()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_label; }
<a name="l03008"></a>03008         expr* get_literal() { <span class="keywordflow">return</span> m_literal.get(); }
<a name="l03009"></a>03009     };
<a name="l03010"></a>03010     
<a name="l03011"></a>03011     <span class="keyword">typedef</span> vector&lt;labeled_literal&gt; labels;
<a name="l03012"></a>03012 
<a name="l03013"></a><a class="code" href="group__capi.html#ga610976c4d68e5a964e4ebef46522945b">03013</a>     Z3_literals Z3_API <a class="code" href="group__capi.html#ga610976c4d68e5a964e4ebef46522945b" title="Retrieve the set of labels that were relevant in the context of the current satisfied...">Z3_get_relevant_labels</a>(__in Z3_context c) {
<a name="l03014"></a>03014         LOG_Z3_get_relevant_labels(c);
<a name="l03015"></a>03015         RESET_ERROR_CODE();
<a name="l03016"></a>03016         buffer&lt;symbol&gt; labl_syms;
<a name="l03017"></a>03017         ast_manager&amp; m = mk_c(c)-&gt;m_manager;
<a name="l03018"></a>03018         expr_ref_vector lits(m);
<a name="l03019"></a>03019         mk_c(c)-&gt;get_context().get_relevant_labels(0, labl_syms);
<a name="l03020"></a>03020         mk_c(c)-&gt;get_context().get_relevant_labeled_literals(mk_c(c)-&gt;m_params.m_at_labels_cex, lits);        
<a name="l03021"></a>03021         labels* lbls = alloc(labels);
<a name="l03022"></a>03022         SASSERT(labl_syms.size() == lits.size());
<a name="l03023"></a>03023         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; lits.size(); ++i) {
<a name="l03024"></a>03024             lbls-&gt;push_back(labeled_literal(m,lits[i].<span class="keyword">get</span>(), labl_syms[i]));
<a name="l03025"></a>03025         }
<a name="l03026"></a>03026         RETURN_Z3(reinterpret_cast&lt;Z3_literals&gt;(lbls));
<a name="l03027"></a>03027     }
<a name="l03028"></a>03028 
<a name="l03029"></a><a class="code" href="group__capi.html#ga4d92e896ecb13f203323c98b6a67c525">03029</a>     Z3_literals Z3_API <a class="code" href="group__capi.html#ga4d92e896ecb13f203323c98b6a67c525" title="Retrieve the set of literals that satisfy the current context.">Z3_get_relevant_literals</a>(__in Z3_context c) {
<a name="l03030"></a>03030         LOG_Z3_get_relevant_literals(c);
<a name="l03031"></a>03031         RESET_ERROR_CODE();
<a name="l03032"></a>03032         ast_manager&amp; m = mk_c(c)-&gt;m_manager;
<a name="l03033"></a>03033         expr_ref_vector lits(m);
<a name="l03034"></a>03034         mk_c(c)-&gt;get_context().get_relevant_literals(lits);        
<a name="l03035"></a>03035         labels* lbls = alloc(labels);
<a name="l03036"></a>03036         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; lits.size(); ++i) {
<a name="l03037"></a>03037             lbls-&gt;push_back(labeled_literal(m,lits[i].<span class="keyword">get</span>()));
<a name="l03038"></a>03038         }
<a name="l03039"></a>03039         RETURN_Z3(reinterpret_cast&lt;Z3_literals&gt;(lbls));        
<a name="l03040"></a>03040     }
<a name="l03041"></a>03041 
<a name="l03042"></a><a class="code" href="group__capi.html#ga434e9b070e037608a7038e4290d5673c">03042</a>     Z3_literals Z3_API <a class="code" href="group__capi.html#ga434e9b070e037608a7038e4290d5673c" title="Retrieve the set of literals that whose assignment were guess, but not propagated...">Z3_get_guessed_literals</a>(__in Z3_context c) {
<a name="l03043"></a>03043         LOG_Z3_get_guessed_literals(c);
<a name="l03044"></a>03044         RESET_ERROR_CODE();
<a name="l03045"></a>03045         ast_manager&amp; m = mk_c(c)-&gt;m_manager;
<a name="l03046"></a>03046         expr_ref_vector lits(m);
<a name="l03047"></a>03047         mk_c(c)-&gt;get_context().get_guessed_literals(lits);        
<a name="l03048"></a>03048         labels* lbls = alloc(labels);
<a name="l03049"></a>03049         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; lits.size(); ++i) {
<a name="l03050"></a>03050             lbls-&gt;push_back(labeled_literal(m,lits[i].<span class="keyword">get</span>()));
<a name="l03051"></a>03051         }
<a name="l03052"></a>03052         RETURN_Z3(reinterpret_cast&lt;Z3_literals&gt;(lbls));        
<a name="l03053"></a>03053     }
<a name="l03054"></a>03054 
<a name="l03055"></a><a class="code" href="group__capi.html#ga3224882c7224ee76787c8e48ecc0a7ae">03055</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga3224882c7224ee76787c8e48ecc0a7ae" title="Delete a labels context.">Z3_del_literals</a>(__in Z3_context c, __in Z3_literals lbls) {
<a name="l03056"></a>03056         LOG_Z3_del_literals(c, lbls);
<a name="l03057"></a>03057         RESET_ERROR_CODE();
<a name="l03058"></a>03058         dealloc(reinterpret_cast&lt;labels*&gt;(lbls));
<a name="l03059"></a>03059     }
<a name="l03060"></a>03060 
<a name="l03061"></a><a class="code" href="group__capi.html#gaae868f4ef6939b95d9c0ba2eb3d1e913">03061</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#gaae868f4ef6939b95d9c0ba2eb3d1e913" title="Retrieve the number of label symbols that were returned.">Z3_get_num_literals</a>(__in Z3_context c,__in Z3_literals lbls) {
<a name="l03062"></a>03062         LOG_Z3_get_num_literals(c, lbls);
<a name="l03063"></a>03063         RESET_ERROR_CODE();
<a name="l03064"></a>03064         <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>labels*<span class="keyword">&gt;</span>(lbls)-&gt;size();   
<a name="l03065"></a>03065     }
<a name="l03066"></a>03066 
<a name="l03067"></a><a class="code" href="group__capi.html#gaf0ecf0a7282aba9556e7c34bbe332568">03067</a>     Z3_symbol Z3_API <a class="code" href="group__capi.html#gaf0ecf0a7282aba9556e7c34bbe332568" title="Retrieve label symbol at idx.">Z3_get_label_symbol</a>(__in Z3_context c,__in Z3_literals lbls, __in <span class="keywordtype">unsigned</span> idx) {
<a name="l03068"></a>03068         LOG_Z3_get_label_symbol(c, lbls, idx);
<a name="l03069"></a>03069         RESET_ERROR_CODE();
<a name="l03070"></a>03070         <span class="keywordflow">return</span> of_symbol((*reinterpret_cast&lt;labels*&gt;(lbls))[idx].get_label());        
<a name="l03071"></a>03071     }
<a name="l03072"></a>03072 
<a name="l03073"></a><a class="code" href="group__capi.html#ga515a79517c3c80da345027846eea2a81">03073</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga515a79517c3c80da345027846eea2a81" title="Retrieve literal expression at idx.">Z3_get_literal</a>(__in Z3_context c,__in Z3_literals lbls, __in <span class="keywordtype">unsigned</span> idx) {
<a name="l03074"></a>03074         LOG_Z3_get_literal(c, lbls, idx);
<a name="l03075"></a>03075         RESET_ERROR_CODE();
<a name="l03076"></a>03076         expr* e = (*<span class="keyword">reinterpret_cast&lt;</span>labels*<span class="keyword">&gt;</span>(lbls))[idx].get_literal();
<a name="l03077"></a>03077         mk_c(c)-&gt;save_ast_trail(e);
<a name="l03078"></a>03078         RETURN_Z3(of_ast(e));
<a name="l03079"></a>03079     }
<a name="l03080"></a>03080 
<a name="l03081"></a><a class="code" href="group__capi.html#ga9e7d5cb3fe2b88c5938668c93fa6a4ff">03081</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga9e7d5cb3fe2b88c5938668c93fa6a4ff" title="Disable label.">Z3_disable_literal</a>(__in Z3_context c, __in Z3_literals lbls, __in <span class="keywordtype">unsigned</span> idx) {
<a name="l03082"></a>03082         LOG_Z3_disable_literal(c, lbls, idx);
<a name="l03083"></a>03083         RESET_ERROR_CODE();
<a name="l03084"></a>03084         (*<span class="keyword">reinterpret_cast&lt;</span>labels*<span class="keyword">&gt;</span>(lbls))[idx].disable(); 
<a name="l03085"></a>03085     }
<a name="l03086"></a>03086 
<a name="l03087"></a><a class="code" href="group__capi.html#ga99c8f733b2f42b178ba63bd79a284241">03087</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga99c8f733b2f42b178ba63bd79a284241" title="Block subsequent checks using the remaining enabled labels.">Z3_block_literals</a>(__in Z3_context c, __in Z3_literals lbls) {
<a name="l03088"></a>03088         LOG_Z3_block_literals(c, lbls);
<a name="l03089"></a>03089         RESET_ERROR_CODE();
<a name="l03090"></a>03090         labels* _lbls = <span class="keyword">reinterpret_cast&lt;</span>labels*<span class="keyword">&gt;</span>(lbls);
<a name="l03091"></a>03091         ast_manager&amp; m = mk_c(c)-&gt;m_manager;
<a name="l03092"></a>03092         expr_ref_vector lits(m);
<a name="l03093"></a>03093         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; _lbls-&gt;size(); ++i) {
<a name="l03094"></a>03094             <span class="keywordflow">if</span> ((*_lbls)[i].is_enabled()) {
<a name="l03095"></a>03095                 lits.push_back(m.mk_not((*_lbls)[i].get_literal()));
<a name="l03096"></a>03096             }
<a name="l03097"></a>03097         }
<a name="l03098"></a>03098         expr_ref clause(m);
<a name="l03099"></a>03099         clause = m.mk_or(lits.size(), lits.c_ptr());
<a name="l03100"></a>03100         mk_c(c)-&gt;save_ast_trail(clause.get());
<a name="l03101"></a>03101         mk_c(c)-&gt;assert_cnstr(clause.get());
<a name="l03102"></a>03102     }
<a name="l03103"></a>03103 
<a name="l03104"></a>03104     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga93fd4227621601199c749822ddaaf030" title="Return the number of constants assigned by the given model.">Z3_get_model_num_constants</a>(Z3_context c, Z3_model m) {
<a name="l03105"></a>03105         LOG_Z3_get_model_num_constants(c, m);
<a name="l03106"></a>03106         RESET_ERROR_CODE();
<a name="l03107"></a>03107         CHECK_NON_NULL(m, 0);
<a name="l03108"></a>03108         model* _m = to_model(m);
<a name="l03109"></a>03109         <span class="keywordflow">return</span> _m-&gt;get_num_constants();
<a name="l03110"></a>03110     }
<a name="l03111"></a>03111 
<a name="l03112"></a>03112     Z3_func_decl Z3_API <a class="code" href="group__capi.html#gaa2fa9cf35930b7be2d708c8862993e92" title="Return the i-th constant in the given model.">Z3_get_model_constant</a>(Z3_context c, Z3_model m, <span class="keywordtype">unsigned</span> i) {
<a name="l03113"></a>03113         LOG_Z3_get_model_constant(c, m, i);
<a name="l03114"></a>03114         RESET_ERROR_CODE();        
<a name="l03115"></a>03115         CHECK_NON_NULL(m, 0);
<a name="l03116"></a>03116         model* _m = to_model(m);
<a name="l03117"></a>03117         <span class="keywordflow">if</span> (i &lt; _m-&gt;get_num_constants()) {
<a name="l03118"></a>03118             RETURN_Z3(of_func_decl(_m-&gt;get_constant(i))); 
<a name="l03119"></a>03119         }
<a name="l03120"></a>03120         <span class="keywordflow">else</span> {
<a name="l03121"></a>03121             SET_ERROR_CODE(Z3_IOB);
<a name="l03122"></a>03122             RETURN_Z3(0);
<a name="l03123"></a>03123         }
<a name="l03124"></a>03124     }
<a name="l03125"></a>03125 
<a name="l03126"></a>03126     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API Z3_get_numeral_rational(__in Z3_context c, __in Z3_ast a, rational&amp; r) {
<a name="l03127"></a>03127         <span class="comment">// This function is not part of the public API</span>
<a name="l03128"></a>03128         RESET_ERROR_CODE();
<a name="l03129"></a>03129         expr* e = to_expr(a);
<a name="l03130"></a>03130         <span class="keywordflow">if</span> (!e) {
<a name="l03131"></a>03131             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l03132"></a>03132             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;            
<a name="l03133"></a>03133         }
<a name="l03134"></a>03134         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_arith_util.is_numeral(e, r)) {
<a name="l03135"></a>03135             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l03136"></a>03136         }
<a name="l03137"></a>03137         <span class="keywordtype">unsigned</span> bv_size;
<a name="l03138"></a>03138         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_bv_util.is_numeral(e, r, bv_size)) {
<a name="l03139"></a>03139             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l03140"></a>03140         }
<a name="l03141"></a>03141         <span class="keywordflow">if</span> (mk_c(c)-&gt;datalog_is_numeral(e, r)) {
<a name="l03142"></a>03142             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l03143"></a>03143         }
<a name="l03144"></a>03144         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;            
<a name="l03145"></a>03145     }
<a name="l03146"></a>03146 
<a name="l03147"></a>03147     
<a name="l03148"></a><a class="code" href="group__capi.html#ga94617ef18fa7157e1a3f85db625d2f4b">03148</a>     <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> Z3_API <a class="code" href="group__capi.html#ga94617ef18fa7157e1a3f85db625d2f4b" title="Return numeral value, as a string of a numeric constant term.">Z3_get_numeral_string</a>(__in Z3_context c, __in Z3_ast a) {
<a name="l03149"></a>03149         <span class="comment">// This function invokes Z3_get_numeral_rational, but it is still ok to add LOG command here because it does not return a Z3 object.</span>
<a name="l03150"></a>03150         LOG_Z3_get_numeral_string(c, a);
<a name="l03151"></a>03151         rational r;
<a name="l03152"></a>03152         <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> ok = Z3_get_numeral_rational(c, a, r);
<a name="l03153"></a>03153         <span class="keywordflow">if</span> (ok == <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>) {
<a name="l03154"></a>03154             mk_c(c)-&gt;m_numeral_ast_buffer = r.to_string();
<a name="l03155"></a>03155             <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(mk_c(c)-&gt;m_numeral_ast_buffer.c_str());            
<a name="l03156"></a>03156         }
<a name="l03157"></a>03157         <span class="keywordflow">else</span> {
<a name="l03158"></a>03158             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l03159"></a>03159             <span class="keywordflow">return</span> 0;
<a name="l03160"></a>03160         }
<a name="l03161"></a>03161     }
<a name="l03162"></a>03162 
<a name="l03163"></a>03163     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga52e859de3a172f499feb2ddab670da38" title="Return numeral value, as a pair of 64 bit numbers if the representation fits.">Z3_get_numeral_small</a>(__in Z3_context c, __in Z3_ast a, __out <span class="keywordtype">long</span> <span class="keywordtype">long</span>* num, __out <span class="keywordtype">long</span> <span class="keywordtype">long</span>* den) {
<a name="l03164"></a>03164         <span class="comment">// This function invokes Z3_get_numeral_rational, but it is still ok to add LOG command here because it does not return a Z3 object. </span>
<a name="l03165"></a>03165         LOG_Z3_get_numeral_small(c, a, num, den);
<a name="l03166"></a>03166         rational r;
<a name="l03167"></a>03167         <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> ok = Z3_get_numeral_rational(c, a, r);
<a name="l03168"></a>03168         <span class="keywordflow">if</span> (ok == <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>) {
<a name="l03169"></a>03169             rational n = numerator(r);
<a name="l03170"></a>03170             rational d = denominator(r);
<a name="l03171"></a>03171             <span class="keywordflow">if</span> (n.is_int64() &amp;&amp; d.is_int64()) {
<a name="l03172"></a>03172                 *num = n.get_int64();
<a name="l03173"></a>03173                 *den = d.get_int64();
<a name="l03174"></a>03174                 <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l03175"></a>03175             }
<a name="l03176"></a>03176             <span class="keywordflow">else</span> {
<a name="l03177"></a>03177                 <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03178"></a>03178             }
<a name="l03179"></a>03179         }
<a name="l03180"></a>03180         SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l03181"></a>03181         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03182"></a>03182     }
<a name="l03183"></a>03183 
<a name="l03184"></a>03184 
<a name="l03185"></a>03185     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga620c6d7e5f7992451bb97743d53afc63" title="Similar to Z3_get_numeral_string, but only succeeds if the value can fit in a machine...">Z3_get_numeral_int</a>(Z3_context c, Z3_ast v, <span class="keywordtype">int</span>* i) {
<a name="l03186"></a>03186         <span class="comment">// This function invokes Z3_get_numeral_int64, but it is still ok to add LOG command here because it does not return a Z3 object.</span>
<a name="l03187"></a>03187         LOG_Z3_get_numeral_int(c, v, i);
<a name="l03188"></a>03188         RESET_ERROR_CODE();
<a name="l03189"></a>03189         <span class="keywordflow">if</span> (!i) { 
<a name="l03190"></a>03190             SET_ERROR_CODE(Z3_INVALID_ARG);          
<a name="l03191"></a>03191             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03192"></a>03192         }
<a name="l03193"></a>03193         <span class="keywordtype">long</span> <span class="keywordtype">long</span> l;
<a name="l03194"></a>03194         <span class="keywordflow">if</span> (<a class="code" href="group__capi.html#ga9605fd61b46e9d5d8fc8885e38531c0e" title="Similar to Z3_get_numeral_string, but only succeeds if the value can fit in a machine...">Z3_get_numeral_int64</a>(c, v, &amp;l) &amp;&amp; l &gt;= INT_MIN &amp;&amp; l &lt;= INT_MAX) {
<a name="l03195"></a>03195             *i = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(l);
<a name="l03196"></a>03196             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l03197"></a>03197         }
<a name="l03198"></a>03198         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03199"></a>03199     }
<a name="l03200"></a>03200     
<a name="l03201"></a>03201     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga0dd4a509b27cbf96627e6edd6a74209e" title="Similar to Z3_get_numeral_string, but only succeeds if the value can fit in a machine...">Z3_get_numeral_uint</a>(Z3_context c, Z3_ast v, <span class="keywordtype">unsigned</span>* u) {
<a name="l03202"></a>03202         <span class="comment">// This function invokes Z3_get_numeral_uint64, but it is still ok to add LOG command here because it does not return a Z3 object.</span>
<a name="l03203"></a>03203         LOG_Z3_get_numeral_uint(c, v, u);
<a name="l03204"></a>03204         RESET_ERROR_CODE();
<a name="l03205"></a>03205         <span class="keywordflow">if</span> (!u) { 
<a name="l03206"></a>03206             SET_ERROR_CODE(Z3_INVALID_ARG);          
<a name="l03207"></a>03207             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03208"></a>03208         }
<a name="l03209"></a>03209         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> l;        
<a name="l03210"></a>03210         <span class="keywordflow">if</span> (<a class="code" href="group__capi.html#ga9c54827d910f0f341aa4a87401beed80" title="Similar to Z3_get_numeral_string, but only succeeds if the value can fit in a machine...">Z3_get_numeral_uint64</a>(c, v, &amp;l) &amp;&amp; (l &lt;= 0xFFFFFFFF)) {
<a name="l03211"></a>03211             *u = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(l);
<a name="l03212"></a>03212             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l03213"></a>03213         }
<a name="l03214"></a>03214         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03215"></a>03215     }
<a name="l03216"></a>03216     
<a name="l03217"></a>03217     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga9c54827d910f0f341aa4a87401beed80" title="Similar to Z3_get_numeral_string, but only succeeds if the value can fit in a machine...">Z3_get_numeral_uint64</a>(Z3_context c, Z3_ast v, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>* u) {
<a name="l03218"></a>03218         <span class="comment">// This function invokes Z3_get_numeral_rational, but it is still ok to add LOG command here because it does not return a Z3 object.</span>
<a name="l03219"></a>03219         LOG_Z3_get_numeral_uint64(c, v, u);
<a name="l03220"></a>03220         RESET_ERROR_CODE();
<a name="l03221"></a>03221         <span class="keywordflow">if</span> (!u) {
<a name="l03222"></a>03222             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l03223"></a>03223             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03224"></a>03224         }
<a name="l03225"></a>03225         rational r;
<a name="l03226"></a>03226         <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> ok = Z3_get_numeral_rational(c, v, r);
<a name="l03227"></a>03227         SASSERT(u);
<a name="l03228"></a>03228         <span class="keywordflow">if</span> (ok == <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a> &amp;&amp; r.is_uint64()) {
<a name="l03229"></a>03229             *u = r.get_uint64();
<a name="l03230"></a>03230             <span class="keywordflow">return</span> ok;
<a name="l03231"></a>03231         }
<a name="l03232"></a>03232         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03233"></a>03233     }
<a name="l03234"></a>03234     
<a name="l03235"></a>03235     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga9605fd61b46e9d5d8fc8885e38531c0e" title="Similar to Z3_get_numeral_string, but only succeeds if the value can fit in a machine...">Z3_get_numeral_int64</a>(Z3_context c, Z3_ast v, <span class="keywordtype">long</span> <span class="keywordtype">long</span>* i) {
<a name="l03236"></a>03236         <span class="comment">// This function invokes Z3_get_numeral_rational, but it is still ok to add LOG command here because it does not return a Z3 object.</span>
<a name="l03237"></a>03237         LOG_Z3_get_numeral_int64(c, v, i);
<a name="l03238"></a>03238         RESET_ERROR_CODE();
<a name="l03239"></a>03239         <span class="keywordflow">if</span> (!i) {
<a name="l03240"></a>03240             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l03241"></a>03241             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03242"></a>03242         }
<a name="l03243"></a>03243         rational r;
<a name="l03244"></a>03244         <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> ok = Z3_get_numeral_rational(c, v, r);
<a name="l03245"></a>03245         <span class="keywordflow">if</span> (ok == <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a> &amp;&amp; r.is_int64()) {
<a name="l03246"></a>03246             *i = r.get_int64();
<a name="l03247"></a>03247             <span class="keywordflow">return</span> ok;
<a name="l03248"></a>03248         }
<a name="l03249"></a>03249         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03250"></a>03250     }
<a name="l03251"></a>03251 
<a name="l03252"></a>03252     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga8c17fe5d5b6cdf3ed63178cede4d727e" title="Similar to Z3_get_numeral_string, but only succeeds if the value can fit as a reational...">Z3_get_numeral_rational_int64</a>(__in Z3_context c, __in Z3_ast v, __out <span class="keywordtype">long</span> <span class="keywordtype">long</span>* num, __out <span class="keywordtype">long</span> <span class="keywordtype">long</span>* den) {
<a name="l03253"></a>03253         <span class="comment">// This function invokes Z3_get_numeral_rational, but it is still ok to add LOG command here because it does not return a Z3 object.</span>
<a name="l03254"></a>03254         LOG_Z3_get_numeral_rational_int64(c, v, num, den);
<a name="l03255"></a>03255         RESET_ERROR_CODE();
<a name="l03256"></a>03256         <span class="keywordflow">if</span> (!num || !den) {
<a name="l03257"></a>03257             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l03258"></a>03258             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03259"></a>03259         }
<a name="l03260"></a>03260         rational r;
<a name="l03261"></a>03261         <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> ok = Z3_get_numeral_rational(c, v, r);
<a name="l03262"></a>03262         <span class="keywordflow">if</span> (ok != <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>) {
<a name="l03263"></a>03263             <span class="keywordflow">return</span> ok;
<a name="l03264"></a>03264         }
<a name="l03265"></a>03265         rational n = numerator(r);
<a name="l03266"></a>03266         rational d = denominator(r);
<a name="l03267"></a>03267         <span class="keywordflow">if</span> (n.is_int64() &amp;&amp; d.is_int64()) {
<a name="l03268"></a>03268             *num = n.get_int64();
<a name="l03269"></a>03269             *den = d.get_int64();
<a name="l03270"></a>03270             <span class="keywordflow">return</span> ok;
<a name="l03271"></a>03271         }
<a name="l03272"></a>03272         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03273"></a>03273     }
<a name="l03274"></a>03274 
<a name="l03275"></a>03275 
<a name="l03276"></a><a class="code" href="group__capi.html#ga133aaa1ec31af9b570ed7627a3c8c5a4">03276</a>     <a class="code" href="group__capi.html#ga6c2de6ea89b244e37c3ffb17a9ea2a89" title="Lifted Boolean type: false, undefined, true.">Z3_lbool</a> Z3_API <a class="code" href="group__capi.html#ga133aaa1ec31af9b570ed7627a3c8c5a4" title="Return Z3_L_TRUE if a is true, Z3_L_FALSE if it is false, and Z3_L_UNDEF otherwise...">Z3_get_bool_value</a>(__in Z3_context c, __in Z3_ast a) {
<a name="l03277"></a>03277         LOG_Z3_get_bool_value(c, a);
<a name="l03278"></a>03278         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l03279"></a>03279         ast * n         = to_ast(a);
<a name="l03280"></a>03280         <span class="keywordflow">if</span> (!is_expr(n)) {
<a name="l03281"></a>03281             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l03282"></a>03282             <span class="keywordflow">return</span> Z3_L_UNDEF;
<a name="l03283"></a>03283         }
<a name="l03284"></a>03284         <span class="keywordflow">if</span> (m.is_true(to_expr(n)))
<a name="l03285"></a>03285             <span class="keywordflow">return</span> Z3_L_TRUE;
<a name="l03286"></a>03286         <span class="keywordflow">if</span> (m.is_false(to_expr(n)))
<a name="l03287"></a>03287             <span class="keywordflow">return</span> Z3_L_FALSE;
<a name="l03288"></a>03288         <span class="keywordflow">return</span> Z3_L_UNDEF;
<a name="l03289"></a>03289     }
<a name="l03290"></a>03290 
<a name="l03291"></a>03291     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga93bbc1e93644b836fd81bcb99941efa0" title="Return the number of function interpretations in the given model.">Z3_get_model_num_funcs</a>(Z3_context c, Z3_model m) {
<a name="l03292"></a>03292         LOG_Z3_get_model_num_funcs(c, m);
<a name="l03293"></a>03293         RESET_ERROR_CODE();
<a name="l03294"></a>03294         CHECK_NON_NULL(m, 0);
<a name="l03295"></a>03295         model* _m = to_model(m);
<a name="l03296"></a>03296         <span class="keywordflow">return</span> _m-&gt;get_num_functions();
<a name="l03297"></a>03297     }
<a name="l03298"></a>03298 
<a name="l03299"></a>03299     Z3_func_decl get_model_func_decl_core(Z3_context c, Z3_model m, <span class="keywordtype">unsigned</span> i) {
<a name="l03300"></a>03300         CHECK_NON_NULL(m, 0);
<a name="l03301"></a>03301         model* _m = to_model(m);
<a name="l03302"></a>03302         <span class="keywordflow">if</span> (i &gt;= _m-&gt;get_num_functions()) {
<a name="l03303"></a>03303             SET_ERROR_CODE(Z3_IOB);
<a name="l03304"></a>03304             <span class="keywordflow">return</span> 0;
<a name="l03305"></a>03305         }
<a name="l03306"></a>03306         <span class="keywordflow">return</span> of_func_decl(_m-&gt;get_function(i));
<a name="l03307"></a>03307     }
<a name="l03308"></a>03308     
<a name="l03309"></a>03309     Z3_func_decl Z3_API <a class="code" href="group__capi.html#ga69a6b71175fbad3b803b14a03fd1619d" title="Return the declaration of the i-th function in the given model.">Z3_get_model_func_decl</a>(Z3_context c, Z3_model m, <span class="keywordtype">unsigned</span> i) {
<a name="l03310"></a>03310         LOG_Z3_get_model_func_decl(c, m, i);
<a name="l03311"></a>03311         RESET_ERROR_CODE();
<a name="l03312"></a>03312         Z3_func_decl r = get_model_func_decl_core(c, m, i);
<a name="l03313"></a>03313         RETURN_Z3(r);
<a name="l03314"></a>03314     }
<a name="l03315"></a>03315     
<a name="l03316"></a>03316     Z3_ast Z3_API <a class="code" href="group__capi.html#ga4d88b799f76b076a29d4435e6cbcc890" title="Return the &amp;#39;else&amp;#39; value of the i-th function interpretation in the given...">Z3_get_model_func_else</a>(Z3_context c, Z3_model m, <span class="keywordtype">unsigned</span> i) {
<a name="l03317"></a>03317         LOG_Z3_get_model_func_else(c, m, i);
<a name="l03318"></a>03318         RESET_ERROR_CODE();
<a name="l03319"></a>03319         CHECK_NON_NULL(m, 0);
<a name="l03320"></a>03320         Z3_func_decl d = get_model_func_decl_core(c, m, i);
<a name="l03321"></a>03321         <span class="keywordflow">if</span> (d) {
<a name="l03322"></a>03322             model* _m = to_model(m);            
<a name="l03323"></a>03323             func_interp * g = _m-&gt;get_func_interp(to_func_decl(d));
<a name="l03324"></a>03324             <span class="keywordflow">if</span> (g) {
<a name="l03325"></a>03325                 expr* e = g-&gt;get_else();
<a name="l03326"></a>03326                 mk_c(c)-&gt;save_ast_trail(e);
<a name="l03327"></a>03327                 RETURN_Z3(of_ast(e));
<a name="l03328"></a>03328             }
<a name="l03329"></a>03329             SET_ERROR_CODE(Z3_IOB);
<a name="l03330"></a>03330             RETURN_Z3(0);
<a name="l03331"></a>03331         }
<a name="l03332"></a>03332         RETURN_Z3(0);
<a name="l03333"></a>03333     }
<a name="l03334"></a>03334 
<a name="l03335"></a>03335     <span class="keywordtype">unsigned</span> get_model_func_num_entries_core(Z3_context c, Z3_model m, <span class="keywordtype">unsigned</span> i) {
<a name="l03336"></a>03336         RESET_ERROR_CODE();
<a name="l03337"></a>03337         CHECK_NON_NULL(m, 0);
<a name="l03338"></a>03338         Z3_func_decl d = get_model_func_decl_core(c, m, i);
<a name="l03339"></a>03339         <span class="keywordflow">if</span> (d) {
<a name="l03340"></a>03340             model* _m = to_model(m);            
<a name="l03341"></a>03341             func_interp * g = _m-&gt;get_func_interp(to_func_decl(d));
<a name="l03342"></a>03342             <span class="keywordflow">if</span> (g) {
<a name="l03343"></a>03343                 <span class="keywordflow">return</span> g-&gt;num_entries();
<a name="l03344"></a>03344             }
<a name="l03345"></a>03345             SET_ERROR_CODE(Z3_IOB);
<a name="l03346"></a>03346             <span class="keywordflow">return</span> 0;
<a name="l03347"></a>03347         }
<a name="l03348"></a>03348         <span class="keywordflow">return</span> 0;
<a name="l03349"></a>03349     }
<a name="l03350"></a>03350     
<a name="l03351"></a>03351     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga08b6982830120de746c3459391e10f37" title="Return the number of entries of the i-th function interpretation in the given model...">Z3_get_model_func_num_entries</a>(Z3_context c, Z3_model m, <span class="keywordtype">unsigned</span> i) {
<a name="l03352"></a>03352         LOG_Z3_get_model_func_num_entries(c, m, i);
<a name="l03353"></a>03353         <span class="keywordflow">return</span> get_model_func_num_entries_core(c, m, i);
<a name="l03354"></a>03354     }
<a name="l03355"></a>03355 
<a name="l03356"></a>03356     <span class="keywordtype">unsigned</span> get_model_func_entry_num_args_core(Z3_context c,
<a name="l03357"></a>03357                                                 Z3_model m,
<a name="l03358"></a>03358                                                 <span class="keywordtype">unsigned</span> i,
<a name="l03359"></a>03359                                                 <span class="keywordtype">unsigned</span> j) {
<a name="l03360"></a>03360         RESET_ERROR_CODE();
<a name="l03361"></a>03361         CHECK_NON_NULL(m, 0);
<a name="l03362"></a>03362         <span class="keywordflow">if</span> (j &gt;= get_model_func_num_entries_core(c, m, i)) {
<a name="l03363"></a>03363             SET_ERROR_CODE(Z3_IOB);
<a name="l03364"></a>03364             <span class="keywordflow">return</span> 0;
<a name="l03365"></a>03365         }
<a name="l03366"></a>03366         Z3_func_decl d = get_model_func_decl_core(c, m, i);
<a name="l03367"></a>03367         <span class="keywordflow">if</span> (d) {
<a name="l03368"></a>03368             model* _m = <span class="keyword">reinterpret_cast&lt;</span>model*<span class="keyword">&gt;</span>(m);            
<a name="l03369"></a>03369             func_interp * g = _m-&gt;get_func_interp(to_func_decl(d));
<a name="l03370"></a>03370             <span class="keywordflow">return</span> g-&gt;get_arity();
<a name="l03371"></a>03371         }
<a name="l03372"></a>03372         <span class="keywordflow">return</span> 0;
<a name="l03373"></a>03373     }
<a name="l03374"></a>03374     
<a name="l03375"></a>03375     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga72b4aa37bbd7e79ff1ea0f02e182d044" title="Return the number of arguments of the j-th entry of the i-th function interpretation...">Z3_get_model_func_entry_num_args</a>(Z3_context c,
<a name="l03376"></a>03376                                                      Z3_model m,
<a name="l03377"></a>03377                                                      <span class="keywordtype">unsigned</span> i,
<a name="l03378"></a>03378                                                      <span class="keywordtype">unsigned</span> j) {
<a name="l03379"></a>03379         LOG_Z3_get_model_func_entry_num_args(c, m, i, j);
<a name="l03380"></a>03380         <span class="keywordflow">return</span> get_model_func_entry_num_args_core(c, m, i, j);
<a name="l03381"></a>03381     }
<a name="l03382"></a>03382 
<a name="l03383"></a>03383     Z3_ast Z3_API <a class="code" href="group__capi.html#ga5a6dc26868b3815fbbca68bfa50445dc" title="Return the k-th argument of the j-th entry of the i-th function interpretation in...">Z3_get_model_func_entry_arg</a>(Z3_context c,
<a name="l03384"></a>03384                                                 Z3_model m,
<a name="l03385"></a>03385                                                 <span class="keywordtype">unsigned</span> i,
<a name="l03386"></a>03386                                                 <span class="keywordtype">unsigned</span> j,
<a name="l03387"></a>03387                                                 <span class="keywordtype">unsigned</span> k) {
<a name="l03388"></a>03388         LOG_Z3_get_model_func_entry_arg(c, m, i, j, k);
<a name="l03389"></a>03389         RESET_ERROR_CODE();
<a name="l03390"></a>03390         CHECK_NON_NULL(m, 0);
<a name="l03391"></a>03391         <span class="keywordflow">if</span> (j &gt;= get_model_func_num_entries_core(c, m, i) || k &gt;= get_model_func_entry_num_args_core(c, m, i, j)) {
<a name="l03392"></a>03392             SET_ERROR_CODE(Z3_IOB);
<a name="l03393"></a>03393             RETURN_Z3(0);
<a name="l03394"></a>03394         }
<a name="l03395"></a>03395         Z3_func_decl d = get_model_func_decl_core(c, m, i);
<a name="l03396"></a>03396         <span class="keywordflow">if</span> (d) {
<a name="l03397"></a>03397             model* _m = to_model(m);            
<a name="l03398"></a>03398             func_interp * g = _m-&gt;get_func_interp(to_func_decl(d));
<a name="l03399"></a>03399             <span class="keywordflow">if</span> (g &amp;&amp; j &lt; g-&gt;num_entries()) {
<a name="l03400"></a>03400                 func_entry <span class="keyword">const</span>* e = g-&gt;get_entry(j);
<a name="l03401"></a>03401                 <span class="keywordflow">if</span> (k &lt; g-&gt;get_arity()) {
<a name="l03402"></a>03402                     expr* a = e-&gt;get_arg(k);
<a name="l03403"></a>03403                     mk_c(c)-&gt;save_ast_trail(a);
<a name="l03404"></a>03404                     RETURN_Z3(of_ast(a));
<a name="l03405"></a>03405                 }
<a name="l03406"></a>03406             }
<a name="l03407"></a>03407             SET_ERROR_CODE(Z3_IOB);
<a name="l03408"></a>03408             RETURN_Z3(0);
<a name="l03409"></a>03409         }
<a name="l03410"></a>03410         RETURN_Z3(0);
<a name="l03411"></a>03411     }
<a name="l03412"></a>03412 
<a name="l03413"></a>03413     Z3_ast Z3_API <a class="code" href="group__capi.html#gaf9ccc474d05703daa12f54067f691940" title="Return the return value of the j-th entry of the i-th function interpretation in...">Z3_get_model_func_entry_value</a>(Z3_context c,
<a name="l03414"></a>03414                                                 Z3_model m,
<a name="l03415"></a>03415                                                 <span class="keywordtype">unsigned</span> i,
<a name="l03416"></a>03416                                                 <span class="keywordtype">unsigned</span> j) {
<a name="l03417"></a>03417         LOG_Z3_get_model_func_entry_value(c, m, i, j);
<a name="l03418"></a>03418         RESET_ERROR_CODE();
<a name="l03419"></a>03419         CHECK_NON_NULL(m, 0);
<a name="l03420"></a>03420         <span class="keywordflow">if</span> (j &gt;= get_model_func_num_entries_core(c, m, i)) {
<a name="l03421"></a>03421             SET_ERROR_CODE(Z3_IOB);
<a name="l03422"></a>03422             RETURN_Z3(0);
<a name="l03423"></a>03423         }
<a name="l03424"></a>03424         Z3_func_decl d = get_model_func_decl_core(c, m, i);
<a name="l03425"></a>03425         <span class="keywordflow">if</span> (d) {
<a name="l03426"></a>03426             model* _m = to_model(m);            
<a name="l03427"></a>03427             func_interp * g = _m-&gt;get_func_interp(to_func_decl(d));
<a name="l03428"></a>03428             <span class="keywordflow">if</span> (g &amp;&amp; j &lt; g-&gt;num_entries()) {
<a name="l03429"></a>03429                 func_entry <span class="keyword">const</span>* e = g-&gt;get_entry(j);
<a name="l03430"></a>03430                 expr* a = e-&gt;get_result();
<a name="l03431"></a>03431                 mk_c(c)-&gt;save_ast_trail(a);
<a name="l03432"></a>03432                 RETURN_Z3(of_ast(a));
<a name="l03433"></a>03433             }
<a name="l03434"></a>03434             SET_ERROR_CODE(Z3_IOB);
<a name="l03435"></a>03435             RETURN_Z3(0);
<a name="l03436"></a>03436         }
<a name="l03437"></a>03437         RETURN_Z3(0);
<a name="l03438"></a>03438     }
<a name="l03439"></a>03439     
<a name="l03440"></a>03440     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga47d3655283564918c85bda0b423b7f67" title="Evaluate the AST node t in the given model. Return Z3_TRUE if succeeded, and store...">Z3_eval</a>(Z3_context c,
<a name="l03441"></a>03441                            Z3_model m,
<a name="l03442"></a>03442                            Z3_ast t,
<a name="l03443"></a>03443                            Z3_ast * v) {
<a name="l03444"></a>03444         LOG_Z3_eval(c, m, t, v);
<a name="l03445"></a>03445         RESET_ERROR_CODE();
<a name="l03446"></a>03446         CHECK_NON_NULL(m, <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>);
<a name="l03447"></a>03447         model * _m = to_model(m);
<a name="l03448"></a>03448         expr_ref result(mk_c(c)-&gt;m_manager);
<a name="l03449"></a>03449         _m-&gt;eval(to_expr(t), result, mk_c(c)-&gt;m_params.m_model_completion);
<a name="l03450"></a>03450         mk_c(c)-&gt;save_ast_trail(result.get());
<a name="l03451"></a>03451         *v = of_ast(result.get());
<a name="l03452"></a>03452         RETURN_Z3_eval <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l03453"></a>03453     }
<a name="l03454"></a>03454 
<a name="l03455"></a><a class="code" href="group__capi.html#ga0cdba60a991c137e8cc5d1a921e3a990">03455</a>     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga0cdba60a991c137e8cc5d1a921e3a990" title="Return the value of the given constant or function in the given model.">Z3_eval_func_decl</a>(__in Z3_context c, 
<a name="l03456"></a>03456                                      __in Z3_model m, 
<a name="l03457"></a>03457                                      __in Z3_func_decl decl,
<a name="l03458"></a>03458                                      __out Z3_ast* v) {
<a name="l03459"></a>03459         LOG_Z3_eval_func_decl(c, m, decl, v);
<a name="l03460"></a>03460         RESET_ERROR_CODE();
<a name="l03461"></a>03461         CHECK_NON_NULL(m, <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>);
<a name="l03462"></a>03462         ast_manager &amp; mgr = mk_c(c)-&gt;m_manager;
<a name="l03463"></a>03463         model * _m = to_model(m);
<a name="l03464"></a>03464         expr_ref result(mgr);
<a name="l03465"></a>03465         <span class="keywordflow">if</span>( _m-&gt;eval(to_func_decl(decl), result)) {
<a name="l03466"></a>03466             mk_c(c)-&gt;save_ast_trail(result.get());
<a name="l03467"></a>03467             *v = of_ast(result.get());
<a name="l03468"></a>03468             RETURN_Z3_eval_func_decl <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l03469"></a>03469         }
<a name="l03470"></a>03470         <span class="keywordflow">else</span> {
<a name="l03471"></a>03471             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03472"></a>03472         }        
<a name="l03473"></a>03473     }
<a name="l03474"></a>03474 
<a name="l03475"></a>03475 
<a name="l03476"></a><a class="code" href="group__capi.html#ga61281d91e14d274f17a78d7189c69c5e">03476</a>     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga61281d91e14d274f17a78d7189c69c5e" title="Determine whether the term encodes an array value. A term encodes an array value...">Z3_is_array_value</a>(__in Z3_context c, __in Z3_model _m, __in Z3_ast _v, __out <span class="keywordtype">unsigned</span>* size) {
<a name="l03477"></a>03477         LOG_Z3_is_array_value(c, _m, _v, size);
<a name="l03478"></a>03478         RESET_ERROR_CODE();
<a name="l03479"></a>03479         CHECK_NON_NULL(_v, <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>);
<a name="l03480"></a>03480         CHECK_NON_NULL(_m, <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>);
<a name="l03481"></a>03481         model* m = to_model(_m);
<a name="l03482"></a>03482         expr* v = to_expr(_v);
<a name="l03483"></a>03483         ast_manager&amp; mgr = mk_c(c)-&gt;m_manager;
<a name="l03484"></a>03484         family_id afid = mk_c(c)-&gt;m_array_fid;
<a name="l03485"></a>03485         <span class="keywordtype">unsigned</span> sz = 0;
<a name="l03486"></a>03486         array_util pl(mgr);
<a name="l03487"></a>03487         <span class="keywordflow">if</span> (pl.is_as_array(v)) {
<a name="l03488"></a>03488             func_decl* f = pl.get_as_array_func_decl(to_app(v));
<a name="l03489"></a>03489             func_interp* g = m-&gt;get_func_interp(f);
<a name="l03490"></a>03490             sz = g-&gt;num_entries();
<a name="l03491"></a>03491             <span class="keywordflow">if</span> (sz &gt; 0 &amp;&amp; g-&gt;get_arity() != 1) {
<a name="l03492"></a>03492                 <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03493"></a>03493             }
<a name="l03494"></a>03494         }
<a name="l03495"></a>03495         <span class="keywordflow">else</span> {
<a name="l03496"></a>03496             <span class="keywordflow">while</span> (pl.is_store(v)) {
<a name="l03497"></a>03497                 <span class="keywordflow">if</span> (to_app(v)-&gt;get_num_args() != 3) {
<a name="l03498"></a>03498                     <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03499"></a>03499                 }
<a name="l03500"></a>03500                 v = to_app(v)-&gt;get_arg(0);
<a name="l03501"></a>03501                 ++sz;
<a name="l03502"></a>03502             }
<a name="l03503"></a>03503             <span class="keywordflow">if</span> (!is_app_of(v, afid, OP_CONST_ARRAY)) {
<a name="l03504"></a>03504                 <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l03505"></a>03505             }
<a name="l03506"></a>03506         }
<a name="l03507"></a>03507         <span class="keywordflow">if</span> (size) {
<a name="l03508"></a>03508             *size = sz;
<a name="l03509"></a>03509         }
<a name="l03510"></a>03510         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l03511"></a>03511     }
<a name="l03512"></a>03512 
<a name="l03513"></a>03513 
<a name="l03514"></a><a class="code" href="group__capi.html#ga205dc8a4c21432e12c9aafedc6c68db2">03514</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga205dc8a4c21432e12c9aafedc6c68db2" title="An array values is represented as a dictionary plus a default (else) value. This...">Z3_get_array_value</a>(__in Z3_context c, 
<a name="l03515"></a>03515                                    __in Z3_model _m,
<a name="l03516"></a>03516                                    __in Z3_ast _v,
<a name="l03517"></a>03517                                    __in <span class="keywordtype">unsigned</span> num_entries,
<a name="l03518"></a>03518                                    __inout_ecount(num_entries) Z3_ast indices[],
<a name="l03519"></a>03519                                    __inout_ecount(num_entries) Z3_ast values[],
<a name="l03520"></a>03520                                    __out Z3_ast* else_value) {
<a name="l03521"></a>03521         LOG_Z3_get_array_value(c, _m, _v, num_entries, indices, values, else_value);
<a name="l03522"></a>03522         RESET_ERROR_CODE();
<a name="l03523"></a>03523         model* m = to_model(_m);
<a name="l03524"></a>03524 
<a name="l03525"></a>03525         expr* v = to_expr(_v);
<a name="l03526"></a>03526         family_id afid = mk_c(c)-&gt;m_array_fid;
<a name="l03527"></a>03527         ast_manager&amp; mgr = mk_c(c)-&gt;m_manager;
<a name="l03528"></a>03528         array_util pl(mgr);
<a name="l03529"></a>03529 
<a name="l03530"></a>03530         <span class="comment">//</span>
<a name="l03531"></a>03531         <span class="comment">// note: _v is already reference counted.</span>
<a name="l03532"></a>03532         <span class="comment">// saving the trail for the returned values </span>
<a name="l03533"></a>03533         <span class="comment">// is redundant.</span>
<a name="l03534"></a>03534         <span class="comment">//</span>
<a name="l03535"></a>03535         <span class="keywordtype">unsigned</span> sz = 0;
<a name="l03536"></a>03536         <span class="keywordflow">if</span> (pl.is_as_array(v)) {
<a name="l03537"></a>03537             func_decl* f = pl.get_as_array_func_decl(to_app(v));
<a name="l03538"></a>03538             func_interp* g = m-&gt;get_func_interp(f);
<a name="l03539"></a>03539             sz = g-&gt;num_entries();
<a name="l03540"></a>03540             <span class="keywordflow">if</span> (g-&gt;get_arity() != 1) {
<a name="l03541"></a>03541                 SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l03542"></a>03542                 <span class="keywordflow">return</span>;
<a name="l03543"></a>03543             }
<a name="l03544"></a>03544             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; sz &amp;&amp; i &lt; num_entries; ++i) {
<a name="l03545"></a>03545                 indices[i] = of_ast(g-&gt;get_entry(i)-&gt;get_arg(0));
<a name="l03546"></a>03546                 values[i] = of_ast(g-&gt;get_entry(i)-&gt;get_result());                
<a name="l03547"></a>03547             }
<a name="l03548"></a>03548             <span class="keywordflow">if</span> (else_value) {
<a name="l03549"></a>03549                 *else_value = of_ast(g-&gt;get_else());
<a name="l03550"></a>03550             }                       
<a name="l03551"></a>03551         }
<a name="l03552"></a>03552         <span class="keywordflow">else</span> {
<a name="l03553"></a>03553             <span class="keywordflow">while</span> (sz &lt;= num_entries &amp;&amp; is_app_of(v, afid, OP_STORE)) {
<a name="l03554"></a>03554                 app* a = to_app(v);
<a name="l03555"></a>03555                 <span class="keywordflow">if</span> (a-&gt;get_num_args() != 3) {
<a name="l03556"></a>03556                     SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l03557"></a>03557                     <span class="keywordflow">return</span>;
<a name="l03558"></a>03558                 }
<a name="l03559"></a>03559                 expr* idx = a-&gt;get_arg(1);
<a name="l03560"></a>03560                 expr* val = a-&gt;get_arg(2);
<a name="l03561"></a>03561                 indices[sz] = of_ast(idx);
<a name="l03562"></a>03562                 values[sz] = of_ast(val);
<a name="l03563"></a>03563                 v = to_app(v)-&gt;get_arg(0);   
<a name="l03564"></a>03564                 ++sz;
<a name="l03565"></a>03565             }
<a name="l03566"></a>03566         
<a name="l03567"></a>03567             <span class="keywordflow">if</span> (is_app_of(v, afid, OP_CONST_ARRAY)) {
<a name="l03568"></a>03568                 <span class="keywordflow">if</span> (else_value) {
<a name="l03569"></a>03569                     *else_value = of_ast(to_app(v)-&gt;get_arg(0));
<a name="l03570"></a>03570                 }
<a name="l03571"></a>03571             }
<a name="l03572"></a>03572             <span class="keywordflow">else</span> {
<a name="l03573"></a>03573                 SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l03574"></a>03574                 <span class="keywordflow">return</span>;
<a name="l03575"></a>03575             }
<a name="l03576"></a>03576         }
<a name="l03577"></a>03577         RETURN_Z3_get_array_value;
<a name="l03578"></a>03578     }
<a name="l03579"></a>03579 
<a name="l03580"></a>03580     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#gab05c70e7d212a50ae683b871f983a875" title="Evaluate declaration given values.">Z3_eval_decl</a>(Z3_context c, 
<a name="l03581"></a>03581                                 Z3_model m, 
<a name="l03582"></a>03582                                 Z3_func_decl d, 
<a name="l03583"></a>03583                                 <span class="keywordtype">unsigned</span> num_args,
<a name="l03584"></a>03584                                 Z3_ast <span class="keyword">const</span> args[],
<a name="l03585"></a>03585                                 Z3_ast* v) {
<a name="l03586"></a>03586         LOG_Z3_eval_decl(c, m, d, num_args, args, v);
<a name="l03587"></a>03587         RESET_ERROR_CODE();
<a name="l03588"></a>03588         CHECK_NON_NULL(m, <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>);
<a name="l03589"></a>03589         ast_manager &amp; mgr = mk_c(c)-&gt;m_manager;
<a name="l03590"></a>03590         model * _m = to_model(m);
<a name="l03591"></a>03591         app_ref app(mgr);
<a name="l03592"></a>03592         app = mgr.mk_app(to_func_decl(d), num_args, to_exprs(args));
<a name="l03593"></a>03593         expr_ref result(mgr);
<a name="l03594"></a>03594         _m-&gt;eval(app.get(), result);
<a name="l03595"></a>03595         mk_c(c)-&gt;save_ast_trail(result.get());
<a name="l03596"></a>03596         *v = of_ast(result.get());
<a name="l03597"></a>03597         RETURN_Z3_eval_decl <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l03598"></a>03598     }
<a name="l03599"></a>03599 
<a name="l03600"></a><a class="code" href="group__capi.html#gada433553406475e5dd6a494ea957844c">03600</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#gada433553406475e5dd6a494ea957844c" title="Interface to simplifier.">Z3_simplify</a>(__in Z3_context c, __in Z3_ast _a) {
<a name="l03601"></a>03601         LOG_Z3_simplify(c, _a);
<a name="l03602"></a>03602         smt::solver &amp; ctx = mk_c(c)-&gt;get_context();
<a name="l03603"></a>03603         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l03604"></a>03604         expr * a = to_expr(_a);
<a name="l03605"></a>03605         th_rewriter   m_rw(m);
<a name="l03606"></a>03606         expr_ref      result(m);
<a name="l03607"></a>03607         m_rw(a, result);
<a name="l03608"></a>03608         RETURN_Z3(of_ast(result.get()));   
<a name="l03609"></a>03609     }    
<a name="l03610"></a>03610 
<a name="l03611"></a><a class="code" href="group__capi.html#gaa7497c70a827db2d61ba98889fe657b5">03611</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#gaa7497c70a827db2d61ba98889fe657b5" title="Update the arguments of term a using the arguments args. The number of arguments...">Z3_update_term</a>(__in Z3_context c, __in Z3_ast _a, __in <span class="keywordtype">unsigned</span> num_args, __in_ecount(num_args) Z3_ast <span class="keyword">const</span> _args[]) {
<a name="l03612"></a>03612         LOG_Z3_update_term(c, _a, num_args, _args);
<a name="l03613"></a>03613         RESET_ERROR_CODE();
<a name="l03614"></a>03614         ast_manager&amp; m = mk_c(c)-&gt;m_manager;
<a name="l03615"></a>03615         expr* a = to_expr(_a);
<a name="l03616"></a>03616         expr* <span class="keyword">const</span>* args = to_exprs(_args);
<a name="l03617"></a>03617         <span class="keywordflow">switch</span>(a-&gt;get_kind()) {
<a name="l03618"></a>03618         <span class="keywordflow">case</span> AST_APP: {
<a name="l03619"></a>03619             app* e = to_app(a);
<a name="l03620"></a>03620             <span class="keywordflow">if</span> (e-&gt;get_num_args() != num_args) {
<a name="l03621"></a>03621                 SET_ERROR_CODE(Z3_IOB);
<a name="l03622"></a>03622             }
<a name="l03623"></a>03623             <span class="keywordflow">else</span> {
<a name="l03624"></a>03624                 a = m.mk_app(e-&gt;get_decl(), num_args, args);
<a name="l03625"></a>03625             }
<a name="l03626"></a>03626             <span class="keywordflow">break</span>;
<a name="l03627"></a>03627         }
<a name="l03628"></a>03628         <span class="keywordflow">case</span> AST_QUANTIFIER: {
<a name="l03629"></a>03629             <span class="keywordflow">if</span> (num_args != 1) {
<a name="l03630"></a>03630                 SET_ERROR_CODE(Z3_IOB);
<a name="l03631"></a>03631             }
<a name="l03632"></a>03632             <span class="keywordflow">else</span> {
<a name="l03633"></a>03633                 a = m.update_quantifier(to_quantifier(a), args[0]);
<a name="l03634"></a>03634             }
<a name="l03635"></a>03635             <span class="keywordflow">break</span>;
<a name="l03636"></a>03636         }
<a name="l03637"></a>03637         <span class="keywordflow">default</span>:
<a name="l03638"></a>03638             <span class="keywordflow">break</span>;
<a name="l03639"></a>03639         }            
<a name="l03640"></a>03640         mk_c(c)-&gt;save_ast_trail(a);
<a name="l03641"></a>03641         RETURN_Z3(of_expr(a));
<a name="l03642"></a>03642     }
<a name="l03643"></a>03643 
<a name="l03644"></a><a class="code" href="group__capi.html#gaa92c98c0357b0387a436d67ba19ec39f">03644</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#gaa92c98c0357b0387a436d67ba19ec39f" title="Substitute every occurrence of from[i] in a with to[i], for i smaller than num_exprs...">Z3_substitute</a>(__in Z3_context c, 
<a name="l03645"></a>03645                                 __in Z3_ast _a, 
<a name="l03646"></a>03646                                 __in <span class="keywordtype">unsigned</span> num_exprs, 
<a name="l03647"></a>03647                                 __in_ecount(num_exprs) Z3_ast <span class="keyword">const</span> _from[], 
<a name="l03648"></a>03648                                 __in_ecount(num_exprs) Z3_ast <span class="keyword">const</span> _to[]) {
<a name="l03649"></a>03649         LOG_Z3_substitute(c, _a, num_exprs, _from, _to);
<a name="l03650"></a>03650         RESET_ERROR_CODE();
<a name="l03651"></a>03651         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l03652"></a>03652         expr * a = to_expr(_a);
<a name="l03653"></a>03653         expr * <span class="keyword">const</span> * from = to_exprs(_from);
<a name="l03654"></a>03654         expr * <span class="keyword">const</span> * to   = to_exprs(_to);
<a name="l03655"></a>03655         expr * r = 0;
<a name="l03656"></a>03656         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_exprs; i++) {
<a name="l03657"></a>03657             <span class="keywordflow">if</span> (m.get_sort(from[i]) != m.get_sort(to[i])) {
<a name="l03658"></a>03658                 SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l03659"></a>03659                 RETURN_Z3(of_expr(0));
<a name="l03660"></a>03660             }
<a name="l03661"></a>03661         }
<a name="l03662"></a>03662 
<a name="l03663"></a>03663         expr_substitution subst(m);
<a name="l03664"></a>03664         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_exprs; i++) {
<a name="l03665"></a>03665             subst.insert(from[i], to[i]);
<a name="l03666"></a>03666         }
<a name="l03667"></a>03667         th_rewriter   m_rw(m);
<a name="l03668"></a>03668         m_rw.set_substitution(&amp;subst);
<a name="l03669"></a>03669         
<a name="l03670"></a>03670         expr_ref   new_a(m);
<a name="l03671"></a>03671         proof_ref  pr(m);
<a name="l03672"></a>03672         m_rw(a, new_a, pr);
<a name="l03673"></a>03673         mk_c(c)-&gt;save_ast_trail(new_a);
<a name="l03674"></a>03674         r = new_a.get();
<a name="l03675"></a>03675         RETURN_Z3(of_expr(r));
<a name="l03676"></a>03676     }
<a name="l03677"></a>03677 
<a name="l03678"></a><a class="code" href="group__capi.html#ga5c5c9197923791fbeb9ac6c5cfdbf19f">03678</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga5c5c9197923791fbeb9ac6c5cfdbf19f" title="Substitute the free variables in a with the expressions in to. For every i smaller...">Z3_substitute_vars</a>(__in Z3_context c, 
<a name="l03679"></a>03679                                      __in Z3_ast _a, 
<a name="l03680"></a>03680                                      __in <span class="keywordtype">unsigned</span> num_exprs, 
<a name="l03681"></a>03681                                      __in_ecount(num_exprs) Z3_ast <span class="keyword">const</span> _to[]) {
<a name="l03682"></a>03682         LOG_Z3_substitute_vars(c, _a, num_exprs, _to);
<a name="l03683"></a>03683         RESET_ERROR_CODE();
<a name="l03684"></a>03684         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l03685"></a>03685         expr * a = to_expr(_a);
<a name="l03686"></a>03686         expr * <span class="keyword">const</span> * to   = to_exprs(_to);
<a name="l03687"></a>03687         var_subst subst(m, <span class="keyword">false</span>);
<a name="l03688"></a>03688         expr_ref new_a(m);
<a name="l03689"></a>03689         subst(a, num_exprs, to, new_a);
<a name="l03690"></a>03690         mk_c(c)-&gt;save_ast_trail(new_a);
<a name="l03691"></a>03691         RETURN_Z3(of_expr(new_a.get()));
<a name="l03692"></a>03692     }
<a name="l03693"></a>03693 
<a name="l03694"></a><a class="code" href="group__capi.html#gacc9b2bdacfef5ec85185dd09a1734f27">03694</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#gacc9b2bdacfef5ec85185dd09a1734f27" title="Cancel an ongoing check.">Z3_soft_check_cancel</a>(__in Z3_context c) {
<a name="l03695"></a>03695         LOG_Z3_soft_check_cancel(c);
<a name="l03696"></a>03696         mk_c(c)-&gt;get_context().set_cancel(<span class="keyword">true</span>);
<a name="l03697"></a>03697     }
<a name="l03698"></a>03698 
<a name="l03699"></a><a class="code" href="group__capi.html#ga20d66dac19b6d6a06537843d0e25f761">03699</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga20d66dac19b6d6a06537843d0e25f761" title="Select mode for the format used for pretty-printing AST nodes.">Z3_set_ast_print_mode</a>(__in Z3_context c, __in <a class="code" href="group__capi.html#ga0112dc1e8e08a19bf7a4299bb09a9727" title="Z3 pretty printing modes (See Z3_set_ast_print_mode).">Z3_ast_print_mode</a> mode) {
<a name="l03700"></a>03700         LOG_Z3_set_ast_print_mode(c, mode);
<a name="l03701"></a>03701         RESET_ERROR_CODE();
<a name="l03702"></a>03702         mk_c(c)-&gt;m_print_mode = mode;
<a name="l03703"></a>03703     }
<a name="l03704"></a>03704     
<a name="l03705"></a>03705     <span class="keywordtype">char</span> <span class="keyword">const</span> * Z3_API <a class="code" href="group__capi.html#gab1aa4b78298fe00b3167bf7bfd88aea3" title="Convert the given AST node into a string.">Z3_ast_to_string</a>(Z3_context c, Z3_ast a) {
<a name="l03706"></a>03706         LOG_Z3_ast_to_string(c, a);
<a name="l03707"></a>03707         RESET_ERROR_CODE();
<a name="l03708"></a>03708         std::ostringstream buffer;
<a name="l03709"></a>03709         <span class="keywordflow">switch</span> (mk_c(c)-&gt;m_print_mode) {
<a name="l03710"></a>03710         <span class="keywordflow">case</span> Z3_PRINT_SMTLIB_FULL:
<a name="l03711"></a>03711             buffer &lt;&lt; mk_pp(to_ast(a), mk_c(c)-&gt;m_manager);
<a name="l03712"></a>03712             <span class="keywordflow">break</span>;
<a name="l03713"></a>03713         <span class="keywordflow">case</span> Z3_PRINT_LOW_LEVEL:
<a name="l03714"></a>03714             buffer &lt;&lt; mk_ll_pp(to_ast(a), mk_c(c)-&gt;m_manager);
<a name="l03715"></a>03715             <span class="keywordflow">break</span>;
<a name="l03716"></a>03716         <span class="keywordflow">case</span> Z3_PRINT_SMTLIB_COMPLIANT: 
<a name="l03717"></a>03717         <span class="keywordflow">case</span> Z3_PRINT_SMTLIB2_COMPLIANT: {
<a name="l03718"></a>03718             ast_smt_pp pp(mk_c(c)-&gt;m_manager);
<a name="l03719"></a>03719             pp.set_simplify_implies(get_pp_default_params().m_pp_simplify_implies);
<a name="l03720"></a>03720             ast* a1 = to_ast(a);
<a name="l03721"></a>03721             pp.set_logic(mk_c(c)-&gt;m_params.m_smtlib_logic.c_str());
<a name="l03722"></a>03722             <span class="keywordflow">if</span> (!is_expr(a1)) {
<a name="l03723"></a>03723                 buffer &lt;&lt; mk_pp(a1, mk_c(c)-&gt;m_manager);
<a name="l03724"></a>03724                 <span class="keywordflow">break</span>;
<a name="l03725"></a>03725             }
<a name="l03726"></a>03726             <span class="keywordflow">if</span> (mk_c(c)-&gt;m_print_mode == Z3_PRINT_SMTLIB_COMPLIANT) {
<a name="l03727"></a>03727                 pp.display_expr(buffer, to_expr(a1));
<a name="l03728"></a>03728                 <span class="keywordflow">break</span>;
<a name="l03729"></a>03729             }
<a name="l03730"></a>03730             <span class="keywordflow">if</span> (mk_c(c)-&gt;m_print_mode == Z3_PRINT_SMTLIB2_COMPLIANT) {
<a name="l03731"></a>03731                 pp.display_expr_smt2(buffer, to_expr(a1));
<a name="l03732"></a>03732                 <span class="keywordflow">break</span>;
<a name="l03733"></a>03733             }
<a name="l03734"></a>03734             <span class="keywordflow">break</span>;
<a name="l03735"></a>03735         }
<a name="l03736"></a>03736         <span class="keywordflow">default</span>:
<a name="l03737"></a>03737             UNREACHABLE();
<a name="l03738"></a>03738         }
<a name="l03739"></a>03739         mk_c(c)-&gt;m_ast_to_string_buffer = buffer.str();
<a name="l03740"></a>03740         <span class="keywordflow">return</span> mk_c(c)-&gt;m_ast_to_string_buffer.c_str();
<a name="l03741"></a>03741     }
<a name="l03742"></a>03742 
<a name="l03743"></a>03743     <span class="keywordtype">char</span> <span class="keyword">const</span> * Z3_API Z3_sort_to_string(Z3_context c, Z3_sort s) {
<a name="l03744"></a>03744         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gab1aa4b78298fe00b3167bf7bfd88aea3" title="Convert the given AST node into a string.">Z3_ast_to_string</a>(c, reinterpret_cast&lt;Z3_ast&gt;(s));
<a name="l03745"></a>03745     }
<a name="l03746"></a>03746 
<a name="l03747"></a>03747     <span class="keywordtype">char</span> <span class="keyword">const</span> * Z3_API Z3_pattern_to_string(Z3_context c, Z3_pattern p) {
<a name="l03748"></a>03748         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gab1aa4b78298fe00b3167bf7bfd88aea3" title="Convert the given AST node into a string.">Z3_ast_to_string</a>(c, reinterpret_cast&lt;Z3_ast&gt;(p));
<a name="l03749"></a>03749     }
<a name="l03750"></a>03750 
<a name="l03751"></a>03751     <span class="keywordtype">char</span> <span class="keyword">const</span> * Z3_API Z3_func_decl_to_string(Z3_context c, Z3_func_decl f) {
<a name="l03752"></a>03752         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gab1aa4b78298fe00b3167bf7bfd88aea3" title="Convert the given AST node into a string.">Z3_ast_to_string</a>(c, reinterpret_cast&lt;Z3_ast&gt;(f));
<a name="l03753"></a>03753     }
<a name="l03754"></a>03754 
<a name="l03755"></a>03755     
<a name="l03756"></a>03756     <span class="keywordtype">char</span> <span class="keyword">const</span> * Z3_API <a class="code" href="group__capi.html#gaf36d49862a8c0d20dd5e6508eef5f8af" title="Convert the given model into a string.">Z3_model_to_string</a>(Z3_context c, Z3_model m) {
<a name="l03757"></a>03757         LOG_Z3_model_to_string(c, m);
<a name="l03758"></a>03758         RESET_ERROR_CODE();
<a name="l03759"></a>03759         CHECK_NON_NULL(m, 0);
<a name="l03760"></a>03760         std::ostringstream buffer;
<a name="l03761"></a>03761         
<a name="l03762"></a>03762         <span class="comment">// TODO: investigate how to do SMT2 compliant pp without using the context</span>
<a name="l03763"></a>03763         model_v2_pp(buffer, *(to_model(m)), mk_c(c)-&gt;m_params.m_model_partial);
<a name="l03764"></a>03764         
<a name="l03765"></a>03765         mk_c(c)-&gt;m_model_to_string_buffer = buffer.str();
<a name="l03766"></a>03766         <span class="keywordflow">return</span> mk_c(c)-&gt;m_model_to_string_buffer.c_str();
<a name="l03767"></a>03767     }
<a name="l03768"></a>03768     
<a name="l03769"></a>03769 
<a name="l03770"></a>03770     <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> Z3_API <a class="code" href="group__capi.html#ga5ad2d3b577747f8716cbc571d8a2af38" title="Convert the given benchmark into SMT-LIB formatted string.">Z3_benchmark_to_smtlib_string</a>(__in Z3_context c, 
<a name="l03771"></a>03771                                                    __in <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> name,
<a name="l03772"></a>03772                                                    __in <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> logic,
<a name="l03773"></a>03773                                                    __in <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> status,
<a name="l03774"></a>03774                                                    __in <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> attributes,
<a name="l03775"></a>03775                                                    __in <span class="keywordtype">unsigned</span> num_assumptions,
<a name="l03776"></a>03776                                                    __in Z3_ast <span class="keyword">const</span> assumptions[],
<a name="l03777"></a>03777                                                    __in Z3_ast formula) {
<a name="l03778"></a>03778         LOG_Z3_benchmark_to_smtlib_string(c, name, logic, status, attributes, num_assumptions, assumptions, formula);
<a name="l03779"></a>03779         RESET_ERROR_CODE();
<a name="l03780"></a>03780         std::ostringstream buffer;
<a name="l03781"></a>03781         ast_smt_pp pp(mk_c(c)-&gt;m_manager);
<a name="l03782"></a>03782         pp.set_benchmark_name(name);
<a name="l03783"></a>03783         pp.set_logic(logic);
<a name="l03784"></a>03784         pp.set_status(status);
<a name="l03785"></a>03785         pp.add_attributes(attributes);
<a name="l03786"></a>03786         pp.set_simplify_implies(get_pp_default_params().m_pp_simplify_implies);
<a name="l03787"></a>03787         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_assumptions; ++i) {
<a name="l03788"></a>03788             pp.add_assumption(to_expr(assumptions[i]));
<a name="l03789"></a>03789         }
<a name="l03790"></a>03790         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_print_mode == Z3_PRINT_SMTLIB2_COMPLIANT) {
<a name="l03791"></a>03791             pp.display_smt2(buffer, to_expr(formula));
<a name="l03792"></a>03792         }
<a name="l03793"></a>03793         <span class="keywordflow">else</span> {
<a name="l03794"></a>03794             pp.display(buffer, to_expr(formula));
<a name="l03795"></a>03795         }
<a name="l03796"></a>03796         mk_c(c)-&gt;m_benchmark_to_smtlib_string_buffer = buffer.str();
<a name="l03797"></a>03797         <span class="keywordflow">return</span> mk_c(c)-&gt;m_benchmark_to_smtlib_string_buffer.c_str();
<a name="l03798"></a>03798     }
<a name="l03799"></a>03799  
<a name="l03800"></a>03800     
<a name="l03801"></a>03801     <span class="keywordtype">char</span> <span class="keyword">const</span> * Z3_API <a class="code" href="group__capi.html#ga165e38ddfc928f586cb738cdf6c5f216" title="Convert the given logical context into a string.">Z3_context_to_string</a>(Z3_context c) {
<a name="l03802"></a>03802         LOG_Z3_context_to_string(c);
<a name="l03803"></a>03803         RESET_ERROR_CODE();
<a name="l03804"></a>03804         std::ostringstream buffer;
<a name="l03805"></a>03805         mk_c(c)-&gt;get_context().display(buffer);
<a name="l03806"></a>03806         mk_c(c)-&gt;m_context_to_string_buffer = buffer.str();
<a name="l03807"></a>03807         <span class="keywordflow">return</span> mk_c(c)-&gt;m_context_to_string_buffer.c_str();
<a name="l03808"></a>03808     }
<a name="l03809"></a>03809 
<a name="l03810"></a><a class="code" href="group__capi.html#gaf5281db92a1f635977b725f1be112836">03810</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#gaf5281db92a1f635977b725f1be112836" title="Extract satisfying assignment from context as a conjunction.">Z3_get_context_assignment</a>(__in Z3_context c) {
<a name="l03811"></a>03811         LOG_Z3_get_context_assignment(c);
<a name="l03812"></a>03812         RESET_ERROR_CODE();
<a name="l03813"></a>03813         ast_manager&amp; m = mk_c(c)-&gt;m_manager;
<a name="l03814"></a>03814         expr_ref result(m);
<a name="l03815"></a>03815         expr_ref_vector assignment(m);
<a name="l03816"></a>03816         mk_c(c)-&gt;get_context().get_assignments(assignment);
<a name="l03817"></a>03817         result = mk_c(c)-&gt;mk_and(assignment.size(), assignment.c_ptr());
<a name="l03818"></a>03818         RETURN_Z3(of_ast(result.get()));
<a name="l03819"></a>03819     }
<a name="l03820"></a>03820 
<a name="l03821"></a>03821     
<a name="l03822"></a>03822     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga45fcd18a00379b13a536c5b6117190ae" title="Return Z3 version number information.">Z3_get_version</a>(<span class="keywordtype">unsigned</span> * major, 
<a name="l03823"></a>03823                                <span class="keywordtype">unsigned</span> * minor, 
<a name="l03824"></a>03824                                <span class="keywordtype">unsigned</span> * build_number, 
<a name="l03825"></a>03825                                <span class="keywordtype">unsigned</span> * revision_number) {
<a name="l03826"></a>03826         LOG_Z3_get_version(major, minor, build_number, revision_number);
<a name="l03827"></a>03827         *major           = Z3_MAJOR_VERSION;
<a name="l03828"></a>03828         *minor           = Z3_MINOR_VERSION;
<a name="l03829"></a>03829         *build_number    = Z3_BUILD_NUMBER;
<a name="l03830"></a>03830         *revision_number = Z3_REVISION_NUMBER;
<a name="l03831"></a>03831     }
<a name="l03832"></a>03832 
<a name="l03833"></a><a class="code" href="group__capi.html#gaf6130e567b229fc5ea0e3e6229f7e307">03833</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#gaf6130e567b229fc5ea0e3e6229f7e307" title="Reset all allocated resources.">Z3_reset_memory</a>(<span class="keywordtype">void</span>) {
<a name="l03834"></a>03834         LOG_Z3_reset_memory();
<a name="l03835"></a>03835         memory::finalize();
<a name="l03836"></a>03836         memory::initialize(0);
<a name="l03837"></a>03837     }
<a name="l03838"></a>03838     
<a name="l03839"></a>03839 
<a name="l03840"></a>03840     <a class="code" href="group__capi.html#gaa9f9e7b1b5b81381fab96debbaaa638f" title="Z3 error codes (See Z3_get_error_code).">Z3_error_code</a> Z3_API <a class="code" href="group__capi.html#ga8ac771e68b28d2c86f40aa84889b3807" title="Return the error code for the last API call.">Z3_get_error_code</a>(Z3_context c) {
<a name="l03841"></a>03841         LOG_Z3_get_error_code(c);
<a name="l03842"></a>03842         <span class="keywordflow">return</span> mk_c(c)-&gt;m_error_code;
<a name="l03843"></a>03843     }
<a name="l03844"></a>03844 
<a name="l03845"></a>03845     <a class="code" href="group__capi.html#ga4f0c179e183c96ebdaa639628c6cdbb2" title="Z3 custom error handler (See Z3_set_error_handler).">Z3_error_handler</a>* g_error_handler = 0;
<a name="l03846"></a>03846 
<a name="l03847"></a>03847     <span class="keywordtype">void</span> fatal_error_handler(<span class="keywordtype">int</span> error_code) {
<a name="l03848"></a>03848         <span class="keywordflow">if</span> (g_error_handler == 0) {
<a name="l03849"></a>03849             exit(error_code);
<a name="l03850"></a>03850         }
<a name="l03851"></a>03851 
<a name="l03852"></a>03852         <span class="keywordflow">switch</span>(error_code) {        
<a name="l03853"></a>03853         <span class="keywordflow">case</span> ERR_MEMOUT: 
<a name="l03854"></a>03854             g_error_handler(Z3_MEMOUT_FAIL);
<a name="l03855"></a>03855             <span class="keywordflow">break</span>;
<a name="l03856"></a>03856         <span class="keywordflow">case</span> ERR_PARSER: 
<a name="l03857"></a>03857             g_error_handler(Z3_PARSER_ERROR);
<a name="l03858"></a>03858             <span class="keywordflow">break</span>;
<a name="l03859"></a>03859         <span class="keywordflow">case</span> ERR_INI_FILE: 
<a name="l03860"></a>03860             g_error_handler(Z3_INVALID_ARG);
<a name="l03861"></a>03861             <span class="keywordflow">break</span>;
<a name="l03862"></a>03862         <span class="keywordflow">case</span> ERR_OPEN_FILE:
<a name="l03863"></a>03863             g_error_handler(Z3_FILE_ACCESS_ERROR);
<a name="l03864"></a>03864             <span class="keywordflow">break</span>;
<a name="l03865"></a>03865         <span class="keywordflow">case</span> ERR_UNSOUNDNESS: 
<a name="l03866"></a>03866         <span class="keywordflow">case</span> ERR_INCOMPLETENESS: 
<a name="l03867"></a>03867         <span class="keywordflow">case</span> ERR_NOT_IMPLEMENTED_YET: 
<a name="l03868"></a>03868         <span class="keywordflow">case</span> ERR_INTERNAL_FATAL:
<a name="l03869"></a>03869         <span class="keywordflow">case</span> ERR_CMD_LINE:
<a name="l03870"></a>03870             g_error_handler(Z3_INTERNAL_FATAL);
<a name="l03871"></a>03871             <span class="keywordflow">break</span>;
<a name="l03872"></a>03872         }
<a name="l03873"></a>03873         exit(error_code);
<a name="l03874"></a>03874         <span class="comment">// not reachable.</span>
<a name="l03875"></a>03875     }
<a name="l03876"></a>03876 
<a name="l03877"></a>03877     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#gadaa12e9990f37b0c1e2bf1dd502dbf39" title="Register a Z3 error handler.">Z3_set_error_handler</a>(Z3_context c, <a class="code" href="group__capi.html#ga4f0c179e183c96ebdaa639628c6cdbb2" title="Z3 custom error handler (See Z3_set_error_handler).">Z3_error_handler</a> h) {
<a name="l03878"></a>03878         RESET_ERROR_CODE();    
<a name="l03879"></a>03879         mk_c(c)-&gt;m_error_handler = h;
<a name="l03880"></a>03880         <span class="comment">//</span>
<a name="l03881"></a>03881         <span class="comment">// N.B. The memory manager is shared among potentially different </span>
<a name="l03882"></a>03882         <span class="comment">// contexts; the local context error handler gets set globally </span>
<a name="l03883"></a>03883         <span class="comment">// on the memory manager.</span>
<a name="l03884"></a>03884         <span class="comment">//</span>
<a name="l03885"></a>03885         memory::set_out_of_memory_handler(mk_c(c), _Z3_context::out_of_memory_handler);
<a name="l03886"></a>03886         g_error_handler = h;
<a name="l03887"></a>03887         set_fatal_error_handler(fatal_error_handler);
<a name="l03888"></a>03888     }
<a name="l03889"></a>03889 
<a name="l03890"></a><a class="code" href="group__capi.html#ga41cf70319c4802ab7301dd168d6f5e45">03890</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga41cf70319c4802ab7301dd168d6f5e45" title="Set an error.">Z3_set_error</a>(__in Z3_context c, __in <a class="code" href="group__capi.html#gaa9f9e7b1b5b81381fab96debbaaa638f" title="Z3 error codes (See Z3_get_error_code).">Z3_error_code</a> e) {
<a name="l03891"></a>03891         SET_ERROR_CODE(e);
<a name="l03892"></a>03892     }
<a name="l03893"></a>03893 
<a name="l03894"></a>03894     <span class="keyword">const</span> <span class="keywordtype">char</span> * Z3_API <a class="code" href="group__capi.html#gaf06357c49299efb8a0bdaeb3bc96c6d6" title="Return a string describing the given error code.">Z3_get_error_msg</a>(<a class="code" href="group__capi.html#gaa9f9e7b1b5b81381fab96debbaaa638f" title="Z3 error codes (See Z3_get_error_code).">Z3_error_code</a> err) {
<a name="l03895"></a>03895         LOG_Z3_get_error_msg(err);
<a name="l03896"></a>03896         <span class="keywordflow">switch</span>(err) {
<a name="l03897"></a>03897         <span class="keywordflow">case</span> Z3_OK:                <span class="keywordflow">return</span> <span class="stringliteral">&quot;ok&quot;</span>;
<a name="l03898"></a>03898         <span class="keywordflow">case</span> Z3_SORT_ERROR:        <span class="keywordflow">return</span> <span class="stringliteral">&quot;type error&quot;</span>;
<a name="l03899"></a>03899         <span class="keywordflow">case</span> Z3_IOB:               <span class="keywordflow">return</span> <span class="stringliteral">&quot;index out of bounds&quot;</span>;
<a name="l03900"></a>03900         <span class="keywordflow">case</span> Z3_INVALID_ARG:       <span class="keywordflow">return</span> <span class="stringliteral">&quot;invalid argument&quot;</span>;
<a name="l03901"></a>03901         <span class="keywordflow">case</span> Z3_PARSER_ERROR:      <span class="keywordflow">return</span> <span class="stringliteral">&quot;parser error&quot;</span>;
<a name="l03902"></a>03902         <span class="keywordflow">case</span> Z3_NO_PARSER:         <span class="keywordflow">return</span> <span class="stringliteral">&quot;parser (data) is not available&quot;</span>;
<a name="l03903"></a>03903         <span class="keywordflow">case</span> Z3_INVALID_PATTERN:   <span class="keywordflow">return</span> <span class="stringliteral">&quot;invalid pattern&quot;</span>;
<a name="l03904"></a>03904         <span class="keywordflow">case</span> Z3_MEMOUT_FAIL:       <span class="keywordflow">return</span> <span class="stringliteral">&quot;out of memory&quot;</span>;
<a name="l03905"></a>03905         <span class="keywordflow">case</span> Z3_FILE_ACCESS_ERROR: <span class="keywordflow">return</span> <span class="stringliteral">&quot;file access error&quot;</span>;
<a name="l03906"></a>03906         <span class="keywordflow">case</span> Z3_INTERNAL_FATAL:    <span class="keywordflow">return</span> <span class="stringliteral">&quot;internal error&quot;</span>;
<a name="l03907"></a>03907         <span class="keywordflow">case</span> Z3_INVALID_USAGE:     <span class="keywordflow">return</span> <span class="stringliteral">&quot;invalid usage&quot;</span>;
<a name="l03908"></a>03908         <span class="keywordflow">case</span> Z3_DEC_REF_ERROR:     <span class="keywordflow">return</span> <span class="stringliteral">&quot;invalid dec_ref command&quot;</span>;
<a name="l03909"></a>03909         <span class="keywordflow">default</span>:                   <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown&quot;</span>;
<a name="l03910"></a>03910         }
<a name="l03911"></a>03911     }
<a name="l03912"></a>03912 
<a name="l03913"></a>03913     <span class="keywordtype">void</span> init_smtlib_parser(Z3_context c, 
<a name="l03914"></a>03914                             <span class="keywordtype">unsigned</span> num_sorts,
<a name="l03915"></a>03915                             Z3_symbol <span class="keyword">const</span> sort_names[],
<a name="l03916"></a>03916                             Z3_sort <span class="keyword">const</span> types[],
<a name="l03917"></a>03917                             <span class="keywordtype">unsigned</span> num_decls,
<a name="l03918"></a>03918                             Z3_symbol <span class="keyword">const</span> decl_names[],
<a name="l03919"></a>03919                             Z3_func_decl <span class="keyword">const</span> decls[]) {
<a name="l03920"></a>03920         mk_c(c)-&gt;reset_parser();
<a name="l03921"></a>03921         mk_c(c)-&gt;m_smtlib_parser = smtlib::parser::create(mk_c(c)-&gt;m_manager);
<a name="l03922"></a>03922         mk_c(c)-&gt;m_smtlib_parser-&gt;initialize_smtlib();
<a name="l03923"></a>03923         smtlib::symtable * table = mk_c(c)-&gt;m_smtlib_parser-&gt;get_benchmark()-&gt;get_symtable();
<a name="l03924"></a>03924         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_sorts; i++) {
<a name="l03925"></a>03925             table-&gt;insert(to_symbol(sort_names[i]), to_sort(types[i]));
<a name="l03926"></a>03926         }
<a name="l03927"></a>03927         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_decls; i++) {
<a name="l03928"></a>03928             table-&gt;insert(to_symbol(decl_names[i]), to_func_decl(decls[i]));
<a name="l03929"></a>03929         }
<a name="l03930"></a>03930     }
<a name="l03931"></a>03931     
<a name="l03932"></a>03932     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga94e2d053b85f2904486c83d8844c21d0" title="Parse the given string using the SMT-LIB parser.">Z3_parse_smtlib_string</a>(Z3_context c, 
<a name="l03933"></a>03933                                        <span class="keyword">const</span> <span class="keywordtype">char</span> * str,
<a name="l03934"></a>03934                                        <span class="keywordtype">unsigned</span>  num_sorts,
<a name="l03935"></a>03935                                        Z3_symbol <span class="keyword">const</span> sort_names[],
<a name="l03936"></a>03936                                        Z3_sort   <span class="keyword">const</span> sorts[],
<a name="l03937"></a>03937                                        <span class="keywordtype">unsigned</span>  num_decls,
<a name="l03938"></a>03938                                        Z3_symbol <span class="keyword">const</span> decl_names[],
<a name="l03939"></a>03939                                        Z3_func_decl <span class="keyword">const</span> decls[]) {
<a name="l03940"></a>03940         LOG_Z3_parse_smtlib_string(c, str, num_sorts, sort_names, sorts, num_decls, decl_names, decls);
<a name="l03941"></a>03941         std::ostringstream outs;
<a name="l03942"></a>03942         <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l03943"></a>03943 
<a name="l03944"></a>03944         RESET_ERROR_CODE();
<a name="l03945"></a>03945         init_smtlib_parser(c, num_sorts, sort_names, sorts, num_decls, decl_names, decls);
<a name="l03946"></a>03946         mk_c(c)-&gt;m_smtlib_parser-&gt;set_error_stream(outs);
<a name="l03947"></a>03947         <span class="keywordflow">try</span> {
<a name="l03948"></a>03948             ok = mk_c(c)-&gt;m_smtlib_parser-&gt;parse_string(str);        
<a name="l03949"></a>03949         }
<a name="l03950"></a>03950         <span class="keywordflow">catch</span> (...) {
<a name="l03951"></a>03951             ok = <span class="keyword">false</span>;
<a name="l03952"></a>03952         }
<a name="l03953"></a>03953         mk_c(c)-&gt;m_parser_buffer = outs.str();
<a name="l03954"></a>03954         <span class="keywordflow">if</span> (!ok) {
<a name="l03955"></a>03955             mk_c(c)-&gt;reset_parser();
<a name="l03956"></a>03956             SET_ERROR_CODE(Z3_PARSER_ERROR);
<a name="l03957"></a>03957         }
<a name="l03958"></a>03958     }
<a name="l03959"></a>03959 
<a name="l03960"></a>03960     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#gaaba11221fb7fda6ee9ab371ac3700075" title="Similar to Z3_parse_smtlib_string, but reads the benchmark from a file.">Z3_parse_smtlib_file</a>(Z3_context c, 
<a name="l03961"></a>03961                                      <span class="keyword">const</span> <span class="keywordtype">char</span> * file_name,
<a name="l03962"></a>03962                                      <span class="keywordtype">unsigned</span> num_sorts,
<a name="l03963"></a>03963                                      Z3_symbol <span class="keyword">const</span> sort_names[],
<a name="l03964"></a>03964                                      Z3_sort <span class="keyword">const</span> types[],
<a name="l03965"></a>03965                                      <span class="keywordtype">unsigned</span> num_decls,
<a name="l03966"></a>03966                                      Z3_symbol <span class="keyword">const</span> decl_names[],
<a name="l03967"></a>03967                                      Z3_func_decl <span class="keyword">const</span> decls[]) {
<a name="l03968"></a>03968         LOG_Z3_parse_smtlib_file(c, file_name, num_sorts, sort_names, types, num_decls, decl_names, decls);
<a name="l03969"></a>03969         <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l03970"></a>03970         RESET_ERROR_CODE();
<a name="l03971"></a>03971         std::ostringstream outs;
<a name="l03972"></a>03972         init_smtlib_parser(c, num_sorts, sort_names, types, num_decls, decl_names, decls);
<a name="l03973"></a>03973         mk_c(c)-&gt;m_smtlib_parser-&gt;set_error_stream(outs);
<a name="l03974"></a>03974         <span class="keywordflow">try</span> {
<a name="l03975"></a>03975             ok = mk_c(c)-&gt;m_smtlib_parser-&gt;parse_file(file_name);
<a name="l03976"></a>03976         }
<a name="l03977"></a>03977         <span class="keywordflow">catch</span>(...) {
<a name="l03978"></a>03978             ok = <span class="keyword">false</span>;
<a name="l03979"></a>03979         }
<a name="l03980"></a>03980         mk_c(c)-&gt;m_parser_buffer = outs.str();
<a name="l03981"></a>03981         <span class="keywordflow">if</span> (!ok) {
<a name="l03982"></a>03982             mk_c(c)-&gt;reset_parser();
<a name="l03983"></a>03983             SET_ERROR_CODE(Z3_PARSER_ERROR);
<a name="l03984"></a>03984         }
<a name="l03985"></a>03985     }
<a name="l03986"></a>03986 
<a name="l03987"></a>03987     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga5dd0dfb9ec1fcc7edba1e86a6ff98a77" title="Return the number of SMTLIB formulas parsed by the last call to Z3_parse_smtlib_string...">Z3_get_smtlib_num_formulas</a>(Z3_context c) {
<a name="l03988"></a>03988         LOG_Z3_get_smtlib_num_formulas(c);
<a name="l03989"></a>03989         RESET_ERROR_CODE();
<a name="l03990"></a>03990         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_smtlib_parser) {
<a name="l03991"></a>03991             <span class="keywordflow">return</span> mk_c(c)-&gt;m_smtlib_parser-&gt;get_benchmark()-&gt;get_num_formulas();
<a name="l03992"></a>03992         }
<a name="l03993"></a>03993         SET_ERROR_CODE(Z3_NO_PARSER);
<a name="l03994"></a>03994         <span class="keywordflow">return</span> 0;
<a name="l03995"></a>03995     }
<a name="l03996"></a>03996 
<a name="l03997"></a>03997     Z3_ast Z3_API <a class="code" href="group__capi.html#ga0ac42d0fa1874e4e773c89a56066f242" title="Return the i-th formula parsed by the last call to Z3_parse_smtlib_string or Z3_parse_smtlib_file...">Z3_get_smtlib_formula</a>(Z3_context c, <span class="keywordtype">unsigned</span> i) {
<a name="l03998"></a>03998         LOG_Z3_get_smtlib_formula(c, i);
<a name="l03999"></a>03999         RESET_ERROR_CODE();
<a name="l04000"></a>04000         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_smtlib_parser) {
<a name="l04001"></a>04001             <span class="keywordflow">if</span> (i &lt; mk_c(c)-&gt;m_smtlib_parser-&gt;get_benchmark()-&gt;get_num_formulas()) {
<a name="l04002"></a>04002                 ast * f = mk_c(c)-&gt;m_smtlib_parser-&gt;get_benchmark()-&gt;begin_formulas()[i];
<a name="l04003"></a>04003                 mk_c(c)-&gt;save_ast_trail(f);
<a name="l04004"></a>04004                 RETURN_Z3(of_ast(f));
<a name="l04005"></a>04005             }
<a name="l04006"></a>04006             <span class="keywordflow">else</span> {
<a name="l04007"></a>04007                 SET_ERROR_CODE(Z3_IOB);
<a name="l04008"></a>04008             }
<a name="l04009"></a>04009         }
<a name="l04010"></a>04010         <span class="keywordflow">else</span> {
<a name="l04011"></a>04011             SET_ERROR_CODE(Z3_NO_PARSER);
<a name="l04012"></a>04012         }
<a name="l04013"></a>04013         RETURN_Z3(0);
<a name="l04014"></a>04014     }
<a name="l04015"></a>04015 
<a name="l04016"></a>04016     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#gaa6682931827a2af6413c2ad6e57a01b4" title="Return the number of SMTLIB assumptions parsed by Z3_parse_smtlib_string or Z3_parse_smtlib_file...">Z3_get_smtlib_num_assumptions</a>(Z3_context c) {
<a name="l04017"></a>04017         LOG_Z3_get_smtlib_num_assumptions(c);
<a name="l04018"></a>04018         RESET_ERROR_CODE();
<a name="l04019"></a>04019         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_smtlib_parser) {
<a name="l04020"></a>04020             <span class="keywordflow">return</span> mk_c(c)-&gt;m_smtlib_parser-&gt;get_benchmark()-&gt;get_num_axioms();
<a name="l04021"></a>04021         }
<a name="l04022"></a>04022         SET_ERROR_CODE(Z3_NO_PARSER);
<a name="l04023"></a>04023         <span class="keywordflow">return</span> 0;
<a name="l04024"></a>04024     }
<a name="l04025"></a>04025 
<a name="l04026"></a>04026     Z3_ast Z3_API <a class="code" href="group__capi.html#ga00764430965b47fbcba657305e1dd820" title="Return the i-th assumption parsed by the last call to Z3_parse_smtlib_string or Z3_parse_smtlib_file...">Z3_get_smtlib_assumption</a>(Z3_context c, <span class="keywordtype">unsigned</span> i) {
<a name="l04027"></a>04027         LOG_Z3_get_smtlib_assumption(c, i);
<a name="l04028"></a>04028         RESET_ERROR_CODE();
<a name="l04029"></a>04029         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_smtlib_parser) {
<a name="l04030"></a>04030             <span class="keywordflow">if</span> (i &lt; mk_c(c)-&gt;m_smtlib_parser-&gt;get_benchmark()-&gt;get_num_axioms()) {
<a name="l04031"></a>04031                 ast * a = mk_c(c)-&gt;m_smtlib_parser-&gt;get_benchmark()-&gt;begin_axioms()[i];
<a name="l04032"></a>04032                 mk_c(c)-&gt;save_ast_trail(a);
<a name="l04033"></a>04033                 RETURN_Z3(of_ast(a));
<a name="l04034"></a>04034             }
<a name="l04035"></a>04035             <span class="keywordflow">else</span> {
<a name="l04036"></a>04036                 SET_ERROR_CODE(Z3_IOB);
<a name="l04037"></a>04037             }
<a name="l04038"></a>04038         }
<a name="l04039"></a>04039         <span class="keywordflow">else</span> {
<a name="l04040"></a>04040             SET_ERROR_CODE(Z3_NO_PARSER);
<a name="l04041"></a>04041         }
<a name="l04042"></a>04042         RETURN_Z3(0);
<a name="l04043"></a>04043     }
<a name="l04044"></a>04044 
<a name="l04045"></a>04045     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga33fc0f55a4d60408a6e15d89da5b1cbe" title="Return the number of declarations parsed by Z3_parse_smtlib_string or Z3_parse_smtlib_file...">Z3_get_smtlib_num_decls</a>(Z3_context c) {
<a name="l04046"></a>04046         LOG_Z3_get_smtlib_num_decls(c);
<a name="l04047"></a>04047         RESET_ERROR_CODE();
<a name="l04048"></a>04048         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_smtlib_parser) {
<a name="l04049"></a>04049             mk_c(c)-&gt;extract_smtlib_parser_decls();
<a name="l04050"></a>04050             <span class="keywordflow">return</span> mk_c(c)-&gt;m_smtlib_parser_decls.size();
<a name="l04051"></a>04051         }
<a name="l04052"></a>04052         SET_ERROR_CODE(Z3_NO_PARSER);
<a name="l04053"></a>04053         <span class="keywordflow">return</span> 0;
<a name="l04054"></a>04054     }
<a name="l04055"></a>04055 
<a name="l04056"></a>04056     Z3_func_decl Z3_API <a class="code" href="group__capi.html#ga9cb99b7d3b0ff5ea324f799c660ac3cb" title="Return the i-th declaration parsed by the last call to Z3_parse_smtlib_string or...">Z3_get_smtlib_decl</a>(Z3_context c, <span class="keywordtype">unsigned</span> i) {
<a name="l04057"></a>04057         LOG_Z3_get_smtlib_decl(c, i);
<a name="l04058"></a>04058         RESET_ERROR_CODE(); 
<a name="l04059"></a>04059         mk_c(c)-&gt;extract_smtlib_parser_decls();
<a name="l04060"></a>04060         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_smtlib_parser) {
<a name="l04061"></a>04061             <span class="keywordflow">if</span> (i &lt; mk_c(c)-&gt;m_smtlib_parser_decls.size()) {
<a name="l04062"></a>04062                 func_decl * d = mk_c(c)-&gt;m_smtlib_parser_decls[i];
<a name="l04063"></a>04063                 mk_c(c)-&gt;save_ast_trail(d);
<a name="l04064"></a>04064                 RETURN_Z3(of_func_decl(d));
<a name="l04065"></a>04065             }
<a name="l04066"></a>04066             <span class="keywordflow">else</span> {
<a name="l04067"></a>04067                 SET_ERROR_CODE(Z3_IOB);
<a name="l04068"></a>04068             }
<a name="l04069"></a>04069         }
<a name="l04070"></a>04070         <span class="keywordflow">else</span> {
<a name="l04071"></a>04071             SET_ERROR_CODE(Z3_NO_PARSER);
<a name="l04072"></a>04072         }
<a name="l04073"></a>04073         RETURN_Z3(0);
<a name="l04074"></a>04074     }
<a name="l04075"></a>04075 
<a name="l04076"></a>04076     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga604c31b838d55a378465a8d2d04bfb45" title="Return the number of sorts parsed by Z3_parse_smtlib_string or Z3_parse_smtlib_file...">Z3_get_smtlib_num_sorts</a>(Z3_context c) {
<a name="l04077"></a>04077         LOG_Z3_get_smtlib_num_sorts(c);
<a name="l04078"></a>04078         RESET_ERROR_CODE();
<a name="l04079"></a>04079         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_smtlib_parser) {
<a name="l04080"></a>04080             mk_c(c)-&gt;extract_smtlib_parser_decls();
<a name="l04081"></a>04081             <span class="keywordflow">return</span> mk_c(c)-&gt;m_smtlib_parser_sorts.size();
<a name="l04082"></a>04082         }
<a name="l04083"></a>04083         SET_ERROR_CODE(Z3_NO_PARSER);
<a name="l04084"></a>04084         <span class="keywordflow">return</span> 0;
<a name="l04085"></a>04085     }
<a name="l04086"></a>04086 
<a name="l04087"></a>04087     Z3_sort Z3_API <a class="code" href="group__capi.html#ga9b8fa7d7ee55392a23a60660678bc71a" title="Return the i-th sort parsed by the last call to Z3_parse_smtlib_string or Z3_parse_smtlib_file...">Z3_get_smtlib_sort</a>(Z3_context c, <span class="keywordtype">unsigned</span> i) {
<a name="l04088"></a>04088         LOG_Z3_get_smtlib_sort(c, i);
<a name="l04089"></a>04089         RESET_ERROR_CODE(); 
<a name="l04090"></a>04090         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_smtlib_parser) {
<a name="l04091"></a>04091             mk_c(c)-&gt;extract_smtlib_parser_decls();
<a name="l04092"></a>04092             <span class="keywordflow">if</span> (i &lt; mk_c(c)-&gt;m_smtlib_parser_sorts.size()) {
<a name="l04093"></a>04093                 sort* s = mk_c(c)-&gt;m_smtlib_parser_sorts[i];
<a name="l04094"></a>04094                 mk_c(c)-&gt;save_ast_trail(s);
<a name="l04095"></a>04095                 RETURN_Z3(of_sort(s));
<a name="l04096"></a>04096             }
<a name="l04097"></a>04097             <span class="keywordflow">else</span> {
<a name="l04098"></a>04098                 SET_ERROR_CODE(Z3_IOB);
<a name="l04099"></a>04099             }
<a name="l04100"></a>04100         }
<a name="l04101"></a>04101         <span class="keywordflow">else</span> {
<a name="l04102"></a>04102             SET_ERROR_CODE(Z3_NO_PARSER);
<a name="l04103"></a>04103         }
<a name="l04104"></a>04104         RETURN_Z3(0);
<a name="l04105"></a>04105     }
<a name="l04106"></a>04106 
<a name="l04107"></a>04107     <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> Z3_API <a class="code" href="group__capi.html#gaf595a7ac994547d11525cc1b21083c76" title="Retrieve that last error message information generated from parsing.">Z3_get_smtlib_error</a>(Z3_context c) {        
<a name="l04108"></a>04108         LOG_Z3_get_smtlib_error(c);
<a name="l04109"></a>04109         <span class="keywordflow">return</span> mk_c(c)-&gt;m_parser_buffer.c_str();
<a name="l04110"></a>04110     }
<a name="l04111"></a>04111 
<a name="l04112"></a>04112     
<a name="l04113"></a>04113     Z3_ast parse_z3_stream(__in Z3_context c, __in_z std::istream&amp; is) {
<a name="l04114"></a>04114         z3_solver parser(c, is, verbose_stream(), mk_c(c)-&gt;m_params, <span class="keyword">false</span>);
<a name="l04115"></a>04115         <span class="keywordflow">if</span> (!parser.parse()) {
<a name="l04116"></a>04116             SET_ERROR_CODE(Z3_PARSER_ERROR);
<a name="l04117"></a>04117             <span class="keywordflow">return</span> of_ast(mk_c(c)-&gt;m_manager.mk_true());
<a name="l04118"></a>04118         }
<a name="l04119"></a>04119         expr_ref_vector assumptions(mk_c(c)-&gt;m_manager);
<a name="l04120"></a>04120         parser.get_assumptions(assumptions);
<a name="l04121"></a>04121         <span class="keywordflow">return</span> of_ast(mk_c(c)-&gt;mk_and(assumptions.size(), assumptions.c_ptr()));
<a name="l04122"></a>04122     }
<a name="l04123"></a>04123 
<a name="l04124"></a><a class="code" href="group__capi.html#gabcf00179386fbb144e05b882236ecb72">04124</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#gabcf00179386fbb144e05b882236ecb72" title="Parse the given string using the Z3 native parser.">Z3_parse_z3_string</a>(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> str) { 
<a name="l04125"></a>04125         LOG_Z3_parse_z3_string(c, str);
<a name="l04126"></a>04126         std::string s(str);
<a name="l04127"></a>04127         std::istringstream is(s);
<a name="l04128"></a>04128         Z3_ast r = parse_z3_stream(c, is);
<a name="l04129"></a>04129         RETURN_Z3(r);
<a name="l04130"></a>04130     }
<a name="l04131"></a>04131 
<a name="l04132"></a><a class="code" href="group__capi.html#ga356d184e90ef69128c9d2edf7ac4552d">04132</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga356d184e90ef69128c9d2edf7ac4552d" title="Similar to Z3_parse_z3_string, but reads the benchmark from a file.">Z3_parse_z3_file</a>(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> file_name) {
<a name="l04133"></a>04133         LOG_Z3_parse_z3_file(c, file_name);
<a name="l04134"></a>04134         std::ifstream is(file_name);
<a name="l04135"></a>04135         <span class="keywordflow">if</span> (!is) {
<a name="l04136"></a>04136             SET_ERROR_CODE(Z3_PARSER_ERROR);
<a name="l04137"></a>04137             <span class="keywordflow">return</span> 0;
<a name="l04138"></a>04138         }
<a name="l04139"></a>04139         Z3_ast r = parse_z3_stream(c, is);
<a name="l04140"></a>04140         RETURN_Z3(r);
<a name="l04141"></a>04141     }
<a name="l04142"></a>04142 
<a name="l04143"></a>04143     <span class="comment">// ---------------</span>
<a name="l04144"></a>04144     <span class="comment">// Support for SMTLIB2</span>
<a name="l04145"></a>04145 
<a name="l04146"></a>04146     <span class="keyword">class </span>z3_context_solver : <span class="keyword">public</span> solver {
<a name="l04147"></a>04147         _Z3_context &amp; m_ctx;
<a name="l04148"></a>04148         smt::solver &amp; ctx()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_ctx.get_context(); }
<a name="l04149"></a>04149     <span class="keyword">public</span>:
<a name="l04150"></a>04150         <span class="keyword">virtual</span> ~z3_context_solver() {}
<a name="l04151"></a>04151         z3_context_solver(_Z3_context&amp; c) : m_ctx(c) {}
<a name="l04152"></a>04152         <span class="keyword">virtual</span> <span class="keywordtype">void</span> init(ast_manager &amp; m, symbol <span class="keyword">const</span> &amp; logic) {}
<a name="l04153"></a>04153         <span class="keyword">virtual</span> <span class="keywordtype">void</span> collect_statistics(statistics &amp; st)<span class="keyword"> const </span>{}
<a name="l04154"></a>04154         <span class="keyword">virtual</span> <span class="keywordtype">void</span> reset() { ctx().reset(); }
<a name="l04155"></a>04155         <span class="keyword">virtual</span> <span class="keywordtype">void</span> assert_expr(expr * t) { ctx().assert_expr(t); }
<a name="l04156"></a>04156         <span class="keyword">virtual</span> <span class="keywordtype">void</span> push() { ctx().push(); }
<a name="l04157"></a>04157         <span class="keyword">virtual</span> <span class="keywordtype">void</span> pop(<span class="keywordtype">unsigned</span> n) { ctx().pop(n); }
<a name="l04158"></a>04158         <span class="keyword">virtual</span> lbool check_sat(<span class="keywordtype">unsigned</span> num_assumptions, expr * <span class="keyword">const</span> * assumptions) {
<a name="l04159"></a>04159             <span class="keywordflow">return</span> ctx().check(num_assumptions, assumptions);
<a name="l04160"></a>04160         }
<a name="l04161"></a>04161         <span class="keyword">virtual</span> <span class="keywordtype">void</span> get_unsat_core(ptr_vector&lt;expr&gt; &amp; r) {
<a name="l04162"></a>04162             <span class="keywordtype">unsigned</span> sz = ctx().get_unsat_core_size();
<a name="l04163"></a>04163             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; sz; i++)
<a name="l04164"></a>04164                 r.push_back(ctx().get_unsat_core_expr(i));            
<a name="l04165"></a>04165         }
<a name="l04166"></a>04166         <span class="keyword">virtual</span> <span class="keywordtype">void</span> get_model(model_ref &amp; m) { ctx().get_model(m); }
<a name="l04167"></a>04167         <span class="keyword">virtual</span> proof * get_proof() { <span class="keywordflow">return</span> ctx().get_proof(); }
<a name="l04168"></a>04168         <span class="keyword">virtual</span> std::string reason_unknown()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ctx().last_failure_as_string(); }
<a name="l04169"></a>04169         <span class="keyword">virtual</span> <span class="keywordtype">void</span> get_labels(svector&lt;symbol&gt; &amp; r) {
<a name="l04170"></a>04170             buffer&lt;symbol&gt; tmp;
<a name="l04171"></a>04171             ctx().get_relevant_labels(0, tmp);
<a name="l04172"></a>04172             r.append(tmp.size(), tmp.c_ptr());            
<a name="l04173"></a>04173         }
<a name="l04174"></a>04174         
<a name="l04175"></a>04175         <span class="comment">// These are controlled by the main API</span>
<a name="l04176"></a>04176         <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_cancel(<span class="keywordtype">bool</span> f) { }
<a name="l04177"></a>04177         <span class="keywordtype">void</span> cancel() { set_cancel(<span class="keyword">true</span>); }
<a name="l04178"></a>04178         <span class="keywordtype">void</span> reset_cancel() { set_cancel(<span class="keyword">false</span>); }        
<a name="l04179"></a>04179         <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_progress_callback(progress_callback * callback) {}        
<a name="l04180"></a>04180     };
<a name="l04181"></a>04181 
<a name="l04182"></a>04182     Z3_ast parse_smtlib2_stream(<span class="keywordtype">bool</span> exec, __in Z3_context c, __in_z std::istream&amp; is,
<a name="l04183"></a>04183                                 __in <span class="keywordtype">unsigned</span> num_sorts,
<a name="l04184"></a>04184                                 __in_ecount(num_sorts) Z3_symbol <span class="keyword">const</span> sort_names[],
<a name="l04185"></a>04185                                 __in_ecount(num_sorts) Z3_sort <span class="keyword">const</span> sorts[],
<a name="l04186"></a>04186                                 __in <span class="keywordtype">unsigned</span> num_decls,
<a name="l04187"></a>04187                                 __in_ecount(num_decls) Z3_symbol <span class="keyword">const</span> decl_names[],
<a name="l04188"></a>04188                                 __in_ecount(num_decls) Z3_func_decl <span class="keyword">const</span> decls[]) {
<a name="l04189"></a>04189         cmd_context ctx(mk_c(c)-&gt;m_params, <span class="keyword">false</span>, &amp;(mk_c(c)-&gt;m_manager));
<a name="l04190"></a>04190         <span class="keywordflow">if</span> (exec) {
<a name="l04191"></a>04191             ctx.set_solver(alloc(z3_context_solver, *mk_c(c)));
<a name="l04192"></a>04192         }
<a name="l04193"></a>04193         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_decls; ++i) {
<a name="l04194"></a>04194            ctx.insert(to_symbol(decl_names[i]), to_func_decl(decls[i]));
<a name="l04195"></a>04195         }
<a name="l04196"></a>04196         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_sorts; ++i) {
<a name="l04197"></a>04197             psort* ps = ctx.pm().mk_psort_cnst(to_sort(sorts[i]));
<a name="l04198"></a>04198             ctx.insert(ctx.pm().mk_psort_user_decl(0, to_symbol(sort_names[i]), ps));
<a name="l04199"></a>04199         }
<a name="l04200"></a>04200         <span class="keywordflow">if</span> (!parse_smt2_commands(ctx, is)) {
<a name="l04201"></a>04201             SET_ERROR_CODE(Z3_PARSER_ERROR);
<a name="l04202"></a>04202             <span class="keywordflow">return</span> of_ast(mk_c(c)-&gt;m_manager.mk_true());
<a name="l04203"></a>04203         }
<a name="l04204"></a>04204         ptr_vector&lt;expr&gt;::const_iterator it  = ctx.begin_assertions();
<a name="l04205"></a>04205         ptr_vector&lt;expr&gt;::const_iterator end = ctx.end_assertions();
<a name="l04206"></a>04206         <span class="keywordtype">unsigned</span> size = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(end - it);
<a name="l04207"></a>04207         <span class="keywordflow">return</span> of_ast(mk_c(c)-&gt;mk_and(size, it));
<a name="l04208"></a>04208     }
<a name="l04209"></a>04209 
<a name="l04210"></a><a class="code" href="group__capi.html#ga199452aebb37cb160bd6abead8a84d08">04210</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga199452aebb37cb160bd6abead8a84d08" title="Parse the given string using the SMT-LIB2 parser.">Z3_parse_smtlib2_string</a>(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> str,
<a name="l04211"></a>04211                                           __in <span class="keywordtype">unsigned</span> num_sorts,
<a name="l04212"></a>04212                                           __in_ecount(num_sorts) Z3_symbol <span class="keyword">const</span> sort_names[],
<a name="l04213"></a>04213                                           __in_ecount(num_sorts) Z3_sort <span class="keyword">const</span> sorts[],
<a name="l04214"></a>04214                                           __in <span class="keywordtype">unsigned</span> num_decls,
<a name="l04215"></a>04215                                           __in_ecount(num_decls) Z3_symbol <span class="keyword">const</span> decl_names[],
<a name="l04216"></a>04216                                           __in_ecount(num_decls) Z3_func_decl <span class="keyword">const</span> decls[]) {
<a name="l04217"></a>04217         LOG_Z3_parse_smtlib2_string(c, str, num_sorts, sort_names, sorts, num_decls, decl_names, decls);
<a name="l04218"></a>04218         std::string s(str);
<a name="l04219"></a>04219         std::istringstream is(s);
<a name="l04220"></a>04220         Z3_ast r = parse_smtlib2_stream(<span class="keyword">false</span>, c, is, num_sorts, sort_names, sorts, num_decls, decl_names, decls);
<a name="l04221"></a>04221         RETURN_Z3(r);
<a name="l04222"></a>04222     }
<a name="l04223"></a>04223 
<a name="l04224"></a><a class="code" href="group__capi.html#ga6dd0bce4cfabe2734b9f8c6916b0f80a">04224</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga6dd0bce4cfabe2734b9f8c6916b0f80a" title="Similar to Z3_parse_smtlib2_string, but reads the benchmark from a file.">Z3_parse_smtlib2_file</a>(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> file_name,
<a name="l04225"></a>04225                                           __in <span class="keywordtype">unsigned</span> num_sorts,
<a name="l04226"></a>04226                                           __in_ecount(num_sorts) Z3_symbol <span class="keyword">const</span> sort_names[],
<a name="l04227"></a>04227                                           __in_ecount(num_sorts) Z3_sort <span class="keyword">const</span> sorts[],
<a name="l04228"></a>04228                                           __in <span class="keywordtype">unsigned</span> num_decls,
<a name="l04229"></a>04229                                           __in_ecount(num_decls) Z3_symbol <span class="keyword">const</span> decl_names[],
<a name="l04230"></a>04230                                           __in_ecount(num_decls) Z3_func_decl <span class="keyword">const</span> decls[]) {
<a name="l04231"></a>04231 
<a name="l04232"></a>04232         LOG_Z3_parse_smtlib2_string(c, file_name, num_sorts, sort_names, sorts, num_decls, decl_names, decls);
<a name="l04233"></a>04233         std::ifstream is(file_name);
<a name="l04234"></a>04234         <span class="keywordflow">if</span> (!is) {
<a name="l04235"></a>04235             SET_ERROR_CODE(Z3_PARSER_ERROR);
<a name="l04236"></a>04236             <span class="keywordflow">return</span> 0;
<a name="l04237"></a>04237         }
<a name="l04238"></a>04238         Z3_ast r = parse_smtlib2_stream(<span class="keyword">false</span>, c, is, num_sorts, sort_names, sorts, num_decls, decl_names, decls);
<a name="l04239"></a>04239         RETURN_Z3(r);
<a name="l04240"></a>04240     }
<a name="l04241"></a>04241 
<a name="l04242"></a>04242     Z3_ast Z3_API Z3_exec_smtlib2_string(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> str,
<a name="l04243"></a>04243                                          __in <span class="keywordtype">unsigned</span> num_sorts,
<a name="l04244"></a>04244                                          __in_ecount(num_sorts) Z3_symbol sort_names[],
<a name="l04245"></a>04245                                          __in_ecount(num_sorts) Z3_sort sorts[],
<a name="l04246"></a>04246                                          __in <span class="keywordtype">unsigned</span> num_decls,
<a name="l04247"></a>04247                                          __in_ecount(num_decls) Z3_symbol decl_names[],
<a name="l04248"></a>04248                                          __in_ecount(num_decls) Z3_func_decl decls[]) { 
<a name="l04249"></a>04249         cmd_context ctx(mk_c(c)-&gt;m_params, <span class="keyword">false</span>, &amp;(mk_c(c)-&gt;m_manager));
<a name="l04250"></a>04250         std::string s(str);
<a name="l04251"></a>04251         std::istringstream is(s);
<a name="l04252"></a>04252         <span class="comment">// No logging for this one, since it private.</span>
<a name="l04253"></a>04253         <span class="keywordflow">return</span> parse_smtlib2_stream(<span class="keyword">true</span>, c, is, num_sorts, sort_names, sorts, num_decls, decl_names, decls);
<a name="l04254"></a>04254     }
<a name="l04255"></a>04255 
<a name="l04256"></a>04256     Z3_ast Z3_API Z3_exec_smtlib2_file(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> file_name,
<a name="l04257"></a>04257                                        __in <span class="keywordtype">unsigned</span> num_sorts,
<a name="l04258"></a>04258                                        __in_ecount(num_sorts) Z3_symbol sort_names[],
<a name="l04259"></a>04259                                        __in_ecount(num_sorts) Z3_sort sorts[],
<a name="l04260"></a>04260                                        __in <span class="keywordtype">unsigned</span> num_decls,
<a name="l04261"></a>04261                                        __in_ecount(num_decls) Z3_symbol decl_names[],
<a name="l04262"></a>04262                                        __in_ecount(num_decls) Z3_func_decl decls[]) { 
<a name="l04263"></a>04263         std::ifstream is(file_name);
<a name="l04264"></a>04264         <span class="keywordflow">if</span> (!is) {
<a name="l04265"></a>04265             SET_ERROR_CODE(Z3_PARSER_ERROR);
<a name="l04266"></a>04266             <span class="keywordflow">return</span> 0;
<a name="l04267"></a>04267         }
<a name="l04268"></a>04268         <span class="comment">// No logging for this one, since it private.</span>
<a name="l04269"></a>04269         <span class="keywordflow">return</span> parse_smtlib2_stream(<span class="keyword">true</span>, c, is, num_sorts, sort_names, sorts, num_decls, decl_names, decls);
<a name="l04270"></a>04270     }
<a name="l04271"></a>04271 
<a name="l04272"></a><a class="code" href="group__capi.html#gac70374447fdbc793c851ba63c2392a5d">04272</a>     <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> Z3_API <a class="code" href="group__capi.html#gac70374447fdbc793c851ba63c2392a5d" title="Convert a set of axioms, rules and queries to a benchmark in SMT-LIB2 + rules format...">Z3_fixpoint_benchmark_to_string</a>(__in Z3_context c,
<a name="l04273"></a>04273                                                      __in <span class="keywordtype">unsigned</span> num_axioms,
<a name="l04274"></a>04274                                                      __in_ecount(num_axioms) Z3_ast _axioms[],
<a name="l04275"></a>04275                                                      __in <span class="keywordtype">unsigned</span> num_rules,
<a name="l04276"></a>04276                                                      __in_ecount(num_rules) Z3_ast _rules[],
<a name="l04277"></a>04277                                                      __in <span class="keywordtype">unsigned</span> num_queries,
<a name="l04278"></a>04278                                                      __in_ecount(num_queries) Z3_ast _queries[]) {
<a name="l04279"></a>04279         expr*<span class="keyword">const</span>* axioms  = to_exprs(_axioms);
<a name="l04280"></a>04280         expr*<span class="keyword">const</span>* rules   = to_exprs(_rules);
<a name="l04281"></a>04281         expr*<span class="keyword">const</span>* queries = to_exprs(_queries);        
<a name="l04282"></a>04282         std::ostringstream strm;
<a name="l04283"></a>04283         mk_c(c)-&gt;datalog_display_smt2(num_axioms, axioms, num_rules, rules, num_queries, queries, strm);
<a name="l04284"></a>04284         mk_c(c)-&gt;m_benchmark_to_smtlib_string_buffer = strm.str();
<a name="l04285"></a>04285         <span class="keywordflow">return</span> mk_c(c)-&gt;m_benchmark_to_smtlib_string_buffer.c_str();
<a name="l04286"></a>04286     }
<a name="l04287"></a>04287                     
<a name="l04288"></a><a class="code" href="group__capi.html#ga8f43a077bd276a3ea1aa7001488d253a">04288</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga8f43a077bd276a3ea1aa7001488d253a" title="Delete array of asts.">Z3_del_asts</a>(__in Z3_context c, __in Z3_asts asts) {
<a name="l04289"></a>04289         LOG_Z3_del_asts(c, asts);
<a name="l04290"></a>04290         RESET_ERROR_CODE();
<a name="l04291"></a>04291         dealloc(<span class="keyword">reinterpret_cast&lt;</span>ptr_vector&lt;expr&gt;*<span class="keyword">&gt;</span>(asts));
<a name="l04292"></a>04292     }
<a name="l04293"></a>04293 
<a name="l04294"></a><a class="code" href="group__capi.html#ga3bff8589005c4e6f9cc8b3433f226bb9">04294</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga3bff8589005c4e6f9cc8b3433f226bb9" title="Retrieve length of asts array.">Z3_asts_count</a>(__in Z3_context c, __in Z3_asts asts) {
<a name="l04295"></a>04295         LOG_Z3_asts_count(c, asts);
<a name="l04296"></a>04296         RESET_ERROR_CODE();
<a name="l04297"></a>04297         <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>ptr_vector&lt;expr&gt;*<span class="keyword">&gt;</span>(asts)-&gt;size();
<a name="l04298"></a>04298     }
<a name="l04299"></a>04299 
<a name="l04300"></a><a class="code" href="group__capi.html#gac01e0595b6b8d0b4f39a40b80511d7da">04300</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#gac01e0595b6b8d0b4f39a40b80511d7da" title="Access element of asts array at index.">Z3_asts_get</a>(__in Z3_context c, __in Z3_asts asts, __in <span class="keywordtype">unsigned</span> index) {
<a name="l04301"></a>04301         LOG_Z3_asts_get(c, asts, index);
<a name="l04302"></a>04302         RESET_ERROR_CODE();
<a name="l04303"></a>04303         ptr_vector&lt;expr&gt;&amp; exprs = *<span class="keyword">reinterpret_cast&lt;</span>ptr_vector&lt;expr&gt;*<span class="keyword">&gt;</span>(asts);        
<a name="l04304"></a>04304         RETURN_Z3(reinterpret_cast&lt;Z3_ast&gt;(exprs[index]));
<a name="l04305"></a>04305     }
<a name="l04306"></a>04306 
<a name="l04307"></a>04307     
<a name="l04308"></a><a class="code" href="group__capi.html#ga1ae5445041c8a116c62e5dca0b333bed">04308</a>     Z3_asts Z3_API <a class="code" href="group__capi.html#ga1ae5445041c8a116c62e5dca0b333bed" title="Simplify rules into a set of new rules that are returned. The simplification routines...">Z3_fixpoint_simplify_rules</a>(__in Z3_context c,
<a name="l04309"></a>04309                                               __in <span class="keywordtype">unsigned</span> num_rules,
<a name="l04310"></a>04310                                               __in_ecount(num_rules) Z3_ast _rules[],
<a name="l04311"></a>04311                                               __in <span class="keywordtype">unsigned</span> num_outputs,
<a name="l04312"></a>04312                                               __in_ecount(num_outputs) Z3_func_decl outputs[]
<a name="l04313"></a>04313                                               ) {
<a name="l04314"></a>04314         LOG_Z3_fixpoint_simplify_rules(c, num_rules, _rules, num_outputs, outputs);
<a name="l04315"></a>04315         RESET_ERROR_CODE();
<a name="l04316"></a>04316         expr_ref_vector res(mk_c(c)-&gt;m_manager);
<a name="l04317"></a>04317         mk_c(c)-&gt;datalog_simplify_rules(num_rules, to_exprs(_rules), num_outputs, to_func_decls(outputs), res);
<a name="l04318"></a>04318         ptr_vector&lt;expr&gt;* result = alloc(ptr_vector&lt;expr&gt;);
<a name="l04319"></a>04319         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; res.size(); ++i) {
<a name="l04320"></a>04320             mk_c(c)-&gt;save_ast_trail(res[i].<span class="keyword">get</span>());
<a name="l04321"></a>04321             result-&gt;push_back(res[i].<span class="keyword">get</span>());
<a name="l04322"></a>04322         }
<a name="l04323"></a>04323         RETURN_Z3(reinterpret_cast&lt;Z3_asts&gt;(result));
<a name="l04324"></a>04324     }
<a name="l04325"></a>04325 
<a name="l04326"></a>04326 
<a name="l04327"></a>04327     <span class="comment">// -------------------</span>
<a name="l04328"></a>04328     <span class="comment">// Simplify</span>
<a name="l04329"></a>04329     Z3_ast parse_simplify_stream(__in Z3_context c, __in std::istream&amp; is, __out std::ostream&amp; outs) {
<a name="l04330"></a>04330         simplify_env parser(mk_c(c)-&gt;m_manager, mk_c(c)-&gt;m_params, <span class="keyword">true</span>);
<a name="l04331"></a>04331         read_simplify_input(parser, is, outs, outs);
<a name="l04332"></a>04332         expr_ref_vector assumptions(mk_c(c)-&gt;m_manager);
<a name="l04333"></a>04333         parser.get_assertions(assumptions);
<a name="l04334"></a>04334         <span class="keywordflow">return</span> of_ast(mk_c(c)-&gt;mk_and(assumptions.size(), assumptions.c_ptr()));
<a name="l04335"></a>04335     }
<a name="l04336"></a>04336 
<a name="l04337"></a>04337 
<a name="l04338"></a>04338     Z3_ast parse_simplify_stream1(__in Z3_context c, __in std::istream&amp; is, __out <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a>* output) {
<a name="l04339"></a>04339         Z3_ast result = 0;
<a name="l04340"></a>04340         <span class="keywordtype">bool</span> exn = <span class="keyword">false</span>;
<a name="l04341"></a>04341         std::ostringstream outs;
<a name="l04342"></a>04342         <span class="keywordflow">try</span> {
<a name="l04343"></a>04343             result = parse_simplify_stream(c, is, outs);
<a name="l04344"></a>04344         }
<a name="l04345"></a>04345         <span class="keywordflow">catch</span>(...) {
<a name="l04346"></a>04346             exn = <span class="keyword">true</span>;
<a name="l04347"></a>04347         }
<a name="l04348"></a>04348         mk_c(c)-&gt;m_parser_buffer = outs.str();
<a name="l04349"></a>04349         <span class="keywordflow">if</span> (output) {
<a name="l04350"></a>04350             *output = mk_c(c)-&gt;m_parser_buffer.c_str();
<a name="l04351"></a>04351         }
<a name="l04352"></a>04352         <span class="keywordflow">if</span> (exn) {
<a name="l04353"></a>04353             SET_ERROR_CODE(Z3_PARSER_ERROR);
<a name="l04354"></a>04354             <span class="keywordflow">return</span> 0;
<a name="l04355"></a>04355         }
<a name="l04356"></a>04356         mk_c(c)-&gt;save_ast_trail(to_ast(result));
<a name="l04357"></a>04357         <span class="keywordflow">return</span> result;
<a name="l04358"></a>04358     }
<a name="l04359"></a>04359 
<a name="l04360"></a><a class="code" href="group__capi.html#ga061840f03ee6ce4b862ce95b10948bb8">04360</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga061840f03ee6ce4b862ce95b10948bb8" title="Parse the given string using the Simplify parser.">Z3_parse_simplify_string</a>(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> str, __out <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a>* output) {
<a name="l04361"></a>04361         LOG_Z3_parse_simplify_string(c, str, output);
<a name="l04362"></a>04362         std::string s(str);
<a name="l04363"></a>04363         std::istringstream is(s);
<a name="l04364"></a>04364         Z3_ast r = parse_simplify_stream1(c, is, output);
<a name="l04365"></a>04365         RETURN_Z3(r);
<a name="l04366"></a>04366     }
<a name="l04367"></a>04367     
<a name="l04368"></a><a class="code" href="group__capi.html#ga9c938b354f47aed75bc02028f98cec18">04368</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga9c938b354f47aed75bc02028f98cec18" title="Similar to Z3_parse_simplify_string, but reads the benchmark from a file.">Z3_parse_simplify_file</a>(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> file_name, __out <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a>* output) {
<a name="l04369"></a>04369         LOG_Z3_parse_simplify_string(c, file_name, output);
<a name="l04370"></a>04370         std::ifstream is(file_name);
<a name="l04371"></a>04371         <span class="keywordflow">if</span> (!is) {
<a name="l04372"></a>04372             SET_ERROR_CODE(Z3_PARSER_ERROR);
<a name="l04373"></a>04373             <span class="keywordflow">return</span> 0;
<a name="l04374"></a>04374         }
<a name="l04375"></a>04375         Z3_ast r = parse_simplify_stream1(c, is, output);
<a name="l04376"></a>04376         RETURN_Z3(r);
<a name="l04377"></a>04377     }
<a name="l04378"></a>04378 
<a name="l04379"></a><a class="code" href="group__capi.html#ga8cc3224c9b9f2149550701275207bedf">04379</a>     <a class="code" href="group__capi.html#ga1fe4399e5468621e2a799a680c6667cd" title="The different kinds of interpreted function kinds.">Z3_decl_kind</a> Z3_API <a class="code" href="group__capi.html#ga8cc3224c9b9f2149550701275207bedf" title="Return declaration kind corresponding to declaration.">Z3_get_decl_kind</a>(__in Z3_context c, __in Z3_func_decl d) {
<a name="l04380"></a>04380         LOG_Z3_get_decl_kind(c, d);
<a name="l04381"></a>04381         func_decl* _d = to_func_decl(d);
<a name="l04382"></a>04382 
<a name="l04383"></a>04383         <span class="keywordflow">if</span> (null_family_id == _d-&gt;get_family_id()) {
<a name="l04384"></a>04384             <span class="keywordflow">return</span> Z3_OP_UNINTERPRETED;
<a name="l04385"></a>04385         }
<a name="l04386"></a>04386         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_basic_fid == _d-&gt;get_family_id()) {
<a name="l04387"></a>04387             <span class="keywordflow">switch</span>(_d-&gt;get_decl_kind()) {
<a name="l04388"></a>04388             <span class="keywordflow">case</span> OP_TRUE:     <span class="keywordflow">return</span> Z3_OP_TRUE;
<a name="l04389"></a>04389             <span class="keywordflow">case</span> OP_FALSE:    <span class="keywordflow">return</span> Z3_OP_FALSE;
<a name="l04390"></a>04390             <span class="keywordflow">case</span> OP_EQ:       <span class="keywordflow">return</span> Z3_OP_EQ;
<a name="l04391"></a>04391             <span class="keywordflow">case</span> OP_DISTINCT: <span class="keywordflow">return</span> Z3_OP_DISTINCT;
<a name="l04392"></a>04392             <span class="keywordflow">case</span> OP_ITE:      <span class="keywordflow">return</span> Z3_OP_ITE;
<a name="l04393"></a>04393             <span class="keywordflow">case</span> OP_AND:      <span class="keywordflow">return</span> Z3_OP_AND;
<a name="l04394"></a>04394             <span class="keywordflow">case</span> OP_OR:       <span class="keywordflow">return</span> Z3_OP_OR;
<a name="l04395"></a>04395             <span class="keywordflow">case</span> OP_IFF:      <span class="keywordflow">return</span> Z3_OP_IFF;
<a name="l04396"></a>04396             <span class="keywordflow">case</span> OP_XOR:      <span class="keywordflow">return</span> Z3_OP_XOR;
<a name="l04397"></a>04397             <span class="keywordflow">case</span> OP_NOT:      <span class="keywordflow">return</span> Z3_OP_NOT;
<a name="l04398"></a>04398             <span class="keywordflow">case</span> OP_IMPLIES:  <span class="keywordflow">return</span> Z3_OP_IMPLIES;
<a name="l04399"></a>04399             <span class="keywordflow">case</span> OP_OEQ:      <span class="keywordflow">return</span> Z3_OP_OEQ;
<a name="l04400"></a>04400 
<a name="l04401"></a>04401             <span class="keywordflow">case</span> PR_UNDEF:    <span class="keywordflow">return</span> Z3_OP_PR_UNDEF;
<a name="l04402"></a>04402             <span class="keywordflow">case</span> PR_TRUE:     <span class="keywordflow">return</span> Z3_OP_PR_TRUE;
<a name="l04403"></a>04403             <span class="keywordflow">case</span> PR_ASSERTED: <span class="keywordflow">return</span> Z3_OP_PR_ASSERTED; 
<a name="l04404"></a>04404             <span class="keywordflow">case</span> PR_GOAL:     <span class="keywordflow">return</span> Z3_OP_PR_GOAL; 
<a name="l04405"></a>04405             <span class="keywordflow">case</span> PR_MODUS_PONENS: <span class="keywordflow">return</span> Z3_OP_PR_MODUS_PONENS; 
<a name="l04406"></a>04406             <span class="keywordflow">case</span> PR_REFLEXIVITY: <span class="keywordflow">return</span> Z3_OP_PR_REFLEXIVITY; 
<a name="l04407"></a>04407             <span class="keywordflow">case</span> PR_SYMMETRY: <span class="keywordflow">return</span> Z3_OP_PR_SYMMETRY; 
<a name="l04408"></a>04408             <span class="keywordflow">case</span> PR_TRANSITIVITY: <span class="keywordflow">return</span> Z3_OP_PR_TRANSITIVITY; 
<a name="l04409"></a>04409             <span class="keywordflow">case</span> PR_TRANSITIVITY_STAR: <span class="keywordflow">return</span> Z3_OP_PR_TRANSITIVITY_STAR; 
<a name="l04410"></a>04410             <span class="keywordflow">case</span> PR_MONOTONICITY: <span class="keywordflow">return</span> Z3_OP_PR_MONOTONICITY; 
<a name="l04411"></a>04411             <span class="keywordflow">case</span> PR_QUANT_INTRO: <span class="keywordflow">return</span> Z3_OP_PR_QUANT_INTRO;
<a name="l04412"></a>04412             <span class="keywordflow">case</span> PR_DISTRIBUTIVITY: <span class="keywordflow">return</span> Z3_OP_PR_DISTRIBUTIVITY; 
<a name="l04413"></a>04413             <span class="keywordflow">case</span> PR_AND_ELIM: <span class="keywordflow">return</span> Z3_OP_PR_AND_ELIM; 
<a name="l04414"></a>04414             <span class="keywordflow">case</span> PR_NOT_OR_ELIM: <span class="keywordflow">return</span> Z3_OP_PR_NOT_OR_ELIM; 
<a name="l04415"></a>04415             <span class="keywordflow">case</span> PR_REWRITE: <span class="keywordflow">return</span> Z3_OP_PR_REWRITE; 
<a name="l04416"></a>04416             <span class="keywordflow">case</span> PR_REWRITE_STAR: <span class="keywordflow">return</span> Z3_OP_PR_REWRITE_STAR; 
<a name="l04417"></a>04417             <span class="keywordflow">case</span> PR_PULL_QUANT: <span class="keywordflow">return</span> Z3_OP_PR_PULL_QUANT; 
<a name="l04418"></a>04418             <span class="keywordflow">case</span> PR_PULL_QUANT_STAR: <span class="keywordflow">return</span> Z3_OP_PR_PULL_QUANT_STAR; 
<a name="l04419"></a>04419             <span class="keywordflow">case</span> PR_PUSH_QUANT: <span class="keywordflow">return</span> Z3_OP_PR_PUSH_QUANT; 
<a name="l04420"></a>04420             <span class="keywordflow">case</span> PR_ELIM_UNUSED_VARS: <span class="keywordflow">return</span> Z3_OP_PR_ELIM_UNUSED_VARS; 
<a name="l04421"></a>04421             <span class="keywordflow">case</span> PR_DER: <span class="keywordflow">return</span> Z3_OP_PR_DER; 
<a name="l04422"></a>04422             <span class="keywordflow">case</span> PR_QUANT_INST: <span class="keywordflow">return</span> Z3_OP_PR_QUANT_INST;
<a name="l04423"></a>04423             <span class="keywordflow">case</span> PR_HYPOTHESIS: <span class="keywordflow">return</span> Z3_OP_PR_HYPOTHESIS; 
<a name="l04424"></a>04424             <span class="keywordflow">case</span> PR_LEMMA: <span class="keywordflow">return</span> Z3_OP_PR_LEMMA; 
<a name="l04425"></a>04425             <span class="keywordflow">case</span> PR_UNIT_RESOLUTION: <span class="keywordflow">return</span> Z3_OP_PR_UNIT_RESOLUTION; 
<a name="l04426"></a>04426             <span class="keywordflow">case</span> PR_IFF_TRUE: <span class="keywordflow">return</span> Z3_OP_PR_IFF_TRUE; 
<a name="l04427"></a>04427             <span class="keywordflow">case</span> PR_IFF_FALSE: <span class="keywordflow">return</span> Z3_OP_PR_IFF_FALSE; 
<a name="l04428"></a>04428             <span class="keywordflow">case</span> PR_COMMUTATIVITY: <span class="keywordflow">return</span> Z3_OP_PR_COMMUTATIVITY; 
<a name="l04429"></a>04429             <span class="keywordflow">case</span> PR_DEF_AXIOM: <span class="keywordflow">return</span> Z3_OP_PR_DEF_AXIOM;
<a name="l04430"></a>04430             <span class="keywordflow">case</span> PR_DEF_INTRO: <span class="keywordflow">return</span> Z3_OP_PR_DEF_INTRO; 
<a name="l04431"></a>04431             <span class="keywordflow">case</span> PR_APPLY_DEF: <span class="keywordflow">return</span> Z3_OP_PR_APPLY_DEF; 
<a name="l04432"></a>04432             <span class="keywordflow">case</span> PR_IFF_OEQ: <span class="keywordflow">return</span> Z3_OP_PR_IFF_OEQ; 
<a name="l04433"></a>04433             <span class="keywordflow">case</span> PR_NNF_POS: <span class="keywordflow">return</span> Z3_OP_PR_NNF_POS; 
<a name="l04434"></a>04434             <span class="keywordflow">case</span> PR_NNF_NEG: <span class="keywordflow">return</span> Z3_OP_PR_NNF_NEG; 
<a name="l04435"></a>04435             <span class="keywordflow">case</span> PR_NNF_STAR: <span class="keywordflow">return</span> Z3_OP_PR_NNF_STAR; 
<a name="l04436"></a>04436             <span class="keywordflow">case</span> PR_SKOLEMIZE:  <span class="keywordflow">return</span> Z3_OP_PR_SKOLEMIZE; 
<a name="l04437"></a>04437             <span class="keywordflow">case</span> PR_CNF_STAR: <span class="keywordflow">return</span> Z3_OP_PR_CNF_STAR; 
<a name="l04438"></a>04438             <span class="keywordflow">case</span> PR_MODUS_PONENS_OEQ: <span class="keywordflow">return</span> Z3_OP_PR_MODUS_PONENS_OEQ; 
<a name="l04439"></a>04439             <span class="keywordflow">case</span> PR_TH_LEMMA: <span class="keywordflow">return</span> Z3_OP_PR_TH_LEMMA; 
<a name="l04440"></a>04440 
<a name="l04441"></a>04441             <span class="keywordflow">default</span>:
<a name="l04442"></a>04442                 UNREACHABLE();
<a name="l04443"></a>04443                 <span class="keywordflow">return</span> Z3_OP_UNINTERPRETED;
<a name="l04444"></a>04444             }
<a name="l04445"></a>04445         }
<a name="l04446"></a>04446         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_arith_fid == _d-&gt;get_family_id()) {
<a name="l04447"></a>04447             <span class="keywordflow">switch</span>(_d-&gt;get_decl_kind()) {
<a name="l04448"></a>04448             <span class="keywordflow">case</span> OP_NUM: <span class="keywordflow">return</span> Z3_OP_ANUM;
<a name="l04449"></a>04449             <span class="keywordflow">case</span> OP_LE: <span class="keywordflow">return</span> Z3_OP_LE;
<a name="l04450"></a>04450             <span class="keywordflow">case</span> OP_GE: <span class="keywordflow">return</span> Z3_OP_GE;
<a name="l04451"></a>04451             <span class="keywordflow">case</span> OP_LT: <span class="keywordflow">return</span> Z3_OP_LT;
<a name="l04452"></a>04452             <span class="keywordflow">case</span> OP_GT: <span class="keywordflow">return</span> Z3_OP_GT;
<a name="l04453"></a>04453             <span class="keywordflow">case</span> OP_ADD: <span class="keywordflow">return</span> Z3_OP_ADD;
<a name="l04454"></a>04454             <span class="keywordflow">case</span> OP_SUB: <span class="keywordflow">return</span> Z3_OP_SUB;
<a name="l04455"></a>04455             <span class="keywordflow">case</span> OP_UMINUS: <span class="keywordflow">return</span> Z3_OP_UMINUS;
<a name="l04456"></a>04456             <span class="keywordflow">case</span> OP_MUL: <span class="keywordflow">return</span> Z3_OP_MUL;
<a name="l04457"></a>04457             <span class="keywordflow">case</span> OP_DIV: <span class="keywordflow">return</span> Z3_OP_DIV;
<a name="l04458"></a>04458             <span class="keywordflow">case</span> OP_IDIV: <span class="keywordflow">return</span> Z3_OP_IDIV;
<a name="l04459"></a>04459             <span class="keywordflow">case</span> OP_REM: <span class="keywordflow">return</span> Z3_OP_REM;
<a name="l04460"></a>04460             <span class="keywordflow">case</span> OP_MOD: <span class="keywordflow">return</span> Z3_OP_MOD;
<a name="l04461"></a>04461             <span class="keywordflow">case</span> OP_TO_REAL: <span class="keywordflow">return</span> Z3_OP_TO_REAL;
<a name="l04462"></a>04462             <span class="keywordflow">case</span> OP_TO_INT: <span class="keywordflow">return</span> Z3_OP_TO_INT;
<a name="l04463"></a>04463             <span class="keywordflow">case</span> OP_IS_INT: <span class="keywordflow">return</span> Z3_OP_IS_INT;
<a name="l04464"></a>04464             <span class="keywordflow">default</span>:
<a name="l04465"></a>04465                 UNREACHABLE();
<a name="l04466"></a>04466                 <span class="keywordflow">return</span> Z3_OP_UNINTERPRETED;
<a name="l04467"></a>04467             }
<a name="l04468"></a>04468         }
<a name="l04469"></a>04469         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_array_fid == _d-&gt;get_family_id()) {
<a name="l04470"></a>04470             <span class="keywordflow">switch</span>(_d-&gt;get_decl_kind()) {
<a name="l04471"></a>04471             <span class="keywordflow">case</span> OP_STORE: <span class="keywordflow">return</span> Z3_OP_STORE;
<a name="l04472"></a>04472             <span class="keywordflow">case</span> OP_SELECT: <span class="keywordflow">return</span> Z3_OP_SELECT;
<a name="l04473"></a>04473             <span class="keywordflow">case</span> OP_CONST_ARRAY: <span class="keywordflow">return</span> Z3_OP_CONST_ARRAY;
<a name="l04474"></a>04474             <span class="keywordflow">case</span> OP_ARRAY_DEFAULT: <span class="keywordflow">return</span> Z3_OP_ARRAY_DEFAULT;
<a name="l04475"></a>04475             <span class="keywordflow">case</span> OP_ARRAY_MAP: <span class="keywordflow">return</span> Z3_OP_ARRAY_MAP;
<a name="l04476"></a>04476             <span class="keywordflow">case</span> OP_SET_UNION: <span class="keywordflow">return</span> Z3_OP_SET_UNION;
<a name="l04477"></a>04477             <span class="keywordflow">case</span> OP_SET_INTERSECT: <span class="keywordflow">return</span> Z3_OP_SET_INTERSECT;
<a name="l04478"></a>04478             <span class="keywordflow">case</span> OP_SET_DIFFERENCE: <span class="keywordflow">return</span> Z3_OP_SET_DIFFERENCE;
<a name="l04479"></a>04479             <span class="keywordflow">case</span> OP_SET_COMPLEMENT: <span class="keywordflow">return</span> Z3_OP_SET_COMPLEMENT;
<a name="l04480"></a>04480             <span class="keywordflow">case</span> OP_SET_SUBSET: <span class="keywordflow">return</span> Z3_OP_SET_SUBSET;
<a name="l04481"></a>04481             <span class="keywordflow">case</span> OP_AS_ARRAY: <span class="keywordflow">return</span> Z3_OP_AS_ARRAY;
<a name="l04482"></a>04482             <span class="keywordflow">default</span>:
<a name="l04483"></a>04483                 UNREACHABLE();
<a name="l04484"></a>04484                 <span class="keywordflow">return</span> Z3_OP_UNINTERPRETED;
<a name="l04485"></a>04485             }
<a name="l04486"></a>04486         }
<a name="l04487"></a>04487 
<a name="l04488"></a>04488         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_bv_fid == _d-&gt;get_family_id()) {
<a name="l04489"></a>04489             <span class="keywordflow">switch</span>(_d-&gt;get_decl_kind()) {
<a name="l04490"></a>04490             <span class="keywordflow">case</span> OP_BV_NUM: <span class="keywordflow">return</span> Z3_OP_BNUM;
<a name="l04491"></a>04491             <span class="keywordflow">case</span> OP_BIT1: <span class="keywordflow">return</span> Z3_OP_BIT1;
<a name="l04492"></a>04492             <span class="keywordflow">case</span> OP_BIT0: <span class="keywordflow">return</span> Z3_OP_BIT0;
<a name="l04493"></a>04493             <span class="keywordflow">case</span> OP_BNEG: <span class="keywordflow">return</span> Z3_OP_BNEG;
<a name="l04494"></a>04494             <span class="keywordflow">case</span> OP_BADD: <span class="keywordflow">return</span> Z3_OP_BADD;
<a name="l04495"></a>04495             <span class="keywordflow">case</span> OP_BSUB: <span class="keywordflow">return</span> Z3_OP_BSUB;
<a name="l04496"></a>04496             <span class="keywordflow">case</span> OP_BMUL: <span class="keywordflow">return</span> Z3_OP_BMUL; 
<a name="l04497"></a>04497             <span class="keywordflow">case</span> OP_BSDIV: <span class="keywordflow">return</span> Z3_OP_BSDIV;
<a name="l04498"></a>04498             <span class="keywordflow">case</span> OP_BUDIV: <span class="keywordflow">return</span> Z3_OP_BUDIV;
<a name="l04499"></a>04499             <span class="keywordflow">case</span> OP_BSREM: <span class="keywordflow">return</span> Z3_OP_BSREM;
<a name="l04500"></a>04500             <span class="keywordflow">case</span> OP_BUREM: <span class="keywordflow">return</span> Z3_OP_BUREM;
<a name="l04501"></a>04501             <span class="keywordflow">case</span> OP_BSMOD: <span class="keywordflow">return</span> Z3_OP_BSMOD;
<a name="l04502"></a>04502             <span class="keywordflow">case</span> OP_BSDIV0: <span class="keywordflow">return</span> Z3_OP_BSDIV0;
<a name="l04503"></a>04503             <span class="keywordflow">case</span> OP_BUDIV0: <span class="keywordflow">return</span> Z3_OP_BUDIV0;
<a name="l04504"></a>04504             <span class="keywordflow">case</span> OP_BSREM0: <span class="keywordflow">return</span> Z3_OP_BUREM0;
<a name="l04505"></a>04505             <span class="keywordflow">case</span> OP_BUREM0: <span class="keywordflow">return</span> Z3_OP_BUREM0;
<a name="l04506"></a>04506             <span class="keywordflow">case</span> OP_BSMOD0: <span class="keywordflow">return</span> Z3_OP_BSMOD0;    
<a name="l04507"></a>04507             <span class="keywordflow">case</span> OP_ULEQ:   <span class="keywordflow">return</span> Z3_OP_ULEQ;
<a name="l04508"></a>04508             <span class="keywordflow">case</span> OP_SLEQ:   <span class="keywordflow">return</span> Z3_OP_SLEQ;
<a name="l04509"></a>04509             <span class="keywordflow">case</span> OP_UGEQ:   <span class="keywordflow">return</span> Z3_OP_UGEQ;
<a name="l04510"></a>04510             <span class="keywordflow">case</span> OP_SGEQ:   <span class="keywordflow">return</span> Z3_OP_SGEQ;
<a name="l04511"></a>04511             <span class="keywordflow">case</span> OP_ULT:  <span class="keywordflow">return</span> Z3_OP_ULT;
<a name="l04512"></a>04512             <span class="keywordflow">case</span> OP_SLT:  <span class="keywordflow">return</span> Z3_OP_SLT;
<a name="l04513"></a>04513             <span class="keywordflow">case</span> OP_UGT:  <span class="keywordflow">return</span> Z3_OP_UGT;
<a name="l04514"></a>04514             <span class="keywordflow">case</span> OP_SGT:  <span class="keywordflow">return</span> Z3_OP_SGT;
<a name="l04515"></a>04515             <span class="keywordflow">case</span> OP_BAND:     <span class="keywordflow">return</span> Z3_OP_BAND;
<a name="l04516"></a>04516             <span class="keywordflow">case</span> OP_BOR:      <span class="keywordflow">return</span> Z3_OP_BOR;
<a name="l04517"></a>04517             <span class="keywordflow">case</span> OP_BNOT:     <span class="keywordflow">return</span> Z3_OP_BNOT;
<a name="l04518"></a>04518             <span class="keywordflow">case</span> OP_BXOR:     <span class="keywordflow">return</span> Z3_OP_BXOR;
<a name="l04519"></a>04519             <span class="keywordflow">case</span> OP_BNAND:    <span class="keywordflow">return</span> Z3_OP_BNAND;
<a name="l04520"></a>04520             <span class="keywordflow">case</span> OP_BNOR:     <span class="keywordflow">return</span> Z3_OP_BNOR;
<a name="l04521"></a>04521             <span class="keywordflow">case</span> OP_BXNOR:    <span class="keywordflow">return</span> Z3_OP_BXNOR;
<a name="l04522"></a>04522             <span class="keywordflow">case</span> OP_CONCAT:   <span class="keywordflow">return</span> Z3_OP_CONCAT;
<a name="l04523"></a>04523             <span class="keywordflow">case</span> OP_SIGN_EXT: <span class="keywordflow">return</span> Z3_OP_SIGN_EXT;
<a name="l04524"></a>04524             <span class="keywordflow">case</span> OP_ZERO_EXT: <span class="keywordflow">return</span> Z3_OP_ZERO_EXT;
<a name="l04525"></a>04525             <span class="keywordflow">case</span> OP_EXTRACT:  <span class="keywordflow">return</span> Z3_OP_EXTRACT;
<a name="l04526"></a>04526             <span class="keywordflow">case</span> OP_REPEAT:       <span class="keywordflow">return</span> Z3_OP_REPEAT;
<a name="l04527"></a>04527             <span class="keywordflow">case</span> OP_BREDOR:       <span class="keywordflow">return</span> Z3_OP_BREDOR;
<a name="l04528"></a>04528             <span class="keywordflow">case</span> OP_BREDAND:      <span class="keywordflow">return</span> Z3_OP_BREDAND;
<a name="l04529"></a>04529             <span class="keywordflow">case</span> OP_BCOMP:        <span class="keywordflow">return</span> Z3_OP_BCOMP;
<a name="l04530"></a>04530             <span class="keywordflow">case</span> OP_BSHL:         <span class="keywordflow">return</span> Z3_OP_BSHL;
<a name="l04531"></a>04531             <span class="keywordflow">case</span> OP_BLSHR:        <span class="keywordflow">return</span> Z3_OP_BLSHR;
<a name="l04532"></a>04532             <span class="keywordflow">case</span> OP_BASHR:        <span class="keywordflow">return</span> Z3_OP_BASHR;
<a name="l04533"></a>04533             <span class="keywordflow">case</span> OP_ROTATE_LEFT:  <span class="keywordflow">return</span> Z3_OP_ROTATE_LEFT;
<a name="l04534"></a>04534             <span class="keywordflow">case</span> OP_ROTATE_RIGHT: <span class="keywordflow">return</span> Z3_OP_ROTATE_RIGHT;
<a name="l04535"></a>04535             <span class="keywordflow">case</span> OP_EXT_ROTATE_LEFT:  <span class="keywordflow">return</span> Z3_OP_EXT_ROTATE_LEFT;
<a name="l04536"></a>04536             <span class="keywordflow">case</span> OP_EXT_ROTATE_RIGHT: <span class="keywordflow">return</span> Z3_OP_EXT_ROTATE_RIGHT;
<a name="l04537"></a>04537             <span class="keywordflow">case</span> OP_INT2BV:    <span class="keywordflow">return</span> Z3_OP_INT2BV;
<a name="l04538"></a>04538             <span class="keywordflow">case</span> OP_BV2INT:    <span class="keywordflow">return</span> Z3_OP_BV2INT;
<a name="l04539"></a>04539             <span class="keywordflow">case</span> OP_CARRY:     <span class="keywordflow">return</span> Z3_OP_CARRY;
<a name="l04540"></a>04540             <span class="keywordflow">case</span> OP_XOR3:      <span class="keywordflow">return</span> Z3_OP_XOR3;
<a name="l04541"></a>04541             <span class="keywordflow">default</span>:
<a name="l04542"></a>04542                 UNREACHABLE();
<a name="l04543"></a>04543                 <span class="keywordflow">return</span> Z3_OP_UNINTERPRETED;
<a name="l04544"></a>04544             }
<a name="l04545"></a>04545         }
<a name="l04546"></a>04546         <span class="keywordflow">if</span> (mk_c(c)-&gt;datalog_get_family_id() == _d-&gt;get_family_id()) {
<a name="l04547"></a>04547             <span class="keywordflow">switch</span>(_d-&gt;get_decl_kind()) {
<a name="l04548"></a>04548             <span class="keywordflow">case</span> datalog::OP_RA_STORE: <span class="keywordflow">return</span> Z3_OP_RA_STORE;
<a name="l04549"></a>04549             <span class="keywordflow">case</span> datalog::OP_RA_EMPTY: <span class="keywordflow">return</span> Z3_OP_RA_EMPTY;
<a name="l04550"></a>04550             <span class="keywordflow">case</span> datalog::OP_RA_IS_EMPTY: <span class="keywordflow">return</span> Z3_OP_RA_IS_EMPTY;
<a name="l04551"></a>04551             <span class="keywordflow">case</span> datalog::OP_RA_JOIN: <span class="keywordflow">return</span> Z3_OP_RA_JOIN;
<a name="l04552"></a>04552             <span class="keywordflow">case</span> datalog::OP_RA_UNION: <span class="keywordflow">return</span> Z3_OP_RA_UNION;
<a name="l04553"></a>04553             <span class="keywordflow">case</span> datalog::OP_RA_WIDEN: <span class="keywordflow">return</span> Z3_OP_RA_WIDEN;
<a name="l04554"></a>04554             <span class="keywordflow">case</span> datalog::OP_RA_PROJECT: <span class="keywordflow">return</span> Z3_OP_RA_PROJECT;
<a name="l04555"></a>04555             <span class="keywordflow">case</span> datalog::OP_RA_FILTER: <span class="keywordflow">return</span> Z3_OP_RA_FILTER;
<a name="l04556"></a>04556             <span class="keywordflow">case</span> datalog::OP_RA_NEGATION_FILTER: <span class="keywordflow">return</span> Z3_OP_RA_NEGATION_FILTER;
<a name="l04557"></a>04557             <span class="keywordflow">case</span> datalog::OP_RA_RENAME: <span class="keywordflow">return</span> Z3_OP_RA_RENAME;
<a name="l04558"></a>04558             <span class="keywordflow">case</span> datalog::OP_RA_COMPLEMENT: <span class="keywordflow">return</span> Z3_OP_RA_COMPLEMENT;
<a name="l04559"></a>04559             <span class="keywordflow">case</span> datalog::OP_RA_SELECT: <span class="keywordflow">return</span> Z3_OP_RA_SELECT;
<a name="l04560"></a>04560             <span class="keywordflow">case</span> datalog::OP_RA_CLONE:  <span class="keywordflow">return</span> Z3_OP_RA_CLONE;
<a name="l04561"></a>04561             <span class="keywordflow">case</span> datalog::OP_DL_LT: <span class="keywordflow">return</span> Z3_OP_FD_LT;
<a name="l04562"></a>04562             <span class="keywordflow">default</span>:
<a name="l04563"></a>04563                 UNREACHABLE();
<a name="l04564"></a>04564                 <span class="keywordflow">return</span> Z3_OP_UNINTERPRETED;
<a name="l04565"></a>04565             }
<a name="l04566"></a>04566         }
<a name="l04567"></a>04567 
<a name="l04568"></a>04568         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_manager.get_label_family_id() == _d-&gt;get_family_id()) {
<a name="l04569"></a>04569             <span class="keywordflow">switch</span>(_d-&gt;get_decl_kind()) {
<a name="l04570"></a>04570             <span class="keywordflow">case</span> OP_LABEL: <span class="keywordflow">return</span> Z3_OP_LABEL;
<a name="l04571"></a>04571             <span class="keywordflow">case</span> OP_LABEL_LIT: <span class="keywordflow">return</span> Z3_OP_LABEL_LIT;
<a name="l04572"></a>04572             <span class="keywordflow">default</span>:
<a name="l04573"></a>04573                 UNREACHABLE();
<a name="l04574"></a>04574                 <span class="keywordflow">return</span> Z3_OP_UNINTERPRETED;                
<a name="l04575"></a>04575             }
<a name="l04576"></a>04576         }
<a name="l04577"></a>04577 
<a name="l04578"></a>04578         <span class="keywordflow">return</span> Z3_OP_UNINTERPRETED;                
<a name="l04579"></a>04579     }
<a name="l04580"></a>04580 
<a name="l04581"></a><a class="code" href="group__capi.html#gaba865ef17f1692ab14dbd304987db411">04581</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#gaba865ef17f1692ab14dbd304987db411" title="Return index of de-Brujin bound variable.">Z3_get_index_value</a>(__in Z3_context c, __in Z3_ast a) {
<a name="l04582"></a>04582         LOG_Z3_get_index_value(c, a);
<a name="l04583"></a>04583         RESET_ERROR_CODE();
<a name="l04584"></a>04584         ast* _a = <span class="keyword">reinterpret_cast&lt;</span>ast*<span class="keyword">&gt;</span>(a);
<a name="l04585"></a>04585         <span class="keywordflow">if</span> (!_a || _a-&gt;get_kind() != AST_VAR) {
<a name="l04586"></a>04586             SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l04587"></a>04587             <span class="keywordflow">return</span> 0;            
<a name="l04588"></a>04588         }
<a name="l04589"></a>04589         var* va = to_var(_a);
<a name="l04590"></a>04590         <span class="keywordflow">if</span> (va) {
<a name="l04591"></a>04591             <span class="keywordflow">return</span> va-&gt;get_idx();
<a name="l04592"></a>04592         }
<a name="l04593"></a>04593         SET_ERROR_CODE(Z3_INVALID_ARG);
<a name="l04594"></a>04594         <span class="keywordflow">return</span> 0;        
<a name="l04595"></a>04595     }
<a name="l04596"></a>04596 
<a name="l04597"></a>04597 
<a name="l04598"></a><a class="code" href="group__capi.html#ga47f5d660c3ce6361f9d80d5d5100be01">04598</a>     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#ga47f5d660c3ce6361f9d80d5d5100be01" title="Determine if quantifier is universal.">Z3_is_quantifier_forall</a>(__in Z3_context c, __in Z3_ast a) {
<a name="l04599"></a>04599         LOG_Z3_is_quantifier_forall(c, a);
<a name="l04600"></a>04600         RESET_ERROR_CODE();
<a name="l04601"></a>04601         ast * _a = to_ast(a);
<a name="l04602"></a>04602         <span class="keywordflow">if</span> (_a-&gt;get_kind() == AST_QUANTIFIER) {
<a name="l04603"></a>04603             <span class="keywordflow">return</span> to_quantifier(_a)-&gt;is_forall();
<a name="l04604"></a>04604         }
<a name="l04605"></a>04605         <span class="keywordflow">else</span> {
<a name="l04606"></a>04606             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04607"></a>04607             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l04608"></a>04608         }
<a name="l04609"></a>04609     }
<a name="l04610"></a>04610 
<a name="l04611"></a><a class="code" href="group__capi.html#gae36ba5c269ac3ecc77ffedb7f8b54649">04611</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#gae36ba5c269ac3ecc77ffedb7f8b54649" title="Obtain weight of quantifier.">Z3_get_quantifier_weight</a>(__in Z3_context c, __in Z3_ast a) {
<a name="l04612"></a>04612         LOG_Z3_get_quantifier_weight(c, a);
<a name="l04613"></a>04613         RESET_ERROR_CODE();
<a name="l04614"></a>04614         ast * _a = to_ast(a);
<a name="l04615"></a>04615         <span class="keywordflow">if</span> (_a-&gt;get_kind() == AST_QUANTIFIER) {
<a name="l04616"></a>04616             <span class="keywordflow">return</span> to_quantifier(_a)-&gt;get_weight();
<a name="l04617"></a>04617         }
<a name="l04618"></a>04618         <span class="keywordflow">else</span> {
<a name="l04619"></a>04619             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04620"></a>04620             <span class="keywordflow">return</span> 0;
<a name="l04621"></a>04621         }
<a name="l04622"></a>04622     }
<a name="l04623"></a>04623 
<a name="l04624"></a><a class="code" href="group__capi.html#ga1f9f624a1f8963a207a2c3cf7ab09363">04624</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga1f9f624a1f8963a207a2c3cf7ab09363" title="Return number of patterns used in quantifier.">Z3_get_quantifier_num_patterns</a>(__in Z3_context c, __in Z3_ast a) {
<a name="l04625"></a>04625         LOG_Z3_get_quantifier_num_patterns(c, a);
<a name="l04626"></a>04626         RESET_ERROR_CODE();
<a name="l04627"></a>04627         ast * _a = to_ast(a);
<a name="l04628"></a>04628         <span class="keywordflow">if</span> (_a-&gt;get_kind() == AST_QUANTIFIER) {
<a name="l04629"></a>04629             <span class="keywordflow">return</span> to_quantifier(_a)-&gt;get_num_patterns();
<a name="l04630"></a>04630         }
<a name="l04631"></a>04631         <span class="keywordflow">else</span> {
<a name="l04632"></a>04632             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04633"></a>04633             <span class="keywordflow">return</span> 0;
<a name="l04634"></a>04634         }
<a name="l04635"></a>04635     }
<a name="l04636"></a>04636 
<a name="l04637"></a><a class="code" href="group__capi.html#gaa5e209275d866057c2c79e20891d3696">04637</a>     Z3_pattern Z3_API <a class="code" href="group__capi.html#gaa5e209275d866057c2c79e20891d3696" title="Return i&amp;#39;th pattern.">Z3_get_quantifier_pattern_ast</a>(__in Z3_context c, __in Z3_ast a, <span class="keywordtype">unsigned</span> i) {
<a name="l04638"></a>04638         LOG_Z3_get_quantifier_pattern_ast(c, a, i);
<a name="l04639"></a>04639         RESET_ERROR_CODE();
<a name="l04640"></a>04640         ast * _a = to_ast(a);
<a name="l04641"></a>04641         <span class="keywordflow">if</span> (_a-&gt;get_kind() == AST_QUANTIFIER) {
<a name="l04642"></a>04642             Z3_pattern r = of_pattern(to_quantifier(_a)-&gt;get_patterns()[i]);
<a name="l04643"></a>04643             RETURN_Z3(r);
<a name="l04644"></a>04644         }
<a name="l04645"></a>04645         <span class="keywordflow">else</span> {
<a name="l04646"></a>04646             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04647"></a>04647             RETURN_Z3(0);
<a name="l04648"></a>04648         }
<a name="l04649"></a>04649     }
<a name="l04650"></a>04650 
<a name="l04651"></a>04651 
<a name="l04652"></a><a class="code" href="group__capi.html#ga855e54e6d6d304fa4b42d39eb5990eb8">04652</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga855e54e6d6d304fa4b42d39eb5990eb8" title="Return number of no_patterns used in quantifier.">Z3_get_quantifier_num_no_patterns</a>(__in Z3_context c, __in Z3_ast a) {
<a name="l04653"></a>04653         LOG_Z3_get_quantifier_num_no_patterns(c, a);
<a name="l04654"></a>04654         RESET_ERROR_CODE();
<a name="l04655"></a>04655         ast * _a = to_ast(a);
<a name="l04656"></a>04656         <span class="keywordflow">if</span> (_a-&gt;get_kind() == AST_QUANTIFIER) {
<a name="l04657"></a>04657             <span class="keywordflow">return</span> to_quantifier(_a)-&gt;get_num_no_patterns();
<a name="l04658"></a>04658         }
<a name="l04659"></a>04659         <span class="keywordflow">else</span> {
<a name="l04660"></a>04660             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04661"></a>04661             <span class="keywordflow">return</span> 0;
<a name="l04662"></a>04662         }
<a name="l04663"></a>04663     }
<a name="l04664"></a>04664 
<a name="l04665"></a><a class="code" href="group__capi.html#ga5bb0d2cbe24ba06f15c2cf849e461666">04665</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga5bb0d2cbe24ba06f15c2cf849e461666" title="Return i&amp;#39;th no_pattern.">Z3_get_quantifier_no_pattern_ast</a>(__in Z3_context c, __in Z3_ast a, <span class="keywordtype">unsigned</span> i) {
<a name="l04666"></a>04666         LOG_Z3_get_quantifier_no_pattern_ast(c, a, i);
<a name="l04667"></a>04667         RESET_ERROR_CODE();
<a name="l04668"></a>04668         ast * _a = to_ast(a);
<a name="l04669"></a>04669         <span class="keywordflow">if</span> (_a-&gt;get_kind() == AST_QUANTIFIER) {
<a name="l04670"></a>04670             Z3_ast r = of_ast(to_quantifier(_a)-&gt;get_no_pattern(i));
<a name="l04671"></a>04671             RETURN_Z3(r);
<a name="l04672"></a>04672         }
<a name="l04673"></a>04673         <span class="keywordflow">else</span> {
<a name="l04674"></a>04674             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04675"></a>04675             RETURN_Z3(0);
<a name="l04676"></a>04676         }
<a name="l04677"></a>04677     }
<a name="l04678"></a>04678 
<a name="l04679"></a><a class="code" href="group__capi.html#gab554587e623297f7d953b030d71d08a6">04679</a>     Z3_symbol Z3_API <a class="code" href="group__capi.html#gab554587e623297f7d953b030d71d08a6" title="Return symbol of the i&amp;#39;th bound variable.">Z3_get_quantifier_bound_name</a>(__in Z3_context c, __in Z3_ast a, <span class="keywordtype">unsigned</span> i) {
<a name="l04680"></a>04680         LOG_Z3_get_quantifier_bound_name(c, a, i);
<a name="l04681"></a>04681         RESET_ERROR_CODE();
<a name="l04682"></a>04682         ast * _a = to_ast(a);
<a name="l04683"></a>04683         <span class="keywordflow">if</span> (_a-&gt;get_kind() == AST_QUANTIFIER) {
<a name="l04684"></a>04684             <span class="keywordflow">return</span> of_symbol(to_quantifier(_a)-&gt;get_decl_names()[i]);
<a name="l04685"></a>04685         }
<a name="l04686"></a>04686         <span class="keywordflow">else</span> {
<a name="l04687"></a>04687             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04688"></a>04688             <span class="keywordflow">return</span> 0;
<a name="l04689"></a>04689         }
<a name="l04690"></a>04690     }
<a name="l04691"></a>04691 
<a name="l04692"></a><a class="code" href="group__capi.html#gad699ea4859fb0f05a5277c75be0d3d1a">04692</a>     Z3_sort Z3_API <a class="code" href="group__capi.html#gad699ea4859fb0f05a5277c75be0d3d1a" title="Return sort of the i&amp;#39;th bound variable.">Z3_get_quantifier_bound_sort</a>(__in Z3_context c, __in Z3_ast a, <span class="keywordtype">unsigned</span> i) {
<a name="l04693"></a>04693         LOG_Z3_get_quantifier_bound_sort(c, a, i);
<a name="l04694"></a>04694         RESET_ERROR_CODE();
<a name="l04695"></a>04695         ast * _a = to_ast(a);
<a name="l04696"></a>04696         <span class="keywordflow">if</span> (_a-&gt;get_kind() == AST_QUANTIFIER) {
<a name="l04697"></a>04697             Z3_sort r = of_sort(to_quantifier(_a)-&gt;get_decl_sort(i));
<a name="l04698"></a>04698             RETURN_Z3(r);
<a name="l04699"></a>04699         }
<a name="l04700"></a>04700         <span class="keywordflow">else</span> {
<a name="l04701"></a>04701             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04702"></a>04702             RETURN_Z3(0);
<a name="l04703"></a>04703         }
<a name="l04704"></a>04704     }
<a name="l04705"></a>04705 
<a name="l04706"></a><a class="code" href="group__capi.html#ga587bbc8419bdb327dd2c9e83a75480b0">04706</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga587bbc8419bdb327dd2c9e83a75480b0" title="Return body of quantifier.">Z3_get_quantifier_body</a>(__in Z3_context c, __in Z3_ast a) {
<a name="l04707"></a>04707         LOG_Z3_get_quantifier_body(c, a);
<a name="l04708"></a>04708         RESET_ERROR_CODE();
<a name="l04709"></a>04709         ast * _a = to_ast(a);
<a name="l04710"></a>04710         <span class="keywordflow">if</span> (_a-&gt;get_kind() == AST_QUANTIFIER) {
<a name="l04711"></a>04711             Z3_ast r = of_ast(to_quantifier(_a)-&gt;get_expr());
<a name="l04712"></a>04712             RETURN_Z3(r);
<a name="l04713"></a>04713         }
<a name="l04714"></a>04714         <span class="keywordflow">else</span> {
<a name="l04715"></a>04715             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04716"></a>04716             RETURN_Z3(0);
<a name="l04717"></a>04717         }
<a name="l04718"></a>04718     }
<a name="l04719"></a>04719 
<a name="l04720"></a><a class="code" href="group__capi.html#gaf70b1b38d3ded4b1c5d2c25ffd1dc73f">04720</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#gaf70b1b38d3ded4b1c5d2c25ffd1dc73f" title="Return number of bound variables of quantifier.">Z3_get_quantifier_num_bound</a>(__in Z3_context c, __in Z3_ast a) {
<a name="l04721"></a>04721         LOG_Z3_get_quantifier_num_bound(c, a);
<a name="l04722"></a>04722         RESET_ERROR_CODE();
<a name="l04723"></a>04723         ast * _a = to_ast(a);
<a name="l04724"></a>04724         <span class="keywordflow">if</span> (_a-&gt;get_kind() == AST_QUANTIFIER) {
<a name="l04725"></a>04725 
<a name="l04726"></a>04726             <span class="keywordflow">return</span> to_quantifier(_a)-&gt;get_num_decls();
<a name="l04727"></a>04727         }
<a name="l04728"></a>04728         <span class="keywordflow">else</span> {
<a name="l04729"></a>04729             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04730"></a>04730             <span class="keywordflow">return</span> 0;
<a name="l04731"></a>04731         }        
<a name="l04732"></a>04732     }
<a name="l04733"></a>04733 
<a name="l04734"></a><a class="code" href="group__capi.html#ga203297c7c1c08cfcd101fa7ea0d4644f">04734</a>     <span class="keywordtype">unsigned</span> Z3_API <a class="code" href="group__capi.html#ga203297c7c1c08cfcd101fa7ea0d4644f" title="Return number of terms in pattern.">Z3_get_pattern_num_terms</a>(__in Z3_context c, __in Z3_pattern p) {
<a name="l04735"></a>04735         LOG_Z3_get_pattern_num_terms(c, p);
<a name="l04736"></a>04736         RESET_ERROR_CODE();
<a name="l04737"></a>04737         app* _p = to_pattern(p);
<a name="l04738"></a>04738         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_manager.is_pattern(_p)) {
<a name="l04739"></a>04739             <span class="keywordflow">return</span> _p-&gt;get_num_args();
<a name="l04740"></a>04740         }
<a name="l04741"></a>04741         <span class="keywordflow">else</span> {
<a name="l04742"></a>04742             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04743"></a>04743             <span class="keywordflow">return</span> 0;            
<a name="l04744"></a>04744         }
<a name="l04745"></a>04745     }
<a name="l04746"></a>04746 
<a name="l04747"></a><a class="code" href="group__capi.html#ga8a23c0c656ee4db11b2f44c2ccb2fb5b">04747</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga8a23c0c656ee4db11b2f44c2ccb2fb5b" title="Return i&amp;#39;th ast in pattern.">Z3_get_pattern</a>(__in Z3_context c, __in Z3_pattern p, __in <span class="keywordtype">unsigned</span> idx) {
<a name="l04748"></a>04748         LOG_Z3_get_pattern(c, p, idx);
<a name="l04749"></a>04749         RESET_ERROR_CODE();
<a name="l04750"></a>04750         app* _p = to_pattern(p);
<a name="l04751"></a>04751         <span class="keywordflow">if</span> (mk_c(c)-&gt;m_manager.is_pattern(_p)) {
<a name="l04752"></a>04752             Z3_ast r = of_ast(_p-&gt;get_arg(idx));
<a name="l04753"></a>04753             RETURN_Z3(r);
<a name="l04754"></a>04754         }
<a name="l04755"></a>04755         <span class="keywordflow">else</span> {
<a name="l04756"></a>04756             SET_ERROR_CODE(Z3_SORT_ERROR);
<a name="l04757"></a>04757             RETURN_Z3(0);
<a name="l04758"></a>04758         }
<a name="l04759"></a>04759     }
<a name="l04760"></a>04760 
<a name="l04761"></a>04761 
<a name="l04762"></a><a class="code" href="group__capi.html#ga660933fbbc1cd0dce85680d532fb56e0">04762</a>     <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> Z3_API <a class="code" href="group__capi.html#ga660933fbbc1cd0dce85680d532fb56e0" title="Return runtime statistics as a string.">Z3_statistics_to_string</a>(__in Z3_context c) {
<a name="l04763"></a>04763         LOG_Z3_statistics_to_string(c);
<a name="l04764"></a>04764         RESET_ERROR_CODE();
<a name="l04765"></a>04765         std::ostringstream buffer;
<a name="l04766"></a>04766         mk_c(c)-&gt;get_context().display_statistics(buffer);
<a name="l04767"></a>04767         memory::display_max_usage(buffer);
<a name="l04768"></a>04768         mk_c(c)-&gt;m_statistics_to_string_buffer = buffer.str();
<a name="l04769"></a>04769         <span class="keywordflow">return</span> mk_c(c)-&gt;m_statistics_to_string_buffer.c_str();
<a name="l04770"></a>04770 
<a name="l04771"></a>04771     }
<a name="l04772"></a>04772 
<a name="l04773"></a><a class="code" href="group__capi.html#ga84ea6f0c32b99c70033feaa8f00e8f2d">04773</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga84ea6f0c32b99c70033feaa8f00e8f2d" title="Create the constant array.">Z3_mk_const_array</a>(__in Z3_context c, __in Z3_sort domain, __in Z3_ast v) {
<a name="l04774"></a>04774         LOG_Z3_mk_const_array(c, domain, v);
<a name="l04775"></a>04775         RESET_ERROR_CODE(); 
<a name="l04776"></a>04776         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l04777"></a>04777         expr * _v        = to_expr(v);
<a name="l04778"></a>04778         sort * _range = m.get_sort(_v);
<a name="l04779"></a>04779         sort * _domain = to_sort(domain);
<a name="l04780"></a>04780         parameter params[2]  = { parameter(_domain), parameter(_range) };
<a name="l04781"></a>04781         sort * a_ty    = mk_c(c)-&gt;m_manager.mk_sort(mk_c(c)-&gt;m_array_fid, ARRAY_SORT, 2, params);
<a name="l04782"></a>04782         parameter param(a_ty);
<a name="l04783"></a>04783 
<a name="l04784"></a>04784         func_decl* cd   = m.mk_func_decl(mk_c(c)-&gt;m_array_fid, OP_CONST_ARRAY, 1, &amp;param, 1, &amp;_range);
<a name="l04785"></a>04785         app * r        = m.mk_app(cd, 1, &amp;_v);
<a name="l04786"></a>04786         mk_c(c)-&gt;save_ast_trail(r);
<a name="l04787"></a>04787         check_sorts(c, r);
<a name="l04788"></a>04788         RETURN_Z3(of_ast(r));        
<a name="l04789"></a>04789     }
<a name="l04790"></a>04790 
<a name="l04791"></a><a class="code" href="group__capi.html#ga78e89cca82f0ab4d5f4e662e5e5fba7d">04791</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga78e89cca82f0ab4d5f4e662e5e5fba7d" title="Access the array default value. Produces the default range value, for arrays that...">Z3_mk_array_default</a>(__in Z3_context c, __in Z3_ast array) {
<a name="l04792"></a>04792         LOG_Z3_mk_array_default(c, array);
<a name="l04793"></a>04793         RESET_ERROR_CODE(); 
<a name="l04794"></a>04794         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l04795"></a>04795         expr * _a        = to_expr(array);
<a name="l04796"></a>04796 
<a name="l04797"></a>04797         func_decl * f   = m.mk_func_decl(mk_c(c)-&gt;m_array_fid, OP_ARRAY_DEFAULT, 0, 0, 1, &amp;_a);
<a name="l04798"></a>04798         app * r        = m.mk_app(f, 1, &amp;_a);
<a name="l04799"></a>04799         mk_c(c)-&gt;save_ast_trail(r);
<a name="l04800"></a>04800         check_sorts(c, r);
<a name="l04801"></a>04801         RETURN_Z3(of_ast(r));        
<a name="l04802"></a>04802     }
<a name="l04803"></a>04803 
<a name="l04804"></a>04804     Z3_ast mk_app_array_core(__in Z3_context c, __in Z3_sort domain, __in Z3_ast v) {
<a name="l04805"></a>04805         RESET_ERROR_CODE();   
<a name="l04806"></a>04806         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l04807"></a>04807         expr * _v        = to_expr(v);
<a name="l04808"></a>04808         sort * _range = m.get_sort(_v);
<a name="l04809"></a>04809         sort * _domain = to_sort(domain);
<a name="l04810"></a>04810         parameter params[2]  = { parameter(_domain), parameter(_range) };
<a name="l04811"></a>04811         sort * a_ty    = mk_c(c)-&gt;m_manager.mk_sort(mk_c(c)-&gt;m_array_fid, ARRAY_SORT, 2, params);
<a name="l04812"></a>04812         parameter param(a_ty);
<a name="l04813"></a>04813         func_decl * cd   = m.mk_func_decl(mk_c(c)-&gt;m_array_fid, OP_CONST_ARRAY, 1, &amp;param, 1, &amp;_range);
<a name="l04814"></a>04814         app * r        = m.mk_app(cd, 1, &amp;_v);
<a name="l04815"></a>04815         mk_c(c)-&gt;save_ast_trail(r);
<a name="l04816"></a>04816         check_sorts(c, r);
<a name="l04817"></a>04817         <span class="keywordflow">return</span> of_ast(r);
<a name="l04818"></a>04818     }
<a name="l04819"></a>04819 
<a name="l04820"></a><a class="code" href="group__capi.html#ga6865879523e7e882d7e50a2d8445ac8b">04820</a>     Z3_sort Z3_API <a class="code" href="group__capi.html#ga6865879523e7e882d7e50a2d8445ac8b" title="Create Set type.">Z3_mk_set_sort</a>(__in Z3_context c, __in Z3_sort ty) {
<a name="l04821"></a>04821         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gafe617994cce1b516f46128e448c84445" title="Create an array type.">Z3_mk_array_sort</a>(c, ty, <a class="code" href="group__capi.html#gacdc73510b69a010b71793d429015f342" title="Create the Boolean type.">Z3_mk_bool_sort</a>(c));
<a name="l04822"></a>04822     }
<a name="l04823"></a>04823 
<a name="l04824"></a><a class="code" href="group__capi.html#ga358b6b80509a567148f1c0ca9252118c">04824</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga358b6b80509a567148f1c0ca9252118c" title="Create the empty set.">Z3_mk_empty_set</a>(__in Z3_context c, __in Z3_sort domain) {
<a name="l04825"></a>04825         LOG_Z3_mk_empty_set(c, domain);
<a name="l04826"></a>04826         Z3_ast r = mk_app_array_core(c, domain, <a class="code" href="group__capi.html#ga5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(c));
<a name="l04827"></a>04827         RETURN_Z3(r);
<a name="l04828"></a>04828     }
<a name="l04829"></a>04829 
<a name="l04830"></a><a class="code" href="group__capi.html#ga5e92662c657374f7332aa32ce4503dd2">04830</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga5e92662c657374f7332aa32ce4503dd2" title="Create the full set.">Z3_mk_full_set</a>(__in Z3_context c, __in Z3_sort domain) {
<a name="l04831"></a>04831         LOG_Z3_mk_full_set(c, domain);
<a name="l04832"></a>04832         Z3_ast r = mk_app_array_core(c, domain, <a class="code" href="group__capi.html#gae898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(c));
<a name="l04833"></a>04833         RETURN_Z3(r);  
<a name="l04834"></a>04834     }
<a name="l04835"></a>04835 
<a name="l04836"></a>04836     MK_NARY(<a class="code" href="group__capi.html#ga4050162a13d539b8913200963bb4743c" title="Take the union of a list of sets.">Z3_mk_set_union</a>, mk_c(c)-&gt;m_array_fid, OP_SET_UNION, SKIP);
<a name="l04837"></a>04837     MK_NARY(<a class="code" href="group__capi.html#ga8a8abff0ebe6aeeaa6c919eaa013049d" title="Take the intersection of a list of sets.">Z3_mk_set_intersect</a>, mk_c(c)-&gt;m_array_fid, OP_SET_INTERSECT, SKIP);
<a name="l04838"></a>04838     MK_BINARY(<a class="code" href="group__capi.html#gabb49c62f70b8198362e1a29ba6d8bde1" title="Take the set difference between two sets.">Z3_mk_set_difference</a>, mk_c(c)-&gt;m_array_fid, OP_SET_DIFFERENCE, SKIP);
<a name="l04839"></a>04839     MK_UNARY(<a class="code" href="group__capi.html#ga5c57143c9229cdf730c5103ff696590f" title="Take the complement of a set.">Z3_mk_set_complement</a>, mk_c(c)-&gt;m_array_fid, OP_SET_COMPLEMENT, SKIP);
<a name="l04840"></a>04840     MK_BINARY(<a class="code" href="group__capi.html#ga139c5803af0e86464adc7cedc53e7f3a" title="Check for subsetness of sets.">Z3_mk_set_subset</a>, mk_c(c)-&gt;m_array_fid, OP_SET_SUBSET, SKIP);
<a name="l04841"></a>04841     
<a name="l04842"></a><a class="code" href="group__capi.html#gac6e516f3dce0bdd41095c6d6daf56063">04842</a>     Z3_ast <a class="code" href="group__capi.html#gac6e516f3dce0bdd41095c6d6daf56063" title="Check for set membership.">Z3_mk_set_member</a>(__in Z3_context c, __in Z3_ast elem, __in Z3_ast <span class="keyword">set</span>) {
<a name="l04843"></a>04843         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga38f423f3683379e7f597a7fe59eccb67" title="Array read. The argument a is the array and i is the index of the array that gets...">Z3_mk_select</a>(c, <span class="keyword">set</span>, elem);
<a name="l04844"></a>04844     }
<a name="l04845"></a>04845 
<a name="l04846"></a><a class="code" href="group__capi.html#ga856c3d0e28ce720f53912c2bbdd76175">04846</a>     Z3_ast <a class="code" href="group__capi.html#ga856c3d0e28ce720f53912c2bbdd76175" title="Add an element to a set.">Z3_mk_set_add</a>(__in Z3_context c, __in Z3_ast <span class="keyword">set</span>, __in Z3_ast elem) {
<a name="l04847"></a>04847         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gae305a4f54b4a64f7e5973ae6ccb13593" title="Array update.">Z3_mk_store</a>(c, <span class="keyword">set</span>, elem, <a class="code" href="group__capi.html#gae898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(c));
<a name="l04848"></a>04848     }
<a name="l04849"></a>04849 
<a name="l04850"></a><a class="code" href="group__capi.html#ga80e883f39dd3b88f9d0745c8a5b91d1d">04850</a>     Z3_ast <a class="code" href="group__capi.html#ga80e883f39dd3b88f9d0745c8a5b91d1d" title="Remove an element to a set.">Z3_mk_set_del</a>(__in Z3_context c, __in Z3_ast <span class="keyword">set</span>, __in Z3_ast elem) {
<a name="l04851"></a>04851         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gae305a4f54b4a64f7e5973ae6ccb13593" title="Array update.">Z3_mk_store</a>(c, <span class="keyword">set</span>, elem, <a class="code" href="group__capi.html#ga5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(c));
<a name="l04852"></a>04852     }
<a name="l04853"></a>04853 
<a name="l04854"></a><a class="code" href="group__capi.html#ga6d4773731412be814daa64040480b2f0">04854</a>     Z3_func_decl Z3_API <a class="code" href="group__capi.html#ga6d4773731412be814daa64040480b2f0" title="Create injective function declaration.">Z3_mk_injective_function</a>(__in Z3_context c, 
<a name="l04855"></a>04855                                                  __in Z3_symbol s, 
<a name="l04856"></a>04856                                                  <span class="keywordtype">unsigned</span> domain_size, 
<a name="l04857"></a>04857                                                  __in_ecount(domain_size) Z3_sort <span class="keyword">const</span> domain[],
<a name="l04858"></a>04858                                                  __in Z3_sort range) {
<a name="l04859"></a>04859         LOG_Z3_mk_injective_function(c, s, domain_size, domain, range);
<a name="l04860"></a>04860         RESET_ERROR_CODE(); 
<a name="l04861"></a>04861         ast_manager &amp; m = mk_c(c)-&gt;m_manager;
<a name="l04862"></a>04862         mk_c(c)-&gt;reset_last_result();
<a name="l04863"></a>04863         sort* range_ = to_sort(range);
<a name="l04864"></a>04864         func_decl* d = m.mk_func_decl(to_symbol(s), domain_size, to_sorts(domain), range_);
<a name="l04865"></a>04865         expr_ref_vector args(m);
<a name="l04866"></a>04866         expr_ref fn(m), body(m);
<a name="l04867"></a>04867         vector&lt;symbol&gt; names;
<a name="l04868"></a>04868         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; domain_size; ++i) {
<a name="l04869"></a>04869             <span class="keywordtype">unsigned</span> idx = domain_size-i-1;
<a name="l04870"></a>04870             args.push_back(m.mk_var(idx, to_sort(domain[i])));
<a name="l04871"></a>04871             names.push_back(symbol(idx));
<a name="l04872"></a>04872         }
<a name="l04873"></a>04873         fn = m.mk_app(d, args.size(), args.c_ptr());
<a name="l04874"></a>04874 
<a name="l04875"></a>04875         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; domain_size; ++i) {
<a name="l04876"></a>04876             expr* arg = args[i].get();
<a name="l04877"></a>04877             sort* dom = m.get_sort(arg);
<a name="l04878"></a>04878             func_decl* inv = m.mk_fresh_func_decl(symbol(<span class="stringliteral">&quot;inv&quot;</span>), to_symbol(s), 1, &amp;range_, dom);
<a name="l04879"></a>04879             body = m.mk_eq(m.mk_app(inv, fn.get()), arg);
<a name="l04880"></a>04880             body = m.mk_forall(args.size(), to_sorts(domain), names.c_ptr(), body.get());
<a name="l04881"></a>04881             mk_c(c)-&gt;save_multiple_ast_trail(body.get());
<a name="l04882"></a>04882             mk_c(c)-&gt;assert_cnstr(body.get());
<a name="l04883"></a>04883         }
<a name="l04884"></a>04884         mk_c(c)-&gt;save_multiple_ast_trail(d);       
<a name="l04885"></a>04885         RETURN_Z3(of_func_decl(d));
<a name="l04886"></a>04886     }
<a name="l04887"></a>04887 
<a name="l04888"></a>04888     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> Z3_API <a class="code" href="group__capi.html#gaccd71300e77d3ffe666e266a650661fa" title="Log interaction to a file.">Z3_open_log</a>(__in <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> filename) {
<a name="l04889"></a>04889         <span class="keywordflow">if</span> (g_z3_log != 0)
<a name="l04890"></a>04890             <a class="code" href="group__capi.html#ga75e8f574662250cf508984af0681ecfd" title="Close interaction log.">Z3_close_log</a>();
<a name="l04891"></a>04891         g_z3_log = alloc(std::ofstream, filename);
<a name="l04892"></a>04892         g_z3_log_enabled = <span class="keyword">true</span>;
<a name="l04893"></a>04893         <span class="keywordflow">if</span> (g_z3_log-&gt;bad() || g_z3_log-&gt;fail()) {
<a name="l04894"></a>04894             dealloc(g_z3_log);
<a name="l04895"></a>04895             g_z3_log = 0;
<a name="l04896"></a>04896             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#ga1d9cee57472b2c7623642f123b8f1781" title="False value. It is just an alias for 0.">Z3_FALSE</a>;
<a name="l04897"></a>04897         }
<a name="l04898"></a>04898         <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>;
<a name="l04899"></a>04899     }
<a name="l04900"></a>04900 
<a name="l04901"></a>04901     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga6501136a90fdba515b0b46e8b1aed33e" title="Append user-defined string to interaction log.">Z3_append_log</a>(__in <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> str) {
<a name="l04902"></a>04902         <span class="keywordflow">if</span> (g_z3_log == 0)
<a name="l04903"></a>04903             <span class="keywordflow">return</span>;
<a name="l04904"></a>04904         _Z3_append_log(static_cast&lt;char const *&gt;(str));
<a name="l04905"></a>04905     }
<a name="l04906"></a>04906 
<a name="l04907"></a><a class="code" href="group__capi.html#ga75e8f574662250cf508984af0681ecfd">04907</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga75e8f574662250cf508984af0681ecfd" title="Close interaction log.">Z3_close_log</a>() {
<a name="l04908"></a>04908         <span class="keywordflow">if</span> (g_z3_log != 0) {
<a name="l04909"></a>04909             dealloc(g_z3_log);
<a name="l04910"></a>04910             g_z3_log_enabled = <span class="keyword">false</span>;
<a name="l04911"></a>04911             g_z3_log = 0;
<a name="l04912"></a>04912         }
<a name="l04913"></a>04913     }
<a name="l04914"></a>04914 
<a name="l04916"></a>04916     <span class="comment">// Registering user-supplied simplifier. </span>
<a name="l04917"></a>04917     <span class="comment">// No support for logging</span>
<a name="l04918"></a>04918 
<a name="l04919"></a><a class="code" href="group__capi.html#gafe69008f019881eb5aa63293a8564141">04919</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#gafe69008f019881eb5aa63293a8564141" title="Register a user-supplied simplification function. The simplifier gets invoked during...">Z3_set_simplifier_callback</a>(__in Z3_context c, __in <span class="keywordtype">void</span>* user_context, __in Z3_simplify_ast_fn* simplifier) {
<a name="l04920"></a>04920         NOT_IMPLEMENTED_YET();
<a name="l04921"></a>04921 <span class="preprocessor">#if 0</span>
<a name="l04922"></a>04922 <span class="preprocessor"></span>        <span class="comment">// TODO: put it back</span>
<a name="l04923"></a>04923         mk_c(c)-&gt;get_context().set_user_rewriter(user_context, reinterpret_cast&lt;user_rewriter::fn*&gt;(simplifier));
<a name="l04924"></a>04924 <span class="preprocessor">#endif</span>
<a name="l04925"></a>04925 <span class="preprocessor"></span>    }
<a name="l04926"></a>04926 
<a name="l04927"></a>04927 
<a name="l04929"></a>04929     <span class="comment">// Theory plugin</span>
<a name="l04930"></a>04930     <span class="comment">// No support for logging</span>
<a name="l04931"></a>04931 
<a name="l04932"></a>04932     Z3_theory <a class="code" href="group__capi.html#gaa370f8baf213e3ef13c27056e22cd08e" title="Create a new user defined theory. The new theory will be identified by the name th_name...">Z3_mk_theory</a>(__in Z3_context c, __in_z <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> th_name, __in <span class="keywordtype">void</span> * ext_data) {
<a name="l04933"></a>04933         <span class="keywordflow">if</span> (mk_c(c)-&gt;get_context().get_scope_level() &gt; 0) {
<a name="l04934"></a>04934             SET_ERROR_CODE(Z3_INVALID_USAGE);
<a name="l04935"></a>04935             <span class="keywordflow">return</span> 0;
<a name="l04936"></a>04936         }
<a name="l04937"></a>04937         <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Z3_theory<span class="keyword">&gt;</span>(mk_user_theory(mk_c(c)-&gt;get_context(), c, ext_data, th_name));
<a name="l04938"></a>04938     }
<a name="l04939"></a>04939 
<a name="l04940"></a><a class="code" href="group__capi.html#ga9f8a5c32a1cc523d23a561780824e3af">04940</a>     <span class="keywordtype">void</span> * <a class="code" href="group__capi.html#ga9f8a5c32a1cc523d23a561780824e3af" title="Return a pointer to the external data-structure supplied to the function Z3_mk_theory...">Z3_theory_get_ext_data</a>(__in Z3_theory t) {
<a name="l04941"></a>04941         <span class="keywordtype">void</span> * r = mk_t(t)-&gt;get_ext_data();
<a name="l04942"></a>04942         <span class="keywordflow">return</span> r;
<a name="l04943"></a>04943     }
<a name="l04944"></a>04944     
<a name="l04945"></a><a class="code" href="group__capi.html#gaca80d3711728d0d492cd53ea6dda73a0">04945</a>     Z3_sort <a class="code" href="group__capi.html#gaca80d3711728d0d492cd53ea6dda73a0" title="Create an interpreted theory sort.">Z3_theory_mk_sort</a>(__in Z3_context c, __in Z3_theory t, __in Z3_symbol s) {
<a name="l04946"></a>04946         sort * r = mk_t(t)-&gt;mk_sort(to_symbol(s));
<a name="l04947"></a>04947         mk_c(c)-&gt;save_ast_trail(r);
<a name="l04948"></a>04948         <span class="keywordflow">return</span> of_sort(r);
<a name="l04949"></a>04949     }
<a name="l04950"></a>04950     
<a name="l04951"></a><a class="code" href="group__capi.html#ga239d03127793eeff0bdffbe335eed83a">04951</a>     Z3_ast <a class="code" href="group__capi.html#ga239d03127793eeff0bdffbe335eed83a" title="Create an interpreted theory constant value. Values are assumed to be different from...">Z3_theory_mk_value</a>(__in Z3_context c, __in Z3_theory t, __in Z3_symbol n, __in Z3_sort s) {
<a name="l04952"></a>04952         func_decl * d = mk_t(t)-&gt;mk_value_decl(to_symbol(n), to_sort(s));
<a name="l04953"></a>04953         app * r       = mk_c(c)-&gt;m_manager.mk_const(d);
<a name="l04954"></a>04954         mk_c(c)-&gt;save_ast_trail(r);
<a name="l04955"></a>04955         <span class="keywordflow">return</span> of_ast(r);
<a name="l04956"></a>04956     }
<a name="l04957"></a>04957     
<a name="l04958"></a><a class="code" href="group__capi.html#gab91110cd869988342168cef30f311671">04958</a>     Z3_ast <a class="code" href="group__capi.html#gab91110cd869988342168cef30f311671" title="Create an interpreted constant for the given theory.">Z3_theory_mk_constant</a>(__in Z3_context c, __in Z3_theory t, __in Z3_symbol n, __in Z3_sort s) {
<a name="l04959"></a>04959         Z3_func_decl d = <a class="code" href="group__capi.html#gad6cc1a1533c58d9d3011df0bf6ad5c85" title="Create an interpreted function declaration for the given theory.">Z3_theory_mk_func_decl</a>(c, t, n, 0, 0, s);
<a name="l04960"></a>04960         app * r        = mk_c(c)-&gt;m_manager.mk_const(to_func_decl(d));
<a name="l04961"></a>04961         mk_c(c)-&gt;save_ast_trail(r);
<a name="l04962"></a>04962         <span class="keywordflow">return</span> of_ast(r);
<a name="l04963"></a>04963     }
<a name="l04964"></a>04964     
<a name="l04965"></a><a class="code" href="group__capi.html#gad6cc1a1533c58d9d3011df0bf6ad5c85">04965</a>     Z3_func_decl <a class="code" href="group__capi.html#gad6cc1a1533c58d9d3011df0bf6ad5c85" title="Create an interpreted function declaration for the given theory.">Z3_theory_mk_func_decl</a>(__in Z3_context c, __in Z3_theory t, __in Z3_symbol n,
<a name="l04966"></a>04966                                         __in <span class="keywordtype">unsigned</span> domain_size, __in_ecount(domain_size) Z3_sort <span class="keyword">const</span> domain[],
<a name="l04967"></a>04967                                         __in Z3_sort range) {
<a name="l04968"></a>04968         func_decl * r = mk_t(t)-&gt;mk_func_decl(to_symbol(n), domain_size, to_sorts(domain), to_sort(range));
<a name="l04969"></a>04969         mk_c(c)-&gt;save_ast_trail(r);
<a name="l04970"></a>04970         <span class="keywordflow">return</span> of_func_decl(r);
<a name="l04971"></a>04971     }
<a name="l04972"></a>04972 
<a name="l04973"></a><a class="code" href="group__capi.html#gad5486b1e8ccfb3d75a09c27ffcdd7be2">04973</a>     Z3_context <a class="code" href="group__capi.html#gad5486b1e8ccfb3d75a09c27ffcdd7be2" title="Return the context where the given theory is installed.">Z3_theory_get_context</a>(__in Z3_theory t) {
<a name="l04974"></a>04974         <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Z3_context<span class="keyword">&gt;</span>(mk_t(t)-&gt;get_ext_context());
<a name="l04975"></a>04975     }
<a name="l04976"></a>04976 
<a name="l04977"></a><a class="code" href="group__capi.html#gaade10aabc6565728566c8f06b33758ee">04977</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#gaade10aabc6565728566c8f06b33758ee" title="Set a callback that is invoked when theory t is deleted. This callback should be...">Z3_set_delete_callback</a>(__in Z3_theory t, __in Z3_theory_callback_fptr f) {
<a name="l04978"></a>04978         mk_t(t)-&gt;set_delete_fptr(reinterpret_cast&lt;smt::theory_callback_fptr&gt;(f));
<a name="l04979"></a>04979     }
<a name="l04980"></a>04980 
<a name="l04981"></a><a class="code" href="group__capi.html#ga0525c3189026db9d7a3c8703604efb1a">04981</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga0525c3189026db9d7a3c8703604efb1a" title="Set a callback for simplifying operators of the given theory. The callback f is invoked...">Z3_set_reduce_app_callback</a>(__in Z3_theory t, __in Z3_reduce_app_callback_fptr f) {
<a name="l04982"></a>04982         mk_t(t)-&gt;set_reduce_app_fptr(reinterpret_cast&lt;reduce_app_fptr&gt;(f));
<a name="l04983"></a>04983     }
<a name="l04984"></a>04984 
<a name="l04985"></a><a class="code" href="group__capi.html#gad625d1dd1b2f3f721a7fbe8b399e39d9">04985</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#gad625d1dd1b2f3f721a7fbe8b399e39d9" title="Set a callback for simplifying the atom s_1 = s_2, when the sort of s_1 and s_2 is...">Z3_set_reduce_eq_callback</a>(__in Z3_theory t, __in Z3_reduce_eq_callback_fptr f) {
<a name="l04986"></a>04986         mk_t(t)-&gt;set_reduce_eq_fptr(reinterpret_cast&lt;reduce_eq_fptr&gt;(f));
<a name="l04987"></a>04987     }
<a name="l04988"></a>04988 
<a name="l04989"></a><a class="code" href="group__capi.html#gaa04372a1bb186ab36c8973b244fe287d">04989</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#gaa04372a1bb186ab36c8973b244fe287d" title="Set a callback for simplifying the atom distinct(s_1, ..., s_n), when the sort of...">Z3_set_reduce_distinct_callback</a>(__in Z3_theory t, __in Z3_reduce_distinct_callback_fptr f) {
<a name="l04990"></a>04990         mk_t(t)-&gt;set_reduce_distinct_fptr(reinterpret_cast&lt;reduce_distinct_fptr&gt;(f));
<a name="l04991"></a>04991     }
<a name="l04992"></a>04992 
<a name="l04993"></a><a class="code" href="group__capi.html#ga0344abe444ca8fd4905b6b52cd2e28c6">04993</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga0344abe444ca8fd4905b6b52cd2e28c6" title="Set a callback that is invoked when a theory application is finally added into the...">Z3_set_new_app_callback</a>(__in Z3_theory t, __in Z3_theory_ast_callback_fptr f) {
<a name="l04994"></a>04994         mk_t(t)-&gt;set_new_app_fptr(reinterpret_cast&lt;smt::theory_app_callback_fptr&gt;(f));
<a name="l04995"></a>04995     }
<a name="l04996"></a>04996 
<a name="l04997"></a><a class="code" href="group__capi.html#gaf7fb053e9262c4dbd532eed6b0bd8369">04997</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#gaf7fb053e9262c4dbd532eed6b0bd8369" title="Set a callback that is invoked when an expression of sort s, where s is an interpreted...">Z3_set_new_elem_callback</a>(__in Z3_theory t, __in Z3_theory_ast_callback_fptr f) {
<a name="l04998"></a>04998         mk_t(t)-&gt;set_new_elem_fptr(reinterpret_cast&lt;smt::theory_app_callback_fptr&gt;(f));
<a name="l04999"></a>04999     }
<a name="l05000"></a>05000 
<a name="l05001"></a><a class="code" href="group__capi.html#gab0fb8f0deedd6b4df5d830c789f8e4da">05001</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#gab0fb8f0deedd6b4df5d830c789f8e4da" title="Set a callback that is invoked when Z3 starts searching for a satisfying assignment...">Z3_set_init_search_callback</a>(__in Z3_theory t, __in Z3_theory_callback_fptr f) {
<a name="l05002"></a>05002         mk_t(t)-&gt;set_init_search_fptr(reinterpret_cast&lt;smt::theory_callback_fptr&gt;(f));
<a name="l05003"></a>05003     }
<a name="l05004"></a>05004         
<a name="l05005"></a><a class="code" href="group__capi.html#ga8ad0c85d1ead3473da2c50b8b668a705">05005</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga8ad0c85d1ead3473da2c50b8b668a705" title="Set a callback that is invoked when Z3 creates a case-split (aka backtracking point)...">Z3_set_push_callback</a>(__in Z3_theory t, __in Z3_theory_callback_fptr f) {
<a name="l05006"></a>05006         mk_t(t)-&gt;set_push_fptr(reinterpret_cast&lt;smt::theory_callback_fptr&gt;(f));
<a name="l05007"></a>05007     }
<a name="l05008"></a>05008  
<a name="l05009"></a><a class="code" href="group__capi.html#gaa9f4fdf16b8a18d70a40d983629afb5e">05009</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#gaa9f4fdf16b8a18d70a40d983629afb5e" title="Set a callback that is invoked when Z3 backtracks a case-split.">Z3_set_pop_callback</a>(__in Z3_theory t, __in Z3_theory_callback_fptr f) {
<a name="l05010"></a>05010         mk_t(t)-&gt;set_pop_fptr(reinterpret_cast&lt;smt::theory_callback_fptr&gt;(f));
<a name="l05011"></a>05011     }
<a name="l05012"></a>05012 
<a name="l05013"></a><a class="code" href="group__capi.html#ga6acbd8dbbd83ec5b17766ceee681088e">05013</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga6acbd8dbbd83ec5b17766ceee681088e" title="Set a callback that is invoked when Z3 restarts the search for a satisfying assignment...">Z3_set_restart_callback</a>(__in Z3_theory t, __in Z3_theory_callback_fptr f) {
<a name="l05014"></a>05014         mk_t(t)-&gt;set_restart_fptr(reinterpret_cast&lt;smt::theory_callback_fptr&gt;(f));
<a name="l05015"></a>05015     }
<a name="l05016"></a>05016 
<a name="l05017"></a><a class="code" href="group__capi.html#ga97e19b9c36dcc8e09ac70f1e89a2df78">05017</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga97e19b9c36dcc8e09ac70f1e89a2df78" title="Set a callback that is invoked when the logical context is reset by the user. This...">Z3_set_reset_callback</a>(__in Z3_theory t, __in Z3_theory_callback_fptr f) {
<a name="l05018"></a>05018         mk_t(t)-&gt;set_reset_fptr(reinterpret_cast&lt;smt::theory_callback_fptr&gt;(f));
<a name="l05019"></a>05019     }
<a name="l05020"></a>05020     
<a name="l05021"></a><a class="code" href="group__capi.html#ga04473f09d9c9b789a34962f10a4c21db">05021</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga04473f09d9c9b789a34962f10a4c21db" title="Set a callback that is invoked before Z3 starts building a model. A theory may use...">Z3_set_final_check_callback</a>(__in Z3_theory t, __in Z3_theory_final_check_callback_fptr f) {
<a name="l05022"></a>05022         mk_t(t)-&gt;set_final_check_fptr(reinterpret_cast&lt;smt::theory_final_check_callback_fptr&gt;(f));
<a name="l05023"></a>05023     }
<a name="l05024"></a>05024         
<a name="l05025"></a><a class="code" href="group__capi.html#gad40d9edc929039e6a5c7890681fd17ae">05025</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#gad40d9edc929039e6a5c7890681fd17ae" title="Set a callback that is invoked when an equality s_1 = s_2 is found by the logical...">Z3_set_new_eq_callback</a>(__in Z3_theory t, __in Z3_theory_ast_ast_callback_fptr f) {
<a name="l05026"></a>05026         mk_t(t)-&gt;set_new_eq_fptr(reinterpret_cast&lt;smt::theory_app_app_callback_fptr&gt;(f));
<a name="l05027"></a>05027     }
<a name="l05028"></a>05028 
<a name="l05029"></a><a class="code" href="group__capi.html#ga788c974f6bc7701764807b29f3db8ea1">05029</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga788c974f6bc7701764807b29f3db8ea1" title="Set a callback that is invoked when a disequality s_1 != s_2 is found by the logical...">Z3_set_new_diseq_callback</a>(__in Z3_theory t, __in Z3_theory_ast_ast_callback_fptr f) {
<a name="l05030"></a>05030         mk_t(t)-&gt;set_new_diseq_fptr(reinterpret_cast&lt;smt::theory_app_app_callback_fptr&gt;(f));
<a name="l05031"></a>05031     }
<a name="l05032"></a>05032     
<a name="l05033"></a><a class="code" href="group__capi.html#ga7f66a5a5418f09cfbf88ecc06d970300">05033</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga7f66a5a5418f09cfbf88ecc06d970300" title="Set a callback that is invoked when a theory predicate is assigned to true/false...">Z3_set_new_assignment_callback</a>(__in Z3_theory t, __in Z3_theory_ast_bool_callback_fptr f) {
<a name="l05034"></a>05034         mk_t(t)-&gt;set_new_assignment_fptr(reinterpret_cast&lt;smt::theory_app_bool_callback_fptr&gt;(f));
<a name="l05035"></a>05035     }
<a name="l05036"></a>05036 
<a name="l05037"></a><a class="code" href="group__capi.html#ga208efc416e985f8dbe94630ca2a59e04">05037</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga208efc416e985f8dbe94630ca2a59e04" title="Set a callback that is invoked when an expression is marked as relevant during the...">Z3_set_new_relevant_callback</a>(__in Z3_theory t, __in Z3_theory_ast_callback_fptr f) {
<a name="l05038"></a>05038         mk_t(t)-&gt;set_new_relevant_fptr(reinterpret_cast&lt;smt::theory_app_callback_fptr&gt;(f));
<a name="l05039"></a>05039     }
<a name="l05040"></a>05040     
<a name="l05041"></a><a class="code" href="group__capi.html#ga6ab97a5867aef0556c64bb29c72f9ced">05041</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga6ab97a5867aef0556c64bb29c72f9ced" title="Assert a theory axiom/lemmas during the search.">Z3_theory_assert_axiom</a>(__in Z3_theory t, __in Z3_ast ax) {
<a name="l05042"></a>05042         mk_t(t)-&gt;assert_axiom(to_ast(ax));
<a name="l05043"></a>05043     }
<a name="l05044"></a>05044 
<a name="l05045"></a><a class="code" href="group__capi.html#ga277e6cd16cddc0c7315306151b9816ef">05045</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga277e6cd16cddc0c7315306151b9816ef" title="Inform to the logical context that lhs and rhs have the same interpretation in the...">Z3_theory_assume_eq</a>(__in Z3_theory t, __in Z3_ast lhs, __in Z3_ast rhs) {
<a name="l05046"></a>05046         mk_t(t)-&gt;assume_eq(to_ast(lhs), to_ast(rhs));
<a name="l05047"></a>05047     }
<a name="l05048"></a>05048 
<a name="l05049"></a><a class="code" href="group__capi.html#ga2cdc617cf02b74c0e59ad34afc7f433a">05049</a>     <span class="keywordtype">void</span> <a class="code" href="group__capi.html#ga2cdc617cf02b74c0e59ad34afc7f433a" title="Enable/disable the simplification of theory axioms asserted using Z3_theory_assert_axiom...">Z3_theory_enable_axiom_simplification</a>(__in Z3_theory t, __in <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> flag) {
<a name="l05050"></a>05050         mk_t(t)-&gt;enable_axiom_simplification(flag == <a class="code" href="group__capi.html#gad86c8730a2e4e61bac585b240a6288d4" title="True value. It is just an alias for 1.">Z3_TRUE</a>);
<a name="l05051"></a>05051     }
<a name="l05052"></a>05052 
<a name="l05053"></a><a class="code" href="group__capi.html#gaf8b5b897959cbf30b20f7449cb02ebe3">05053</a>     Z3_ast <a class="code" href="group__capi.html#gaf8b5b897959cbf30b20f7449cb02ebe3" title="Return the root of the equivalence class containing n.">Z3_theory_get_eqc_root</a>(__in Z3_theory t, __in Z3_ast n) {
<a name="l05054"></a>05054         <span class="keywordflow">return</span> of_ast(mk_t(t)-&gt;get_root(to_ast(n)));
<a name="l05055"></a>05055     }
<a name="l05056"></a>05056 
<a name="l05057"></a><a class="code" href="group__capi.html#gab91ac2b25b88f92d51359c0185cf1357">05057</a>     Z3_ast <a class="code" href="group__capi.html#gab91ac2b25b88f92d51359c0185cf1357" title="Return the next element in the equivalence class containing n.">Z3_theory_get_eqc_next</a>(__in Z3_theory t, __in Z3_ast n) {
<a name="l05058"></a>05058         <span class="keywordflow">return</span> of_ast(mk_t(t)-&gt;get_next(to_ast(n)));
<a name="l05059"></a>05059     }
<a name="l05060"></a>05060 
<a name="l05061"></a><a class="code" href="group__capi.html#ga00cf5d469ac5f267cb92d221fd8bcfd4">05061</a>     <span class="keywordtype">unsigned</span> <a class="code" href="group__capi.html#ga00cf5d469ac5f267cb92d221fd8bcfd4" title="Return the number of parents of n that are operators of the given theory.">Z3_theory_get_num_parents</a>(__in Z3_theory t, __in Z3_ast n) {
<a name="l05062"></a>05062         <span class="keywordflow">return</span> mk_t(t)-&gt;get_num_parents(to_ast(n));
<a name="l05063"></a>05063     }
<a name="l05064"></a>05064     
<a name="l05065"></a><a class="code" href="group__capi.html#ga9b3099dcf4f295cc05e6f94693e7be35">05065</a>     Z3_ast <a class="code" href="group__capi.html#ga9b3099dcf4f295cc05e6f94693e7be35" title="Return the i-th parent of n. See Z3_theory_get_num_parents.">Z3_theory_get_parent</a>(__in Z3_theory t, __in Z3_ast n, __in <span class="keywordtype">unsigned</span> i) {
<a name="l05066"></a>05066         <span class="keywordflow">return</span> of_ast(mk_t(t)-&gt;get_parent(to_ast(n), i));
<a name="l05067"></a>05067     }
<a name="l05068"></a>05068 
<a name="l05069"></a><a class="code" href="group__capi.html#ga3f2d2e577849a075129142d8007cf0da">05069</a>     <span class="keywordtype">unsigned</span> <a class="code" href="group__capi.html#ga3f2d2e577849a075129142d8007cf0da" title="Return the number of expressions of the given theory in the logical context. These...">Z3_theory_get_num_elems</a>(__in Z3_theory t) {
<a name="l05070"></a>05070         <span class="keywordflow">return</span> mk_t(t)-&gt;get_num_asts();
<a name="l05071"></a>05071     }
<a name="l05072"></a>05072 
<a name="l05073"></a><a class="code" href="group__capi.html#ga666931824dd7e4f1c9abd9fdab1f5f81">05073</a>     Z3_ast <a class="code" href="group__capi.html#ga666931824dd7e4f1c9abd9fdab1f5f81" title="Return the i-th elem of the given theory in the logical context.">Z3_theory_get_elem</a>(__in Z3_theory t, __in <span class="keywordtype">unsigned</span> i) {
<a name="l05074"></a>05074         <span class="keywordflow">return</span> of_ast(mk_t(t)-&gt;get_ast(i));
<a name="l05075"></a>05075     }
<a name="l05076"></a>05076 
<a name="l05077"></a><a class="code" href="group__capi.html#ga117c55aa5044b5706df0a1926b630857">05077</a>     <span class="keywordtype">unsigned</span> <a class="code" href="group__capi.html#ga117c55aa5044b5706df0a1926b630857" title="Return the number of theory applications in the logical context. These are the expressions...">Z3_theory_get_num_apps</a>(__in Z3_theory t) {
<a name="l05078"></a>05078         <span class="keywordflow">return</span> mk_t(t)-&gt;get_num_parents();
<a name="l05079"></a>05079     }
<a name="l05080"></a>05080 
<a name="l05081"></a><a class="code" href="group__capi.html#gac2ad9c9d6f677433ca27b4cf7466c56c">05081</a>     Z3_ast <a class="code" href="group__capi.html#gac2ad9c9d6f677433ca27b4cf7466c56c" title="Return the i-th application of the given theory in the logical context.">Z3_theory_get_app</a>(__in Z3_theory t, __in <span class="keywordtype">unsigned</span> i) {
<a name="l05082"></a>05082         <span class="keywordflow">return</span> of_ast(mk_t(t)-&gt;get_parent(i));
<a name="l05083"></a>05083     }
<a name="l05084"></a>05084 
<a name="l05085"></a><a class="code" href="group__capi.html#gaca57d0410f9303b524f2050ecf5c0061">05085</a>     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> <a class="code" href="group__capi.html#gaca57d0410f9303b524f2050ecf5c0061" title="Return Z3_TRUE if n is an interpreted theory value.">Z3_theory_is_value</a>(__in Z3_theory t, __in Z3_ast n) {
<a name="l05086"></a>05086         <span class="keywordflow">return</span> is_app(to_ast(n)) &amp;&amp; mk_t(t)-&gt;get_family_id() == to_app(to_ast(n))-&gt;get_family_id();
<a name="l05087"></a>05087     }
<a name="l05088"></a>05088 
<a name="l05089"></a><a class="code" href="group__capi.html#ga4836063495a93a0a64f7ee55bc57a020">05089</a>     <a class="code" href="group__capi.html#ga3a65ded0ada3ee285865759a21140eeb" title="Z3 Boolean type. It is just an alias for int.">Z3_bool</a> <a class="code" href="group__capi.html#ga4836063495a93a0a64f7ee55bc57a020" title="Return Z3_TRUE if d is an interpreted theory declaration.">Z3_theory_is_decl</a>(__in Z3_theory t, __in Z3_func_decl d) {
<a name="l05090"></a>05090         <span class="keywordflow">return</span> mk_t(t)-&gt;get_family_id() == to_func_decl(d)-&gt;get_family_id();
<a name="l05091"></a>05091     }
<a name="l05092"></a>05092     
<a name="l05094"></a>05094     <span class="comment">// Datalog utilities</span>
<a name="l05095"></a>05095     <span class="comment">// No support for logging</span>
<a name="l05096"></a>05096 
<a name="l05097"></a><a class="code" href="group__capi.html#gadadf94a9482d30b36b19572898f347eb">05097</a>     <span class="keywordtype">void</span> Z3_API  <a class="code" href="group__capi.html#gadadf94a9482d30b36b19572898f347eb" title="Initialize the context with a user-defined state.">Z3_datalog_init</a>(__in Z3_context c, __in <span class="keywordtype">void</span>* state) {
<a name="l05098"></a>05098         mk_c(c)-&gt;datalog_set_state(state);
<a name="l05099"></a>05099     }
<a name="l05100"></a>05100 
<a name="l05101"></a><a class="code" href="group__capi.html#ga517bf4f01658b2382a5ad23357f1cc7f">05101</a>     <span class="keywordtype">void</span>* Z3_API <a class="code" href="group__capi.html#ga517bf4f01658b2382a5ad23357f1cc7f" title="Retrieve the user-define state.">Z3_datalog_get_context</a>(__in Z3_context c) {
<a name="l05102"></a>05102         <span class="keywordflow">return</span> mk_c(c)-&gt;datalog_get_state();
<a name="l05103"></a>05103     }
<a name="l05104"></a>05104     
<a name="l05105"></a><a class="code" href="group__capi.html#gadc44bae9e3ba170c11113371f83df006">05105</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#gadc44bae9e3ba170c11113371f83df006" title="Parse a file in Datalog format and process the queries in it.">Z3_datalog_parse_file</a>(__in Z3_context c, <a class="code" href="group__capi.html#ga49f047b93b0282e686956678da5b86b1" title="Z3 string type. It is just an alias for const char *.">Z3_string</a> filename) {
<a name="l05106"></a>05106         mk_c(c)-&gt;datalog_parse_file(filename);
<a name="l05107"></a>05107     }
<a name="l05108"></a>05108 
<a name="l05109"></a><a class="code" href="group__capi.html#ga08bf7af8cfb2dc315572700987f32585">05109</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga08bf7af8cfb2dc315572700987f32585" title="Register a callback to destructive updates.">Z3_datalog_set_reduce_assign_callback</a>(__in Z3_context c, __in <a class="code" href="group__capi.html#ga906365bab6a522a0eb4d6b8e2b601df4" title="The following utilities allows adding user-defined domains.">Z3_datalog_reduce_assign_callback_fptr</a> f) {
<a name="l05110"></a>05110         mk_c(c)-&gt;datalog_set_reduce_assign_callback(f);
<a name="l05111"></a>05111     }
<a name="l05112"></a>05112 
<a name="l05113"></a><a class="code" href="group__capi.html#ga797ab2ff49a41d41f0d2252d53809918">05113</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga797ab2ff49a41d41f0d2252d53809918" title="Register a callback for buildling terms based on the relational operators.">Z3_datalog_set_reduce_app_callback</a>(__in Z3_context c, __in Z3_datalog_reduce_app_callback_fptr f) {
<a name="l05114"></a>05114         mk_c(c)-&gt;datalog_set_reduce_app_callback(f);        
<a name="l05115"></a>05115     }
<a name="l05116"></a>05116 
<a name="l05117"></a><a class="code" href="group__capi.html#ga47a172fbacbd182d1454b78673161349">05117</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga47a172fbacbd182d1454b78673161349" title="Register relation as Datalog defined. Datalog defined relations have least-fixedpoint...">Z3_datalog_register_relation</a>(__in Z3_context c, __in Z3_func_decl f) {
<a name="l05118"></a>05118         LOG_Z3_datalog_register_relation(c, f);
<a name="l05119"></a>05119         mk_c(c)-&gt;datalog_register_relation(to_func_decl(f));
<a name="l05120"></a>05120     }
<a name="l05121"></a>05121 
<a name="l05122"></a>05122 
<a name="l05123"></a><a class="code" href="group__capi.html#ga0d158891352456e6a4ac9ba398a75653">05123</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga0d158891352456e6a4ac9ba398a75653" title="Add a universal Horn clause as a named rule. The horn_rule should be of the form:...">Z3_datalog_add_rule</a>(__in Z3_context c, __in Z3_ast fml, __in Z3_symbol name) {
<a name="l05124"></a>05124         LOG_Z3_datalog_add_rule(c, fml, name);
<a name="l05125"></a>05125         mk_c(c)-&gt;datalog_add_rule(to_expr(fml), to_symbol(name));
<a name="l05126"></a>05126     }
<a name="l05127"></a>05127     
<a name="l05128"></a><a class="code" href="group__capi.html#ga856a47bf001cd346286a268dbdfd318a">05128</a>     Z3_ast Z3_API <a class="code" href="group__capi.html#ga856a47bf001cd346286a268dbdfd318a" title="Pose a query against the asserted rules.">Z3_datalog_query</a>(__in Z3_context c,  __in Z3_ast query) {
<a name="l05129"></a>05129         LOG_Z3_datalog_query(c, query);
<a name="l05130"></a>05130         expr_ref res(mk_c(c)-&gt;m_manager);
<a name="l05131"></a>05131         mk_c(c)-&gt;datalog_query(to_expr(query), res);
<a name="l05132"></a>05132         expr* e = res.get();
<a name="l05133"></a>05133         <span class="keywordflow">if</span> (e) {
<a name="l05134"></a>05134             mk_c(c)-&gt;save_ast_trail(e);
<a name="l05135"></a>05135             RETURN_Z3(of_expr(e));
<a name="l05136"></a>05136         }
<a name="l05137"></a>05137         <span class="keywordflow">else</span> {
<a name="l05138"></a>05138             RETURN_Z3(0);
<a name="l05139"></a>05139         }
<a name="l05140"></a>05140     }
<a name="l05141"></a>05141 
<a name="l05142"></a><a class="code" href="group__capi.html#ga890b4b2afd5415cc00f0b3b763a6d431">05142</a>     <span class="keywordtype">void</span> Z3_API <a class="code" href="group__capi.html#ga890b4b2afd5415cc00f0b3b763a6d431" title="Configure the predicate representation.">Z3_datalog_set_predicate_representation</a>(
<a name="l05143"></a>05143         __in Z3_context c, __in Z3_func_decl f, 
<a name="l05144"></a>05144         __in <span class="keywordtype">unsigned</span> num_relations, __in_ecount(num_relations) Z3_symbol <span class="keyword">const</span> relation_kinds[]) {
<a name="l05145"></a>05145         LOG_Z3_datalog_set_predicate_representation(c, f, num_relations, relation_kinds);
<a name="l05146"></a>05146         svector&lt;symbol&gt; kinds;
<a name="l05147"></a>05147         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_relations; ++i) {
<a name="l05148"></a>05148             kinds.push_back(to_symbol(relation_kinds[i]));
<a name="l05149"></a>05149         }
<a name="l05150"></a>05150         mk_c(c)-&gt;datalog_set_predicate_representation(to_func_decl(f), num_relations, kinds.c_ptr());
<a name="l05151"></a>05151     }
<a name="l05152"></a>05152 
<a name="l05153"></a>05153 
<a name="l05154"></a>05154 };
<a name="l05155"></a>05155 
<a name="l05156"></a>05156 ast_manager &amp; Z3_API Z3_get_manager(__in Z3_context c) {
<a name="l05157"></a>05157     <span class="keywordflow">return</span> mk_c(c)-&gt;m_manager;
<a name="l05158"></a>05158 }
<a name="l05159"></a>05159 
<a name="l05160"></a>05160 front_end_params&amp; Z3_API Z3_get_parameters(__in Z3_context c) {
<a name="l05161"></a>05161     <span class="keywordflow">return</span> mk_c(c)-&gt;m_params;
<a name="l05162"></a>05162 }
<a name="l05163"></a>05163 
<a name="l05164"></a>05164 Z3_context Z3_mk_context_from_params(front_end_params <span class="keyword">const</span>&amp; p) {
<a name="l05165"></a>05165     config_params cp(p);
<a name="l05166"></a>05166     <span class="keywordflow">return</span> alloc(_Z3_context, &amp;cp);
<a name="l05167"></a>05167 }
<a name="l05168"></a>05168 
<a name="l05169"></a>05169 <span class="keywordtype">void</span> Z3_display_statistics(__in Z3_context c, std::ostream&amp; s) {
<a name="l05170"></a>05170     mk_c(c)-&gt;get_context().display_statistics(s);
<a name="l05171"></a>05171 }
<a name="l05172"></a>05172 
<a name="l05173"></a>05173 <span class="keywordtype">void</span> Z3_display_istatistics(__in Z3_context c, std::ostream&amp; s) {
<a name="l05174"></a>05174     mk_c(c)-&gt;get_context().display_istatistics(s);
<a name="l05175"></a>05175 }
<a name="l05176"></a>05176     
</pre></div></div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Tue Feb 21 13:44:16 2012
</BODY>
</HTML>
