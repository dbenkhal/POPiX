 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">

<table>
<tr>
<th style="width:120px"><a style="border=0px" class="el" href="index.html"><img border="0" src="z3.png" alt="Z3" /></a></th>
<th style="width:100%">
<div id="nav">
<ul>
<li><a href="download.html">Download</a></li>
<li>/</li>
<li><a href="documentation.html#tutorial">Tutorials</a></li>
<li>/</li>
<li><a href="documentation.html">Documentation</a></li>
<li>/</li>
<li><a href="mail.html">Contact</a></li>
<li>/</li>
<li><a href="faq.html">FAQ</a></li>
<li>/</li>
<li><a href="awards.html">Awards</a></li>
<li>/</li>
<li><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx">RiSE</a></li>
</ul>
</div>
</th>
<th style="width:120px">
<a style="border=0px" class="el" href="http://research.microsoft.com"><img border="0" src="logo_msr.gif" alt="Microsoft Research" />
</th>
</tr>
</table>

<!-- <p> -->
<!-- <img align="middle" src="z3.png" alt="Z3" /> -->
<!-- <table class="centered-small"> -->
<!--   <tr> -->
<!--     <th><a href="index.html"><span>Home</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="documentation.html"><span>Docs</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="download.html"><span>Download</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="mail.html"><span>Mail</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="faq.html"><span>FAQ</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="awards.html"><span>Awards</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com"><span>MSR</span></a></th> -->
<!--   </tr> -->
<!-- </table> -->
<!-- </p> -->

<!-- Generated by Doxygen 1.6.3 -->
<h1>PowerPack/PASolver/PASolver/Solver.cs</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 ï»¿using System;
<a name="l00002"></a>00002 <span class="keyword">using</span> System.Collections.Generic;
<a name="l00003"></a>00003 <span class="keyword">using</span> System.Linq;
<a name="l00004"></a>00004 <span class="keyword">using</span> System.Text;
<a name="l00005"></a>00005 <span class="keyword">using</span> Microsoft.Z3;
<a name="l00006"></a>00006 <span class="keyword">using</span> VarType = System.String;
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="keyword">namespace </span>PA
<a name="l00009"></a>00009 {
<a name="l00013"></a><a class="code" href="class_p_a_1_1_solver.html">00013</a>     <span class="keyword">public</span> <span class="keyword">class </span><a class="code" href="class_p_a_1_1_solver.html" title="Solver for Presburger Arithmetic formulas.">Solver</a> :IDisposable
<a name="l00014"></a>00014     {
<a name="l00015"></a>00015         <span class="keyword">public</span> <a class="code" href="class_microsoft_1_1_z3_1_1_context.html" title="The main interaction with Z3 happens via the Context.">Context</a> z3;
<a name="l00016"></a>00016         <span class="keyword">internal</span> <a class="code" href="class_microsoft_1_1_z3_1_1_sort.html" title="The Sort class implements type information for ASTs.">Sort</a> intSort;
<a name="l00017"></a>00017         <span class="keyword">internal</span> Term zero;
<a name="l00021"></a><a class="code" href="class_p_a_1_1_solver.html#a307b0099d5a42a4bf85a56d29c48a6c2">00021</a>         <span class="keyword">public</span> <a class="code" href="class_p_a_1_1_solver.html#a307b0099d5a42a4bf85a56d29c48a6c2" title="Create an instance of a context for the solver.">Solver</a>()
<a name="l00022"></a>00022         {
<a name="l00023"></a>00023             Config par = <span class="keyword">new</span> Config();
<a name="l00024"></a>00024             par.SetParamValue(<span class="stringliteral">&quot;MODEL&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>);
<a name="l00025"></a>00025             par.SetParamValue(<span class="stringliteral">&quot;ARITH_LAZY_PIVOTING&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>);
<a name="l00026"></a>00026             z3 = <span class="keyword">new</span> <a class="code" href="class_microsoft_1_1_z3_1_1_context.html" title="The main interaction with Z3 happens via the Context.">Context</a>(par);
<a name="l00027"></a>00027             intSort = z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#abb672e544c391748b081e4219e5670a0" title="Create a new integer sort.">MkIntSort</a>();
<a name="l00028"></a>00028             zero = z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(0, intSort);
<a name="l00029"></a>00029             par.Dispose();
<a name="l00030"></a>00030         }
<a name="l00031"></a>00031 
<a name="l00037"></a><a class="code" href="class_p_a_1_1_solver.html#a1262ee589183c061e3db0fb5c39af8ff">00037</a>         <span class="keyword">public</span> LinearFormula <a class="code" href="class_p_a_1_1_solver.html#a1262ee589183c061e3db0fb5c39af8ff" title="Top-level call of Coopers quantifier elimination algorithm. Eliminates quantifiers...">CoopersAlgorithm</a>(LinearFormula f)
<a name="l00038"></a>00038         {
<a name="l00039"></a>00039             <span class="keywordflow">if</span> (f.IsQuantifierFree)
<a name="l00040"></a>00040                 <span class="keywordflow">return</span> f;
<a name="l00041"></a>00041 
<a name="l00042"></a>00042             f = GetPrenexForm(f);
<a name="l00043"></a>00043 
<a name="l00044"></a>00044             LinearFormula res = <a class="code" href="class_p_a_1_1_solver.html#a8e968d6fda3bcb605b4a6f938e5bbe9d" title="Assumes that f is in prenex form and variables with the same kind of quantifier are...">CoopersAlgorithm1</a>(f);
<a name="l00045"></a>00045             <span class="keywordflow">return</span> res;
<a name="l00046"></a>00046         }
<a name="l00047"></a>00047 
<a name="l00051"></a><a class="code" href="class_p_a_1_1_solver.html#a8e968d6fda3bcb605b4a6f938e5bbe9d">00051</a>         <span class="keyword">public</span> LinearFormula <a class="code" href="class_p_a_1_1_solver.html#a8e968d6fda3bcb605b4a6f938e5bbe9d" title="Assumes that f is in prenex form and variables with the same kind of quantifier are...">CoopersAlgorithm1</a>(LinearFormula f)
<a name="l00052"></a>00052         {
<a name="l00053"></a>00053             QuantifiedFormula f1 = f as QuantifiedFormula;
<a name="l00054"></a>00054             <span class="keywordflow">if</span> (f1 != null)
<a name="l00055"></a>00055             {
<a name="l00056"></a>00056                 LinearFormula f2 = <a class="code" href="class_p_a_1_1_solver.html#a8e968d6fda3bcb605b4a6f938e5bbe9d" title="Assumes that f is in prenex form and variables with the same kind of quantifier are...">CoopersAlgorithm1</a>(f1.Formula);
<a name="l00057"></a>00057                 <span class="keywordflow">if</span> (f1.IsExists)
<a name="l00058"></a>00058                     <span class="keywordflow">return</span> EliminateExs(f1.Variables, f2);
<a name="l00059"></a>00059                 <span class="keywordflow">else</span>
<a name="l00060"></a>00060                     <span class="keywordflow">return</span> ~EliminateExs(f1.Variables, ~f2);
<a name="l00061"></a>00061             }
<a name="l00062"></a>00062             <span class="keywordflow">return</span> f;
<a name="l00063"></a>00063         }
<a name="l00064"></a>00064 
<a name="l00068"></a>00068         <span class="keyword">private</span> LinearFormula EliminateExs(ICollection&lt;string&gt; vars, LinearFormula f)
<a name="l00069"></a>00069         {
<a name="l00070"></a>00070             <span class="keywordflow">if</span> (vars.Count == 0) 
<a name="l00071"></a>00071                 <span class="keywordflow">return</span> f;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073             Disjunction disj = f as Disjunction;
<a name="l00074"></a>00074             <span class="keywordflow">if</span> (disj != null)
<a name="l00075"></a>00075                 <span class="keywordflow">return</span> Disjunction.Create(EliminateExsFromDisjunction(vars, disj));
<a name="l00076"></a>00076 
<a name="l00077"></a>00077             List&lt;string&gt; vs = <span class="keyword">new</span> List&lt;string&gt;(vars);
<a name="l00078"></a>00078             <span class="keywordtype">string</span> x;
<a name="l00079"></a>00079             <span class="keywordtype">int</span> m;                                                         <span class="comment">//m is the l.c.m. of all the coefficients of x</span>
<a name="l00080"></a>00080             ChooseVarWithLeastLCM(vs, f, out x, out m);
<a name="l00081"></a>00081             vs.Remove(x);
<a name="l00082"></a>00082             <span class="keywordflow">if</span> (m == -1)                                                   <span class="comment">//x does not occur in f</span>
<a name="l00083"></a>00083                 <span class="keywordflow">return</span> EliminateExs(vs, f);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085             LinearFormula div = (m | LinearTerm.Var(x));
<a name="l00086"></a>00086             List&lt;BoundedVariable&gt; bvs = <span class="keyword">new</span> List&lt;BoundedVariable&gt;();
<a name="l00087"></a>00087 
<a name="l00088"></a>00088             BigOR bor = f as BigOR;
<a name="l00089"></a>00089             <span class="keywordflow">if</span> (bor != null)
<a name="l00090"></a>00090             {
<a name="l00091"></a>00091                 div = div &amp; bor.Divs;
<a name="l00092"></a>00092                 bvs.AddRange(bor.Vars);
<a name="l00093"></a>00093                 f = bor.F;
<a name="l00094"></a>00094             }
<a name="l00095"></a>00095 
<a name="l00096"></a>00096             LinearFormula p = f.Normalize(m, x);                            <span class="comment">//&#39;p &amp; div&#39; is equiv to f and x has unit coefficients</span>
<a name="l00097"></a>00097             <span class="keywordtype">int</span> d = <a class="code" href="class_p_a_1_1_solver.html#ae5830f5780068ae444c1fa7172ac270b" title="Calculate the least common multiple of the coefficients in the given enumeration...">LCM</a>(m, Math.Abs(<a class="code" href="class_p_a_1_1_solver.html#ae5830f5780068ae444c1fa7172ac270b" title="Calculate the least common multiple of the coefficients in the given enumeration...">LCM</a>(p.GetDivCoeff(x))));                <span class="comment">//d is the l.c.m. of all the divisibility constants</span>
<a name="l00098"></a>00098 
<a name="l00099"></a>00099             List&lt;LinearTerm&gt; lowerBounds = <span class="keyword">new</span> List&lt;LinearTerm&gt;(p.GetLowerBounds(x));
<a name="l00100"></a>00100             List&lt;LinearTerm&gt; upperBounds = <span class="keyword">new</span> List&lt;LinearTerm&gt;(p.GetUpperBounds(x));
<a name="l00101"></a>00101             <span class="keywordtype">bool</span> useUpper = (lowerBounds.Count &gt; upperBounds.Count);
<a name="l00102"></a>00102             LinearFormula p_inf = p.Inf(useUpper, x);
<a name="l00103"></a>00103 
<a name="l00104"></a>00104             LinearFormula bigORs = Disjunction.Create(EnumerateBigORs((useUpper ? upperBounds : lowerBounds),
<a name="l00105"></a>00105                                                                       p, p_inf, div, x, d, useUpper));
<a name="l00106"></a>00106             <span class="keywordflow">if</span> (disj == LinearFormula.True || disj == LinearFormula.False)
<a name="l00107"></a>00107                 <span class="keywordflow">return</span> disj;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109             LinearFormula f2 = EliminateExs(vs, bigORs);
<a name="l00110"></a>00110             <span class="comment">//add back the missing bounded variables to each disjunct</span>
<a name="l00111"></a>00111             <span class="keywordflow">if</span> (bvs.Count &gt; 0)
<a name="l00112"></a>00112                 f2 = Disjunction.Create(AppendBoundedVariables(bvs,f2));
<a name="l00113"></a>00113             <span class="keywordflow">return</span> f2;
<a name="l00114"></a>00114         }
<a name="l00115"></a>00115 
<a name="l00116"></a>00116         <span class="keyword">private</span> IEnumerable&lt;LinearFormula&gt; AppendBoundedVariables(List&lt;BoundedVariable&gt; bvs, LinearFormula f)
<a name="l00117"></a>00117         {
<a name="l00118"></a>00118             BigOR bor = f as BigOR;
<a name="l00119"></a>00119             <span class="keywordflow">if</span> (bor != null)
<a name="l00120"></a>00120             {
<a name="l00121"></a>00121                 List&lt;BoundedVariable&gt; bvs1 = <span class="keyword">new</span> List&lt;BoundedVariable&gt;(bvs);
<a name="l00122"></a>00122                 bvs1.AddRange(bor.Vars);
<a name="l00123"></a>00123                 yield <span class="keywordflow">return</span> <span class="keyword">new</span> BigOR(bor.F, bvs1, bor.Divs);
<a name="l00124"></a>00124             }
<a name="l00125"></a>00125             <span class="keywordflow">else</span>
<a name="l00126"></a>00126             {
<a name="l00127"></a>00127                 Disjunction disj = f as Disjunction;
<a name="l00128"></a>00128                 <span class="keywordflow">if</span> (disj == null)
<a name="l00129"></a>00129                     <span class="keywordflow">throw</span> <span class="keyword">new</span> ArgumentException(<span class="stringliteral">&quot;Invalid formula&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>);
<a name="l00130"></a>00130                 <span class="keywordflow">foreach</span> (BigOR f1 <span class="keywordflow">in</span> disj.EnumerateSubformulas())
<a name="l00131"></a>00131                 {
<a name="l00132"></a>00132                     List&lt;BoundedVariable&gt; bvs1 = <span class="keyword">new</span> List&lt;BoundedVariable&gt;(bvs);
<a name="l00133"></a>00133                     bvs1.AddRange(f1.Vars);
<a name="l00134"></a>00134                     yield <span class="keywordflow">return</span> <span class="keyword">new</span> BigOR(f1.F, bvs1, f1.Divs);
<a name="l00135"></a>00135                 }
<a name="l00136"></a>00136             }
<a name="l00137"></a>00137         }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         IEnumerable&lt;LinearFormula&gt; EliminateExsFromDisjunction(ICollection&lt;string&gt; vars, Disjunction f)
<a name="l00141"></a>00141         {
<a name="l00142"></a>00142             <span class="keywordflow">foreach</span> (LinearFormula f1 <span class="keywordflow">in</span> f.EnumerateSubformulas())
<a name="l00143"></a>00143                 yield <span class="keywordflow">return</span> EliminateExs(vars, f1);
<a name="l00144"></a>00144         }
<a name="l00145"></a>00145 
<a name="l00149"></a>00149         <span class="keyword">private</span> <span class="keywordtype">void</span> ChooseVarWithLeastLCM(IEnumerable&lt;string&gt; vars, LinearFormula f, out <span class="keywordtype">string</span> v, out <span class="keywordtype">int</span> lcm)
<a name="l00150"></a>00150         {
<a name="l00151"></a>00151             lcm = -1;
<a name="l00152"></a>00152             v = null;
<a name="l00153"></a>00153             <span class="keywordflow">foreach</span> (<span class="keywordtype">string</span> x <span class="keywordflow">in</span> vars)
<a name="l00154"></a>00154             {
<a name="l00155"></a>00155                 <span class="keywordtype">int</span> k = <a class="code" href="class_p_a_1_1_solver.html#ae5830f5780068ae444c1fa7172ac270b" title="Calculate the least common multiple of the coefficients in the given enumeration...">LCM</a>(f.GetCoefficients(x));
<a name="l00156"></a>00156                 <span class="keywordflow">if</span> (v == null || k &lt; lcm)
<a name="l00157"></a>00157                 {
<a name="l00158"></a>00158                     lcm = k;
<a name="l00159"></a>00159                     v = x;
<a name="l00160"></a>00160                     <span class="keywordflow">if</span> (lcm == -1) <span class="comment">//v does not occur in f</span>
<a name="l00161"></a>00161                         <span class="keywordflow">return</span>;
<a name="l00162"></a>00162                 }
<a name="l00163"></a>00163             }
<a name="l00164"></a>00164         }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         <span class="keyword">private</span> <span class="keyword">class </span>VariableAndLCM
<a name="l00167"></a>00167         {
<a name="l00168"></a>00168             <span class="keyword">public</span> <span class="keywordtype">string</span> var;
<a name="l00169"></a>00169             <span class="keyword">public</span> <span class="keywordtype">int</span> lcm;
<a name="l00170"></a>00170             <span class="keyword">public</span> VariableAndLCM(<span class="keywordtype">string</span> var, <span class="keywordtype">int</span> lcm)
<a name="l00171"></a>00171             {
<a name="l00172"></a>00172                 this.var = var;
<a name="l00173"></a>00173                 this.lcm = lcm;
<a name="l00174"></a>00174             }
<a name="l00175"></a>00175         }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 
<a name="l00178"></a>00178         <span class="comment">//assumes currently that the formula is already in prenex form</span>
<a name="l00179"></a>00179         <span class="comment">//it only groups the consequtive quantifiers together</span>
<a name="l00180"></a>00180         <span class="keyword">private</span> LinearFormula GetPrenexForm(LinearFormula f)
<a name="l00181"></a>00181         {
<a name="l00182"></a>00182             QuantifiedFormula qf = f as QuantifiedFormula;
<a name="l00183"></a>00183             <span class="keywordflow">if</span> (qf != null)
<a name="l00184"></a>00184             {
<a name="l00185"></a>00185                 LinearFormula f1 = GetPrenexForm(qf.Formula);
<a name="l00186"></a>00186                 QuantifiedFormula qf1 = f1 as QuantifiedFormula;
<a name="l00187"></a>00187                 <span class="keywordflow">if</span> (qf1 != null)
<a name="l00188"></a>00188                 {
<a name="l00189"></a>00189                     <span class="keywordflow">if</span> (qf1.IsExists == qf.IsExists)
<a name="l00190"></a>00190                     {
<a name="l00191"></a>00191                         List&lt;string&gt; vars = <span class="keyword">new</span> List&lt;string&gt;(qf.Variables);
<a name="l00192"></a>00192                         vars.AddRange(qf1.Variables);
<a name="l00193"></a>00193                         LinearFormula qf2 = QuantifiedFormula.Create(qf.IsExists, vars.ToArray(), qf1.Formula);
<a name="l00194"></a>00194                         <span class="keywordflow">return</span> qf2;
<a name="l00195"></a>00195                     }
<a name="l00196"></a>00196                     <span class="keywordflow">else</span>
<a name="l00197"></a>00197                     {
<a name="l00198"></a>00198                         LinearFormula qf2 = QuantifiedFormula.Create(qf.IsExists, qf.Variables.ToArray(), qf1);
<a name="l00199"></a>00199                         <span class="keywordflow">return</span> qf2;
<a name="l00200"></a>00200                     }
<a name="l00201"></a>00201                 }
<a name="l00202"></a>00202                 <span class="keywordflow">else</span>
<a name="l00203"></a>00203                 {
<a name="l00204"></a>00204                     LinearFormula qf2 = QuantifiedFormula.Create(qf.IsExists, qf.Variables.ToArray(), f1);
<a name="l00205"></a>00205                     <span class="keywordflow">return</span> qf2;
<a name="l00206"></a>00206                 }
<a name="l00207"></a>00207             }
<a name="l00208"></a>00208             <span class="keywordflow">if</span> (!f.IsQuantifierFree)
<a name="l00209"></a>00209                 <span class="keywordflow">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="stringliteral">&quot;Deeply nested quantifiers&quot;</span>);
<a name="l00210"></a>00210             <span class="keywordflow">return</span> f;
<a name="l00211"></a>00211         }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213         IEnumerable&lt;LinearFormula&gt; EliminateQuantifiersFromSubformulas(BooleanFormula f)
<a name="l00214"></a>00214         {
<a name="l00215"></a>00215             <span class="keywordflow">foreach</span> (LinearFormula f1 <span class="keywordflow">in</span> f.EnumerateSubformulas())
<a name="l00216"></a>00216                 yield <span class="keywordflow">return</span> <a class="code" href="class_p_a_1_1_solver.html#a1262ee589183c061e3db0fb5c39af8ff" title="Top-level call of Coopers quantifier elimination algorithm. Eliminates quantifiers...">CoopersAlgorithm</a>(f1);
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218 
<a name="l00223"></a>00223         LinearFormula EliminateEx(VarType x, LinearFormula f)
<a name="l00224"></a>00224         {
<a name="l00225"></a>00225             <span class="keywordflow">if</span> (!f.ContainsFreeVariable(x))
<a name="l00226"></a>00226                 <span class="keywordflow">return</span> f;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228             Disjunction disj = f as Disjunction;
<a name="l00229"></a>00229             <span class="keywordflow">if</span> (disj != null)
<a name="l00230"></a>00230                 <span class="keywordflow">return</span> Disjunction.Create(EliminateExInDisj(x, disj));
<a name="l00231"></a>00231 
<a name="l00232"></a>00232             BigOR bq = f as BigOR;
<a name="l00233"></a>00233             <span class="keywordflow">if</span> (bq != null)
<a name="l00234"></a>00234             {
<a name="l00235"></a>00235                 LinearFormula f1 = EliminateEx(x, bq.F);
<a name="l00236"></a>00236                 <span class="keywordflow">return</span> <span class="keyword">new</span> BigOR(f1, bq.vars, bq.divs);
<a name="l00237"></a>00237             }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239             <span class="keywordtype">int</span> m = <a class="code" href="class_p_a_1_1_solver.html#ae5830f5780068ae444c1fa7172ac270b" title="Calculate the least common multiple of the coefficients in the given enumeration...">LCM</a>(f.GetCoefficients(x));                             <span class="comment">//m is the l.c.m. of all the coefficients of x</span>
<a name="l00240"></a>00240             LinearFormula p = f.Normalize(m, x) &amp; (m | LinearTerm.Var(x)); <span class="comment">//p is equiv to f and x has unit coefficients in p</span>
<a name="l00241"></a>00241             <span class="keywordtype">int</span> d = Math.Abs(<a class="code" href="class_p_a_1_1_solver.html#ae5830f5780068ae444c1fa7172ac270b" title="Calculate the least common multiple of the coefficients in the given enumeration...">LCM</a>(p.GetDivCoeff(x)));                     <span class="comment">//d is the l.c.m. of all the divisibility constants</span>
<a name="l00242"></a>00242             List&lt;LinearTerm&gt; lowerBounds = <span class="keyword">new</span> List&lt;LinearTerm&gt;(p.GetLowerBounds(x));
<a name="l00243"></a>00243             List&lt;LinearTerm&gt; upperBounds = <span class="keyword">new</span> List&lt;LinearTerm&gt;(p.GetUpperBounds(x));
<a name="l00244"></a>00244             <span class="keywordtype">bool</span> useUpper = (lowerBounds.Count &gt; upperBounds.Count);
<a name="l00245"></a>00245             LinearFormula p_inf = p.Inf(useUpper, x);
<a name="l00246"></a>00246             <span class="comment">//LinearFormula res = CreateBigOR((useUpper ? upperBounds : lowerBounds), p, p_inf, x, d, useUpper);</span>
<a name="l00247"></a>00247             <span class="comment">//return res;</span>
<a name="l00248"></a>00248             <span class="keywordflow">return</span> null;
<a name="l00249"></a>00249         }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251         <span class="keywordtype">int</span> newVarId = 0;
<a name="l00252"></a>00252         <span class="keywordtype">string</span> CreateNewVar()
<a name="l00253"></a>00253         {
<a name="l00254"></a>00254             <span class="keywordflow">return</span> <span class="stringliteral">&quot;X&quot;</span> + newVarId++;
<a name="l00255"></a>00255         }
<a name="l00256"></a>00256 
<a name="l00260"></a>00260         <span class="keyword">private</span> IEnumerable&lt;LinearFormula&gt; EnumerateBigORs(List&lt;LinearTerm&gt; ls, LinearFormula p, 
<a name="l00261"></a>00261                                                            LinearFormula p_inf, LinearFormula div,
<a name="l00262"></a>00262                                                            <span class="keywordtype">string</span> x, <span class="keywordtype">int</span> d, <span class="keywordtype">bool</span> negate)
<a name="l00263"></a>00263         {
<a name="l00264"></a>00264             <span class="keywordtype">string</span> freshvarname = CreateNewVar();
<a name="l00265"></a>00265             LinearTerm freshvar = LinearTerm.Var(freshvarname);
<a name="l00266"></a>00266             BoundedVariable bv = <span class="keyword">new</span> BoundedVariable(freshvarname, 0, d - 1);
<a name="l00267"></a>00267             LinearTerm i = (negate ? ~freshvar : freshvar);
<a name="l00268"></a>00268             List&lt;BoundedVariable&gt; bvs = <span class="keyword">new</span> List&lt;BoundedVariable&gt;();
<a name="l00269"></a>00269             bvs.Add(bv);
<a name="l00270"></a>00270 
<a name="l00271"></a>00271             LinearFormula div1 = div.Subst(x, i);
<a name="l00272"></a>00272             LinearFormula f = p_inf.Subst(x, i);
<a name="l00273"></a>00273             BigOR bigOr = <span class="keyword">new</span> BigOR(f, bvs, div1);
<a name="l00274"></a>00274             yield <span class="keywordflow">return</span> bigOr;
<a name="l00275"></a>00275 
<a name="l00276"></a>00276             <span class="keywordflow">foreach</span> (LinearTerm l <span class="keywordflow">in</span> ls)
<a name="l00277"></a>00277             {
<a name="l00278"></a>00278                 div1 = div.Subst(x, l + i);
<a name="l00279"></a>00279                 <span class="keywordflow">if</span> (div1 != LinearFormula.False)
<a name="l00280"></a>00280                 {
<a name="l00281"></a>00281                     f = p.Subst(x, l + i);
<a name="l00282"></a>00282                     <span class="keywordflow">if</span> (f != LinearFormula.False)
<a name="l00283"></a>00283                     {
<a name="l00284"></a>00284                         <span class="keywordflow">if</span> (div1 == LinearFormula.True &amp;&amp; f == LinearFormula.True)
<a name="l00285"></a>00285                         {
<a name="l00286"></a>00286                             yield <span class="keywordflow">return</span> LinearFormula.True;
<a name="l00287"></a>00287                         }
<a name="l00288"></a>00288                         <span class="keywordflow">else</span>
<a name="l00289"></a>00289                         {
<a name="l00290"></a>00290                             bigOr = <span class="keyword">new</span> BigOR(f, bvs, div1);
<a name="l00291"></a>00291                             yield <span class="keywordflow">return</span> bigOr;
<a name="l00292"></a>00292                         }
<a name="l00293"></a>00293                     }
<a name="l00294"></a>00294                 }
<a name="l00295"></a>00295             }
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 
<a name="l00299"></a>00299         IEnumerable&lt;LinearFormula&gt; EliminateExInDisj(<span class="keywordtype">string</span> x, Disjunction f)
<a name="l00300"></a>00300         {
<a name="l00301"></a>00301             <span class="keywordflow">foreach</span> (LinearFormula f1 <span class="keywordflow">in</span> f.EnumerateSubformulas())
<a name="l00302"></a>00302             {
<a name="l00303"></a>00303                 yield <span class="keywordflow">return</span> EliminateEx(x, f1);
<a name="l00304"></a>00304             }
<a name="l00305"></a>00305         }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307         IEnumerable&lt;LinearFormula&gt; GenerateConstInstances(LinearFormula p_inf, VarType x, <span class="keywordtype">int</span> d, <span class="keywordtype">bool</span> negate)
<a name="l00308"></a>00308         {
<a name="l00309"></a>00309             <span class="keywordflow">if</span> (p_inf.ContainsFreeVariable(x))
<a name="l00310"></a>00310                 <span class="comment">//foreach (LinearFormula f in SimplifyBigOr2(x, d, p_inf))</span>
<a name="l00311"></a>00311                 <span class="comment">//    yield return f;</span>
<a name="l00312"></a>00312                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; d; j++)
<a name="l00313"></a>00313                 {
<a name="l00314"></a>00314                     LinearFormula p1 = p_inf.Subst(x, LinearTerm.Const(negate ? -j : j));
<a name="l00315"></a>00315                     <span class="keywordflow">if</span> (p1 != LinearFormula.False)
<a name="l00316"></a>00316                         <span class="comment">//if (IsSatisfiable(p1))</span>
<a name="l00317"></a>00317                             yield <span class="keywordflow">return</span> p1;
<a name="l00318"></a>00318                 }
<a name="l00319"></a>00319             <span class="keywordflow">else</span>
<a name="l00320"></a>00320                 yield <span class="keywordflow">return</span> p_inf;
<a name="l00321"></a>00321         }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323         <span class="keywordtype">bool</span> IsSatisfiable(LinearFormula f)
<a name="l00324"></a>00324         {
<a name="l00325"></a>00325             <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> res = <a class="code" href="class_p_a_1_1_solver.html#a5381b47833667566da3207539dfbe69b" title="Checks if f is satisfiable without changing the current context. Returns LBool.True...">IsSat</a>(f);
<a name="l00326"></a>00326             <span class="keywordflow">return</span> res == <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a>.True;
<a name="l00327"></a>00327         }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329         IEnumerable&lt;LinearFormula&gt; GenerateBoundInstances(List&lt;LinearTerm&gt; ls, LinearFormula p, VarType x, <span class="keywordtype">int</span> d, <span class="keywordtype">bool</span> negate)
<a name="l00330"></a>00330         {
<a name="l00331"></a>00331             <span class="keywordflow">foreach</span> (LinearTerm l <span class="keywordflow">in</span> ls)
<a name="l00332"></a>00332             {
<a name="l00333"></a>00333                 <span class="comment">//LinearFormula p1 = p.Subst(x, LinearTerm.Var(x) + l);</span>
<a name="l00334"></a>00334                 <span class="comment">//foreach (LinearFormula p2 in SimplifyBigOr2(x, d - 1, p1))</span>
<a name="l00335"></a>00335                 <span class="comment">//    yield return p2;</span>
<a name="l00336"></a>00336                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; d; j++)
<a name="l00337"></a>00337                 {
<a name="l00338"></a>00338                     LinearFormula p1 = p.Subst(x, l + LinearTerm.Const(negate ? -j : j));
<a name="l00339"></a>00339                     <span class="keywordflow">if</span> (p1 != LinearFormula.False)
<a name="l00340"></a>00340                         <span class="comment">//if (IsSatisfiable(p1))</span>
<a name="l00341"></a>00341                         yield <span class="keywordflow">return</span> p1;
<a name="l00342"></a>00342                 }
<a name="l00343"></a>00343             }
<a name="l00344"></a>00344         }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 <span class="preprocessor">        #region L.C.M. and G.C.D</span>
<a name="l00347"></a>00347 <span class="preprocessor"></span>
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 
<a name="l00351"></a>00351 
<a name="l00352"></a><a class="code" href="class_p_a_1_1_solver.html#ae5830f5780068ae444c1fa7172ac270b">00352</a>         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="class_p_a_1_1_solver.html#ae5830f5780068ae444c1fa7172ac270b" title="Calculate the least common multiple of the coefficients in the given enumeration...">LCM</a>(IEnumerable&lt;int&gt; ks)
<a name="l00353"></a>00353         {
<a name="l00354"></a>00354             <span class="keywordtype">int</span> m = -1;
<a name="l00355"></a>00355             <span class="keywordflow">foreach</span> (<span class="keywordtype">int</span> k <span class="keywordflow">in</span> ks)
<a name="l00356"></a>00356             {
<a name="l00357"></a>00357                 m = Math.Abs(m);
<a name="l00358"></a>00358                 <span class="keywordtype">int</span> n = Math.Abs(k);
<a name="l00359"></a>00359                 <span class="keywordflow">if</span> (m &lt; n)
<a name="l00360"></a>00360                     m = (m / <a class="code" href="class_p_a_1_1_solver.html#a39846e1a0944917a17981dd99fa5d6ad" title="Euclides algorithm. Calculate the greatest common divisor of a and b. It is assumed...">GCD</a>(n, m)) * n;
<a name="l00361"></a>00361                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m &gt; n)
<a name="l00362"></a>00362                     m = (n / <a class="code" href="class_p_a_1_1_solver.html#a39846e1a0944917a17981dd99fa5d6ad" title="Euclides algorithm. Calculate the greatest common divisor of a and b. It is assumed...">GCD</a>(m, n)) * m;
<a name="l00363"></a>00363             }
<a name="l00364"></a>00364             <span class="keywordflow">return</span> m;
<a name="l00365"></a>00365         }
<a name="l00366"></a>00366 
<a name="l00370"></a><a class="code" href="class_p_a_1_1_solver.html#ac2357c25735747b74a123bedda121bb1">00370</a>         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="class_p_a_1_1_solver.html#ae5830f5780068ae444c1fa7172ac270b" title="Calculate the least common multiple of the coefficients in the given enumeration...">LCM</a>(<span class="keywordtype">int</span> m, <span class="keywordtype">int</span> k)
<a name="l00371"></a>00371         {
<a name="l00372"></a>00372             <span class="keywordtype">int</span> n = Math.Abs(k);
<a name="l00373"></a>00373             <span class="keywordflow">if</span> (m &lt; n)
<a name="l00374"></a>00374                 m = (m / <a class="code" href="class_p_a_1_1_solver.html#a39846e1a0944917a17981dd99fa5d6ad" title="Euclides algorithm. Calculate the greatest common divisor of a and b. It is assumed...">GCD</a>(n, m)) * n;
<a name="l00375"></a>00375             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m &gt; n)
<a name="l00376"></a>00376                 m = (n / <a class="code" href="class_p_a_1_1_solver.html#a39846e1a0944917a17981dd99fa5d6ad" title="Euclides algorithm. Calculate the greatest common divisor of a and b. It is assumed...">GCD</a>(m, n)) * m;
<a name="l00377"></a>00377             <span class="keywordflow">return</span> m;
<a name="l00378"></a>00378         }
<a name="l00379"></a>00379 
<a name="l00384"></a><a class="code" href="class_p_a_1_1_solver.html#a39846e1a0944917a17981dd99fa5d6ad">00384</a>         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="class_p_a_1_1_solver.html#a39846e1a0944917a17981dd99fa5d6ad" title="Euclides algorithm. Calculate the greatest common divisor of a and b. It is assumed...">GCD</a>(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)
<a name="l00385"></a>00385         {
<a name="l00386"></a>00386             <span class="comment">//if (a == 0)</span>
<a name="l00387"></a>00387             <span class="comment">//    return b;</span>
<a name="l00388"></a>00388             <span class="keywordflow">while</span> (b &gt; 0)
<a name="l00389"></a>00389             {
<a name="l00390"></a>00390                 <span class="keywordtype">int</span> tmp = b;
<a name="l00391"></a>00391                 b = a % b;
<a name="l00392"></a>00392                 a = tmp;
<a name="l00393"></a>00393             }
<a name="l00394"></a>00394             <span class="keywordflow">return</span> a;
<a name="l00395"></a>00395         }
<a name="l00396"></a>00396 
<a name="l00400"></a>00400         <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="class_p_a_1_1_solver.html#a39846e1a0944917a17981dd99fa5d6ad" title="Euclides algorithm. Calculate the greatest common divisor of a and b. It is assumed...">GCD</a>(<span class="keywordtype">int</span> m, IEnumerable&lt;int&gt; ks)
<a name="l00401"></a>00401         {
<a name="l00402"></a>00402             <span class="keywordflow">if</span> (m == 1)
<a name="l00403"></a>00403                 <span class="keywordflow">return</span> 1;
<a name="l00404"></a>00404             <span class="keywordflow">foreach</span> (<span class="keywordtype">int</span> k <span class="keywordflow">in</span> ks)
<a name="l00405"></a>00405             {
<a name="l00406"></a>00406                 m = <a class="code" href="class_p_a_1_1_solver.html#a39846e1a0944917a17981dd99fa5d6ad" title="Euclides algorithm. Calculate the greatest common divisor of a and b. It is assumed...">GCD</a>(m, Math.Abs(k));
<a name="l00407"></a>00407                 <span class="keywordflow">if</span> (m == 1)
<a name="l00408"></a>00408                     <span class="keywordflow">return</span> 1; <span class="comment">//no need to look any further</span>
<a name="l00409"></a>00409             }
<a name="l00410"></a>00410             <span class="keywordflow">return</span> m;
<a name="l00411"></a>00411         }
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="preprocessor">        #endregion</span>
<a name="l00415"></a>00415 <span class="preprocessor"></span>
<a name="l00419"></a>00419         <span class="keyword">internal</span> IEnumerable&lt;LinearFormula&gt; SimplifyBigOr(<span class="keywordtype">string</span> x, <span class="keywordtype">int</span> d, LinearFormula f)
<a name="l00420"></a>00420         {
<a name="l00421"></a>00421             <a class="code" href="class_p_a_1_1_solver.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Pushes the current context as a new backtrack point.">Push</a>();
<a name="l00422"></a>00422             <a class="code" href="class_p_a_1_1_solver.html#a66e717ba8a739ac2f4b1c22b1e49cda6" title="Adds the constraint f to the current context (throws ArgumentException if f includes...">AddConstraint</a>(f);
<a name="l00423"></a>00423             Term bound = z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8d71f67aa7ad851c2aa1ed5693737a77" title="Create an expression representing t[0] and t[1] and ....">MkAnd</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a1d13462c9cd1d38636a0c332148abae4" title="Create an expression representing t1 &amp;lt;= t2">MkLe</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(0, intSort), z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8ca84ff84e3488b10c965b5eaca146cc" title="Creates a new Constant of sort range  and named name .">MkConst</a>(x, intSort)),
<a name="l00424"></a>00424                                   z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a1d13462c9cd1d38636a0c332148abae4" title="Create an expression representing t1 &amp;lt;= t2">MkLe</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8ca84ff84e3488b10c965b5eaca146cc" title="Creates a new Constant of sort range  and named name .">MkConst</a>(x, intSort), z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(d, intSort)));
<a name="l00425"></a>00425             z3.AssertCnstr(bound);
<a name="l00426"></a>00426             PAModel model;
<a name="l00427"></a>00427             <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> sat = <a class="code" href="class_p_a_1_1_solver.html#ac602759713bc222730d629a83fa73ea1" title="Checks and returns a model if the constraints in the current context are satisfiable...">CheckAndGetModel</a>(out model);
<a name="l00428"></a>00428             <span class="comment">//yield all the possible instances of f</span>
<a name="l00429"></a>00429             <span class="keywordflow">while</span> (sat == <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a>.True)
<a name="l00430"></a>00430             {
<a name="l00431"></a>00431                 <span class="keywordtype">int</span> k = model.Evaluate(x);
<a name="l00432"></a>00432                 yield <span class="keywordflow">return</span> f.Subst(x, LinearTerm.Const(k));
<a name="l00433"></a>00433                 Term xNotk = z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a30035dfa3d793ae384fffeaf7dab5bab" title="Mk an expression representing not(a).">MkNot</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac074b41e6f212ec00da6cdc3245b492b" title="Creates the equality x  = y .">MkEq</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8ca84ff84e3488b10c965b5eaca146cc" title="Creates a new Constant of sort range  and named name .">MkConst</a>(x, intSort), z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(k, intSort)));
<a name="l00434"></a>00434                 z3.AssertCnstr(xNotk);
<a name="l00435"></a>00435                 sat = <a class="code" href="class_p_a_1_1_solver.html#ac602759713bc222730d629a83fa73ea1" title="Checks and returns a model if the constraints in the current context are satisfiable...">CheckAndGetModel</a>(out model);
<a name="l00436"></a>00436             }
<a name="l00437"></a>00437             <a class="code" href="class_p_a_1_1_solver.html#a701a584ce72cccbcce9cb0656b6c898b" title="Returns to the previously pushed context.">Pop</a>();
<a name="l00438"></a>00438         }
<a name="l00439"></a>00439 
<a name="l00443"></a>00443         <span class="keyword">internal</span> IEnumerable&lt;LinearFormula&gt; SimplifyBigOr2(<span class="keywordtype">string</span> x, <span class="keywordtype">int</span> d, LinearFormula f)
<a name="l00444"></a>00444         {
<a name="l00445"></a>00445             <a class="code" href="class_p_a_1_1_solver.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Pushes the current context as a new backtrack point.">Push</a>();
<a name="l00446"></a>00446             <a class="code" href="class_p_a_1_1_solver.html#a66e717ba8a739ac2f4b1c22b1e49cda6" title="Adds the constraint f to the current context (throws ArgumentException if f includes...">AddConstraint</a>(f);
<a name="l00447"></a>00447             <span class="keywordflow">foreach</span> (LinearFormula p <span class="keywordflow">in</span> SplitAndSearchForSatisfiableInstances(x, 0, d, f))
<a name="l00448"></a>00448                 yield <span class="keywordflow">return</span> p;
<a name="l00449"></a>00449             <a class="code" href="class_p_a_1_1_solver.html#a701a584ce72cccbcce9cb0656b6c898b" title="Returns to the previously pushed context.">Pop</a>();
<a name="l00450"></a>00450         }
<a name="l00451"></a>00451 
<a name="l00452"></a>00452         <span class="keyword">private</span> IEnumerable&lt;LinearFormula&gt; SplitAndSearchForSatisfiableInstances(<span class="keywordtype">string</span> x, <span class="keywordtype">int</span> lower, <span class="keywordtype">int</span> upper, LinearFormula f)
<a name="l00453"></a>00453         {
<a name="l00454"></a>00454             <span class="keywordflow">if</span> (lower &lt;= upper)
<a name="l00455"></a>00455             {
<a name="l00456"></a>00456                 <a class="code" href="class_p_a_1_1_solver.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Pushes the current context as a new backtrack point.">Push</a>();
<a name="l00457"></a>00457                 Term bound = z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8d71f67aa7ad851c2aa1ed5693737a77" title="Create an expression representing t[0] and t[1] and ....">MkAnd</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a1d13462c9cd1d38636a0c332148abae4" title="Create an expression representing t1 &amp;lt;= t2">MkLe</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(lower, intSort), z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8ca84ff84e3488b10c965b5eaca146cc" title="Creates a new Constant of sort range  and named name .">MkConst</a>(x, intSort)),
<a name="l00458"></a>00458                                        z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a1d13462c9cd1d38636a0c332148abae4" title="Create an expression representing t1 &amp;lt;= t2">MkLe</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8ca84ff84e3488b10c965b5eaca146cc" title="Creates a new Constant of sort range  and named name .">MkConst</a>(x, intSort), z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(upper, intSort)));
<a name="l00459"></a>00459                 z3.AssertCnstr(bound);
<a name="l00460"></a>00460                 PAModel model;
<a name="l00461"></a>00461                 <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> sat = <a class="code" href="class_p_a_1_1_solver.html#ac602759713bc222730d629a83fa73ea1" title="Checks and returns a model if the constraints in the current context are satisfiable...">CheckAndGetModel</a>(out model);
<a name="l00462"></a>00462                 <a class="code" href="class_p_a_1_1_solver.html#a701a584ce72cccbcce9cb0656b6c898b" title="Returns to the previously pushed context.">Pop</a>();
<a name="l00463"></a>00463                 <span class="keywordflow">if</span> (sat == <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a>.True)
<a name="l00464"></a>00464                 {
<a name="l00465"></a>00465                     <span class="keywordtype">int</span> k = model.Evaluate(x);
<a name="l00466"></a>00466                     yield <span class="keywordflow">return</span> f.Subst(x, LinearTerm.Const(k));
<a name="l00467"></a>00467                     <span class="keywordflow">foreach</span> (LinearFormula p <span class="keywordflow">in</span> SplitAndSearchForSatisfiableInstances(x, lower, k - 1, f))
<a name="l00468"></a>00468                         yield <span class="keywordflow">return</span> p;
<a name="l00469"></a>00469                     <span class="keywordflow">foreach</span> (LinearFormula p <span class="keywordflow">in</span> SplitAndSearchForSatisfiableInstances(x, k + 1, upper, f))
<a name="l00470"></a>00470                         yield <span class="keywordflow">return</span> p;
<a name="l00471"></a>00471                 }
<a name="l00472"></a>00472             }
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="preprocessor">        #region Z3 utilities</span>
<a name="l00477"></a>00477 <span class="preprocessor"></span>
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 
<a name="l00480"></a><a class="code" href="class_p_a_1_1_solver.html#a3daa7394088d49195c7ba5beb7768924">00480</a>         <span class="keyword">public</span> Term <a class="code" href="class_p_a_1_1_solver.html#a3daa7394088d49195c7ba5beb7768924" title="Convert the given linear term to a Z3 term.">ToZ3Term</a>(LinearTerm t)
<a name="l00481"></a>00481         {
<a name="l00482"></a>00482 
<a name="l00483"></a>00483             Term c = z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(t.Constant, intSort);
<a name="l00484"></a>00484             <span class="keywordflow">if</span> (t.IsConstant)
<a name="l00485"></a>00485                 <span class="keywordflow">return</span> z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(t.Constant, intSort);
<a name="l00486"></a>00486             Term[] args;
<a name="l00487"></a>00487             <span class="keywordtype">int</span> i = 0;
<a name="l00488"></a>00488             <span class="keywordflow">if</span> (t.Constant == 0)
<a name="l00489"></a>00489             {
<a name="l00490"></a>00490                 args = <span class="keyword">new</span> Term[t.NumberOfVariables];
<a name="l00491"></a>00491             }
<a name="l00492"></a>00492             <span class="keywordflow">else</span>
<a name="l00493"></a>00493             {
<a name="l00494"></a>00494                 args = <span class="keyword">new</span> Term[t.NumberOfVariables + 1];
<a name="l00495"></a>00495                 args[0] = z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(t.Constant, intSort);
<a name="l00496"></a>00496                 i = 1;
<a name="l00497"></a>00497             }
<a name="l00498"></a>00498             <span class="keywordflow">foreach</span> (VarType x <span class="keywordflow">in</span> t.Variables)
<a name="l00499"></a>00499             {
<a name="l00500"></a>00500                 args[i++] = z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a98a8b6f47bf9d264c62c3b58bebdc554" title="Create an expression representing t[0] * t[1] * ....">MkMul</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(t.Coefficient(x), intSort), z3Var(x));
<a name="l00501"></a>00501             }
<a name="l00502"></a>00502             <span class="keywordflow">return</span> z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#aa1fd6d8365b9c75df1a6aee5f3257c93" title="Create an expression representing t[0] + t[1] + ....">MkAdd</a>(args);
<a name="l00503"></a>00503         }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505         <span class="keyword">internal</span> Term z3Var(VarType v)
<a name="l00506"></a>00506         {
<a name="l00507"></a>00507             <span class="comment">//TermKind.</span>
<a name="l00508"></a>00508             <span class="keywordflow">return</span> z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8ca84ff84e3488b10c965b5eaca146cc" title="Creates a new Constant of sort range  and named name .">MkConst</a>(v, intSort);
<a name="l00509"></a>00509         }
<a name="l00510"></a>00510 
<a name="l00515"></a><a class="code" href="class_p_a_1_1_solver.html#a6b6466a1a3c67709560613ac38697364">00515</a>         <span class="keyword">public</span> Term <a class="code" href="class_p_a_1_1_solver.html#a6b6466a1a3c67709560613ac38697364" title="Convert the given PA formula t to a Z3 formula (throws ArgumentException if t includes...">ToZ3Formula</a>(LinearFormula t)
<a name="l00516"></a>00516         {
<a name="l00517"></a>00517             <span class="keywordflow">if</span> (t is LinearAtom)
<a name="l00518"></a>00518             {
<a name="l00519"></a>00519                 LE le = t as LE;
<a name="l00520"></a>00520                 <span class="keywordflow">if</span> (le != null)
<a name="l00521"></a>00521                     <span class="keywordflow">return</span> z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a1d13462c9cd1d38636a0c332148abae4" title="Create an expression representing t1 &amp;lt;= t2">MkLe</a>(<a class="code" href="class_p_a_1_1_solver.html#a3daa7394088d49195c7ba5beb7768924" title="Convert the given linear term to a Z3 term.">ToZ3Term</a>(le.T), zero);
<a name="l00522"></a>00522                 DIV div = (DIV)t;
<a name="l00523"></a>00523                 <span class="keywordflow">if</span> (div.IsDiv)
<a name="l00524"></a>00524                     <span class="keywordflow">return</span> z3MkDiv(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(div.D, intSort), <a class="code" href="class_p_a_1_1_solver.html#a3daa7394088d49195c7ba5beb7768924" title="Convert the given linear term to a Z3 term.">ToZ3Term</a>(div.T));
<a name="l00525"></a>00525                 <span class="keywordflow">else</span>
<a name="l00526"></a>00526                     <span class="keywordflow">return</span> z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a30035dfa3d793ae384fffeaf7dab5bab" title="Mk an expression representing not(a).">MkNot</a>(z3MkDiv(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(div.D, intSort), <a class="code" href="class_p_a_1_1_solver.html#a3daa7394088d49195c7ba5beb7768924" title="Convert the given linear term to a Z3 term.">ToZ3Term</a>(div.T)));
<a name="l00527"></a>00527             }
<a name="l00528"></a>00528             <span class="keywordflow">else</span>
<a name="l00529"></a>00529             {
<a name="l00530"></a>00530                 Disjunction disj = t as Disjunction;
<a name="l00531"></a>00531                 <span class="keywordflow">if</span> (disj != null)
<a name="l00532"></a>00532                 {
<a name="l00533"></a>00533                     Term[] disjs = <span class="keyword">new</span> Term[disj.fms.Count];
<a name="l00534"></a>00534                     <span class="keywordtype">int</span> i = 0;
<a name="l00535"></a>00535                     <span class="keywordflow">foreach</span> (LinearFormula f <span class="keywordflow">in</span> disj.fms)
<a name="l00536"></a>00536                         disjs[i++] = <a class="code" href="class_p_a_1_1_solver.html#a6b6466a1a3c67709560613ac38697364" title="Convert the given PA formula t to a Z3 formula (throws ArgumentException if t includes...">ToZ3Formula</a>(f);
<a name="l00537"></a>00537                     <span class="keywordflow">return</span> z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#abc7813b246aa0a214b58d61f742f0808" title="Create an expression representing t[0] or t[1] or ....">MkOr</a>(disjs);
<a name="l00538"></a>00538                 }
<a name="l00539"></a>00539                 Conjunction conj = t as Conjunction;
<a name="l00540"></a>00540                 <span class="keywordflow">if</span> (conj != null)
<a name="l00541"></a>00541                 {
<a name="l00542"></a>00542                     Term[] conjs = <span class="keyword">new</span> Term[conj.fms.Count];
<a name="l00543"></a>00543                     <span class="keywordtype">int</span> i = 0;
<a name="l00544"></a>00544                     <span class="keywordflow">foreach</span> (LinearFormula f <span class="keywordflow">in</span> conj.fms)
<a name="l00545"></a>00545                         conjs[i++] = <a class="code" href="class_p_a_1_1_solver.html#a6b6466a1a3c67709560613ac38697364" title="Convert the given PA formula t to a Z3 formula (throws ArgumentException if t includes...">ToZ3Formula</a>(f);
<a name="l00546"></a>00546                     <span class="keywordflow">return</span> z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8d71f67aa7ad851c2aa1ed5693737a77" title="Create an expression representing t[0] and t[1] and ....">MkAnd</a>(conjs);
<a name="l00547"></a>00547                 }
<a name="l00548"></a>00548                 BigOR bq = t as BigOR;
<a name="l00549"></a>00549                 <span class="keywordflow">if</span> (bq != null)
<a name="l00550"></a>00550                 {
<a name="l00551"></a>00551                     List&lt;Term&gt; bounds = <span class="keyword">new</span> List&lt;Term&gt;();
<a name="l00552"></a>00552                     <span class="keywordflow">foreach</span> (BoundedVariable v <span class="keywordflow">in</span> bq.Vars)
<a name="l00553"></a>00553                     {
<a name="l00554"></a>00554                         Term bound = z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8d71f67aa7ad851c2aa1ed5693737a77" title="Create an expression representing t[0] and t[1] and ....">MkAnd</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a1d13462c9cd1d38636a0c332148abae4" title="Create an expression representing t1 &amp;lt;= t2">MkLe</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(v.lower, intSort), z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8ca84ff84e3488b10c965b5eaca146cc" title="Creates a new Constant of sort range  and named name .">MkConst</a>(v.var, intSort)),
<a name="l00555"></a>00555                                               z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a1d13462c9cd1d38636a0c332148abae4" title="Create an expression representing t1 &amp;lt;= t2">MkLe</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8ca84ff84e3488b10c965b5eaca146cc" title="Creates a new Constant of sort range  and named name .">MkConst</a>(v.var, intSort), z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac9d2339a750d5ea92b6ec341d2b308c8" title="Create a Term of a given sort.">MkNumeral</a>(v.upper, intSort)));
<a name="l00556"></a>00556                         bounds.Add(bound);
<a name="l00557"></a>00557                     }
<a name="l00558"></a>00558                     Term divs = <a class="code" href="class_p_a_1_1_solver.html#a6b6466a1a3c67709560613ac38697364" title="Convert the given PA formula t to a Z3 formula (throws ArgumentException if t includes...">ToZ3Formula</a>(bq.Divs);
<a name="l00559"></a>00559                     
<a name="l00560"></a>00560                     Term f = <a class="code" href="class_p_a_1_1_solver.html#a6b6466a1a3c67709560613ac38697364" title="Convert the given PA formula t to a Z3 formula (throws ArgumentException if t includes...">ToZ3Formula</a>(bq.F);
<a name="l00561"></a>00561                     Term bf = z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a8d71f67aa7ad851c2aa1ed5693737a77" title="Create an expression representing t[0] and t[1] and ....">MkAnd</a>(<span class="keyword">new</span> Term[]{z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#abc7813b246aa0a214b58d61f742f0808" title="Create an expression representing t[0] or t[1] or ....">MkOr</a>(bounds.ToArray()),divs,f});
<a name="l00562"></a>00562                     <span class="keywordflow">return</span> bf;
<a name="l00563"></a>00563                 }
<a name="l00564"></a>00564                 <span class="keywordflow">throw</span> <span class="keyword">new</span> ArgumentException(<span class="stringliteral">&quot;Conversion is not supported&quot;</span>);
<a name="l00565"></a>00565             }
<a name="l00566"></a>00566         }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568         Term z3MkDiv(Term x, Term y)
<a name="l00569"></a>00569         {
<a name="l00570"></a>00570             <span class="keywordflow">return</span> z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#ac074b41e6f212ec00da6cdc3245b492b" title="Creates the equality x  = y .">MkEq</a>(z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a4e92d3569de7bba7ef46ba503148150b" title="Create an expression representing t1 mod t2.">MkMod</a>(y, x), zero);
<a name="l00571"></a>00571         }
<a name="l00572"></a>00572 
<a name="l00578"></a><a class="code" href="class_p_a_1_1_solver.html#a5381b47833667566da3207539dfbe69b">00578</a>         <span class="keyword">public</span> <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_p_a_1_1_solver.html#a5381b47833667566da3207539dfbe69b" title="Checks if f is satisfiable without changing the current context. Returns LBool.True...">IsSat</a>(LinearFormula f)
<a name="l00579"></a>00579         {
<a name="l00580"></a>00580             <a class="code" href="class_p_a_1_1_solver.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Pushes the current context as a new backtrack point.">Push</a>();
<a name="l00581"></a>00581             <a class="code" href="class_p_a_1_1_solver.html#a66e717ba8a739ac2f4b1c22b1e49cda6" title="Adds the constraint f to the current context (throws ArgumentException if f includes...">AddConstraint</a>(f);
<a name="l00582"></a>00582             <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> res = <a class="code" href="class_p_a_1_1_solver.html#a338b5a83abb0751e1485885f7f6f513a" title="Returns LBool.True if the current constraints are satisfiable Returns LBool.Undef...">Check</a>();
<a name="l00583"></a>00583             <a class="code" href="class_p_a_1_1_solver.html#a701a584ce72cccbcce9cb0656b6c898b" title="Returns to the previously pushed context.">Pop</a>();
<a name="l00584"></a>00584             <span class="keywordflow">return</span> res;
<a name="l00585"></a>00585         }
<a name="l00586"></a>00586 
<a name="l00591"></a><a class="code" href="class_p_a_1_1_solver.html#a338b5a83abb0751e1485885f7f6f513a">00591</a>         <span class="keyword">public</span> <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_p_a_1_1_solver.html#a338b5a83abb0751e1485885f7f6f513a" title="Returns LBool.True if the current constraints are satisfiable Returns LBool.Undef...">Check</a>()
<a name="l00592"></a>00592         {
<a name="l00593"></a>00593             <span class="keywordflow">return</span> z3.Check();
<a name="l00594"></a>00594         }
<a name="l00595"></a>00595 
<a name="l00601"></a><a class="code" href="class_p_a_1_1_solver.html#a53a0946303084bd8355a020f6fcadc9f">00601</a>         <span class="keyword">public</span> <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_p_a_1_1_solver.html#a5381b47833667566da3207539dfbe69b" title="Checks if f is satisfiable without changing the current context. Returns LBool.True...">IsSat</a>(LinearFormula f, out PAModel model)
<a name="l00602"></a>00602         {
<a name="l00603"></a>00603             <a class="code" href="class_p_a_1_1_solver.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Pushes the current context as a new backtrack point.">Push</a>();
<a name="l00604"></a>00604             <a class="code" href="class_p_a_1_1_solver.html#a66e717ba8a739ac2f4b1c22b1e49cda6" title="Adds the constraint f to the current context (throws ArgumentException if f includes...">AddConstraint</a>(f);
<a name="l00605"></a>00605             <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> res = <a class="code" href="class_p_a_1_1_solver.html#ac602759713bc222730d629a83fa73ea1" title="Checks and returns a model if the constraints in the current context are satisfiable...">CheckAndGetModel</a>(out model);
<a name="l00606"></a>00606             <a class="code" href="class_p_a_1_1_solver.html#a701a584ce72cccbcce9cb0656b6c898b" title="Returns to the previously pushed context.">Pop</a>();
<a name="l00607"></a>00607             <span class="keywordflow">return</span> res;
<a name="l00608"></a>00608         }
<a name="l00609"></a>00609 
<a name="l00613"></a><a class="code" href="class_p_a_1_1_solver.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c">00613</a>         <span class="keyword">public</span> <span class="keywordtype">void</span> <a class="code" href="class_p_a_1_1_solver.html#a447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Pushes the current context as a new backtrack point.">Push</a>()
<a name="l00614"></a>00614         {
<a name="l00615"></a>00615             z3.Push();
<a name="l00616"></a>00616         }
<a name="l00617"></a>00617 
<a name="l00621"></a><a class="code" href="class_p_a_1_1_solver.html#a701a584ce72cccbcce9cb0656b6c898b">00621</a>         <span class="keyword">public</span> <span class="keywordtype">void</span> <a class="code" href="class_p_a_1_1_solver.html#a701a584ce72cccbcce9cb0656b6c898b" title="Returns to the previously pushed context.">Pop</a>()
<a name="l00622"></a>00622         {
<a name="l00623"></a>00623             z3.Pop();
<a name="l00624"></a>00624         }
<a name="l00625"></a>00625 
<a name="l00630"></a><a class="code" href="class_p_a_1_1_solver.html#a66e717ba8a739ac2f4b1c22b1e49cda6">00630</a>         <span class="keyword">public</span> <span class="keywordtype">void</span> <a class="code" href="class_p_a_1_1_solver.html#a66e717ba8a739ac2f4b1c22b1e49cda6" title="Adds the constraint f to the current context (throws ArgumentException if f includes...">AddConstraint</a>(LinearFormula f)
<a name="l00631"></a>00631         {
<a name="l00632"></a>00632             Term zf = <a class="code" href="class_p_a_1_1_solver.html#a6b6466a1a3c67709560613ac38697364" title="Convert the given PA formula t to a Z3 formula (throws ArgumentException if t includes...">ToZ3Formula</a>(f);
<a name="l00633"></a>00633             z3.AssertCnstr(zf);
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635 
<a name="l00640"></a><a class="code" href="class_p_a_1_1_solver.html#ac602759713bc222730d629a83fa73ea1">00640</a>         <span class="keyword">public</span> <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> <a class="code" href="class_p_a_1_1_solver.html#ac602759713bc222730d629a83fa73ea1" title="Checks and returns a model if the constraints in the current context are satisfiable...">CheckAndGetModel</a>(out PAModel model)
<a name="l00641"></a>00641         {
<a name="l00642"></a>00642             <a class="code" href="class_microsoft_1_1_z3_1_1_model.html" title="A Model contains interpretations (assignments) of constants and functions.">Model</a> z3model;
<a name="l00643"></a>00643             <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a> res = z3.CheckAndGetModel(out z3model);
<a name="l00644"></a>00644             <span class="keywordflow">if</span> (res == <a class="code" href="group__mapi.html#ga2a6d3c91705945a27b9f264add662179" title="Lifted Booleans.">LBool</a>.True)
<a name="l00645"></a>00645                 model = <span class="keyword">new</span> PAModel(<span class="keyword">this</span>, z3model);
<a name="l00646"></a>00646             <span class="keywordflow">else</span>
<a name="l00647"></a>00647                 model = null;
<a name="l00648"></a>00648             <span class="keywordflow">return</span> res;
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 <span class="preprocessor">        #endregion</span>
<a name="l00652"></a>00652 <span class="preprocessor"></span>
<a name="l00653"></a>00653 <span class="preprocessor">        #region IDisposable Members</span>
<a name="l00654"></a>00654 <span class="preprocessor"></span>
<a name="l00655"></a>00655         <span class="keyword">public</span> <span class="keywordtype">void</span> Dispose()
<a name="l00656"></a>00656         {
<a name="l00657"></a>00657             z3.<a class="code" href="class_microsoft_1_1_z3_1_1_context.html#a6e2d745cdb7a7b983f861ed6a9a541a7" title="Disposes of the context.">Dispose</a>();
<a name="l00658"></a>00658         }
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 <span class="preprocessor">        #endregion</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span>    }
<a name="l00662"></a>00662 }
</pre></div></div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Aug 9 16:34:43 2012
</BODY>
</HTML>
