 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: theorem prover" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: Theorem Prover</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">

<table>
<tr>
<th style="width:120px"><a style="border=0px" class="el" href="index.html"><img border="0" src="z3.png" alt="Z3" /></a></th>
<th style="width:100%">
<div id="nav">
<ul>
<li><a href="download.html">Download</a></li>
<li>/</li>
<li><a href="documentation.html#tutorial">Tutorials</a></li>
<li>/</li>
<li><a href="documentation.html">Documentation</a></li>
<li>/</li>
<li><a href="mail.html">Contact</a></li>
<li>/</li>
<li><a href="faq.html">FAQ</a></li>
<li>/</li>
<li><a href="awards.html">Awards</a></li>
<li>/</li>
<li><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx">RiSE</a></li>
</ul>
</div>
</th>
<th style="width:120px">
<a style="border=0px" class="el" href="http://research.microsoft.com"><img border="0" src="logo_msr.gif" alt="Microsoft Research" />
</th>
</tr>
</table>

<!-- <p> -->
<!-- <img align="middle" src="z3.png" alt="Z3" /> -->
<!-- <table class="centered-small"> -->
<!--   <tr> -->
<!--     <th><a href="index.html"><span>Home</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="documentation.html"><span>Docs</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="download.html"><span>Download</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="mail.html"><span>Mail</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="faq.html"><span>FAQ</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="awards.html"><span>Awards</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com/en-us/groups/rise/default.aspx"><span>RiSE</span></a></th> -->
<!--     <th> &bull; </th> -->
<!--     <th><a href="http://research.microsoft.com"><span>MSR</span></a></th> -->
<!--   </tr> -->
<!-- </table> -->
<!-- </p> -->

<!-- Generated by Doxygen 1.6.3 -->
<div class="contents">


<h1><a class="anchor" id="muzpdr">The PDR algorithm in muZ. </a></h1><p>This section describes, by a few examples, using the PDR algorithm in Z3.</p>
<p>To enable the PDR engine, use Z3 with the option <code>DL_ENGINE=1</code>. Alternatively, you can set this option in the input file as is done in the following examples.</p>
<p>For example <code>z3.exe sum.smt2</code> where <code>sum.smt2</code> is: </p>
<div class="fragment"><pre class="fragment">(<span class="keyword">set</span>-option :dl-engine 1)
(<span class="keyword">set</span>-option :dl-pdr-use-farkas <span class="keyword">true</span>)
(declare-rel sum (Int Int))
(declare-var n Int)
(declare-var m Int)

(rule (=&gt; (&lt;= n 0) (sum n 0)))
(rule (=&gt; (and (&gt; n 0) (sum (- n 1) m)) (sum n (+ m n))))

(query (and (sum n m) (&lt; m n)) :print-certificate true)
</pre></div><p>Produces </p>
<div class="fragment"><pre class="fragment">unsat
(define-fun query!0 ((query!0_0_0 Int) (query!0_1_0 Int)) Bool
                    <span class="keyword">false</span>)
(define-fun sum ((sum_0_0 Int) (sum_1_0 Int)) Bool
                (and (&gt;= sum_1_0 0) (&lt;= (+ (* (- 1) sum_1_0) sum_0_0) 0)))
</pre></div><p>We use the option <code>:print-certificate true</code> to retrieve a certificate that the query is infeasible. The certificate is provided as a set of definitions for the recursive relations. These definitions are inductive invariants that imply the query is infeasible.</p>
<p>Other options to <code>query</code> are:</p>
<ul>
<li><code>print-answer</code>, default <code>true</code> displays one satisfiable instance to the query if there is one.</li>
</ul>
<ul>
<li><code>print-statistics</code>, default <code>false</code> displays statistics information.</li>
</ul>
<ul>
<li><code>timeout</code>, default is unbounded. Set a timeout on the query. Checking for expiry of the timeout is done periodically and is not guaranteed to be checked instantaneously.</li>
</ul>
<p>The option <code>:dl-use-farkas true</code> turns on solver generalization for linear (real) arithmetic. On the above example Z3 diverges without this option and converges when using the option. Other options are given in examples below.</p>
<p>This example illustrates the use of generalization during backward propagation. The option <code>dl-pdr-use-precond-generalizer</code> causes predicates from the rules that are used during backwards propagation to be included in the current state. These predicates are then available for closing branches. Since both the concrete counter-example, as well as predicates can be used for closing branches, we also enable <code>dl-pdr-use-multi-core-generalizer</code> to extract multiple cores during conflict detection. Then blocking clauses have the option of also using the auxiliary (weaker) predicates that are propagated.</p>
<div class="fragment"><pre class="fragment">(<span class="keyword">set</span>-option :dl-engine 1)
(<span class="keyword">set</span>-option :dl-pdr-use-farkas <span class="keyword">true</span>)
(<span class="keyword">set</span>-option :dl-pdr-use-precond-generalizer <span class="keyword">true</span>)
(<span class="keyword">set</span>-option :dl-pdr-use-multi-core-generalizer <span class="keyword">true</span>)
(declare-rel R (Int Int))
(declare-var x Int)
(declare-var y Int)

(rule (R 0 0))
(rule (=&gt; (R x y) (R (+ x 1) (+ y 2))))
(query (and (R x y) (not (= (* 2 x) y))))
</pre></div><p>This example illustrates the real-time two process Fishcer mutual exclusion algorithm. Z3 is faster with relevancy propagation set to 0 (all atoms participate in unit and theory-propagation).</p>
<div class="fragment"><pre class="fragment">(<span class="keyword">set</span>-option :dl-engine 1)
(<span class="keyword">set</span>-option :relevancy 0)
(<span class="keyword">set</span>-option :dl-pdr-use-farkas <span class="keyword">true</span>)
(declare-datatypes () ((Location (Sleeping) (Waiting) (Trying) (Critical))))
(define-fun A () Real 1.0)
(define-fun B () Real 2.0)
(define-sort Clock () Real)
(declare-var delta Real)
(declare-var a0 Location)
(declare-var c0 Clock)
(declare-var a0_n Location)
(declare-var c0_n Clock)
(declare-rel T0 (Location Location Clock Clock Int Int))
(declare-var a1 Location)
(declare-var c1 Clock)
(declare-var a1_n Location)
(declare-var c1_n Clock)
(declare-rel T1 (Location Location Clock Clock Int Int))
(declare-var l Int)
(declare-var l_n Int)
(declare-rel R (Location Location Clock Clock Int))
(define-fun N () Int 2)
(rule (R Sleeping Sleeping 0.0 0.0 N))
(rule (=&gt; (and (R a0 a1 c0 c1 l) (T0 a0 a0_n c0 c0_n l l_n) (= a1 a1_n) (= c1 c1_n)) 
          (R a0_n a1_n c0_n c1_n l_n)))
(rule (=&gt; (and (R a0 a1 c0 c1 l) (T1 a1 a1_n c1 c1_n l l_n) (= a0 a0_n) (= c0 c0_n)) 
          (R a0_n a1_n c0_n c1_n l_n)))
(rule (=&gt; (= l N) (T0 Sleeping Waiting c0 0.0 l l)))
(rule (=&gt; (&lt;= c0 A) (T0 Waiting Trying c0 0.0 l 0)))
(rule (=&gt; (&gt;= c0 B) (not (= l 0)) (T0 Trying Sleeping c0 c0 l l)))
(rule (=&gt; (&gt;= c0 B) (= l 0) (T0 Trying Critical c0 c0 l l)))
(rule (T0 Critical Sleeping c0 c0 l N))

(rule (=&gt; (= l N) (T1 Sleeping Waiting c1 0.0 l l)))
(rule (=&gt; (&lt;= c1 A) (T1 Waiting Trying c1 0.0 l 1)))
(rule (=&gt; (&gt;= c1 B) (not (= l 1)) (T1 Trying Sleeping c1 c1 l l)))
(rule (=&gt; (&gt;= c1 B) (= l 1) (T1 Trying Critical c1 c1 l l)))
(rule (T1 Critical Sleeping c1 c1 l N))

(rule (=&gt; (and (R a0 a1 c0 c1 l) (&lt; 0.0 delta) 
               (=&gt; (= a0 Waiting) (&lt;= (+ c0 delta) A)) 
               (=&gt; (= a1 Waiting) (&lt;= (+ c1 delta) A))) 
          (R a0 a1 (+ c0 delta) (+ c1 delta) l)))
(query (and (R a0 a1 c0 c1 l) (= a0 Critical) (= a1 Critical)))
</pre></div><p>This example illustrates a four process version of the Bakery mutual-exclusion program.</p>
<div class="fragment"><pre class="fragment">(<span class="keyword">set</span>-option :dl-engine 1)
(<span class="keyword">set</span>-option :dl-pdr-use-farkas <span class="keyword">true</span>)
(<span class="keyword">set</span>-option :relevancy 0)
(define-fun Max ((x Int) (y Int)) Int (ite (&gt; x y) x y))
(define-sort Loc () Int)
(define-fun L0 () Int 0)
(define-fun L1 () Int 1)
(define-fun L2 () Int 2)
(declare-rel state ( Loc Loc Loc Loc Int Int Int Int))
(declare-rel step ( Loc Loc Loc Loc Loc Loc Loc Loc Int Int Int Int Int Int Int
Int))
(declare-rel step1 (Loc Loc Int Int Int Int Int))
(declare-var y0 Int)
(declare-var loc0 Int)
(declare-var y0_n Int)
(declare-var loc0_n Int)
(declare-var y1 Int)
(declare-var loc1 Int)
(declare-var y1_n Int)
(declare-var loc1_n Int)
(declare-var y2 Int)
(declare-var loc2 Int)
(declare-var y2_n Int)
(declare-var loc2_n Int)
(declare-var y3 Int)
(declare-var loc3 Int)
(declare-var y3_n Int)
(declare-var loc3_n Int)
(rule (state L0 L0 L0 L0 0 0 0 0))
(rule (=&gt; 
       (and (state loc0 loc1 loc2 loc3 y0 y1 y2 y3) 
          (step loc0 loc0_n loc1 loc1_n loc2 loc2_n loc3 loc3_n 
                y0 y0_n y1 y1_n y2 y2_n y3 y3_n)) 
          (state loc0_n loc1_n loc2_n loc3_n y0_n y1_n y2_n y3_n)))
(rule (=&gt; (step1 loc0 loc0_n y0 y1 y2 y3 y0_n) 
          (step loc0 loc0_n loc1 loc1 loc2 loc2 loc3 loc3 y0 y0_n y1 y1 y2 y2 y3 y3)))
(rule (=&gt; (step1 loc1 loc1_n y1 y0 y2 y3 y1_n) 
          (step loc0 loc0 loc1 loc1_n loc2 loc2 loc3 loc3 y0 y0 y1 y1_n y2 y2 y3 y3)))
(rule (=&gt; (step1 loc2 loc2_n y2 y0 y1 y3 y2_n) 
          (step loc0 loc0 loc1 loc1 loc2 loc2_n loc3 loc3 y0 y0 y1 y1 y2 y2_n y3 y3)))
(rule (=&gt; (step1 loc3 loc3_n y3 y0 y1 y2 y3_n) 
          (step loc0 loc0 loc1 loc1 loc2 loc2 loc3 loc3_n y0 y0 y1 y1 y2 y2 y3 y3_n)))
(rule (step1 L0 L1 y0 y1 y2 y3 (+ (Max (Max y1 y2) y3) 1)))
(rule (=&gt; (and (or (&lt;= y0 y1) (= y1 0)) (or (&lt;= y0 y2) (= y2 0)) (or (&lt;= y0 y3)
(= y3 0))) (step1 L1 L2 y0 y1 y2 y3 y0)))
(rule (step1 L2 L0 y0 y1 y2 y3 0))
(query (state L2 L2 loc2 loc3 y0 y1 y2 y3))
</pre></div><p>These samples are adapted from Predicate Abstraction and CEGAR for Higher-Order Model Checking, Kobayashi et.al. PLDI 2011<a href="http://www.kb.ecei.tohoku.ac.jp/~uhiro/">Links to the paper and web-demo</a>.</p>
<p>The main idea is to encode closures as abstract data-types. There is a single <code>Eval</code> predicate that takes three arguments. The first two arguments are a beta-redex, and the third argument is the result. The rules for <code>Eval</code> follow an operational semantics of the functional programming language being modeled. Additional arguments can be added for programs that throw exceptions.</p>
<div class="fragment"><pre class="fragment">; let max max2 x y z = max2 (max2 x y) z
; let f x y = <span class="keywordflow">if</span> x &gt; y then x <span class="keywordflow">else</span> y
; assert (f (max f x y z) x) = (max f x y z)

(<span class="keyword">set</span>-option :dl-engine 1)
(<span class="keyword">set</span>-option :dl-pdr-use-farkas <span class="keyword">true</span>)

(declare-datatypes () 
   ((Expr (Max) (f) (I (i Int)) (App (fn Expr) (arg Expr)))))
(declare-rel Eval (Expr Expr Expr))

(declare-var x  Expr)
(declare-var y  Expr)
(declare-var z  Expr)
(declare-var n  Expr)
(declare-var m  Expr)
(declare-var k  Expr)
(declare-var r1 Expr)
(declare-var r2 Expr)
(declare-var max2 Expr)

(declare-var err  Bool)
(declare-var err0 Bool)
(declare-var err1 Bool)
(declare-var xi Int)
(declare-var yi Int)


(rule (=&gt; (and 
            (Eval (App max2 x)  y r1)
            (Eval (App max2 r1) z r2)
          )
          (Eval (App (App (App Max max2) x) y) z r2)))

(rule (=&gt; (&gt;= xi yi) (Eval (App f (I xi)) (I yi) (I xi))))
(rule (=&gt; (&lt; xi yi)  (Eval (App f (I xi)) (I yi) (I yi))))
 
(query (and 
        (Eval (App (App (App Max f) x) y) z m) 
        (Eval (App f x) m k) 
        (not (= k m))))
</pre></div><div class="fragment"><pre class="fragment">; f x y = assert (not (x() &gt; 0 &amp;&amp; y() &lt; 0))
; h x y = x
; g n = f (h n) (h n)
; assert g m is safe.

(set-option :dl-engine 1)
(declare-datatypes () ((Expr (App (fn Expr) (arg Expr)) (I (i Int)) (F) (G) (H) (Unit))))
(declare-rel Eval (Expr Expr Bool))
(declare-var x Expr)
(declare-var y Expr)
(declare-var z Expr)
(declare-var x1 Int)
(declare-var y1 Int)
(declare-var ok1 Bool)
(declare-var ok2 Bool)
(declare-var ok Bool)


(rule (=&gt; (and (Eval x (I x1) ok1)
               (Eval y (I y1) ok2))
          (Eval (App (App F x) y) Unit (and ok1 ok2 (not (and (&gt; x1 0) (&lt; y1 0)))))))


(rule (Eval (App (App H x) y) x <span class="keyword">true</span>))

(rule (=&gt; (Eval (App (App F (App H x)) (App H x)) z ok) (Eval (App G x) z ok)))

(query (Eval (App G x) y <span class="keyword">false</span>))
</pre></div><div class="fragment"><pre class="fragment">;let c q = () in
;let b x q = x 1 in
;let a x y q = <span class="keywordflow">if</span> q=0 then (x 0; y 0) <span class="keywordflow">else</span> assert <span class="keyword">false</span> in
;let rec f n x q = <span class="keywordflow">if</span> n &lt;= 0 then x q <span class="keywordflow">else</span> a x (f (n-1) (b x)) q in
;let s n q = f n c q in
;  s n 0

(<span class="keyword">set</span>-option :dl-engine 1)
(declare-datatypes () ((Expr (App (fn Expr) (arg Expr))
                             (I (i Int))
                             (F) (C) (B) (A) (Unit))))

(declare-rel Eval (Expr Expr Expr Bool))
(declare-var x Expr)
(declare-var y Expr)
(declare-var q Expr)
(declare-var r1 Expr)
(declare-var r2 Expr)
(declare-var r Expr)
(declare-var ok Bool)
(declare-var ok1 Bool)
(declare-var ok2 Bool)
(declare-var n Int)

(rule (Eval C q Unit <span class="keyword">true</span>))
(rule (=&gt; (Eval x (I 1) r ok) (Eval (App B x) q r ok)))
(rule (=&gt; (and
           (Eval x (I 0) r1 ok1)
           (Eval y (I 0) r2 ok2)
          )
          (Eval (App (App A x) y) (I n) Unit (and ok1 ok2 (= n 0)))))

(rule (=&gt; (and (&lt;= n 0) (Eval x q r ok)) (Eval (App (App F (I n)) x) q r ok)))
(rule (=&gt; (and (&gt; n 0) (Eval (App (App A x)
                             (App (App F (I (- n 1))) (App B x))) q r ok))
          (Eval (App (App F (I n)) x) q r ok)))

; unsat
(query (Eval (App (App F (I 0)) C) q r <span class="keyword">false</span>))

; sat
(query (Eval (App (App F (I n)) C) q r <span class="keyword">false</span>))
</pre></div><div class="fragment"><pre class="fragment">; rec f g x = <span class="keywordflow">if</span> x &gt;= 0 then g x <span class="keywordflow">else</span> f (f g) (g x)
; let succ x = x + 1
; assert (f succ n &gt;= 0)

(<span class="keyword">set</span>-option :dl-pdr-use-farkas <span class="keyword">true</span>)
(declare-datatypes () ((Expr (App (fn Expr) (arg Expr)) (I (i Int)) (F) (Succ))))

(declare-rel Eval (Expr Expr Expr))
(declare-var x Expr)
(declare-var g Expr)
(declare-var y Expr)
(declare-var xi Int)
(declare-var yi Int)

(rule (=&gt; (and (&gt;= xi 0) (Eval g (I xi) y)) (Eval (App F g) (I xi) y)))
(rule (=&gt; (and (&lt; xi 0) (Eval (App F (App F g)) (App g (I xi)) y))
                         (Eval (App F g) (I xi) y)))

(rule (Eval Succ (I xi) (I (+ xi 1))))

(query (and (Eval (App F Succ) (I 0) (I yi)) (&lt; yi 0)))
</pre></div><div class="fragment"><pre class="fragment">; g x y = x
; twice f x y = f (f x) y
; neg x y = -x()
; assert (=&gt; (n &gt;= 0 =&gt; twice neg (g n) () &gt;= 0))

(<span class="keyword">set</span>-option :dl-engine 1)
(<span class="keyword">set</span>-option :dl-pdr-use-farkas <span class="keyword">true</span>)
(declare-datatypes () ((Expr (App (fn Expr) (arg Expr))
                             (I (i Int)) (G) (Neg) (Twice) (Unit))))

(declare-rel Eval (Expr Expr Expr))
(declare-var x Expr)
(declare-var y Expr)
(declare-var z Expr)
(declare-var f Expr)
(declare-var n Int)
(declare-var g Expr)
(declare-var xi Int)
(declare-var yi Int)

(rule (Eval (App G x) y x))
(rule (=&gt; (Eval (App f (App f x)) y z) (Eval (App (App Twice f) x) y z)))
(rule (=&gt; (Eval x Unit (I xi)) (Eval (App Neg x) y (I (- xi)))))

; unsat
(query (and
        (&gt;= n 0)
        (Eval (App (App Twice Neg) (App G (I n))) Unit (I xi))
        (&lt; xi 0))
       :print-certificate <span class="keyword">true</span>)


; sat
(query (and
        (&gt;= n 0)
        (Eval (App (App Twice Neg) (App G (I n))) Unit (I xi))
        (&gt; xi 0))
       :print-certificate <span class="keyword">true</span>)
</pre></div><p> Sample run: </p>
<div class="fragment"><pre class="fragment">z3.exe neg.smt2 

unsat
(define-fun query!0 ((query!0_0_0 Int) (query!0_1_0 Int)) Bool
                    <span class="keyword">false</span>)
(define-fun Eval ((Eval_0_0 Expr) (Eval_1_0 Expr) (Eval_2_0 Expr)) Bool
                 (let ((a!1 (+ (* (- 1) (i Eval_2_0)) (i (arg (arg Eval_0_0)))))

                       (a!2 (= (App (fn (fn Eval_0_0)) (arg (fn Eval_0_0)))
                               (fn (App (fn Eval_0_0) (arg Eval_0_0)))))
                       (a!4 (i (arg (arg (arg Eval_0_0)))))
                       (a!6 (= (fn (arg (arg Eval_0_0))) G))
                       (a!7 (= Neg (fn (App (fn Eval_0_0) (arg Eval_0_0)))))
                       (a!9 (&lt;= (+ (* (- 1) (i Eval_2_0)) (i (arg Eval_0_0))) 0)
)
                       (a!10 (= (fn (App (fn Eval_0_0) (arg Eval_0_0))) G))
                       (a!11 (+ (i Eval_2_0) (i (arg (arg Eval_0_0)))))
                       (a!12 (= (fn (App (fn Eval_0_0) (arg Eval_0_0))) Neg)))
                 (let ((a!3 (and (not (&lt;= a!1 0))
                                 (= (fn (arg Eval_0_0)) G)
                                 a!2
                                 (= Neg (arg (fn Eval_0_0)))))
                       (a!5 (&lt;= (+ (* (- 1) (i Eval_2_0)) a!4) 0))
                       (a!13 (and (not (&lt;= a!11 0))
                                  (= (fn (arg Eval_0_0)) G)
                                  a!12)))
                 (let ((a!8 (and (not a!5) a!6 (= Neg (fn (arg Eval_0_0))) a!7))
)
                   (and (not a!3)
                        (not a!8)
                        (not (and (not a!9) a!10))
                        (not a!13))))))
sat
(and (= (:var 0) 1) (= (:var 1) 1))
(and (query!52 1 1)
     (Eval (App (App Twice Neg) (App G (I 1))) Unit (I 1))
     (Eval (App Neg (App Neg (App G (I 1)))) Unit (I 1))
     (Eval (App Neg (App G (I 1))) Unit (I -1))
     (Eval (App G (I 1)) Unit (I 1)))
</pre></div> </div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Aug 9 16:34:44 2012
</BODY>
</HTML>
